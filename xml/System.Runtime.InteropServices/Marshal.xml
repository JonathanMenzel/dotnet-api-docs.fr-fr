<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b582e89d8a536a45d26354652aab5d4e97b21f0f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <TypeSignature Language="VB.NET" Value="Public Class Marshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class Marshal abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="37d7d-101">Fournit une collection de méthodes pour l’allocation de mémoire non managée, la copie de blocs de mémoire non managée et la conversion de types managés en types non managés, ainsi que diverses autres méthodes utilisées lors de l’interaction avec du code non managé.</span>
      <span class="sxs-lookup">
        <span data-stu-id="37d7d-101">Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-102">Le `static` méthodes définies sur la <xref:System.Runtime.InteropServices.Marshal> classe sont essentielles à l’utilisation de code non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-102">The `static` methods defined on the <xref:System.Runtime.InteropServices.Marshal> class are essential to working with unmanaged code.</span></span> <span data-ttu-id="37d7d-103">La plupart des méthodes définies dans cette classe sont généralement utilisées par les développeurs qui souhaitent fournir un pont entre managés et modèles de programmation.</span><span class="sxs-lookup"><span data-stu-id="37d7d-103">Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</span></span> <span data-ttu-id="37d7d-104">Par exemple, le <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> méthode copie les caractères ANSI à partir d’une chaîne spécifiée (dans le tas managé) dans une mémoire tampon dans le tas non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-104">For example, the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</span></span> <span data-ttu-id="37d7d-105">Il alloue également le tas cible de la taille correcte.</span><span class="sxs-lookup"><span data-stu-id="37d7d-105">It also allocates the target heap of the right size.</span></span>  
  
 <span data-ttu-id="37d7d-106">Le common language runtime fournit des fonctionnalités de marshaling spécifiques.</span><span class="sxs-lookup"><span data-stu-id="37d7d-106">The common language runtime provides specific marshaling capabilities.</span></span> <span data-ttu-id="37d7d-107">Pour plus d’informations sur le comportement de marshaling, consultez [Marshaling d’interopérabilité](~/docs/framework/interop/interop-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-107">For details on marshaling behavior, see [Interop Marshaling](~/docs/framework/interop/interop-marshaling.md).</span></span>  
  
 <span data-ttu-id="37d7d-108">Le `Read` et `Write` méthodes dans la <xref:System.Runtime.InteropServices.Marshal> classe prend en charge l’accès à la fois alignés et non alignés.</span><span class="sxs-lookup"><span data-stu-id="37d7d-108">The `Read` and `Write` methods in the <xref:System.Runtime.InteropServices.Marshal> class support both aligned and unaligned access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-109">L’exemple suivant montre comment utiliser différentes méthodes définies par le <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-109">The following example shows how to use various methods defined by the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddRef (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddRef(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">
          <span data-ttu-id="37d7d-110">Décompte de références d'interface à incrémenter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-110">The interface reference count to increment.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-111">Incrémente le décompte de références sur l'interface spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-111">Increments the reference count on the specified interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-112">Nouvelle valeur du décompte de références sur le paramètre <paramref name="pUnk" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-112">The new value of the reference count on the <paramref name="pUnk" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-113">Le common language runtime gère le décompte de références d’un objet COM pour vous, et évite d’avoir à utiliser cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-113">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="37d7d-114">Dans de rares cas, par exemple un test un marshaleur personnalisé, il peut vous sembler nécessaires pour manipuler la durée de vie d’un objet manuellement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-114">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="37d7d-115">Après avoir appelé <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, vous devez décrémenter le décompte de références en utilisant une méthode telle que <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-115">After calling <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, you must decrement the reference count by using a method such as <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-116">Ne comptez pas sur la valeur de retour de <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, comme il peut parfois être instable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-116">Do not rely on the return value of <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, as it can sometimes be unstable.</span></span>  
  
 <span data-ttu-id="37d7d-117">Vous pouvez appeler <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, ou <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> pour obtenir un <xref:System.IntPtr> valeur qui représente un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-117">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer.</span></span> <span data-ttu-id="37d7d-118">Vous pouvez également utiliser ces méthodes et la <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> méthode sur les objets gérés pour obtenir les interfaces COM représentées par le wrapper CCW l’objet managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-118">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</span></span> <span data-ttu-id="37d7d-119">Si vous n’êtes pas familiarisé avec les détails de ce type de wrapper, consultez [Wrapper CCW](~/docs/framework/interop/com-callable-wrapper.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-119">If you are not familiar with the details of this wrapper type, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-120">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-120">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-121">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-121">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocCoTaskMem (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocCoTaskMem(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">
          <span data-ttu-id="37d7d-122">Taille du bloc de mémoire à allouer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-122">The size of the block of memory to be allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-123">Alloue un bloc de mémoire de la taille spécifiée à partir de l’allocateur de mémoire de tâche COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-123">Allocates a block of memory of specified size from the COM task memory allocator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-124">Entier représentant l'adresse du bloc de mémoire alloué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-124">An integer representing the address of the block of memory allocated.</span>
          </span>
          <span data-ttu-id="37d7d-125">Cette mémoire doit être libérée avec <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-125">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-126"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> est un de l’allocation de mémoire de deux méthodes de l’API dans la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-126"><xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> is one of two memory allocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="37d7d-127">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> est l’autre.) Le contenu de mémoire initial retourné n’est pas défini, et la mémoire allouée peut dépasser le nombre d’octets demandé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-127">(<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</span></span> <span data-ttu-id="37d7d-128">Cette méthode expose le modèle COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) (fonction), qui est appelée par l’allocateur de mémoire de tâche COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-128">This method exposes the COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-129">La mémoire est insuffisante pour répondre à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-129">There is insufficient memory to satisfy the request.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-130">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-130">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-131">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-131">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AllocHGlobal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-132">Alloue de la mémoire à partir de la mémoire non managée du processus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-132">Allocates memory from the unmanaged memory of the process.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">
          <span data-ttu-id="37d7d-133">Nombre d'octets requis en mémoire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-133">The required number of bytes in memory.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-134">Alloue de la mémoire à partir de la mémoire non managée du processus à l'aide du nombre d'octets spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-134">Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-135">Pointeur vers la mémoire nouvellement allouée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-135">A pointer to the newly allocated memory.</span>
          </span>
          <span data-ttu-id="37d7d-136">Cette mémoire doit être libérée en utilisant la méthode <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-136">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-137"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> est une des deux méthodes d’allocation de mémoire dans le <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-137"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="37d7d-138">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> est l’autre.) Cette méthode expose Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) fonction à partir de Kernel32.dll.</span><span class="sxs-lookup"><span data-stu-id="37d7d-138">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="37d7d-139">Lorsque <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> appelle `LocalAlloc`, il passe un `LMEM_FIXED` indicateur, ce qui entraîne la mémoire allouée à verrouiller en place.</span><span class="sxs-lookup"><span data-stu-id="37d7d-139">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="37d7d-140">En outre, la mémoire allouée est non remplies de zéros.</span><span class="sxs-lookup"><span data-stu-id="37d7d-140">Also, the allocated memory is not zero-filled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-141">L'exemple suivant montre l'appel à la méthode <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-141">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> method.</span></span> <span data-ttu-id="37d7d-142">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-142">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-143">La mémoire est insuffisante pour répondre à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-143">There is insufficient memory to satisfy the request.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-144">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-144">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-145">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-145">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocHGlobal (cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr AllocHGlobal(IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb">
          <span data-ttu-id="37d7d-146">Nombre d'octets requis en mémoire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-146">The required number of bytes in memory.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-147">Alloue de la mémoire à partir de la mémoire non managée du processus à l'aide du pointeur vers le nombre d'octets spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-147">Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-148">Pointeur vers la mémoire nouvellement allouée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-148">A pointer to the newly allocated memory.</span>
          </span>
          <span data-ttu-id="37d7d-149">Cette mémoire doit être libérée en utilisant la méthode <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-149">This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-150"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> est une des deux méthodes d’allocation de mémoire dans le <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-150"><xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> is one of two memory allocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="37d7d-151">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> est l’autre.) Cette méthode expose Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) fonction à partir de Kernel32.dll.</span><span class="sxs-lookup"><span data-stu-id="37d7d-151">(<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> is the other.) This method exposes the Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) function from Kernel32.dll.</span></span>  
  
 <span data-ttu-id="37d7d-152">Lorsque <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> appelle `LocalAlloc`, il passe un `LMEM_FIXED` indicateur, ce qui entraîne la mémoire allouée à verrouiller en place.</span><span class="sxs-lookup"><span data-stu-id="37d7d-152">When <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> calls `LocalAlloc`, it passes a `LMEM_FIXED` flag, which causes the allocated memory to be locked in place.</span></span> <span data-ttu-id="37d7d-153">En outre, la mémoire allouée est non remplies de zéros.</span><span class="sxs-lookup"><span data-stu-id="37d7d-153">Also, the allocated memory is not zero-filled.</span></span>  
  
 <span data-ttu-id="37d7d-154">Pour obtenir un exemple de code, consultez <xref:System.Runtime.InteropServices.Marshal> et <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-154">For example code, see <xref:System.Runtime.InteropServices.Marshal> and <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-155">La mémoire est insuffisante pour répondre à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-155">There is insufficient memory to satisfy the request.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-156">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-156">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-157">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-157">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreComObjectsAvailableForCleanup () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool AreComObjectsAvailableForCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-158">Indique si des wrappers RCW (Runtime Callable Wrapper) d'un contexte quelconque sont disponibles pour le nettoyage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-158">Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-159">
            <see langword="true" /> si des wrappers RCW sont disponibles pour le nettoyage ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-159">
              <see langword="true" /> if there are any RCWs available for cleanup; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-160">S’il existe un grand nombre de références entre code managé et natif avec des graphiques de dépendance approfondie que peut prendre beaucoup de temps pour tous les objets à nettoyer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-160">If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</span></span> <span data-ttu-id="37d7d-161">À chaque exécution d’un catalogue global il libère un nombre de RCW, qui à son tour libère les objets COM sous-jacents.</span><span class="sxs-lookup"><span data-stu-id="37d7d-161">Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</span></span> <span data-ttu-id="37d7d-162">Ces objets COM ensuite libérer des références managées et que plus d’objets disponibles pour le nettoyage de la prochaine fois un GC s’exécute, ce qui démarre le processus de nouveau.</span><span class="sxs-lookup"><span data-stu-id="37d7d-162">Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</span></span>  
  
 <span data-ttu-id="37d7d-163">Le <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> méthode offre un moyen de l’application déterminer le nombre de cycles de GC. Collecter et catalogue global. WaitForPendingFinalizers doivent se produire pour tout nettoyer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-163">The <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-164">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-164">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-165">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-165">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindToMoniker (monikerName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ BindToMoniker(System::String ^ monikerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="monikerName">
          <span data-ttu-id="37d7d-166">Moniker correspondant au pointeur d'interface voulu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-166">The moniker corresponding to the desired interface pointer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-167">Obtient un pointeur d'interface identifié par le moniker spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-167">Gets an interface pointer identified by the specified moniker.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-168">Objet contenant une référence au pointeur d’interface identifié par le paramètre <paramref name="monikerName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-168">An object containing a reference to the interface pointer identified by the <paramref name="monikerName" /> parameter.</span>
          </span>
          <span data-ttu-id="37d7d-169">Un moniker est un nom et dans ce cas, le moniker est défini par une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-169">A moniker is a name, and in this case, the moniker is defined by an interface.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-170"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> expose le modèle COM `BindToMoniker` (méthode), qui crée un objet que vous pouvez effectuer un cast en toute interface COM que vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="37d7d-170"><xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A> exposes the COM `BindToMoniker` method, which produces an object that you can cast to any COM interface you require.</span></span> <span data-ttu-id="37d7d-171">Cette méthode fournit les mêmes fonctionnalités que le `GetObject` méthode dans Visual Basic 6.0 et [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].</span><span class="sxs-lookup"><span data-stu-id="37d7d-171">This method provides the same functionality as the `GetObject` method in Visual Basic 6.0 and [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="37d7d-172">Un HRESULT non reconnu a été retourné par la méthode <see langword="BindToMoniker" /> non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-172">An unrecognized HRESULT was returned by the unmanaged <see langword="BindToMoniker" /> method.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-173">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-173">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-174">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-174">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BufferToBSTR (ptr As Array, slen As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr BufferToBSTR(Array ^ ptr, int slen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" />
        <Parameter Name="slen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ChangeWrapperHandleStrength (otp As Object, fIsWeak As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChangeWrapperHandleStrength(System::Object ^ otp, bool fIsWeak);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="otp">
          <span data-ttu-id="37d7d-175">Objet dont le wrapper CCW (COM Callable Wrapper) contient un handle de références comptabilisées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-175">The object whose CCW holds a reference counted handle.</span>
          </span>
          <span data-ttu-id="37d7d-176">Le handle est fort si le décompte de références sur le wrapper CCW (COM Callable Wrapper) est supérieur à zéro ; sinon, il est faible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-176">The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</span>
          </span>
        </param>
        <param name="fIsWeak">
          <span data-ttu-id="37d7d-177">
            <see langword="true" /> pour changer la force du handle sur le paramètre <c>otp</c> pour l’affaiblir quel que soit son décompte de références ; <see langword="false" /> pour que la force du handle sur <c>otp</c> soit fonction du décompte de références.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-177">
              <see langword="true" /> to change the strength of the handle on the <c>otp</c> parameter to weak, regardless of its reference count; <see langword="false" /> to reset the handle strength on <c>otp</c> to be reference counted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-178">Modifie la force du handle CCW [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) d’un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-178">Changes the strength of an object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) (CCW) handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-179"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> est utilisé pour la fonctionnalité de pool d’objet et ne doit jamais être appelée par le code utilisateur directement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-179"><xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A> is used for object pooling functionality and should never be called by user code directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-180">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-180">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-181">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-181">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CleanupUnusedObjectsInCurrentContext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CleanupUnusedObjectsInCurrentContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-182">Indique au runtime de nettoyer tous les wrappers RCW [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) alloués dans le contexte actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-182">Notifies the runtime to clean up all [Runtime Callable Wrappers](~/docs/framework/interop/runtime-callable-wrapper.md) (RCWs) allocated in the current context.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-183">Le système d’interopérabilité pompe des messages lorsqu’il tente de nettoyer les wrappers RCW.</span><span class="sxs-lookup"><span data-stu-id="37d7d-183">The interop system pumps messages while it attempts to clean up RCWs.</span></span> <span data-ttu-id="37d7d-184">Cela garantit que le nettoyage pour RCW de thread unique cloisonné (STA) se produit dans toutes les applications, y compris les applications qui ne pompent pas assez souvent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-184">This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</span></span> <span data-ttu-id="37d7d-185">Toutefois, certaines applications qui pompent convenablement sont très sensibles aux où pompage se produit.</span><span class="sxs-lookup"><span data-stu-id="37d7d-185">However, some applications that do pump appropriately are very sensitive to where pumping occurs.</span></span> <span data-ttu-id="37d7d-186">Lorsque le système d’interopérabilité pompe des messages dans ces applications, dans des emplacements qui sont inattendus, l’application peut rencontrer des problèmes de réentrance qui sont difficiles à diagnostiquer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-186">When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</span></span> <span data-ttu-id="37d7d-187">Par conséquent, les applications doivent être en mesure de contrôler leur propre pompage pour un thread cloisonné particulier et de contrôler le nettoyage des RCW.</span><span class="sxs-lookup"><span data-stu-id="37d7d-187">Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</span></span>  
  
 <span data-ttu-id="37d7d-188">Toutefois, les développeurs contrôlent souvent uniquement un sous-ensemble des threads dans leur application et ne peut pas garantir ainsi que tous les threads pompent convenablement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-188">However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</span></span>  
  
 <span data-ttu-id="37d7d-189">Pour résoudre ce problème :</span><span class="sxs-lookup"><span data-stu-id="37d7d-189">To solve this problem:</span></span>  
  
1.  <span data-ttu-id="37d7d-190">Utilisez la <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> méthode pour désactiver le nettoyage automatique des wrappers RCW et le pompage de messages qui se produit, sur une base par thread.</span><span class="sxs-lookup"><span data-stu-id="37d7d-190">Use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</span></span> <span data-ttu-id="37d7d-191">Cela permet aux développeurs de refuser de nettoyage automatique et le pompage de message correspondant.</span><span class="sxs-lookup"><span data-stu-id="37d7d-191">This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</span></span>  
  
2.  <span data-ttu-id="37d7d-192">Utilisez la <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> méthode notifier le runtime pour nettoyer tous les wrappers RCW qui sont alloués dans le contexte actuel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-192">Use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> method to notify the runtime to clean up all RCWs that are allocated in the current context.</span></span> <span data-ttu-id="37d7d-193">Cette méthode auxiliaire permet aux développeurs de contrôler avec précision quand le runtime effectue un nettoyage dans le contexte actuel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-193">This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-194">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-194">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-195">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-195">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-196">Copie les données d'un tableau managé vers un pointeur mémoire non managé ou d'un pointeur mémoire non managé vers un tableau managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-196">Copies data from a managed array to an unmanaged memory pointer, or from an unmanaged memory pointer to a managed array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;System::Byte&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-197">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-197">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-198">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-198">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-199">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-199">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-200">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-200">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-201">Copie des données d'un tableau d'entiers 8 bits non signés managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-201">Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-202">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-202">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-203">L’exemple suivant copie un tableau à la mémoire non managée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> de surcharge et copie ensuite le tableau non managé dans la mémoire managée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-203">The following example copies an array to unmanaged memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> overload, and then copies the unmanaged array back to managed memory by using the <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-204">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-204">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-205">
            <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-205">
              <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-206">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-206">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-207">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-207">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;char&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-208">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-208">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-209">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-209">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-210">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-210">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-211">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-211">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-212">Copie des données d'un tableau de caractères managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-212">Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-213">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-213">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-214">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-214">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-215">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-215">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-216">
            <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-216">
              <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-217">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-217">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-218">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-218">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;double&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-219">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-219">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-220">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-220">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-221">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-221">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-222">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-222">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-223">Copie des données d'un tableau de nombres à virgule flottante double précision managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-223">Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-224">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-224">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-225">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-225">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-226">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-226">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-227">
            <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-227">
              <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-228">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-228">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-229">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-229">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;short&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-230">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-230">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-231">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-231">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-232">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-232">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-233">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-233">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-234">Copie des données à partir d'un tableau d'entiers 16 bits signés managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-234">Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-235">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-235">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-236">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-236">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-237">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-237">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-238">
            <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-238">
              <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-239">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-239">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-240">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-240">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;int&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-241">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-241">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-242">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-242">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-243">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-243">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-244">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-244">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-245">Copie des données à partir d'un tableau d'entiers 32 bits signés managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-245">Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-246">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-246">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-247">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-247">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-248">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-248">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-249">
            <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-249">
              <paramref name="startIndex" /> or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-250">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-250">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-251">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-251">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;long&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-252">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-252">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-253">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-253">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-254">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-254">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-255">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-255">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-256">Copie des données à partir d'un tableau d'entiers 64 bits signés managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-256">Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-257">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-257">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-258">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-258">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-259">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-259">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-260">
            <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-260">
              <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-261">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-261">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-262">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-262">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;System::Byte&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-263">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-263">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-264">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-264">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-265">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-265">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-266">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-266">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-267">Copie des données d'un pointeur mémoire non managé dans un tableau d'entiers 8 bits non signés managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-267">Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-268">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-268">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-269">Par conséquent, les données non managées correspondant à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-269">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-270">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-270">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-271">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-271">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-272">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-272">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-273">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-273">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-274">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-274">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;char&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-275">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-275">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-276">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-276">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-277">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-277">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-278">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-278">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-279">Copie des données d'un pointeur mémoire non managé dans un tableau de caractères managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-279">Copies data from an unmanaged memory pointer to a managed character array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-280">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-280">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-281">Par conséquent, les données non managées correspondant à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-281">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-282">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-282">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-283">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-283">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-284">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-284">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-285">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-285">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-286">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-286">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;double&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-287">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-287">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-288">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-288">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-289">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-289">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-290">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-290">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-291">Copie des données d'un pointeur mémoire non managé dans un tableau de nombres à virgule flottante double précision managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-291">Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-292">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-292">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-293">Par conséquent, les données non managées correspondant à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-293">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-294">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-294">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-295">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-295">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-296">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-296">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-297">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-297">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-298">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-298">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;short&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-299">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-299">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-300">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-300">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-301">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-301">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-302">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-302">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-303">Copie des données à partir d'un pointeur mémoire non managé vers un tableau d'entiers 16 bits signés managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-303">Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-304">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-304">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-305">Par conséquent, les données non managées correspondant à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-305">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-306">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-306">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-307">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-307">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-308">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-308">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-309">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-309">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-310">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-310">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;int&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-311">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-311">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-312">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-312">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-313">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-313">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-314">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-314">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-315">Copie des données à partir d'un pointeur mémoire non managé vers un tableau d'entiers 32 bits signés managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-315">Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-316">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-316">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-317">Par conséquent, les données non managées correspondant à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-317">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-318">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-318">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-319">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-319">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-320">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-320">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-321">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-321">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-322">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-322">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;long&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-323">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-323">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-324">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-324">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-325">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-325">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-326">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-326">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-327">Copie des données à partir d'un pointeur mémoire non managé vers un tableau d'entiers 64 bits signés managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-327">Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-328">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-328">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-329">Par conséquent, les données non managées correspondant à la`source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-329">Thus, the unmanaged data corresponding to the`source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-330">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-330">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-331">L’exemple suivant copie un tableau dans la mémoire non managée et copie ensuite le tableau non managé dans la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-331">The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-332">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-332">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-333">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-333">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-334">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-334">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;IntPtr&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-335">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-335">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-336">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-336">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-337">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-337">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-338">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-338">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-339">Copie des données d’un pointeur mémoire non managé dans un tableau de <see cref="T:System.IntPtr" /> managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-339">Copies data from an unmanaged memory pointer to a managed <see cref="T:System.IntPtr" /> array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-340">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-340">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-341">Par conséquent, les données non managées qui correspond à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-341">Therefore, the unmanaged data that corresponds to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-342">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler le <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-342">You must initialize the managed array with the appropriate size before calling the <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-343">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-343">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-344">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-344">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-345">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-345">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(IntPtr source, cli::array &lt;float&gt; ^ destination, int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-346">Pointeur mémoire à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-346">The memory pointer to copy from.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-347">Tableau dans lequel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-347">The array to copy to.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-348">Index de base zéro dans le tableau de destination où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-348">The zero-based index in the destination array where copying should start.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-349">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-349">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-350">Copie des données d'un pointeur mémoire non managé dans un tableau de nombres à virgule flottante simple précision managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-350">Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-351">Non gérés, tableaux de style C ne contiennent pas les informations de limites, ce qui empêche le `startIndex` et `length` validation des paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-351">Unmanaged, C-style arrays do not contain bounds information, which prevents the `startIndex` and `length` parameters from being validated.</span></span> <span data-ttu-id="37d7d-352">Par conséquent, les données non managées correspondant à la `source` paramètre remplit le tableau managé, quelle que soit son utilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-352">Thus, the unmanaged data corresponding to the `source` parameter populates the managed array regardless of its usefulness.</span></span> <span data-ttu-id="37d7d-353">Vous devez initialiser le tableau managé avec la taille appropriée avant d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-353">You must initialize the managed array with the appropriate size before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-354">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-354">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-355">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-355">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-356">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-356">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;IntPtr&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-357">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-357">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-358">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-358">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-359">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-359">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-360">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-360">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-361">Copie des données d’un tableau de <see cref="T:System.IntPtr" /> managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-361">Copies data from a one-dimensional, managed <see cref="T:System.IntPtr" /> array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-362">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’une dimension gérés <xref:System.IntPtr> tableau à un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-362">You can use this method to copy a subset of a one-dimensional managed <xref:System.IntPtr> array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-363">
            <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-363">
              <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-364">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-364">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-365">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-365">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(cli::array &lt;float&gt; ^ source, int startIndex, IntPtr destination, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="37d7d-366">Tableau unidimensionnel à partir duquel effectuer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-366">The one-dimensional array to copy from.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="37d7d-367">Index de base zéro dans le tableau source où la copie doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-367">The zero-based index in the source array where copying should start.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="37d7d-368">Pointeur mémoire de destination de la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-368">The memory pointer to copy to.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="37d7d-369">Nombre d'éléments de tableau à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-369">The number of array elements to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-370">Copie des données d'un tableau de nombres à virgule flottante simple précision managé et unidimensionnel vers un pointeur mémoire non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-370">Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-371">Vous pouvez utiliser cette méthode pour copier un sous-ensemble d’un tableau managé unidimensionnel vers un tableau de style C non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-371">You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-372">
            <paramref name="startIndex" /> et <paramref name="length" /> ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-372">
              <paramref name="startIndex" /> and <paramref name="length" /> are not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-373">
            <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-373">
              <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" />, or <paramref name="length" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-374">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-374">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-375">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-375">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject (pOuter As IntPtr, o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pOuter">
          <span data-ttu-id="37d7d-376">Le pointeur <see langword="IUnknown" /> externe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-376">The outer <see langword="IUnknown" /> pointer.</span>
          </span>
        </param>
        <param name="o">
          <span data-ttu-id="37d7d-377">Objet à agréger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-377">An object to aggregate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-378">Agrège un objet managé avec l'objet COM spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-378">Aggregates a managed object with the specified COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-379">Le pointeur <see langword="IUnknown" /> interne de l’objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-379">The inner <see langword="IUnknown" /> pointer of the managed object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-380">Le <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> méthode agrège le pointeur managé interne d’un objet managé avec le pointeur externe spécifié et renvoie une exception interne [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur de l’objet managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-380">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-381">
            <paramref name="o" /> est un objet [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-381">
              <paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-382">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-382">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-383">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-383">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAggregatedObject(Of T) (pOuter As IntPtr, o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-384">Type de l'objet managé à agréger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-384">The type of the managed object to aggregate.</span>
          </span>
        </typeparam>
        <param name="pOuter">
          <span data-ttu-id="37d7d-385">Pointeur [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) externe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-385">The outer [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer.</span>
          </span>
        </param>
        <param name="o">
          <span data-ttu-id="37d7d-386">Objet managé à agréger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-386">The managed object to aggregate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-387">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-387">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-388">Agrège un objet managé du type spécifié avec l'objet COM spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-388">Aggregates a managed object of the specified type with the specified COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-389">Pointeur [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interne de l’objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-389">The inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-390">Le <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> méthode agrège le pointeur managé interne d’un objet managé d’un type spécifié avec le pointeur externe spécifié et retourne une exception interne [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur de l’objet managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-390">The <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer of the managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-391">
            <paramref name="o" /> est un objet [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-391">
              <paramref name="o" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-392">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-392">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-393">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-393">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType (o As Object, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateWrapperOfType(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-394">L’objet à encapsuler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-394">The object to be wrapped.</span>
          </span>
        </param>
        <param name="t">
          <span data-ttu-id="37d7d-395">Le type de wrapper à créer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-395">The type of wrapper to create.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-396">Encapsule l'objet COM spécifié dans un objet du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-396">Wraps the specified COM object in an object of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-397">Objet récemment encapsulé constituant une instance du type requis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-397">The newly wrapped object that is an instance of the desired type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-398"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> Convertit un type de classe COM, généralement la base de `__ComObject` type, à un autre type de classe COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-398"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A> converts one COM class type, typically the base `__ComObject` type, to another COM class type.</span></span> <span data-ttu-id="37d7d-399">L’objet COM d’entrée, représenté par le paramètre `o`, est un [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span><span class="sxs-lookup"><span data-stu-id="37d7d-399">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span></span>  
  
 <span data-ttu-id="37d7d-400">À la fois le `t` et `o` paramètres doivent être des classes dont les signatures sont attribuées avec <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-400">Both the `t` and `o` parameters must be classes whose signatures are attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-401">Le [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil applique cet attribut pour vous lorsqu’il importe une bibliothèque de types.</span><span class="sxs-lookup"><span data-stu-id="37d7d-401">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="37d7d-402">Si vous créez le wrapper RCW manuellement dans le code source, vous devez appliquer cet attribut à la signature managée représentant la coclasse d’origine pour indiquer son origine COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-402">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="37d7d-403">Tlbimp.exe importe COM [coclasse](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) en tant que classe managée et une interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-403">Tlbimp.exe imports a COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) as a managed class and an interface.</span></span> <span data-ttu-id="37d7d-404">L’interface de la coclasse a le même nom que la coclasse d’origine et la classe managée a « Classe » ajouté au nom coclasse d’origine.</span><span class="sxs-lookup"><span data-stu-id="37d7d-404">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="37d7d-405">Par exemple, une coclasse appelée `MyCoclass` devient une interface de coclasse appelée `MyCoclass` et une classe managée appelée `MyCoclassClass`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-405">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="37d7d-406">Étant donné que `t` doit être une classe, et non une interface, veillez à spécifier la classe managée (`MyCoclassClass`) et non l’interface de la coclasse.</span><span class="sxs-lookup"><span data-stu-id="37d7d-406">Since `t` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the coclass interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d7d-407">Vous perdez l’identité de l’entrée de l’objet COM, car une nouvelle instance RCW inclut le [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur exposé par le RCW d’origine.</span><span class="sxs-lookup"><span data-stu-id="37d7d-407">You lose the identity of the input COM object because a new RCW instance wraps the [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-408">
            <paramref name="t" /> doit provenir de <see langword="__ComObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-408">
              <paramref name="t" /> must derive from <see langword="__ComObject" />.</span>
          </span>
          <span data-ttu-id="37d7d-409">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-409">-or-</span>
          </span>
          <span data-ttu-id="37d7d-410">
            <paramref name="t" /> est un type [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-410">
              <paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-411">Le paramètre <paramref name="t" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-411">The <paramref name="t" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-412">Impossible de convertir <paramref name="o" /> dans le type de destination, car il ne prend pas en charge toutes les interfaces requises.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-412">
              <paramref name="o" /> cannot be converted to the destination type because it does not support all required interfaces.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-413">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-413">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-414">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-414">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateWrapperOfType(Of T, TWrapper) (o As T) As TWrapper" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TWrapper&gt;&#xA; static TWrapper CreateWrapperOfType(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-415">Type d'objet à encapsuler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-415">The type of object to wrap.</span>
          </span>
        </typeparam>
        <typeparam name="TWrapper">
          <span data-ttu-id="37d7d-416">Type d'objet à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-416">The type of object to return.</span>
          </span>
        </typeparam>
        <param name="o">
          <span data-ttu-id="37d7d-417">L’objet à encapsuler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-417">The object to be wrapped.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-418">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-418">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-419">Encapsule l'objet COM spécifié dans un objet du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-419">Wraps the specified COM object in an object of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-420">Objet récemment encapsulé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-420">The newly wrapped object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-421"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> Convertit un objet COM de type `T` à la `TWrapper` type de classe COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-421"><xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29> converts a COM object of type `T` to the `TWrapper` COM class type.</span></span> <span data-ttu-id="37d7d-422">L’objet COM d’entrée, représenté par le paramètre `o`, est un [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span><span class="sxs-lookup"><span data-stu-id="37d7d-422">The input COM object, represented by parameter `o`, is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).</span></span>  
  
 <span data-ttu-id="37d7d-423">Les deux le `T` paramètre de type générique et le `o` paramètre doit être des classes dont les signatures sont attribuées avec la <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> attribut.</span><span class="sxs-lookup"><span data-stu-id="37d7d-423">Both the `T` generic type parameter and the `o` parameter must be classes whose signatures are attributed with the <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="37d7d-424">Le [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil applique cet attribut pour vous lorsqu’il importe une bibliothèque de types.</span><span class="sxs-lookup"><span data-stu-id="37d7d-424">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span> <span data-ttu-id="37d7d-425">Si vous créez le wrapper RCW manuellement dans le code source, vous devez appliquer cet attribut à la signature managée représentant la coclasse d’origine pour indiquer son origine COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-425">If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</span></span>  
  
 <span data-ttu-id="37d7d-426">Tlbimp.exe importe COM [coclasse](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) en tant que classe managée et une interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-426">Tlbimp.exe imports a COM [coclass](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582) as a managed class and an interface.</span></span> <span data-ttu-id="37d7d-427">L’interface de la coclasse a le même nom que la coclasse d’origine et la classe managée a « Classe » ajouté au nom coclasse d’origine.</span><span class="sxs-lookup"><span data-stu-id="37d7d-427">The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</span></span> <span data-ttu-id="37d7d-428">Par exemple, une coclasse appelée `MyCoclass` devient une interface de coclasse appelée `MyCoclass` et une classe managée appelée `MyCoclassClass`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-428">For example, a coclass called `MyCoclass` becomes a coclass interface called `MyCoclass` and a managed class called `MyCoclassClass`.</span></span> <span data-ttu-id="37d7d-429">Étant donné que`T` doit être une classe, et non une interface, veillez à spécifier la classe managée (`MyCoclassClass`) et non le `coclass` interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-429">Because`T` must be a class, not an interface, be sure to specify the managed class (`MyCoclassClass`) and not the `coclass` interface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d7d-430">Vous perdez l’identité de l’objet COM d’entrée, car une nouvelle instance RCW inclut le [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur exposé par le RCW d’origine.</span><span class="sxs-lookup"><span data-stu-id="37d7d-430">You lose the identity of the input COM object, because a new RCW instance wraps the [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointer exposed by the original RCW.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-431">
            <typeparamref name="T" /> doit provenir de <see langword="__ComObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-431">
              <typeparamref name="T" /> must derive from <see langword="__ComObject" />.</span>
          </span>
          <span data-ttu-id="37d7d-432">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-432">-or-</span>
          </span>
          <span data-ttu-id="37d7d-433">
            <typeparamref name="T" /> est un type [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-433">
              <typeparamref name="T" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-434">
            <paramref name="o" /> ne peut pas être converti dans <paramref name="TWrapper" /> puisqu'il ne prend pas en charge toutes les interfaces requises.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-434">
              <paramref name="o" /> cannot be converted to the <paramref name="TWrapper" /> because it does not support all required interfaces.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-435">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-435">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-436">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-436">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure (ptr As IntPtr, structuretype As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DestroyStructure(IntPtr ptr, Type ^ structuretype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-437">Pointeur vers un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-437">A pointer to an unmanaged block of memory.</span>
          </span>
        </param>
        <param name="structuretype">
          <span data-ttu-id="37d7d-438">Type d'une classe mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-438">Type of a formatted class.</span>
          </span>
          <span data-ttu-id="37d7d-439">Ceci fournit les informations relatives à la disposition nécessaires pour supprimer la mémoire tampon dans le paramètre <c>ptr</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-439">This provides the layout information necessary to delete the buffer in the <c>ptr</c> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-440">Libère toutes les sous-structures vers lesquelles pointe le bloc de mémoire non managée spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-440">Frees all substructures that the specified unmanaged memory block points to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-441">Vous pouvez utiliser cette méthode pour libérer des champs de type référence, telles que des chaînes, d’une structure non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-441">You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="37d7d-442">Contrairement à ses champs, une structure peut être un type valeur ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="37d7d-442">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="37d7d-443">Les structures de type valeur qui contiennent des champs de type valeur (tous blittables) n’avoir aucune référence dont la mémoire doit être libérée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-443">Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="37d7d-444">Le <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> méthode utilise cette méthode pour éviter les fuites de mémoire lors de la réutilisation de la mémoire occupée par une structure.</span><span class="sxs-lookup"><span data-stu-id="37d7d-444">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="37d7d-445"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> appelle le modèle COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) fonction, qui à son tour, libère une chaîne allouée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-445"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 <span data-ttu-id="37d7d-446">En plus de <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, le <xref:System.Runtime.InteropServices.Marshal> classe fournit deux autres méthodes de désallocation de mémoire : <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> et <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-446">In addition to <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-447">
            <paramref name="structureType" /> possède une disposition automatique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-447">
              <paramref name="structureType" /> has an automatic layout.</span>
          </span>
          <span data-ttu-id="37d7d-448">Optez plutôt pour séquentiel ou explicite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-448">Use sequential or explicit instead.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-449">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-449">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-450">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-450">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DestroyStructure(Of T) (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void DestroyStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-451">Type de la structure mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-451">The type of the formatted structure.</span>
          </span>
          <span data-ttu-id="37d7d-452">Ceci fournit les informations relatives à la disposition nécessaires pour supprimer la mémoire tampon dans le paramètre <c>ptr</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-452">This provides the layout information necessary to delete the buffer in the <c>ptr</c> parameter.</span>
          </span>
        </typeparam>
        <param name="ptr">
          <span data-ttu-id="37d7d-453">Pointeur vers un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-453">A pointer to an unmanaged block of memory.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-454">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-454">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-455">Libère toutes les sous-structures d'un type spécifié vers lesquelles pointe le bloc de mémoire non managé spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-455">Frees all substructures of a specified type that the specified unmanaged memory block points to.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-456">Vous pouvez utiliser cette méthode pour libérer des champs de type référence, telles que des chaînes, d’une structure non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-456">You can use this method to free reference type fields, such as strings, of an unmanaged structure.</span></span> <span data-ttu-id="37d7d-457">Contrairement à ses champs, une structure peut être un type valeur ou un type référence.</span><span class="sxs-lookup"><span data-stu-id="37d7d-457">Unlike its fields, a structure can be a value type or a reference type.</span></span> <span data-ttu-id="37d7d-458">Structures de type valeur qui contiennent des champs de type valeur (tous blittables) n’ont aucune référence dont la mémoire doit être libérée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-458">Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</span></span> <span data-ttu-id="37d7d-459">Le <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> méthode utilise cette méthode pour éviter les fuites de mémoire lors de la réutilisation de la mémoire occupée par une structure.</span><span class="sxs-lookup"><span data-stu-id="37d7d-459">The <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</span></span>  
  
 <span data-ttu-id="37d7d-460"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> appelle le modèle COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) fonction, qui à son tour, libère une chaîne allouée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-460"><xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) function, which, in turn, frees an allocated string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-461">
            <typeparamref name="T" /> possède une disposition automatique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-461">
              <typeparamref name="T" /> has an automatic layout.</span>
          </span>
          <span data-ttu-id="37d7d-462">Optez plutôt pour séquentiel ou explicite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-462">Use sequential or explicit instead.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-463">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-463">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-464">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-464">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FinalReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FinalReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-465">Wrapper RCW à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-465">The RCW to be released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-466">Libère toutes les références à un wrapper RCW [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) en affectant la valeur 0 à son décompte de références.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-466">Releases all references to a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) by setting its reference count to 0.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-467">Nouvelle valeur du décompte de références du wrapper RCW associé au paramètre <paramref name="o" />, qui est 0 (zéro) si la libération réussit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-467">The new value of the reference count of the RCW associated with the <paramref name="o" /> parameter, which is 0 (zero) if the release is successful.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-468">Le <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> méthode libère la référence managée à un objet COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-468">The <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method releases the managed reference to a COM object.</span></span> <span data-ttu-id="37d7d-469">Appel de cette méthode équivaut à appeler la <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> méthode dans une boucle jusqu'à ce qu’elle retourne 0 (zéro).</span><span class="sxs-lookup"><span data-stu-id="37d7d-469">Calling this method is equivalent to calling the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="37d7d-470">Lorsque le décompte de références sur l’objet COM devient 0, l’objet COM est généralement libéré, bien que cela varie selon l’implémentation de l’objet COM et dépasse le cadre de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="37d7d-470">When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</span></span> <span data-ttu-id="37d7d-471">Toutefois, le wrapper RCW peut encore exister, en attente d’être le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="37d7d-471">However, the RCW can still exist, waiting to be garbage-collected.</span></span>  
  
 <span data-ttu-id="37d7d-472">L’objet COM ne peut pas être utilisé après que qu’il a été séparé de son RCW sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-472">The COM object cannot be used after it has been separated from its underlying RCW.</span></span> <span data-ttu-id="37d7d-473">Si vous essayez d’appeler une méthode sur le wrapper RCW une fois que son décompte de références est 0, une <xref:System.Runtime.InteropServices.InvalidComObjectException> sera levée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-473">If you try to call a method on the RCW after its reference count becomes 0, a <xref:System.Runtime.InteropServices.InvalidComObjectException> will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-474">
            <paramref name="o" /> n'est pas un objet COM valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-474">
              <paramref name="o" /> is not a valid COM object.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-475">
            <paramref name="o" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-475">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-476">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-476">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-477">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-477">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeBSTR (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-478">Adresse du BSTR à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-478">The address of the BSTR to be freed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-479">Libère un <see langword="BSTR" /> à l’aide de la fonction COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-479">Frees a <see langword="BSTR" /> using the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) function.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-480">Comme <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, vous pouvez utiliser cette méthode pour libérer la mémoire.</span><span class="sxs-lookup"><span data-stu-id="37d7d-480">Like <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, you can use this method to deallocate memory.</span></span> <span data-ttu-id="37d7d-481"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> appelle le modèle COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) (fonction), ce qui libère la mémoire allouée par une des méthodes non managées suivantes : `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-481"><xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A> calls the COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) function, which frees memory allocated by any of the following unmanaged methods: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`.</span></span> <span data-ttu-id="37d7d-482">Vous pouvez appeler des méthodes non managées comme avec la plateforme.</span><span class="sxs-lookup"><span data-stu-id="37d7d-482">You can call unmanaged methods such as these with platform invoke.</span></span> <span data-ttu-id="37d7d-483">Pour plus d’informations, consultez [consommation de fonctions DLL non managées](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-483">For details, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-484">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-484">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-485">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-485">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeCoTaskMem (ptr As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeCoTaskMem(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-486">Adresse de la mémoire à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-486">The address of the memory to be freed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-487">Libère un bloc de mémoire alloué par l’allocateur de mémoire de tâche COM non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-487">Frees a block of memory allocated by the unmanaged COM task memory allocator.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-488">Vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> pour libérer de la mémoire allouée par <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, ou de la méthode non managée n’importe quel équivalente.</span><span class="sxs-lookup"><span data-stu-id="37d7d-488">You can use <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> to free any memory allocated by <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, or any equivalent unmanaged method.</span></span> <span data-ttu-id="37d7d-489">Si le `ptr` paramètre est `null`, la méthode ne fait rien.</span><span class="sxs-lookup"><span data-stu-id="37d7d-489">If the `ptr` parameter is `null`, the method does nothing.</span></span>  
  
 <span data-ttu-id="37d7d-490"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> expose le modèle COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) (fonction), ce qui libère tous les octets afin que vous ne pouvez plus utiliser la mémoire qui le `ptr` paramètre pointe vers.</span><span class="sxs-lookup"><span data-stu-id="37d7d-490"><xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> exposes the COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) function, which frees all bytes so that you can no longer use the memory that the `ptr` parameter points to.</span></span>  
  
 <span data-ttu-id="37d7d-491">En plus de <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, le <xref:System.Runtime.InteropServices.Marshal> classe fournit deux autres méthodes de désallocation de mémoire : <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> et <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-491">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-492">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-492">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-493">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-493">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeHGlobal (hglobal As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeHGlobal(IntPtr hglobal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal">
          <span data-ttu-id="37d7d-494">Handle retourné par l'appel correspondant d'origine à <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-494">The handle returned by the original matching call to <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-495">Libère la mémoire précédemment allouée de la mémoire non managée du processus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-495">Frees memory previously allocated from the unmanaged memory of the process.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-496">Vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> pour libérer de la mémoire du tas global allouée par <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, ou méthode d’API non managée n’importe quel équivalente.</span><span class="sxs-lookup"><span data-stu-id="37d7d-496">You can use <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> to free any memory from the global heap allocated by <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, or any equivalent unmanaged API method.</span></span> <span data-ttu-id="37d7d-497">Si le `hglobal` paramètre est <xref:System.IntPtr.Zero?displayProperty=nameWithType> la méthode ne fait rien.</span><span class="sxs-lookup"><span data-stu-id="37d7d-497">If the `hglobal` parameter is <xref:System.IntPtr.Zero?displayProperty=nameWithType> the method does nothing.</span></span>  
  
 <span data-ttu-id="37d7d-498"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> expose les [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) fonction à partir de Kernel32.DLL, qui libère tous les octets afin que vous ne pouvez plus utiliser la mémoire pointée par `hglobal`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-498"><xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> exposes the [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by `hglobal`.</span></span>  
  
 <span data-ttu-id="37d7d-499">En plus de <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, le <xref:System.Runtime.InteropServices.Marshal> classe fournit des méthodes de l’API de deux autres désallocation de mémoire : <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> et <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-499">In addition to <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, the <xref:System.Runtime.InteropServices.Marshal> class provides two other memory-deallocation API methods: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> and <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-500">L'exemple suivant montre l'appel à la méthode <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-500">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method.</span></span> <span data-ttu-id="37d7d-501">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-501">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 <span data-ttu-id="37d7d-502">L’exemple suivant montre comment convertir le contenu d’un objet <xref:System.String> classe mémoire non managée, puis libérer de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-502">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-503">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-503">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-504">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-504">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GenerateGuidForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="37d7d-505">Type pour lequel un GUID doit être généré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-505">The type to generate a GUID for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-506">Retourne le GUID (identificateur global unique) du type spécifié, ou génère un GUID en utilisant l'algorithme employé par l'exportateur de bibliothèques de types (TlbExp.exe).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-506">Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-507">Identificateur du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-507">An identifier for the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-508">Si le type possède un GUID dans les métadonnées, il est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-508">If the type has a GUID in the metadata, it is returned.</span></span> <span data-ttu-id="37d7d-509">Sinon, un GUID est généré automatiquement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-509">Otherwise, a GUID is automatically generated.</span></span> <span data-ttu-id="37d7d-510">Vous pouvez utiliser cette méthode pour déterminer par programme le GUID COM pour tout type managé, y compris les types non visibles par COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-510">You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</span></span> <span data-ttu-id="37d7d-511">Interfaces de classe sont la seule exception, car ils ne correspondent pas à un type managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-511">Class interfaces are the only exception because they do not correspond to a managed type.</span></span> <span data-ttu-id="37d7d-512"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> fournit les mêmes fonctionnalités que le <xref:System.Type.GUID%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="37d7d-512"><xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A> provides the same functionality as the <xref:System.Type.GUID%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-513">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-513">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-514">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-514">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="P:System.Type.GUID" />
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GenerateProgIdForType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="37d7d-515">Type pour lequel un ProgID doit être obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-515">The type to get a ProgID for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-516">Retourne un ProgID (identificateur programmatique) pour le type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-516">Returns a programmatic identifier (ProgID) for the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-517">ProgID pour le type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-517">The ProgID of the specified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-518">Si le type a un ProgID dans les métadonnées, qui est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-518">If the type has a ProgID in the metadata, that ProgID is returned.</span></span> <span data-ttu-id="37d7d-519">Sinon, un ProgID est généré en fonction du nom qualifié complet du type.</span><span class="sxs-lookup"><span data-stu-id="37d7d-519">Otherwise, a ProgID is generated based on the fully qualified name of the type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-520">Le paramètre <paramref name="type" /> n'est pas une classe qui peut être créée par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-520">The <paramref name="type" /> parameter is not a class that can be create by COM.</span>
          </span>
          <span data-ttu-id="37d7d-521">La classe doit être publique, disposer d'un constructeur public par défaut et être visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-521">The class must be public, have a public default constructor, and be COM visible.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-522">Le paramètre <paramref name="type" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-522">The <paramref name="type" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-523">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-523">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-524">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-524">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetActiveObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetActiveObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="37d7d-525">Identificateur programmatique (ProgID) de l'objet demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-525">The programmatic identifier (ProgID) of the object that was requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-526">Obtient une instance en cours d'exécution de l'objet spécifié à partir de la table ROT (Running Object Table).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-526">Obtains a running instance of the specified object from the running object table (ROT).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-527">Objet demandé ; sinon <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-527">The object that was requested; otherwise <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-528">Vous pouvez effectuer un cast de cet objet en toute interface COM qu'il prend en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-528">You can cast this object to any COM interface that it supports.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-529"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> expose le modèle COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) fonction à partir de OLEAUT32. DLL ; Toutefois, cette dernière attend un identificateur de classe (CLSID) au lieu de l’identificateur programmatique (`ProgID`) attendu par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-529"><xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> exposes the COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (`ProgID`) expected by this method.</span></span> <span data-ttu-id="37d7d-530">Pour obtenir une instance en cours d’exécution d’un objet COM sans inscrite `ProgID`, utilisez non managé pour définir le modèle COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) (fonction).</span><span class="sxs-lookup"><span data-stu-id="37d7d-530">To obtain a running instance of a COM object without a registered `ProgID`, use platform invoke to define the COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) function.</span></span> <span data-ttu-id="37d7d-531">Pour obtenir une description de la plateforme de code non managé, consultez [consommation de fonctions DLL non managées](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-531">For a description of platform invoke, see [Consuming Unmanaged DLL Functions](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).</span></span>  
  
## <a name="progid-and-clsid"></a><span data-ttu-id="37d7d-532">ProgID et CLSID</span><span class="sxs-lookup"><span data-stu-id="37d7d-532">ProgID and CLSID</span></span>  
 <span data-ttu-id="37d7d-533">Les clés dans la sous-arborescence HKEY_CLASSES_ROOT du Registre contiennent divers types de sous-clé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-533">Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</span></span> <span data-ttu-id="37d7d-534">La plupart des sous-clés sont des ProgID, qui mappent une chaîne conviviale à un CLSID.</span><span class="sxs-lookup"><span data-stu-id="37d7d-534">Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</span></span> <span data-ttu-id="37d7d-535">Applications utilisent souvent ces chaînes explicites au lieu des CLSID numériques.</span><span class="sxs-lookup"><span data-stu-id="37d7d-535">Applications often use these human-readable strings instead of the numeric CLSIDs.</span></span> <span data-ttu-id="37d7d-536">Souvent, un composant possède un ProgID indépendants de la version qui est mappé à la version la plus récente du composant qui est installé sur le système.</span><span class="sxs-lookup"><span data-stu-id="37d7d-536">Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</span></span>  
  
 <span data-ttu-id="37d7d-537">Applications et composants utilisent principalement des ProgID pour extraire les CLSID correspondants.</span><span class="sxs-lookup"><span data-stu-id="37d7d-537">Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-538">L’exemple suivant a été exécuté sur un ordinateur qui a été configuré avec une instance en cours d’exécution de Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="37d7d-538">The following example was run on a computer that was configured with a running instance of Microsoft Word.</span></span> <span data-ttu-id="37d7d-539">Il n’existe aucune instance de Microsoft Excel est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="37d7d-539">There were no instances of Microsoft Excel running.</span></span>  
  
 <span data-ttu-id="37d7d-540">L’exemple appelle <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> à deux reprises.</span><span class="sxs-lookup"><span data-stu-id="37d7d-540">The example calls <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> twice.</span></span> <span data-ttu-id="37d7d-541">Le premier appel essaie d’extraire une référence à une instance de Microsoft Word (une instance de la `Word.Application` objet).</span><span class="sxs-lookup"><span data-stu-id="37d7d-541">The first call tries to retrieve a reference to an instance of Microsoft Word (an instance of the `Word.Application` object).</span></span> <span data-ttu-id="37d7d-542">Le deuxième appel essaie d’extraire une référence à une instance de Microsoft Excel (une instance d’un `Excel.Application` objet).</span><span class="sxs-lookup"><span data-stu-id="37d7d-542">The second call tries to retrieve a reference to an instance of Microsoft Excel (an instance of an `Excel.Application` object).</span></span>  
  
 <span data-ttu-id="37d7d-543">Le code récupère une référence à une instance de Microsoft Word avec succès.</span><span class="sxs-lookup"><span data-stu-id="37d7d-543">The code retrieves a reference to an instance of Microsoft Word successfully.</span></span> <span data-ttu-id="37d7d-544">Toutefois, étant donné que Microsoft Excel n’est pas en cours d’exécution, la tentative d’extraire le deuxième objet lève une <xref:System.Runtime.InteropServices.COMException>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-544">However, because Microsoft Excel is not running, the attempt to retrieve the second object raises a <xref:System.Runtime.InteropServices.COMException>.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="37d7d-545">L’objet est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-545">The object was not found.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-546">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-546">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-547">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-547">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComInterfaceForObject">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-548">Retourne un pointeur d'interface qui représente l'interface d'un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-548">Returns an interface pointer that represents an interface for an object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-549">Objet qui fournit l'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-549">The object that provides the interface.</span>
          </span>
        </param>
        <param name="T">
          <span data-ttu-id="37d7d-550">Type d'interface demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-550">The type of interface that is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-551">Retourne un pointeur vers une interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) qui représente l’interface spécifiée de l’objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-551">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on the specified object.</span>
          </span>
          <span data-ttu-id="37d7d-552">L'accès à l'interface de requête personnalisée est activé par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-552">Custom query interface access is enabled by default.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-553">Pointeur d'interface qui représente l'interface spécifiée de l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-553">The interface pointer that represents the specified interface for the object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-554">Cette méthode retourne un pointeur d’interface qui représente l’interface demandée sur l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="37d7d-554">This method returns an interface pointer that represents the requested interface on the specified object.</span></span> <span data-ttu-id="37d7d-555">Il est particulièrement utile si vous avez une méthode non managée qui s’attend à passer un pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-555">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="37d7d-556">Appel d’un objet avec cette méthode entraîne le décompte de références incrémenter sur le pointeur d’interface avant que le pointeur est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-556">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="37d7d-557">Toujours utiliser <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> pour décrémenter le décompte de références, une fois que vous avez terminé avec le pointeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-557">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="37d7d-558">Vous devez respecter les règles définies par COM lors de l’utilisation de pointeurs d’interface COM bruts.</span><span class="sxs-lookup"><span data-stu-id="37d7d-558">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="37d7d-559"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> est utile lors de l’appel d’une méthode qui expose un paramètre d’objet COM en tant qu’un <xref:System.IntPtr> type, ou avec un marshaling personnalisé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-559"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="37d7d-560">Bien que peu fréquente, vous pouvez utiliser cette méthode sur un objet managé pour obtenir un pointeur vers le wrapper CCW de l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-560">Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</span></span> <span data-ttu-id="37d7d-561">Par exemple, vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> sur un objet managé qui est exporté vers COM afin d’obtenir un pointeur d’interface pour <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-561">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-562">Impossible d’obtenir un pointeur vers une interface de classe depuis une interface de classe ne dispose pas du type correspondant pour passer le second paramètre (`t`).</span><span class="sxs-lookup"><span data-stu-id="37d7d-562">You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (`t`).</span></span> <span data-ttu-id="37d7d-563">Au lieu de cela, utilisez <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> pour appeler les membres de l’interface par défaut du wrapper pouvant être appelé par COM, qui est généralement une interface de classe auto dispatch.</span><span class="sxs-lookup"><span data-stu-id="37d7d-563">Instead, use <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</span></span>  
  
 <span data-ttu-id="37d7d-564">Le <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> surcharge de méthode autorise la personnalisation d’interface de requête par défaut.</span><span class="sxs-lookup"><span data-stu-id="37d7d-564">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="37d7d-565">Pour spécifier s’il faut appliquer la personnalisation d’interface de requête, utilisez le <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-565">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="37d7d-566">Pour plus d’informations, consultez la [Wrapper CCW](~/docs/framework/interop/com-callable-wrapper.md), [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md), et [présentation de l’Interface de classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) rubriques.</span><span class="sxs-lookup"><span data-stu-id="37d7d-566">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), and [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) topics.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-567">Le paramètre <typeparamref name="T" /> n'est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-567">The <typeparamref name="T" /> parameter is not an interface.</span>
          </span>
          <span data-ttu-id="37d7d-568">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-568">-or-</span>
          </span>
          <span data-ttu-id="37d7d-569">Le type n'est pas visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-569">The type is not visible to COM.</span>
          </span>
          <span data-ttu-id="37d7d-570">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-570">-or-</span>
          </span>
          <span data-ttu-id="37d7d-571">Le paramètre <typeparamref name="T" /> est une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-571">The <typeparamref name="T" /> parameter is a generic type definition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-572">Le paramètre <paramref name="o" /> ne prend pas en charge l'interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-572">The <paramref name="o" /> parameter does not support the requested interface.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-573">Le paramètre <paramref name="o" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-573">The <paramref name="o" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-574">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-574">-or-</span>
          </span>
          <span data-ttu-id="37d7d-575">Le paramètre <typeparamref name="T" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-575">The <typeparamref name="T" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-576">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-576">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-577">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-577">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject (o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObject(System::Object ^ o, Type ^ T, System::Runtime::InteropServices::CustomQueryInterfaceMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-578">Objet qui fournit l'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-578">The object that provides the interface.</span>
          </span>
        </param>
        <param name="T">
          <span data-ttu-id="37d7d-579">Type d'interface demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-579">The type of interface that is requested.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="37d7d-580">Une des valeurs d'énumération qui indique s'il faut appliquer une personnalisation <see langword="IUnknown::QueryInterface" /> fournie par un <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-580">One of the enumeration values that indicates whether to apply an <see langword="IUnknown::QueryInterface" /> customization that is supplied by an <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-581">Retourne un pointeur vers une interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) qui représente l’interface spécifiée de l’objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-581">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on the specified object.</span>
          </span>
          <span data-ttu-id="37d7d-582">L'accès à l'interface de requête personnalisée est contrôlé par le mode de personnalisation spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-582">Custom query interface access is controlled by the specified customization mode.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-583">Pointeur d'interface qui représente l'interface de l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-583">The interface pointer that represents the interface for the object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-584"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> permet de spécifier s’il faut appliquer la personnalisation d’interface de requête.</span><span class="sxs-lookup"><span data-stu-id="37d7d-584"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> lets you specify whether to apply query interface customization.</span></span> <span data-ttu-id="37d7d-585">Utilisez le <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> surcharge pour appliquer la personnalisation de l’interface requête par défaut.</span><span class="sxs-lookup"><span data-stu-id="37d7d-585">Use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> overload to apply query interface customization by default.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-586">Le paramètre <typeparamref name="T" /> n'est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-586">The <typeparamref name="T" /> parameter is not an interface.</span>
          </span>
          <span data-ttu-id="37d7d-587">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-587">-or-</span>
          </span>
          <span data-ttu-id="37d7d-588">Le type n'est pas visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-588">The type is not visible to COM.</span>
          </span>
          <span data-ttu-id="37d7d-589">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-589">-or-</span>
          </span>
          <span data-ttu-id="37d7d-590">Le paramètre <typeparamref name="T" /> est une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-590">The <typeparamref name="T" /> parameter is a generic type definition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-591">L'objet <paramref name="o" /> ne prend pas en charge l'interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-591">The object <paramref name="o" /> does not support the requested interface.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-592">Le paramètre <paramref name="o" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-592">The <paramref name="o" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-593">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-593">-or-</span>
          </span>
          <span data-ttu-id="37d7d-594">Le paramètre <typeparamref name="T" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-594">The <typeparamref name="T" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-595">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-595">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-596">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-596">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObject(Of T, TInterface) (o As T) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TInterface&gt;&#xA; static IntPtr GetComInterfaceForObject(T o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-597">Le type de <c>o</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-597">The type of <c>o</c>.</span>
          </span>
        </typeparam>
        <typeparam name="TInterface">
          <span data-ttu-id="37d7d-598">Type d'interface à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-598">The type of interface to return.</span>
          </span>
        </typeparam>
        <param name="o">
          <span data-ttu-id="37d7d-599">Objet qui fournit l'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-599">The object that provides the interface.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-600">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-600">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-601">Retourne un pointeur vers une interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) qui représente l’interface spécifiée d’un objet du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-601">Returns a pointer to an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface that represents the specified interface on an object of the specified type.</span>
          </span>
          <span data-ttu-id="37d7d-602">L'accès à l'interface de requête personnalisée est activé par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-602">Custom query interface access is enabled by default.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-603">Pointeur d'interface qui représente l'interface <paramref name="TInterface" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-603">The interface pointer that represents the <paramref name="TInterface" /> interface.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-604">Cette méthode retourne un pointeur d’interface qui représente le `TInterface` interface sur l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="37d7d-604">This method returns an interface pointer that represents the `TInterface` interface on the specified object.</span></span> <span data-ttu-id="37d7d-605">Il est particulièrement utile si vous avez une méthode non managée qui s’attend à passer un pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-605">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span> <span data-ttu-id="37d7d-606">Appel d’un objet avec cette méthode entraîne le décompte de références incrémenter sur le pointeur d’interface avant que le pointeur est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-606">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="37d7d-607">Utilisez toujours le <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> pour décrémenter le décompte de références lorsque vous avez terminé avec le pointeur de la méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-607">Always use the <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> method to decrement the reference count when you have finished with the pointer.</span></span> <span data-ttu-id="37d7d-608">Vous devez respecter les règles définies par COM lors de l’utilisation de pointeurs d’interface COM bruts.</span><span class="sxs-lookup"><span data-stu-id="37d7d-608">You must adhere to the rules defined by COM when using raw COM interface pointers.</span></span>  
  
 <span data-ttu-id="37d7d-609"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> est utile lors de l’appel d’une méthode qui expose un paramètre d’objet COM en tant qu’un <xref:System.IntPtr> type, ou avec un marshaling personnalisé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-609"><xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="37d7d-610">Vous pouvez également utiliser cette méthode sur un objet managé pour obtenir un pointeur vers wrapper CCW l’objet, bien que cela est moins fréquent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-610">You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</span></span> <span data-ttu-id="37d7d-611">Par exemple, vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> sur un objet managé qui est exporté vers COM afin d’obtenir un pointeur d’interface pour <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-611">For example, you can use <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> on a managed object that is exported to COM to obtain an interface pointer for <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-612">Le <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> surcharge de méthode autorise la personnalisation d’interface de requête par défaut.</span><span class="sxs-lookup"><span data-stu-id="37d7d-612">The <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> method overload allows query interface customization by default.</span></span> <span data-ttu-id="37d7d-613">Pour spécifier s’il faut appliquer la personnalisation d’interface de requête, utilisez le <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-613">To specify whether to apply query interface customization, use the <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> method overload.</span></span>  
  
 <span data-ttu-id="37d7d-614">Pour plus d’informations, consultez la [Wrapper CCW](~/docs/framework/interop/com-callable-wrapper.md), [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md), et [présentation de l’Interface de classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) rubriques.</span><span class="sxs-lookup"><span data-stu-id="37d7d-614">For additional information, see the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), and [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024) topics.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-615">Le paramètre <paramref name="TInterface" /> n'est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-615">The <paramref name="TInterface" /> parameter is not an interface.</span>
          </span>
          <span data-ttu-id="37d7d-616">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-616">-or-</span>
          </span>
          <span data-ttu-id="37d7d-617">Le type n'est pas visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-617">The type is not visible to COM.</span>
          </span>
          <span data-ttu-id="37d7d-618">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-618">-or-</span>
          </span>
          <span data-ttu-id="37d7d-619">Le paramètre <typeparamref name="T" /> est un type générique ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-619">The <typeparamref name="T" /> parameter is an open generic type.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-620">Le paramètre <paramref name="o" /> ne prend pas en charge l'interface <paramref name="TInterface" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-620">The <paramref name="o" /> parameter does not support the <paramref name="TInterface" /> interface.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-621">Le paramètre <paramref name="o" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-621">The <paramref name="o" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-622">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-622">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-623">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-623">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComInterfaceForObjectInContext (o As Object, t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetComInterfaceForObjectInContext(System::Object ^ o, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-624">Objet qui fournit l'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-624">The object that provides the interface.</span>
          </span>
        </param>
        <param name="t">
          <span data-ttu-id="37d7d-625">Type d'interface demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-625">The type of interface that is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-626">Retourne un pointeur d'interface qui représente l'interface spécifiée pour un objet, si l'appelant est dans le même contexte que cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-626">Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-627">Pointeur d'interface spécifié par <paramref name="t" /> qui représente l'interface pour l'objet spécifié ou <see langword="null" /> si l'appelant n'est pas dans le même contexte que l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-627">The interface pointer specified by <paramref name="t" /> that represents the interface for the specified object, or <see langword="null" /> if the caller is not in the same context as the object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-628">Cette méthode est identique à <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> , sauf qu’elle retourne `null` si l’appelant n’est pas dans le même contexte que l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-628">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span> <span data-ttu-id="37d7d-629">Il est particulièrement utile si vous avez une méthode non managée qui s’attend à passer un pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-629">It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-630">
            <paramref name="t" /> n'est pas une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-630">
              <paramref name="t" /> is not an interface.</span>
          </span>
          <span data-ttu-id="37d7d-631">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-631">-or-</span>
          </span>
          <span data-ttu-id="37d7d-632">Le type n'est pas visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-632">The type is not visible to COM.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-633">
            <paramref name="o" /> ne prend pas en charge l'interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-633">
              <paramref name="o" /> does not support the requested interface.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-634">
            <paramref name="o" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-634">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-635">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-635">-or-</span>
          </span>
          <span data-ttu-id="37d7d-636">
            <paramref name="t" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-636">
              <paramref name="t" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-637">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-637">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-638">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-638">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComObjectData (obj As Object, key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetComObjectData(System::Object ^ obj, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="37d7d-639">Objet COM qui contient les données souhaitées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-639">The COM object that contains the data that you want.</span>
          </span>
        </param>
        <param name="key">
          <span data-ttu-id="37d7d-640">Clé dans la table de hachage interne de <c>obj</c> dans laquelle récupérer les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-640">The key in the internal hash table of <c>obj</c> to retrieve the data from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-641">Récupère des  données référencées par la clé spécifiée à partir de l'objet COM spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-641">Retrieves data that is referenced by the specified key from the specified COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-642">Données représentées par le paramètre <paramref name="key" /> dans la table de hachage interne du paramètre <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-642">The data represented by the <paramref name="key" /> parameter in the internal hash table of the <paramref name="obj" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-643">Tous les objets COM encapsulés dans un [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md) ont un hachage associée de table, ce qui <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> récupère.</span><span class="sxs-lookup"><span data-stu-id="37d7d-643">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) have an associated hash table, which <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> retrieves.</span></span> <span data-ttu-id="37d7d-644"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> Ajoute des données à la table de hachage.</span><span class="sxs-lookup"><span data-stu-id="37d7d-644"><xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType> adds data to the hash table.</span></span> <span data-ttu-id="37d7d-645">Vous ne devez jamais appeler soit la méthode à partir de votre code.</span><span class="sxs-lookup"><span data-stu-id="37d7d-645">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-646">
            <paramref name="obj" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-646">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-647">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-647">-or-</span>
          </span>
          <span data-ttu-id="37d7d-648">
            <paramref name="key" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-648">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-649">
            <paramref name="obj" /> n’est pas un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-649">
              <paramref name="obj" /> is not a COM object.</span>
          </span>
          <span data-ttu-id="37d7d-650">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-650">-or-</span>
          </span>
          <span data-ttu-id="37d7d-651">
            <paramref name="obj" /> est un objet [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-651">
              <paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-652">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-652">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-653">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-653">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComSlotForMethodInfo (m As MemberInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetComSlotForMethodInfo(System::Reflection::MemberInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="m">
          <span data-ttu-id="37d7d-654">Objet qui représente une méthode d'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-654">An object that represents an interface method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-655">Récupère l'emplacement de la table de fonctions virtuelles (v-table ou VTBL) pour le type <see cref="T:System.Reflection.MemberInfo" /> spécifié lorsque ce type est exposé à COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-655">Retrieves the virtual function table (v-table or VTBL) slot for a specified <see cref="T:System.Reflection.MemberInfo" /> type when that type is exposed to COM.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-656">Identificateur <paramref name="m" /> de l'emplacement VTBL lorsqu'il est exposé à COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-656">The VTBL slot <paramref name="m" /> identifier when it is exposed to COM.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-657">Numéro de l’emplacement de base zéro retourné par cette méthode représente trois [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) et éventuellement quatre [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) méthodes la valeur du premier emplacement disponible égal à 3 ou 7.</span><span class="sxs-lookup"><span data-stu-id="37d7d-657">The zero-based slot number returned by this method accounts for three [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) and possibly four [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="37d7d-658"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> fournit les fonctionnalités inverses de <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-658"><xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-659">Vous pouvez utiliser cette méthode pour récupérer les numéros d’emplacements pour les membres des interfaces qui ne sont pas visibles par COM et pour les membres des interfaces privées.</span><span class="sxs-lookup"><span data-stu-id="37d7d-659">You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</span></span> <span data-ttu-id="37d7d-660">Les numéros d’emplacement retournés correspondent aux chiffres de la vtable qui seraient réservés si le type a été exposé à COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-660">The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</span></span> <span data-ttu-id="37d7d-661">Membres non visibles par COM occupent en fait un emplacement dans une vtable exposée, même si le client COM ne peut pas utiliser l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-661">COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</span></span> <span data-ttu-id="37d7d-662">Vous ne pouvez pas utiliser <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> sur une interface de classe en passant <xref:System.Reflection.MemberInfo> à partir d’une classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-662">You cannot use <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> on a class interface by passing <xref:System.Reflection.MemberInfo> from a class.</span></span> <span data-ttu-id="37d7d-663">Pour plus d’informations, consultez [présentation de l’Interface de classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span><span class="sxs-lookup"><span data-stu-id="37d7d-663">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-664">Le paramètre <paramref name="m" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-664">The <paramref name="m" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-665">Le paramètre <paramref name="m" /> n'est pas un objet <see cref="T:System.Reflection.MemberInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-665">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MemberInfo" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-666">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-666">-or-</span>
          </span>
          <span data-ttu-id="37d7d-667">Le paramètre <paramref name="m" /> n'est pas une méthode d'interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-667">The <paramref name="m" /> parameter is not an interface method.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-668">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-668">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-669">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-669">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer (ptr As IntPtr, t As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ GetDelegateForFunctionPointer(IntPtr ptr, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-670">Pointeur vers la fonction non managée à convertir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-670">The unmanaged function pointer to be converted.</span>
          </span>
        </param>
        <param name="t">
          <span data-ttu-id="37d7d-671">Type du délégué à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-671">The type of the delegate to be returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-672">Convertit un pointeur fonction non managé en un délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-672">Converts an unmanaged function pointer to a delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-673">Instance de délégué qui peut être castée en type délégué approprié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-673">A delegate instance that can be cast to the appropriate delegate type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-674">Dans les versions 1.0 et 1.1 du .NET Framework, il était possible de passer un délégué qui représente une méthode managée au code non managé comme un pointeur de fonction, ce qui permet le code non managé appeler la méthode managée via le pointeur de fonction.</span><span class="sxs-lookup"><span data-stu-id="37d7d-674">In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</span></span> <span data-ttu-id="37d7d-675">Il est également possible pour le code non managé passer ce pointeur de fonction vers du code managé, et le pointeur a été correctement résolu à la méthode managée sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="37d7d-675">It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</span></span>  
  
 <span data-ttu-id="37d7d-676">Dans le .NET Framework 2.0 et les versions ultérieures, vous pouvez utiliser la <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> et <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> méthodes pour marshaler les délégués dans les deux sens.</span><span class="sxs-lookup"><span data-stu-id="37d7d-676">In the .NET Framework 2.0 and later versions, you can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> methods to marshal delegates in both directions.</span></span> <span data-ttu-id="37d7d-677">Avec <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` est importée comme un <xref:System.IntPtr?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-677">With <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` is imported as a <xref:System.IntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-678">A <xref:System.IntPtr?displayProperty=nameWithType> peut être obtenu pour un délégué managé en appelant <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> et passé en tant que paramètre ; il peut ensuite être appelée à partir de la méthode non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-678">A <xref:System.IntPtr?displayProperty=nameWithType> can be obtained for a managed delegate by calling <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> and passed as a parameter; it can then be called from inside the unmanaged method.</span></span> <span data-ttu-id="37d7d-679">Notez que le marshaleur de paramètres peut également marshaler des pointeurs fonction en délégués dans le .NET Framework 2.0 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="37d7d-679">Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</span></span>  
  
 <span data-ttu-id="37d7d-680">Le <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> méthode présente les restrictions suivantes :</span><span class="sxs-lookup"><span data-stu-id="37d7d-680">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="37d7d-681">Les génériques ne sont pas pris en charge dans les scénarios d’interopérabilité.</span><span class="sxs-lookup"><span data-stu-id="37d7d-681">Generics are not supported in interop scenarios.</span></span>  
  
-   <span data-ttu-id="37d7d-682">Vous ne pouvez pas passer un pointeur fonction non valide pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-682">You cannot pass an invalid function pointer to this method.</span></span>  
  
-   <span data-ttu-id="37d7d-683">Vous pouvez utiliser cette méthode uniquement pour les pointeurs de fonction non managés purs.</span><span class="sxs-lookup"><span data-stu-id="37d7d-683">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="37d7d-684">Vous ne pouvez pas utiliser cette méthode avec des pointeurs de fonction obtenues via C++ ou le <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-684">You cannot use this method with function pointers obtained through C++ or from the <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> method.</span></span>  
  
-   <span data-ttu-id="37d7d-685">Vous ne pouvez pas utiliser cette méthode pour créer un délégué à partir d’un pointeur de fonction vers un autre délégué managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-685">You cannot use this method to create a delegate from a function pointer to another managed delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-686">Le paramètre <paramref name="t" /> n'est pas un délégué ou est générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-686">The <paramref name="t" /> parameter is not a delegate or is generic.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-687">Le paramètre <paramref name="ptr" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-687">The <paramref name="ptr" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-688">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-688">-or-</span>
          </span>
          <span data-ttu-id="37d7d-689">Le paramètre <paramref name="t" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-689">The <paramref name="t" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-690">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-690">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-691">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-691">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDelegateForFunctionPointer(Of TDelegate) (ptr As IntPtr) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="37d7d-692">Type de délégué à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-692">The type of the delegate to return.</span>
          </span>
        </typeparam>
        <param name="ptr">
          <span data-ttu-id="37d7d-693">Pointeur vers la fonction non managée à convertir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-693">The unmanaged function pointer to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-694">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-694">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-695">Convertit un pointeur fonction non managé en un délégué d'un type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-695">Converts an unmanaged function pointer to a delegate of a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-696">Instance du type délégué spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-696">A instance of the specified delegate type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-697">Vous pouvez utiliser la <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> et <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> méthodes pour marshaler les délégués dans les deux sens.</span><span class="sxs-lookup"><span data-stu-id="37d7d-697">You can use the <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> and <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> methods to marshal delegates in both directions.</span></span>  
  
 <span data-ttu-id="37d7d-698">Le <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> méthode présente les restrictions suivantes :</span><span class="sxs-lookup"><span data-stu-id="37d7d-698">The <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> method has the following restrictions:</span></span>  
  
-   <span data-ttu-id="37d7d-699">Vous ne pouvez pas passer un pointeur fonction non valide pour cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-699">You cannot pass an invalid function pointer to this method.</span></span>  
  
-   <span data-ttu-id="37d7d-700">Vous pouvez utiliser cette méthode uniquement pour les pointeurs de fonction non managés purs.</span><span class="sxs-lookup"><span data-stu-id="37d7d-700">You can use this method only for pure unmanaged function pointers.</span></span>  
  
-   <span data-ttu-id="37d7d-701">Vous ne pouvez pas utiliser cette méthode avec des pointeurs de fonction obtenues via C++ ou le <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-701">You cannot use this method with function pointers obtained through C++ or from the <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> method.</span></span>  
  
-   <span data-ttu-id="37d7d-702">Vous ne pouvez pas utiliser cette méthode pour créer un délégué à partir d’un pointeur de fonction vers un autre délégué managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-702">You cannot use this method to create a delegate from a function pointer to another managed delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-703">Le paramètre générique <paramref name="TDelegate" /> n'est pas un délégué ou il s'agit d'un type générique ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-703">The <paramref name="TDelegate" /> generic parameter is not a delegate, or it is an open generic type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-704">Le paramètre <paramref name="ptr" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-704">The <paramref name="ptr" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-705">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-705">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-706">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-706">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEndComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEndComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-707">Type qui représente une interface ou une classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-707">A type that represents an interface or class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-708">Récupère le dernier emplacement dans la table de fonctions virtuelles (v-table ou VTBL) d'un type en cas d'exposition à COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-708">Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-709">Dernier emplacement VTBL de l'interface en cas d'exposition à COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-709">The last VTBL slot of the interface when exposed to COM.</span>
          </span>
          <span data-ttu-id="37d7d-710">Si le paramètre <paramref name="t" /> est une classe, l'emplacement VTBL retourné est le dernier emplacement dans l'interface qui est générée à partir de la classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-710">If the <paramref name="t" /> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-711">Cette méthode retourne le nombre de v-table de base zéro, une interface ou une classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-711">This method returns the zero-based, v-table number for an interface or a class.</span></span> <span data-ttu-id="37d7d-712">Lorsqu’il est utilisé sur une classe, le numéro d’emplacement retourné fait référence à l’interface de classe pour la classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-712">When used on a class, the slot number returned refers to the class interface for the class.</span></span> <span data-ttu-id="37d7d-713">Si l’interface de classe est de double automatique, cette méthode retourne toujours -1 pour indiquer que l’interface de dispatch uniquement n’expose pas une vtable à des clients managés.</span><span class="sxs-lookup"><span data-stu-id="37d7d-713">If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="37d7d-714">Vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> et <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> conjointement avec <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> pour passer des emplacements dans une plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-714">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="37d7d-715">Pour plus d’informations, consultez [présentation de l’Interface de classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span><span class="sxs-lookup"><span data-stu-id="37d7d-715">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-716">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-716">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-717">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-717">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetExceptionCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-718">Récupère un code qui identifie le type de l'exception qui s'est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-718">Retrieves a code that identifies the type of the exception that occurred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-719">Type de l'exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-719">The type of the exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-720"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> est exposé pour la prise en charge du compilateur des exceptions structurées (SEH) uniquement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-720"><xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span> <span data-ttu-id="37d7d-721">Si cette méthode est appelée avant une exception est levée, elle retourne 0 x 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-721">If this method is called before an exception is thrown, it returns 0x0.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-722">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-722">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-723">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-723">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-724">Convertit un code d'erreur HRESULT en objet <see cref="T:System.Exception" /> correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-724">Converts an HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">
          <span data-ttu-id="37d7d-725">HRESULT à convertir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-725">The HRESULT to be converted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-726">Convertit le code d'erreur HRESULT spécifié en objet <see cref="T:System.Exception" /> correspondant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-726">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-727">Objet qui représente le HRESULT converti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-727">An object that represents the converted HRESULT.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-728">Utilisez le <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> méthode pour obtenir un <xref:System.Exception> basé sur un HRESULT sans devoir appeler le <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> (méthode) et intercepter l’exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-728">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception.</span></span>  
  
 <span data-ttu-id="37d7d-729">En cours [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface est utilisée pour construire l’exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-729">The current [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface is used to construct the exception.</span></span>  
  
 <span data-ttu-id="37d7d-730">Pour le mappage de chaque HRESULT à sa classe d’exception comparable dans le .NET Framework, consultez [Comment : mappage HRESULT et des Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-730">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-731">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-731">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-732">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-732">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionForHR (errorCode As Integer, errorInfo As IntPtr) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Exception ^ GetExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">
          <span data-ttu-id="37d7d-733">HRESULT à convertir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-733">The HRESULT to be converted.</span>
          </span>
        </param>
        <param name="errorInfo">
          <span data-ttu-id="37d7d-734">Pointeur vers l'interface <see langword="IErrorInfo" /> qui fournit plus d'informations sur l'erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-734">A pointer to the <see langword="IErrorInfo" /> interface that provides more information about the error.</span>
          </span>
          <span data-ttu-id="37d7d-735">Vous pouvez spécifier <c>IntPtr(0)</c> pour utiliser l’interface <see langword="IErrorInfo" /> actuelle ou <c>IntPtr(-1)</c> pour ignorer l’interface <see langword="IErrorInfo" /> actuelle et construire l’exception uniquement à partir du code d’erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-735">You can specify <c>IntPtr(0)</c> to use the current <see langword="IErrorInfo" /> interface, or <c>IntPtr(-1)</c> to ignore the current <see langword="IErrorInfo" /> interface and construct the exception just from the error code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-736">Convertit le code d’erreur HRESULT spécifié en objet <see cref="T:System.Exception" /> correspondant, avec des informations supplémentaires sur l’erreur passées dans une interface [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) pour l’objet exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-736">Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object, with additional error information passed in an [IErrorInfo](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface for the exception object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-737">Objet qui représente le HRESULT converti et les informations obtenues à partir de <paramref name="errorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-737">An object that represents the converted HRESULT and information obtained from <paramref name="errorInfo" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-738">Utilisez le <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> méthode pour obtenir un <xref:System.Exception> basé sur un HRESULT sans devoir appeler le <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> méthode et intercepter l’exception (évitant ainsi la charge de performances correspondante).</span><span class="sxs-lookup"><span data-stu-id="37d7d-738">Use the <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> method to get an <xref:System.Exception> based on an HRESULT without having to call the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method and catch the exception (thus avoiding the corresponding performance overhead).</span></span> <span data-ttu-id="37d7d-739">Le `errorInfo` paramètre fournit des informations supplémentaires sur l’erreur, telles que sa description textuelle et l’identificateur global unique (GUID) pour l’interface ayant défini l’erreur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-739">The `errorInfo` parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</span></span>  
  
 <span data-ttu-id="37d7d-740">Utilisez cette surcharge de méthode si vous disposez des informations d’erreur personnalisées que vous devez fournir dans la conversion.</span><span class="sxs-lookup"><span data-stu-id="37d7d-740">Use this method overload if you have custom error information that you have to supply in the conversion.</span></span>  
  
 <span data-ttu-id="37d7d-741">Pour le mappage de chaque HRESULT à sa classe d’exception comparable dans le .NET Framework, consultez [Comment : mappage HRESULT et des Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-741">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-742">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-742">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-743">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-743">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" />
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExceptionPointers () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetExceptionPointers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-744">Récupère une description indépendante de l'ordinateur d'une exception, ainsi que des informations sur l'état de l'ordinateur qui existait pour le thread lorsque l'exception s'est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-744">Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-745">Pointeur vers une structure [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-745">A pointer to an [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648) structure.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-746"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> est exposé pour la prise en charge du compilateur des exceptions structurées (SEH) uniquement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-746"><xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A> is exposed for compiler support of structured exception handling (SEH) only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-747">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-747">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-748">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-748">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate (d As Delegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetFunctionPointerForDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="37d7d-749">Délégué à passer au code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-749">The delegate to be passed to unmanaged code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-750">Convertit un délégué en pointeur fonction pouvant être appelé à partir du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-750">Converts a delegate into a function pointer that is callable from unmanaged code.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-751">Valeur qui peut être passée à du code non managé, qui peut à son tour l'utiliser pour appeler le délégué managé sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-751">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-752">Le délégué `d` est converti en un pointeur de fonction qui peut être passé au code non managé à l’aide de la [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) convention d’appel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-752">The delegate `d` is converted to a function pointer that can be passed to unmanaged code using the [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) calling convention.</span></span>  
  
 <span data-ttu-id="37d7d-753">Vous devez manuellement empêcher le délégué d’être récupéré par le garbage collector à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-753">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="37d7d-754">Le garbage collector ne suit pas les références au code non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-754">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-755">Le paramètre <paramref name="d" /> est une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-755">The <paramref name="d" /> parameter is a generic type definition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-756">Le paramètre <paramref name="d" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-756">The <paramref name="d" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-757">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-757">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-758">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-758">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFunctionPointerForDelegate(Of TDelegate) (d As TDelegate) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDelegate&gt;&#xA; static IntPtr GetFunctionPointerForDelegate(TDelegate d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">
          <span data-ttu-id="37d7d-759">Type de délégué à convertir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-759">The type of delegate to convert.</span>
          </span>
        </typeparam>
        <param name="d">
          <span data-ttu-id="37d7d-760">Délégué à passer au code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-760">The delegate to be passed to unmanaged code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-761">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-761">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-762">Convertit un délégué d'un type spécifié en pointeur fonction pouvant être appelé à partir du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-762">Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-763">Valeur qui peut être passée à du code non managé, qui peut à son tour l'utiliser pour appeler le délégué managé sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-763">A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-764">Le délégué `d` est converti en un pointeur de fonction qui peut être passé au code non managé en utilisant la [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) convention d’appel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-764">The delegate `d` is converted to a function pointer that can be passed to unmanaged code by using the [__stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) calling convention.</span></span>  
  
 <span data-ttu-id="37d7d-765">Vous devez manuellement empêcher le délégué d’être récupéré par le garbage collector à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-765">You must manually keep the delegate from being collected by the garbage collector from managed code.</span></span> <span data-ttu-id="37d7d-766">Le garbage collector ne suit pas les références au code non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-766">The garbage collector does not track references to unmanaged code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-767">Le paramètre <paramref name="d" /> est une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-767">The <paramref name="d" /> parameter is a generic type definition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-768">Le paramètre <paramref name="d" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-768">The <paramref name="d" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-769">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-769">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-770">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-770">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHINSTANCE (m As Module) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHINSTANCE(System::Reflection::Module ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="m">
          <span data-ttu-id="37d7d-771">Module dont HINSTANCE est souhaité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-771">The module whose HINSTANCE is desired.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-772">Retourne le handle d'instance (HINSTANCE) pour le module spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-772">Returns the instance handle (HINSTANCE) for the specified module.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-773">HINSTANCE de <paramref name="m" /> ou -1 si le module n'a pas de HINSTANCE.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-773">The HINSTANCE for <paramref name="m" />; or -1 if the module does not have an HINSTANCE.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-774">Lorsque les modules dynamiques ou en mémoire, n’ont pas HINSTANCE.</span><span class="sxs-lookup"><span data-stu-id="37d7d-774">When dynamic or in-memory, modules do not have an HINSTANCE.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-775">Le paramètre <paramref name="m" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-775">The <paramref name="m" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-776">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-776">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-777">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-777">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForException (e As Exception) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForException(Exception ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="37d7d-778">Exception à convertir en HRESULT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-778">The exception to convert to an HRESULT.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-779">Convertit l'exception spécifiée en HRESULT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-779">Converts the specified exception to an HRESULT.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-780">HRESULT mappé en l'exception fournie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-780">The HRESULT mapped to the supplied exception.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-781"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> définit également un [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface pour l’exception qui peut être obtenue en appelant la fonction GetErrorInfoNEEDGUID.</span><span class="sxs-lookup"><span data-stu-id="37d7d-781"><xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> also sets up an [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</span></span> <span data-ttu-id="37d7d-782">Vous pouvez utiliser cette fonction pour retourner une valeur HRESULT sur une implémentation de classe managée d’une interface COM dans lequel vous appliquez le <xref:System.Runtime.InteropServices.PreserveSigAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="37d7d-782">You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <xref:System.Runtime.InteropServices.PreserveSigAttribute> attribute.</span></span> <span data-ttu-id="37d7d-783">Disposer de la méthode affectée intercepte toutes les exceptions et utiliser le <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> méthode pour retourner la valeur HRESULT appropriée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-783">Have the attributed method catch all exceptions and use the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method to return the appropriate HRESULT value.</span></span> <span data-ttu-id="37d7d-784">Une exception se propager à l’extérieur de la méthode produit un comportement incorrect.</span><span class="sxs-lookup"><span data-stu-id="37d7d-784">Allowing an exception to propagate outside the method produces incorrect behavior.</span></span> <span data-ttu-id="37d7d-785">(En fait, le common language runtime ne parvient pas à passer une exception à un client COM qui appelle une telle méthode via une vtable.)</span><span class="sxs-lookup"><span data-stu-id="37d7d-785">(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</span></span>  
  
 <span data-ttu-id="37d7d-786">Notez que la <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> méthode définit la [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-786">Note that the <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> method sets the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread.</span></span> <span data-ttu-id="37d7d-787">Cela peut entraîner des résultats inattendus pour des méthodes telles que la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> méthodes par défaut à l’aide de la [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) du thread actuel s’il est défini.</span><span class="sxs-lookup"><span data-stu-id="37d7d-787">This can cause unexpected results for methods like the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> methods that default to using the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) of the current thread if it is set.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-788">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-788">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-789">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-789">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHRForLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHRForLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-790">Retourne le HRESULT correspondant à la dernière erreur provoquée par du code Win32 exécuté en utilisant <see cref="T:System.Runtime.InteropServices.Marshal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-790">Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <see cref="T:System.Runtime.InteropServices.Marshal" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-791">HRESULT correspondant au dernier code d'erreur Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-791">The HRESULT corresponding to the last Win32 error code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-792">La fonction cible doit avoir le `setLastError` indicateur de métadonnées est défini.</span><span class="sxs-lookup"><span data-stu-id="37d7d-792">The target function must have had the `setLastError` metadata flag set.</span></span> <span data-ttu-id="37d7d-793">Par exemple, le `SetLastError` champ le <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> doit être `true`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-793">For example, the `SetLastError` field of the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> must be `true`.</span></span> <span data-ttu-id="37d7d-794">Le processus de définition de cet indicateur varie selon le langage source utilisé : c# et C++ sont `false` par défaut, mais la `Declare` instruction en Visual Basic est `true`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-794">The process for setting this flag depends on the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-795">L’exemple suivant montre comment récupérer un HRESULT correspondant à un code d’erreur Win32 à l’aide du <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-795">The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-796">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-796">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-797">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-797">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-798">Objet dont l'interface <see langword="IDispatch" /> est demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-798">The object whose <see langword="IDispatch" /> interface is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-799">Retourne une interface [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) à partir d’un objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-799">Returns an [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface from a managed object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-800">Pointeur <see langword="IDispatch" /> pour le paramètre <paramref name="o" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-800">The <see langword="IDispatch" /> pointer for the <paramref name="o" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-801">Dans le code managé, vous travaillez rarement directement avec le `IDispatch` interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-801">In managed code, you seldom work directly with the `IDispatch` interface.</span></span> <span data-ttu-id="37d7d-802">Toutefois, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> est utile lors de l’appel d’une méthode qui expose un paramètre d’objet COM en tant qu’un <xref:System.IntPtr> type, ou avec un marshaling personnalisé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-802">However, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="37d7d-803">Appel d’un objet avec cette méthode entraîne le décompte de références incrémenter sur le pointeur d’interface avant que le pointeur est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-803">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="37d7d-804">Toujours utiliser <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> pour décrémenter le décompte de références, une fois que vous avez terminé avec le pointeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-804">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span>  
  
 <span data-ttu-id="37d7d-805">Vous pouvez également utiliser cette méthode sur un objet managé pour obtenir un pointeur d’interface vers le wrapper CCW pour l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-805">You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</span></span> <span data-ttu-id="37d7d-806">Pour plus d’informations, consultez [Wrapper CCW](~/docs/framework/interop/com-callable-wrapper.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-806">For additional information, see [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-807">
            <paramref name="o" /> ne prend pas en charge l'interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-807">
              <paramref name="o" /> does not support the requested interface.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-808">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-808">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-809">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-809">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIDispatchForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIDispatchForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-810">Objet dont l'interface <see langword="IDispatch" /> est demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-810">The object whose <see langword="IDispatch" /> interface is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-811">Retourne un pointeur d’interface [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) à partir d’un objet managé, si l’appelant est dans le même contexte que cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-811">Returns an [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface pointer from a managed object, if the caller is in the same context as that object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-812">Pointeur d'interface <see langword="IDispatch" /> pour l'objet spécifié, ou <see langword="null" /> si l'appelant n'est pas dans le même contexte que l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-812">The <see langword="IDispatch" /> interface pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-813">Cette méthode est identique à <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> , sauf qu’elle retourne `null` si l’appelant n’est pas dans le même contexte que l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-813">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="37d7d-814">
            <paramref name="o" /> ne prend pas en charge l'interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-814">
              <paramref name="o" /> does not support the requested interface.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-815">
            <paramref name="o" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-815">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-816">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-816">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-817">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-817">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetITypeInfoForType (t As Type) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetITypeInfoForType(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-818">Type dont l'interface <see langword="ITypeInfo" /> est demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-818">The type whose <see langword="ITypeInfo" /> interface is being requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-819">Retourne une interface <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> à partir d'un type managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-819">Returns a <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> interface from a managed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-820">Pointeur vers l'interface <see langword="ITypeInfo" /> du paramètre <paramref name="t" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-820">A pointer to the <see langword="ITypeInfo" /> interface for the <paramref name="t" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-821">Cette méthode retourne un pointeur vers un `ITypeInfo` implémentation basée sur le type d’origine.</span><span class="sxs-lookup"><span data-stu-id="37d7d-821">This method returns a pointer to an `ITypeInfo` implementation that is based on the original type.</span></span> <span data-ttu-id="37d7d-822">Appel d’un objet avec <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> entraîne le décompte de références incrémenter sur le pointeur d’interface avant que le pointeur est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-822">Calling an object with <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="37d7d-823">Toujours utiliser <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> pour décrémenter le décompte de références, une fois que vous avez terminé avec le pointeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-823">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="37d7d-824">Vous pouvez appliquer le <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> pour remplacer le comportement de marshaling d’interopérabilité standard par ce marshaleur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-824">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-825">L’exemple suivant montre comment récupérer un pointeur vers le `ITypeInfo` interface pour un type à l’aide de la <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-825">The following example demonstrates how to retrieve a pointer to the `ITypeInfo` interface for a type using the <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-826">
            <paramref name="t" /> n’est pas un type visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-826">
              <paramref name="t" /> is not a visible type to COM.</span>
          </span>
          <span data-ttu-id="37d7d-827">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-827">-or-</span>
          </span>
          <span data-ttu-id="37d7d-828">
            <paramref name="t" /> est un type [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-828">
              <paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="37d7d-829">Une bibliothèque de types est inscrite pour l’assembly qui contient le type, mais la définition de type est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-829">A type library is registered for the assembly that contains the type, but the type definition cannot be found.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-830">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-830">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-831">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-831">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObject (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-832">Objet dont l'interface <see langword="IUnknown" /> est demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-832">The object whose <see langword="IUnknown" /> interface is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-833">Retourne une interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) à partir d’un objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-833">Returns an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface from a managed object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-834">Pointeur <see langword="IUnknown" /> pour le paramètre <paramref name="o" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-834">The <see langword="IUnknown" /> pointer for the <paramref name="o" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-835">Dans le code managé, vous travaillez rarement directement avec le `IUnknown` interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-835">In managed code, you seldom work directly with the `IUnknown` interface.</span></span> <span data-ttu-id="37d7d-836">Toutefois, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> est utile lors de l’appel d’une méthode qui expose un paramètre d’objet COM en tant qu’un <xref:System.IntPtr> type, ou avec un marshaling personnalisé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-836">However, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> is useful when calling a method that exposes a COM object parameter as an <xref:System.IntPtr> type, or with custom marshaling.</span></span> <span data-ttu-id="37d7d-837">Appel d’un objet avec cette méthode entraîne le décompte de références incrémenter sur le pointeur d’interface avant que le pointeur est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-837">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="37d7d-838">Toujours utiliser <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> pour décrémenter le décompte de références, une fois que vous avez terminé avec le pointeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-838">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="37d7d-839">Cette méthode fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-839">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="37d7d-840">Vous pouvez également utiliser cette méthode sur un objet managé pour obtenir un pointeur d’interface vers le [Wrapper CCW](~/docs/framework/interop/com-callable-wrapper.md) pour l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-840">You can also use this method on a managed object to obtain an interface pointer to the [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) for the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-841">L’exemple suivant montre comment récupérer un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pour un objet managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-841">The following example demonstrates how to retrieve an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-842">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-842">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-843">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-843">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIUnknownForObjectInContext (o As Object) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetIUnknownForObjectInContext(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-844">Objet dont l'interface <see langword="IUnknown" /> est demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-844">The object whose <see langword="IUnknown" /> interface is requested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-845">Retourne une interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) à partir d’un objet managé, si l’appelant est dans le même contexte que cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-845">Returns an [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface from a managed object, if the caller is in the same context as that object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-846">Pointeur <see langword="IUnknown" /> pour l'objet spécifié, ou <see langword="null" /> si l'appelant n'est pas dans le même contexte que l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-846">The <see langword="IUnknown" /> pointer for the specified object, or <see langword="null" /> if the caller is not in the same context as the specified object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-847">Cette méthode est identique à <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> , sauf qu’elle retourne `null` si l’appelant n’est pas dans le même contexte que l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-847">This method is the same as <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> except that it returns `null` if the caller is not in the same context as the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-848">L’exemple suivant montre comment récupérer un `IUnknown` interface pour un objet managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-848">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-849">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-849">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-850">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-850">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWin32Error () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetLastWin32Error();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-851">Retourne le code d'erreur retourné par la dernière fonction non managée appelée en utilisant l'appel de code non managé dont l'indicateur <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> est activé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-851">Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-852">Dernier code d’erreur défini par un appel à la fonction Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-852">The last error code set by a call to the Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656) function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-853"><xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> expose Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) fonction à partir de Kernel32.DLL.</span><span class="sxs-lookup"><span data-stu-id="37d7d-853"><xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> exposes the Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) function from Kernel32.DLL.</span></span> <span data-ttu-id="37d7d-854">Cette méthode existe, car il est déconseillé de faire appel à une plateforme directe `GetLastError` pour obtenir ces informations.</span><span class="sxs-lookup"><span data-stu-id="37d7d-854">This method exists because it is not safe to make a direct platform invoke call to `GetLastError` to obtain this information.</span></span> <span data-ttu-id="37d7d-855">Si vous souhaitez accéder à ce code d’erreur, vous devez appeler <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> au lieu d’écrire votre propre code non managé pour la définition de `GetLastError` et l’appeler.</span><span class="sxs-lookup"><span data-stu-id="37d7d-855">If you want to access this error code, you must call <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> instead of writing your own platform invoke definition for `GetLastError` and calling it.</span></span> <span data-ttu-id="37d7d-856">Le common language runtime peut effectuer des appels internes à des API qui remplacent la `GetLastError` gérées par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="37d7d-856">The common language runtime can make internal calls to APIs that overwrite the `GetLastError` maintained by the operating system.</span></span>  
  
 <span data-ttu-id="37d7d-857">Vous pouvez utiliser cette méthode pour obtenir les codes d’erreur uniquement si vous appliquez le <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> à la signature de méthode et un ensemble de la <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> au champ`true`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-857">You can use this method to obtain error codes only if you apply the <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> to the method signature and set the <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> field to`true`.</span></span> <span data-ttu-id="37d7d-858">Ce processus varie en fonction du langage source utilisé : c# et C++ sont `false` par défaut, mais la `Declare` instruction en Visual Basic est `true`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-858">The process for this varies depending upon the source language used: C# and C++ are `false` by default, but the `Declare` statement in Visual Basic is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-859">L'exemple suivant montre l'appel à la méthode <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-859">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> method.</span></span> <span data-ttu-id="37d7d-860">L’exemple montre d’abord appeler la méthode sans erreur, puis la méthode avec une erreur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-860">The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-861">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-861">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-862">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-862">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetManagedThunkForUnmanagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">
          <span data-ttu-id="37d7d-863">Pointeur vers la méthode à marshaler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-863">A pointer to the method to marshal.</span>
          </span>
        </param>
        <param name="pbSignature">
          <span data-ttu-id="37d7d-864">Pointeur vers la signature de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-864">A pointer to the method signature.</span>
          </span>
        </param>
        <param name="cbSignature">
          <span data-ttu-id="37d7d-865">Nombre d’octets dans <c>pbSignature</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-865">The number of bytes in <c>pbSignature</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-866">Obtient un pointeur vers une fonction générée par runtime qui marshale un appel du code managé à du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-866">Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-867">Pointeur vers la fonction qui doit marshaler un appel du paramètre <paramref name="pfnMethodToWrap" /> vers du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-867">A pointer to the function that will marshal a call from the <paramref name="pfnMethodToWrap" /> parameter to unmanaged code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-868"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> est exposé pour la prise en charge du compilateur uniquement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-868"><xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-869">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-869">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-870">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-870">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodInfoForComSlot (t As Type, slot As Integer, ByRef memberType As ComMemberType) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MemberInfo ^ GetMethodInfoForComSlot(Type ^ t, int slot, System::Runtime::InteropServices::ComMemberType % memberType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-871">Type pour lequel <see cref="T:System.Reflection.MemberInfo" /> doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-871">The type for which the <see cref="T:System.Reflection.MemberInfo" /> is to be retrieved.</span>
          </span>
        </param>
        <param name="slot">
          <span data-ttu-id="37d7d-872">Emplacement VTBL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-872">The VTBL slot.</span>
          </span>
        </param>
        <param name="memberType">
          <span data-ttu-id="37d7d-873">Lors d'un retour, une des valeurs d'énumération qui spécifie le type du membre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-873">On successful return, one of the enumeration values that specifies the type of the member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-874">Récupère un objet <see cref="T:System.Reflection.MemberInfo" /> pour l'emplacement de table de fonctions virtuelles (v-table ou VTBL) spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-874">Retrieves a <see cref="T:System.Reflection.MemberInfo" /> object for the specified virtual function table (v-table or VTBL) slot.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-875">Objet qui représente le membre à l'emplacement VTBL spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-875">The object that represents the member at the specified VTBL slot.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-876">La valeur de retour peut être un <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, ou <xref:System.Reflection.PropertyInfo> objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-876">The return value may be a <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, or <xref:System.Reflection.PropertyInfo> object.</span></span> <span data-ttu-id="37d7d-877">La valeur de retour varie selon le type de membre managé qui existe dans l’emplacement COM donné (par conséquent, de type de retour généralisé <xref:System.Reflection.MemberInfo> à partir de laquelle tous les trois dérivent).</span><span class="sxs-lookup"><span data-stu-id="37d7d-877">The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <xref:System.Reflection.MemberInfo> from which all three derive).</span></span>  
  
 <span data-ttu-id="37d7d-878">Le numéro d’emplacement de base zéro qui est retourné par cette méthode représente trois [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) et éventuellement quatre [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) méthodes la valeur du premier emplacement disponible égal à 3 ou 7.</span><span class="sxs-lookup"><span data-stu-id="37d7d-878">The zero-based slot number that is returned by this method accounts for three [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) and possibly four [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) methods, making the value of the first available slot either 3 or 7.</span></span> <span data-ttu-id="37d7d-879"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> fournit les fonctionnalités inverses de <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-879"><xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-880">Vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> conjointement avec <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> pour passer des emplacements dans une plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-880">You can use <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> to pass slots within a specified range.</span></span>  
  
 <span data-ttu-id="37d7d-881">Le `memberType` paramètre est important sur le retour.</span><span class="sxs-lookup"><span data-stu-id="37d7d-881">The `memberType` parameter is important only on return.</span></span> <span data-ttu-id="37d7d-882">Il contient le type du membre COM (une méthode normale ou un accesseur de propriété) qui correspond à le <xref:System.Reflection.MemberInfo> objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-882">It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <xref:System.Reflection.MemberInfo> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-883">
            <paramref name="t" /> n'est pas visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-883">
              <paramref name="t" /> is not visible from COM.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-884">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-884">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-885">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-885">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.ComMemberType" />
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject (obj As Object, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetNativeVariantForObject(System::Object ^ obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="37d7d-886">Objet pour lequel obtenir un VARIANT COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-886">The object for which to get a COM VARIANT.</span>
          </span>
        </param>
        <param name="pDstNativeVariant">
          <span data-ttu-id="37d7d-887">Pointeur devant recevoir le VARIANT et qui correspond au paramètre <c>obj</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-887">A pointer to receive the VARIANT that corresponds to the <c>obj</c> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-888">Convertit un objet en COM VARIANT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-888">Converts an object to a COM VARIANT.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-889">Le `pDstNativeVariant` paramètre doit pointer vers une mémoire suffisante pour stocker le type VARIANT résultant.</span><span class="sxs-lookup"><span data-stu-id="37d7d-889">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="37d7d-890">En outre, l’implémentation de cette méthode appelle la [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) fonction sur la mémoire brute qui le `pDstNativeVariant` paramètre pointe vers.</span><span class="sxs-lookup"><span data-stu-id="37d7d-890">Also, the implementation of this method calls the [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-891">Le paramètre <paramref name="obj" /> est une instance d’un type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-891">The <paramref name="obj" /> parameter is an instance of a generic type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-892">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-892">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-893">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-893">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetNativeVariantForObject(Of T) (obj As T, pDstNativeVariant As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-894">Type de l’objet à convertir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-894">The type of the object to convert.</span>
          </span>
        </typeparam>
        <param name="obj">
          <span data-ttu-id="37d7d-895">Objet pour lequel obtenir un VARIANT COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-895">The object for which to get a COM VARIANT.</span>
          </span>
        </param>
        <param name="pDstNativeVariant">
          <span data-ttu-id="37d7d-896">Pointeur devant recevoir le VARIANT et qui correspond au paramètre <c>obj</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-896">A pointer to receive the VARIANT that corresponds to the <c>obj</c> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-897">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-897">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-898">Convertit un objet d’un type spécifié en COM VARIANT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-898">Converts an object of a specified type to a COM VARIANT.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-899">Le `pDstNativeVariant` paramètre doit pointer vers une mémoire suffisante pour stocker le type VARIANT résultant.</span><span class="sxs-lookup"><span data-stu-id="37d7d-899">The `pDstNativeVariant` parameter must point to sufficient memory to store the resulting VARIANT.</span></span> <span data-ttu-id="37d7d-900">En outre, l’implémentation de cette méthode appelle [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) fonction sur la mémoire brute qui le `pDstNativeVariant` paramètre pointe vers.</span><span class="sxs-lookup"><span data-stu-id="37d7d-900">Also, the implementation of this method calls [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) function on the raw memory that the `pDstNativeVariant` parameter points to.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-901">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-901">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-902">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-902">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForIUnknown (pUnk As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForIUnknown(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">
          <span data-ttu-id="37d7d-903">Pointeur vers l'interface <see langword="IUnknown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-903">A pointer to the <see langword="IUnknown" /> interface.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-904">Retourne une instance d’un type qui représente un objet COM par un pointeur vers son interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-904">Returns an instance of a type that represents a COM object by a pointer to its [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-905">Objet qui représente l'objet COM non managé spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-905">An object that represents the specified unmanaged COM object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-906">Cette méthode encapsule `IUnknown` dans un objet managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-906">This method wraps `IUnknown` in a managed object.</span></span> <span data-ttu-id="37d7d-907">Cela a pour effet d’incrémenter le décompte de références du composant COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-907">This has the effect of incrementing the reference count of the COM component.</span></span> <span data-ttu-id="37d7d-908">Le nombre de références sera décrémenté lorsque le runtime exécute le garbage collection sur l’objet managé qui représente l’objet COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-908">The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</span></span>  
  
 <span data-ttu-id="37d7d-909">Le `pUnk` paramètre représente un `IUnknown` pointeur d’interface ; Toutefois, étant donné que toutes les interfaces COM dérivent directement ou indirectement `IUnknown`, vous pouvez passer toute interface COM à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-909">The `pUnk` parameter represents an `IUnknown` interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="37d7d-910">L’objet retourné par <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> est un [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md), lequel gère le common language runtime tel qu’il est n’importe quel autre objet managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-910">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), which the common language runtime manages as it does any other managed object.</span></span> <span data-ttu-id="37d7d-911">Le type de ce wrapper est souvent une base `System.__ComObject` type, qui est un type caché utilisé lorsque le type de wrapper est ambigu.</span><span class="sxs-lookup"><span data-stu-id="37d7d-911">The type of this wrapper is often a base `System.__ComObject` type, which is a hidden type used when the wrapper type is ambiguous.</span></span> <span data-ttu-id="37d7d-912">Vous pouvez toujours effectuer des appels à liaison tardive à un tel type de base tant que l’objet COM implémente la [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-912">You can still make late-bound calls to such a base type as long as the COM object implements the [IDispatch](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85)) interface.</span></span> <span data-ttu-id="37d7d-913">De même, vous pouvez convertir l’objet retourné en une interface COM appropriée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-913">Likewise, you can cast the returned object to an appropriate COM interface.</span></span>  
  
 <span data-ttu-id="37d7d-914">Pour un objet à encapsuler avec un type de classe managée spécifique (et non un type de wrapper générique), vous devez respecter les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="37d7d-914">For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</span></span>  
  
-   <span data-ttu-id="37d7d-915">Implémentez la [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) interface pour l’objet COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-915">Implement the [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) interface for the COM object.</span></span>  
  
-   <span data-ttu-id="37d7d-916">Enregistrez l’assembly conteneur avec le [Regasm.exe (outil Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-916">Register the containing assembly with the [Regasm.exe (Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).</span></span>  
  
 <span data-ttu-id="37d7d-917">Ou bien, vous pouvez éviter ces conditions et néanmoins obtenir un objet qui est encapsulé avec un type de classe managée spécifique à l’aide de la <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-917">Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-918">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-918">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-919">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-919">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant (pSrcNativeVariant As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant">
          <span data-ttu-id="37d7d-920">Pointeur vers un VARIANT COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-920">A pointer to a COM VARIANT.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-921">Convertit COM VARIANT en un objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-921">Converts a COM VARIANT to an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-922">Objet qui correspond au paramètre <paramref name="pSrcNativeVariant" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-922">An object that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-923"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> Retourne un objet managé qui correspond à un pointeur brut vers un type VARIANT non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-923"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="37d7d-924">L’interopmarshaler exécute la transformation identique lors de l’exposition d’un type VARIANT à du code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-924">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="37d7d-925"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> fournit les fonctionnalités inverses de <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-925"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-926">Lorsque le type VARIANT est VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> retourne un objet de type `Int32` au lieu de `UInt32`.</span><span class="sxs-lookup"><span data-stu-id="37d7d-926">When the VARIANT type is VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> returns an object of type `Int32` instead of `UInt32`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <span data-ttu-id="37d7d-927">
            <paramref name="pSrcNativeVariant" /> n'est pas un type VARIANT valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-927">
              <paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-928">
            <paramref name="pSrcNativeVariant" /> a un type non pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-928">
              <paramref name="pSrcNativeVariant" /> has an unsupported type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-929">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-929">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-930">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-930">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectForNativeVariant(Of T) (pSrcNativeVariant As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-931">Type dans lequel convertir COM VARIANT.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-931">The type to which to convert the COM VARIANT.</span>
          </span>
        </typeparam>
        <param name="pSrcNativeVariant">
          <span data-ttu-id="37d7d-932">Pointeur vers un VARIANT COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-932">A pointer to a COM VARIANT.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-933">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-933">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-934">Convertit COM VARIANT en un objet de type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-934">Converts a COM VARIANT to an object of a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-935">Objet du type spécifié qui correspond au paramètre <paramref name="pSrcNativeVariant" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-935">An object of the specified type that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-936"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> Retourne un objet managé de type `T` qui correspond à un pointeur brut vers un type VARIANT non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-936"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> returns a managed object of type `T` that corresponds to a raw pointer to an unmanaged VARIANT type.</span></span> <span data-ttu-id="37d7d-937">L’interopmarshaler exécute la transformation identique lors de l’exposition d’un type VARIANT à du code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-937">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span>  
  
 <span data-ttu-id="37d7d-938"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> fournit les fonctionnalités inverses de <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-938"><xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <span data-ttu-id="37d7d-939">
            <paramref name="pSrcNativeVariant" /> n'est pas un type VARIANT valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-939">
              <paramref name="pSrcNativeVariant" /> is not a valid VARIANT type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-940">
            <paramref name="pSrcNativeVariant" /> a un type non pris en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-940">
              <paramref name="pSrcNativeVariant" /> has an unsupported type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-941">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-941">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-942">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-942">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants (aSrcNativeVariant As IntPtr, cVars As Integer) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Object ^&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant">
          <span data-ttu-id="37d7d-943">Pointeur vers le premier élément d'un tableau de VARIANT COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-943">A pointer to the first element of an array of COM VARIANTs.</span>
          </span>
        </param>
        <param name="cVars">
          <span data-ttu-id="37d7d-944">Nombre de VARIANT COM dans <c>aSrcNativeVariant</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-944">The count of COM VARIANTs in <c>aSrcNativeVariant</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-945">Convertit un tableau de [VARIANT](http://go.microsoft.com/fwlink/?LinkId=148670) COM en un tableau d’objets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-945">Converts an array of COM [VARIANTs](http://go.microsoft.com/fwlink/?LinkId=148670) to an array of objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-946">Tableau d'objets qui correspond à <paramref name="aSrcNativeVariant" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-946">An object array that corresponds to <paramref name="aSrcNativeVariant" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-947"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> Retourne un tableau d’objets managés qui correspond à un pointeur brut vers un tableau de style C de types managés en types VARIANT.</span><span class="sxs-lookup"><span data-stu-id="37d7d-947"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="37d7d-948">L’interopmarshaler exécute la transformation identique lors de l’exposition d’un type VARIANT à du code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-948">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="37d7d-949">La méthode retourne un tableau vide lorsque le `cVars` paramètre est 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-949">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="37d7d-950">Le tableau d’objets (la valeur de retour) Obtient le garbage collector comme d’habitude.</span><span class="sxs-lookup"><span data-stu-id="37d7d-950">The object array (the return value) gets garbage collected as usual.</span></span> <span data-ttu-id="37d7d-951">Le tableau d’entrée non managé ou des composants individuels dans le tableau d’entrée ne sont pas libérées.</span><span class="sxs-lookup"><span data-stu-id="37d7d-951">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="37d7d-952">Par conséquent il vous incombe de les libérer de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-952">Therefore it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-953">
            <paramref name="cVars" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-953">
              <paramref name="cVars" /> is a negative number.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-954">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-954">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-955">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-955">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectsForNativeVariants(Of T) (aSrcNativeVariant As IntPtr, cVars As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-956">Type de tableau à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-956">The type of the array to return.</span>
          </span>
        </typeparam>
        <param name="aSrcNativeVariant">
          <span data-ttu-id="37d7d-957">Pointeur vers le premier élément d'un tableau de VARIANT COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-957">A pointer to the first element of an array of COM VARIANTs.</span>
          </span>
        </param>
        <param name="cVars">
          <span data-ttu-id="37d7d-958">Nombre de VARIANT COM dans <c>aSrcNativeVariant</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-958">The count of COM VARIANTs in <c>aSrcNativeVariant</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-959">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-959">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-960">Convertit un tableau de COM VARIANT en un tableau d'un type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-960">Converts an array of COM VARIANTs to an array of a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-961">Tableau d'objets <typeparamref name="T" /> qui correspond à <paramref name="aSrcNativeVariant" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-961">An array of <typeparamref name="T" /> objects that corresponds to <paramref name="aSrcNativeVariant" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-962"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> Retourne un tableau de `T` qui correspond à un pointeur brut vers un tableau de style C de types managés en types VARIANT.</span><span class="sxs-lookup"><span data-stu-id="37d7d-962"><xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29> returns an array of `T` that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</span></span> <span data-ttu-id="37d7d-963">L’interopmarshaler exécute la transformation identique lors de l’exposition d’un type VARIANT à du code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-963">The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</span></span> <span data-ttu-id="37d7d-964">La méthode retourne un tableau vide lorsque le `cVars` paramètre est 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-964">The method returns an empty array when the `cVars` parameter is 0.</span></span>  
  
 <span data-ttu-id="37d7d-965">Le tableau retourné est le garbage collector comme d’habitude.</span><span class="sxs-lookup"><span data-stu-id="37d7d-965">The returned array is garbage-collected as usual.</span></span> <span data-ttu-id="37d7d-966">Le tableau d’entrée non managé ou des composants individuels dans le tableau d’entrée ne sont pas libérées.</span><span class="sxs-lookup"><span data-stu-id="37d7d-966">The unmanaged input array or individual VARIANTs in the input array are not freed.</span></span> <span data-ttu-id="37d7d-967">Par conséquent, il vous incombe de les libérer de façon appropriée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-967">Therefore, it is your responsibility to free them as appropriate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-968">
            <paramref name="cVars" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-968">
              <paramref name="cVars" /> is a negative number.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-969">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-969">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-970">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-970">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStartComSlot (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetStartComSlot(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-971">Type qui représente une interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-971">A type that represents an interface.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-972">Obtient le premier emplacement dans la table de fonctions virtuelles (v-table ou VTBL) contenant des méthodes définies par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-972">Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-973">Premier emplacement VTBL qui contient des méthodes définies par l'utilisateur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-973">The first VTBL slot that contains user-defined methods.</span>
          </span>
          <span data-ttu-id="37d7d-974">Le premier emplacement est 3 si l’interface est basée sur [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) et 7 si l’interface est basée sur [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-974">The first slot is 3 if the interface is based on [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003), and 7 if the interface is based on [IDispatch](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-975">Cette méthode retourne le nombre de base zéro de la table v pour une interface ou une classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-975">This method returns the zero-based v-table number for an interface or a class.</span></span> <span data-ttu-id="37d7d-976">Lorsqu’il est utilisé sur une classe, le numéro d’emplacement retourné fait référence à l’interface de classe pour la classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-976">When used on a class, the slot number that is returned refers to the class interface for the class.</span></span> <span data-ttu-id="37d7d-977">Si l’interface de classe est dispatch automatique, cette méthode retourne toujours -1 pour indiquer que l’interface de dispatch uniquement n’expose pas une vtable à des clients managés.</span><span class="sxs-lookup"><span data-stu-id="37d7d-977">If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</span></span> <span data-ttu-id="37d7d-978">Vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> et <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> conjointement avec <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> pour passer des emplacements dans une plage spécifiée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-978">You can use <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> and <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> in conjunction with <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> to pass slots within a specified range.</span></span> <span data-ttu-id="37d7d-979">Pour plus d’informations, consultez [présentation de l’Interface de classe](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span><span class="sxs-lookup"><span data-stu-id="37d7d-979">For additional information, see [Introducing the Class Interface](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-980">
            <paramref name="t" /> n'est pas visible par COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-980">
              <paramref name="t" /> is not visible from COM.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-981">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-981">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-982">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-982">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetThreadFromFiberCookie (cookie As Integer) As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Thread ^ GetThreadFromFiberCookie(int cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cookie">
          <span data-ttu-id="37d7d-983">Entier qui représente un cookie de fibre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-983">An integer that represents a fiber cookie.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-984">Convertit un cookie fiber en l'instance de <see cref="T:System.Threading.Thread" /> correspondante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-984">Converts a fiber cookie into the corresponding <see cref="T:System.Threading.Thread" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-985">Thread qui correspond au paramètre <paramref name="cookie" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-985">A thread that corresponds to the <paramref name="cookie" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-986">Les cookies Fiber sont des jetons opaques qui sont utilisées par l’hôte lors de la génération d’alertes le common language runtime pour les décisions de planification de fibre.</span><span class="sxs-lookup"><span data-stu-id="37d7d-986">Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</span></span> <span data-ttu-id="37d7d-987">Ils se composent d’une pile et enregistrement le contexte.</span><span class="sxs-lookup"><span data-stu-id="37d7d-987">They consist of a stack and register context.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-988">Le paramètre <paramref name="cookie" /> est 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-988">The <paramref name="cookie" /> parameter is 0.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-989">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-989">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-990">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-990">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypedObjectForIUnknown (pUnk As IntPtr, t As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetTypedObjectForIUnknown(IntPtr pUnk, Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="pUnk">
          <span data-ttu-id="37d7d-991">Pointeur vers l’interface <see langword="IUnknown" /> de l’objet non géré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-991">A pointer to the <see langword="IUnknown" /> interface of the unmanaged object.</span>
          </span>
        </param>
        <param name="t">
          <span data-ttu-id="37d7d-992">Type de la classe managée demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-992">The type of the requested managed class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-993">Retourne un objet managé d'un type spécifié qui représente un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-993">Returns a managed object of a specified type that represents a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-994">Instance de la classe correspondant à l’objet <see cref="T:System.Type" /> qui représente l’objet COM non géré demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-994">An instance of the class corresponding to the <see cref="T:System.Type" /> object that represents the requested unmanaged COM object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-995">Le `t` paramètre doit être un type COM importé ou un sous-type d’un type COM importé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-995">The `t` parameter must be either a COM-imported type or a subtype of a COM-imported type.</span></span> <span data-ttu-id="37d7d-996">En outre, `t` doit être un type dont les métadonnées ont été importées par le [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil.</span><span class="sxs-lookup"><span data-stu-id="37d7d-996">In addition, `t` must be a type whose metadata was imported by the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span> <span data-ttu-id="37d7d-997">Ce type doit être une classe et pas une interface de coclasse associée qui porte le nom de la classe COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-997">This type must be a class and not an associated coclass interface, which carries the name of the COM class.</span></span> <span data-ttu-id="37d7d-998">Par exemple, si Tlbimp.exe importe `Myclass` comme une classe appelée `MyclassClass` et comme une interface de coclasse appelée `Myclass`, vous devez utiliser `MyclassClass` (pas `Myclass`) avec cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-998">For example, if Tlbimp.exe imports `Myclass` as a class called `MyclassClass` and as a coclass interface called `Myclass`, you must use `MyclassClass` (not `Myclass`) with this method.</span></span> <span data-ttu-id="37d7d-999">Pour plus d’informations sur les interfaces de coclasse et les classes importées, consultez [importé la Conversion de Type](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).</span><span class="sxs-lookup"><span data-stu-id="37d7d-999">For additional information about imported classes and coclass interfaces, see [Imported Type Conversion](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).</span></span>  
  
 <span data-ttu-id="37d7d-1000">Si un objet a déjà été obtenu pour le `pUnk` paramètre `t` est ignoré et l’objet existant est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1000">If an object has already been obtained for the `pUnk` parameter, `t` is ignored and the existing object is returned.</span></span> <span data-ttu-id="37d7d-1001">`pUnk` représente un[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur d’interface ; Toutefois, étant donné que toutes les interfaces COM dérivent directement ou indirectement `IUnknown`, vous pouvez passer toute interface COM à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1001">`pUnk` represents an[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer; however, because all COM interfaces derive directly or indirectly from `IUnknown`, you can pass any COM interface to this method.</span></span> <span data-ttu-id="37d7d-1002">L’objet retourné par <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> est un [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), qui le common language runtime gère tel qu’il est n’importe quel autre objet managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1002">The object returned by <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> is a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), which the common language runtime manages as it does any other managed object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1003">
            <paramref name="t" /> n’est pas attribué avec <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1003">
              <paramref name="t" /> is not attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.</span>
          </span>
          <span data-ttu-id="37d7d-1004">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1004">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1005">
            <paramref name="t" /> est un type [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1005">
              <paramref name="t" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1006">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1006">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1007">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1007">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeForITypeInfo (piTypeInfo As IntPtr) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeForITypeInfo(IntPtr piTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo">
          <span data-ttu-id="37d7d-1008">Interface <see langword="ITypeInfo" /> à marshaler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1008">The <see langword="ITypeInfo" /> interface to marshal.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1009">Convertit un objet [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) non managé en objet <see cref="T:System.Type" /> managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1009">Converts an unmanaged [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object into a managed <see cref="T:System.Type" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1010">Type managé qui représente l'objet <see langword="ITypeInfo" /> non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1010">A managed type that represents the unmanaged <see langword="ITypeInfo" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1011"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> Retourne un <xref:System.Type?displayProperty=nameWithType> instance qui est basé sur le type d’origine.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1011"><xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> returns a <xref:System.Type?displayProperty=nameWithType> instance that is based on the original type.</span></span> <span data-ttu-id="37d7d-1012">Vous pouvez appliquer le <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> pour remplacer le comportement de marshaling d’interopérabilité standard par ce marshaleur personnalisé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1012">You can apply the <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> to replace standard interop marshaling behavior with this custom marshaler.</span></span> <span data-ttu-id="37d7d-1013">Le [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil utilise le marshaleur personnalisé pour traduire `ITypeInfo` paramètres <xref:System.Type?displayProperty=nameWithType> paramètres.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1013">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool uses the custom marshaler to translate `ITypeInfo` parameters to <xref:System.Type?displayProperty=nameWithType> parameters.</span></span> <span data-ttu-id="37d7d-1014">Toutefois, si vous obtenez un `ITypeInfo` interface par certains autres moyens que Tlbimp.exe, vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> pour effectuer manuellement la même conversion.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1014">However, if you obtain an `ITypeInfo` interface by some means other than Tlbimp.exe, you can use <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> to manually perform the same translation.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1015">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1015">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1016">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1016">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.MarshalAsAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="37d7d-1017">CLSID du type à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1017">The CLSID of the type to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1018">Retourne le type associé à l'identificateur de classe (CLSID) spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1018">Returns the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1019">
            <see langword="System.__ComObject" /> que le CLSID soit valide ou non.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1019">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeInfoName">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1020">Récupère le nom du type représenté par un objet [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1020">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (typeInfo As ITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::ComTypes::ITypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">
          <span data-ttu-id="37d7d-1021">Objet qui représente un pointeur <see langword="ITypeInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1021">An object that represents an <see langword="ITypeInfo" /> pointer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1022">Récupère le nom du type représenté par un objet [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1022">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1023">Nom du type vers lequel pointe le paramètre <paramref name="typeInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1023">The name of the type that the <paramref name="typeInfo" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1024">Vous pouvez également récupérer le nom du type représenté par un `ITypeInfo` en appelant le <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> méthode et en passant la valeur -1 comme premier paramètre.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1024">You can also retrieve the name of the type represented by an `ITypeInfo` by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1025">Le paramètre <paramref name="typeInfo" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1025">The <paramref name="typeInfo" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1026">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1026">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1027">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1027">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeInfoName (pTI As UCOMITypeInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeInfoName(System::Runtime::InteropServices::UCOMITypeInfo ^ pTI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <param name="pTI">
          <span data-ttu-id="37d7d-1028">Objet qui représente un pointeur <see langword="ITypeInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1028">An object that represents an <see langword="ITypeInfo" /> pointer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1029">Récupère le nom du type représenté par un objet [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1029">Retrieves the name of the type represented by an [ITypeInfo](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680) object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1030">Nom du type vers lequel pointe le paramètre <paramref name="pTI" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1030">The name of the type that the <paramref name="pTI" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1031">Vous pouvez également récupérer le nom du type représenté par un `ITypeInfo` objet en appelant le <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> méthode et en passant la valeur -1 comme premier paramètre.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1031">You can also retrieve the name of the type represented by an `ITypeInfo` object by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1032">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1032">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1033">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1033">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibGuid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1034">Récupère l'identificateur de bibliothèque (LIBID) d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1034">Retrieves the library identifier (LIBID) of a type library.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (typelib As ITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">
          <span data-ttu-id="37d7d-1035">Bibliothèque de types où LIBID doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1035">The type library whose LIBID is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1036">Récupère l'identificateur de bibliothèque (LIBID) d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1036">Retrieves the library identifier (LIBID) of a type library.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1037">LIBID de la bibliothèque de types spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1037">The LIBID of the specified type library.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1038"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extrait le LIBID directement à partir d’une bibliothèque de types existante.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1038"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="37d7d-1039">Cette action diffère de celui de la <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> méthode, qui calcule les LIBID doit être basé sur l’assembly actuel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1039">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="37d7d-1040">Pour plus d’informations sur les identificateurs de bibliothèque, consultez [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1040">For more information about library identifiers, see [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1041">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1041">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1042">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1042">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuid (pTLB As UCOMITypeLib) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">
          <span data-ttu-id="37d7d-1043">Bibliothèque de types où LIBID doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1043">The type library whose LIBID is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1044">Récupère l'identificateur de bibliothèque (LIBID) d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1044">Retrieves the library identifier (LIBID) of a type library.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1045">LIBID de la bibliothèque de types vers laquelle pointe le paramètre <paramref name="pTLB" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1045">The LIBID of the type library that the <paramref name="pTLB" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1046"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extrait le LIBID directement à partir d’une bibliothèque de types existante.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1046"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> extracts the LIBID directly from an existing type library.</span></span> <span data-ttu-id="37d7d-1047">Cette action diffère de celui de la <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> méthode, qui calcule les LIBID doit être basé sur l’assembly actuel.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1047">This action differs from that of the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> method, which calculates what the LIBID should be based on the current assembly.</span></span>  
  
 <span data-ttu-id="37d7d-1048">Pour plus d’informations sur les identificateurs de bibliothèque, consultez [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1048">For more information about library identifiers, see [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1049">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1049">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1050">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1050">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
        <altmember cref="T:System.Runtime.InteropServices.UCOMITypeLib" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibGuidForAssembly (asm As Assembly) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetTypeLibGuidForAssembly(System::Reflection::Assembly ^ asm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="asm">
          <span data-ttu-id="37d7d-1051">Assembly à partir duquel la bibliothèque de types a été exportée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1051">The assembly from which the type library was exported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1052">Récupère l'identificateur de bibliothèque (LIBID) qui est assigné à une bibliothèque de types lors de son exportation à partir de l'assembly spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1052">Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1053">LIBID assigné à une bibliothèque de types lors de son exportation à partir de l'assembly spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1053">The LIBID that is assigned to a type library when it is exported from the specified assembly.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1054">Lorsque les assemblys sont exportés pour les bibliothèques de types, un LIBID est assignée à la bibliothèque de types.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1054">When assemblies are exported to type libraries, the type library is assigned a LIBID.</span></span> <span data-ttu-id="37d7d-1055">Vous pouvez définir le LIBID explicitement en appliquant la <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> au niveau de l’assembly au niveau, ou il peut être généré automatiquement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1055">You can set the LIBID explicitly by applying the <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> at the assembly level, or it can be generated automatically.</span></span> <span data-ttu-id="37d7d-1056">Le [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil calcule une valeur LIBID selon l’identité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1056">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool calculates a LIBID value based on the identity of the assembly.</span></span> <span data-ttu-id="37d7d-1057"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> Retourne le LIBID associé à la <xref:System.Runtime.InteropServices.GuidAttribute>, si l’attribut est appliqué.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1057"><xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> returns the LIBID that is associated with the <xref:System.Runtime.InteropServices.GuidAttribute>, if the attribute is applied.</span></span> <span data-ttu-id="37d7d-1058">Dans le cas contraire, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> retourne la valeur calculée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1058">Otherwise, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> returns the calculated value.</span></span> <span data-ttu-id="37d7d-1059">Vous pouvez également utiliser le <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> méthode pour extraire le LIBID actuel à partir d’une bibliothèque de types existante.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1059">Alternatively, you can use the <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> method to extract the actual LIBID from an existing type library.</span></span>  
  
 <span data-ttu-id="37d7d-1060">Consultez le [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) rubrique pour plus d’informations sur les identificateurs de bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1060">See the [Exported Assembly Conversion](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86) topic for more information about library identifiers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1061">
            <paramref name="asm" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1061">
              <paramref name="asm" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1062">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1062">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1063">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1063">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GuidAttribute" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibLcid">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1064">Récupère le LCID d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1064">Retrieves the LCID of a type library.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (typelib As ITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">
          <span data-ttu-id="37d7d-1065">Bibliothèque de types où LCID doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1065">The type library whose LCID is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1066">Récupère le LCID d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1066">Retrieves the LCID of a type library.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1067">LCID de la bibliothèque de types vers laquelle pointe le paramètre <paramref name="typelib" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1067">The LCID of the type library that the <paramref name="typelib" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1068">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1068">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1069">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1069">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibLcid (pTLB As UCOMITypeLib) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetTypeLibLcid(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">
          <span data-ttu-id="37d7d-1070">Bibliothèque de types où LCID doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1070">The type library whose LCID is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1071">Récupère le LCID d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1071">Retrieves the LCID of a type library.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1072">LCID de la bibliothèque de types vers laquelle pointe le paramètre <paramref name="pTLB" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1072">The LCID of the type library that the <paramref name="pTLB" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1073">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1073">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1074">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1074">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeLibName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1075">Récupère le nom d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1075">Retrieves the name of a type library.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (typelib As ITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::ComTypes::ITypeLib ^ typelib);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">
          <span data-ttu-id="37d7d-1076">Bibliothèque de types dont le nom doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1076">The type library whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1077">Récupère le nom d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1077">Retrieves the name of a type library.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1078">Nom de la bibliothèque de types vers laquelle pointe le paramètre <paramref name="typelib" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1078">The name of the type library that the <paramref name="typelib" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1079">Le nom retourné par cette méthode est l’identificateur utilisé avec l’instruction library, telles que ADODB pour la bibliothèque de types Microsoft ADO.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1079">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="37d7d-1080">Le nom n’est pas un nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1080">The name is not a file name.</span></span>  
  
 <span data-ttu-id="37d7d-1081">Vous pouvez également récupérer le nom de bibliothèque de types en appelant le <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> méthode et en passant la valeur -1 comme premier paramètre.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1081">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1082">Le paramètre <paramref name="typelib" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1082">The <paramref name="typelib" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1083">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1083">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1084">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1084">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeLibName (pTLB As UCOMITypeLib) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTypeLibName(System::Runtime::InteropServices::UCOMITypeLib ^ pTLB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">
          <span data-ttu-id="37d7d-1085">Bibliothèque de types dont le nom doit être récupéré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1085">The type library whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1086">Récupère le nom d'une bibliothèque de types.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1086">Retrieves the name of a type library.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1087">Nom de la bibliothèque de types vers laquelle pointe le paramètre <paramref name="pTLB" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1087">The name of the type library that the <paramref name="pTLB" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1088">Le nom retourné par cette méthode est l’identificateur utilisé avec l’instruction library, telles que ADODB pour la bibliothèque de types Microsoft ADO.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1088">The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</span></span> <span data-ttu-id="37d7d-1089">Le nom n’est pas un nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1089">The name is not a file name.</span></span>  
  
 <span data-ttu-id="37d7d-1090">Vous pouvez également récupérer le nom de bibliothèque de types en appelant le <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> méthode et en passant la valeur -1 comme premier paramètre.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1090">You can also retrieve the type library name by calling the <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> method and passing -1 for its first parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1091">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1091">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1092">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1092">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetTypeLibVersionForAssembly (inputAssembly As Assembly, ByRef majorVersion As Integer, ByRef minorVersion As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetTypeLibVersionForAssembly(System::Reflection::Assembly ^ inputAssembly, [Runtime::InteropServices::Out] int % majorVersion, [Runtime::InteropServices::Out] int % minorVersion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly">
          <span data-ttu-id="37d7d-1093">Assembly managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1093">A managed assembly.</span>
          </span>
        </param>
        <param name="majorVersion">
          <span data-ttu-id="37d7d-1094">Numéro de version principale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1094">The major version number.</span>
          </span>
        </param>
        <param name="minorVersion">
          <span data-ttu-id="37d7d-1095">Numéro de version secondaire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1095">The minor version number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1096">Récupère le numéro de version d'une bibliothèque de types qui sera exportée à partir de l'assembly spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1096">Retrieves the version number of a type library that will be exported from the specified assembly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1097">Avant d’exporter un assembly à l’aide de <xref:System.Runtime.InteropServices.TypeLibExporterFlags> avec la `CallerResolvedReferences` valeur, vous pouvez utiliser cette méthode pour récupérer la version de bibliothèque de types à partir de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1097">Before exporting an assembly by using <xref:System.Runtime.InteropServices.TypeLibExporterFlags> with the `CallerResolvedReferences` value, you can use this method to retrieve the type library version from the assembly.</span></span>  
  
 <span data-ttu-id="37d7d-1098">Si vous n’appliquez pas le <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> par un assembly exporté afin de contrôler explicitement le numéro de version de la bibliothèque de types générée, la bibliothèque de types aura le même numéro de version que l’assembly.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1098">If you do not apply the <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1099">
            <paramref name="inputAssembly" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1099">
              <paramref name="inputAssembly" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1100">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1100">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1101">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1101">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.TypeLibExporterFlags" />
        <altmember cref="T:System.Runtime.InteropServices.TypeLibVersionAttribute" />
        <altmember cref="T:System.Runtime.InteropServices.ITypeLibConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUniqueObjectForIUnknown (unknown As IntPtr) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUniqueObjectForIUnknown(IntPtr unknown);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="unknown">
          <span data-ttu-id="37d7d-1102">Pointeur managé vers une interface <see langword="IUnknown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1102">A managed pointer to an <see langword="IUnknown" /> interface.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1103">Crée un objet de wrapper RCW [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) unique pour une interface [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) donnée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1103">Creates a unique [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) object for a given [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1104">Wrapper RCW (Runtime Callable Wrapper) unique pour l'interface <see langword="IUnknown" /> spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1104">A unique RCW for the specified <see langword="IUnknown" /> interface.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1105">Le <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> méthode garantit que vous recevez un wrapper RCW, car il ne correspond pas à un `IUnknown` pointeur vers un objet existant.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1105">The <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> method ensures that you receive a unique RCW, because it does not match an `IUnknown` pointer to an existing object.</span></span> <span data-ttu-id="37d7d-1106">Utilisez cette méthode lorsque vous devez créer un RCW unique qui n’est pas affecté par un autre code qui appelle le <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1106">Use this method when you have to create a unique RCW that is not impacted by other code that calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1107">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1107">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1108">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1108">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnmanagedThunkForManagedMethodPtr (pfnMethodToWrap As IntPtr, pbSignature As IntPtr, cbSignature As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">
          <span data-ttu-id="37d7d-1109">Pointeur vers la méthode à marshaler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1109">A pointer to the method to marshal.</span>
          </span>
        </param>
        <param name="pbSignature">
          <span data-ttu-id="37d7d-1110">Pointeur vers la signature de la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1110">A pointer to the method signature.</span>
          </span>
        </param>
        <param name="cbSignature">
          <span data-ttu-id="37d7d-1111">Nombre d’octets dans <c>pbSignature</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1111">The number of bytes in <c>pbSignature</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1112">Obtient un pointeur vers une fonction générée par runtime qui marshale un appel du code non managé à du code managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1112">Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1113">Pointeur vers une fonction qui doit marshaler un appel de <paramref name="pfnMethodToWrap" /> vers du code managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1113">A pointer to a function that will marshal a call from <paramref name="pfnMethodToWrap" /> to managed code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1114"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> est exposé pour la prise en charge du compilateur uniquement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1114"><xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A> is exposed for compiler support only.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1115">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1115">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1116">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1116">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComObject (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-1117">Objet à vérifier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1117">The object to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1118">Indique si un objet spécifié représente un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1118">Indicates whether a specified object represents a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1119">
            <see langword="true" /> si le paramètre <paramref name="o" /> est un type COM ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1119">
              <see langword="true" /> if the <paramref name="o" /> parameter is a COM type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1120"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> Retourne `true` si le type de classe de l’instance est attribué à <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> ou si elle dérive directement ou indirectement à partir d’une classe possédant l’attribut <xref:System.Runtime.InteropServices.ComImportAttribute>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1120"><xref:System.Runtime.InteropServices.Marshal.IsComObject%2A> returns `true` if the class type of the instance is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> or if it derives directly or indirectly from a class attributed with <xref:System.Runtime.InteropServices.ComImportAttribute>.</span></span> <span data-ttu-id="37d7d-1121">Le [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil applique cet attribut pour vous lorsqu’il importe une bibliothèque de types.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1121">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool applies this attribute for you when it imports a type library.</span></span>  
  
 <span data-ttu-id="37d7d-1122">Deux autres méthodes déterminent également si un objet spécifié représente un objet COM, mais la configuration requise pour le retour `true` diffèrent des spécifications de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1122">Two other methods also determine whether a specified object represents a COM object, but the requirements for returning `true` differ from this method's requirements.</span></span> <span data-ttu-id="37d7d-1123"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> Retourne `true` si la classe (ou interface) est attribuée à <xref:System.Runtime.InteropServices.ComImportAttribute> directement ; elle ne retourne pas `true` pour les types dérivés.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1123"><xref:System.Type.IsImport%2A?displayProperty=nameWithType> returns `true` if the class (or interface) is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> directly; it does not return `true` for derived types.</span></span> <span data-ttu-id="37d7d-1124"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> Retourne `true` si le type est attribué avec <xref:System.Runtime.InteropServices.ComImportAttribute> ou dérive d’un type avec le même GUID.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1124"><xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType> returns `true` if the type is attributed with <xref:System.Runtime.InteropServices.ComImportAttribute> or derives from a type with the same GUID.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1125">
            <paramref name="o" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1125">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.ComImportAttribute" />
        <altmember cref="P:System.Type.IsImport" />
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTypeVisibleFromCom (t As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTypeVisibleFromCom(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-1126">Type à vérifier pour la visibilité COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1126">The type to check for COM visibility.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1127">Indique si un type est visible par les clients COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1127">Indicates whether a type is visible to COM clients.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1128">
            <see langword="true" /> si le type est visible par COM ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1128">
              <see langword="true" /> if the type is visible to COM; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1129"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> permet de vérifier la visibilité COM en une seule étape.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1129"><xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A> enables you to check for COM visibility in one step.</span></span> <span data-ttu-id="37d7d-1130">Les types qui ne sont pas visibles ne peuvent pas être utilisés à partir de COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1130">Types that are not visible cannot be used from COM.</span></span> <span data-ttu-id="37d7d-1131">Un type est visible s’il est `public` et non masqués avec le <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1131">A type is visible if it is `public` and not hidden with the <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NumParamBytes (m As MethodInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int NumParamBytes(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">
          <span data-ttu-id="37d7d-1132">Méthode à vérifier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1132">The method to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1133">Calcule le nombre d'octets en mémoire non managée qui sont nécessaires pour recevoir les paramètres de la méthode spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1133">Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1134">Nombre d'octets nécessaires pour représenter les paramètres de méthode en mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1134">The number of bytes required to represent the method parameters in unmanaged memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1135">Le <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> méthode retourne la taille de pile (en octets) nécessaire pour représenter les paramètres d’une signature de méthode en mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1135">The <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</span></span>  
  
 <span data-ttu-id="37d7d-1136">Notez que la valeur de retour de cette méthode est dépendante de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1136">Note that the return value of this method is platform-dependent.</span></span> <span data-ttu-id="37d7d-1137">Par exemple, une signature avec un seul paramètre entier retourne une valeur de 4 sur les plateformes 32 bits et une valeur de 8 sur les plateformes 64 bits.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1137">For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1138">Le paramètre <paramref name="m" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1138">The <paramref name="m" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1139">Le paramètre <paramref name="m" /> n'est pas un objet <see cref="T:System.Reflection.MethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1139">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1140">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1140">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1141">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1141">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf (t As Type, fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr OffsetOf(Type ^ t, System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-1142">Type valeur ou type référence mis en forme qui spécifie la classe managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1142">A value type or formatted reference type that specifies the managed class.</span>
          </span>
          <span data-ttu-id="37d7d-1143">Vous devez appliquer l'attribut <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> à la classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1143">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> to the class.</span>
          </span>
        </param>
        <param name="fieldName">
          <span data-ttu-id="37d7d-1144">Champ dans le paramètre <c>t</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1144">The field within the <c>t</c> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1145">Retourne l'offset de champ de la forme non managée de la classe managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1145">Returns the field offset of the unmanaged form of the managed class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1146">Offset, en octets, du paramètre <paramref name="fieldName" /> au sein de la classe spécifiée déclarée par l'appel de code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1146">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1147"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> fournit l’offset en termes de la disposition de la structure non managée qui ne correspond pas nécessairement au décalage de la disposition de la structure managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1147"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="37d7d-1148">Marshaling de la structure, vous pouvez transformer la disposition et modifier l’offset.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1148">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="37d7d-1149">Le `t` paramètre peut être un type valeur ou un type référence mis en forme (avec une disposition séquentielle ou explicite).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1149">The `t` parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="37d7d-1150">Vous pouvez obtenir la taille de toute la disposition à l’aide de la <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1150">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="37d7d-1151">Pour plus d’informations, consultez [de Marshaling par défaut pour les Types valeur](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1151">For additional information, see [Default Marshaling for Value Types](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d7d-1152">À partir de .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> peut exposer des champs privés.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1152">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1153">La classe ne peut pas être exportée sous forme de structure ou le champ n'est pas public.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1153">The class cannot be exported as a structure or the field is nonpublic.</span>
          </span>
          <span data-ttu-id="37d7d-1154">À compter de .NET Framework version 2.0, le champ peut être privé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1154">Beginning with the .NET Framework version 2.0, the field may be private.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1155">Le paramètre <paramref name="t" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1155">The <paramref name="t" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OffsetOf(Of T) (fieldName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr OffsetOf(System::String ^ fieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1156">Type valeur managé ou type référence mis en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1156">A managed value type or formatted reference type.</span>
          </span>
          <span data-ttu-id="37d7d-1157">Vous devez appliquer l'attribut <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> à la classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1157">You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute to the class.</span>
          </span>
        </typeparam>
        <param name="fieldName">
          <span data-ttu-id="37d7d-1158">Nom du champ dans le type <c>T</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1158">The name of the field in the <c>T</c> type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1159">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1159">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1160">Retourne l'offset de champ de la forme non managée d'une classe managée spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1160">Returns the field offset of the unmanaged form of a specified managed class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1161">Offset, en octets, du paramètre <paramref name="fieldName" /> au sein de la classe spécifiée déclarée par l'appel de code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1161">The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1162"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> fournit l’offset en termes de la disposition de la structure non managée qui ne correspond pas nécessairement au décalage de la disposition de la structure managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1162"><xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</span></span> <span data-ttu-id="37d7d-1163">Marshaling de la structure, vous pouvez transformer la disposition et modifier l’offset.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1163">Marshaling the structure can transform the layout and alter the offset.</span></span> <span data-ttu-id="37d7d-1164">Le `T` paramètre de type générique peut être un type valeur ou un type référence mis en forme (avec une disposition séquentielle ou explicite).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1164">The `T` generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</span></span> <span data-ttu-id="37d7d-1165">Vous pouvez obtenir la taille de toute la disposition à l’aide de la <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1165">You can obtain the size of the entire layout by using the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method.</span></span> <span data-ttu-id="37d7d-1166">Pour plus d’informations, consultez [de Marshaling par défaut pour les Types valeur](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1166">For additional information, see [Default Marshaling for Value Types](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d7d-1167">À partir de .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> peut exposer des champs privés.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1167">Beginning with the .NET Framework version 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> may expose private fields.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Prelink (m As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Prelink(System::Reflection::MethodInfo ^ m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">
          <span data-ttu-id="37d7d-1168">Méthode à vérifier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1168">The method to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1169">Exécute les tâches de configuration de méthode effectuées une seule fois sans appeler la méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1169">Executes one-time method setup tasks without calling the method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1170">Tâches de configuration fournissent l’initialisation anticipée et sont effectuées automatiquement lorsque la méthode cible est appelée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1170">Setup tasks provide early initialization and are performed automatically when the target method is invoked.</span></span> <span data-ttu-id="37d7d-1171">Première les tâches suivantes :</span><span class="sxs-lookup"><span data-stu-id="37d7d-1171">First-time tasks include the following:</span></span>  
  
-   <span data-ttu-id="37d7d-1172">Vérification que le code non managé métadonnées est correctement formaté.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1172">Verifying that the platform invoke metadata is correctly formatted.</span></span>  
  
-   <span data-ttu-id="37d7d-1173">Vérification que tous les types managés sont des paramètres valides de plateforme appeler des fonctions.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1173">Verifying that all the managed types are valid parameters of platform invoke functions.</span></span>  
  
-   <span data-ttu-id="37d7d-1174">Localisation et de chargement de la DLL non managée dans le processus.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1174">Locating and loading the unmanaged DLL into the process.</span></span>  
  
-   <span data-ttu-id="37d7d-1175">Recherche le point d’entrée dans le processus.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1175">Locating the entry point in the process.</span></span>  
  
 <span data-ttu-id="37d7d-1176">Appel de <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> sur une méthode en dehors de la plateforme de code non managé n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1176">Calling <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> on a method outside of platform invoke has no effect.</span></span> <span data-ttu-id="37d7d-1177">Pour exécuter le programme d’installation des tâches sur toutes les plates-formes appeler des méthodes dans un type, utilisez <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1177">To execute setup tasks on all platform invoke methods in a type, use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1178">Le paramètre <paramref name="m" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1178">The <paramref name="m" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1179">Le paramètre <paramref name="m" /> n'est pas un objet <see cref="T:System.Reflection.MethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1179">The <paramref name="m" /> parameter is not a <see cref="T:System.Reflection.MethodInfo" /> object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1180">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1180">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1181">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1181">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrelinkAll (c As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrelinkAll(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="37d7d-1182">Classe dont les méthodes doivent être vérifiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1182">The class whose methods are to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1183">Exécute un contrôle avant l'édition des liens pour toutes les méthodes sur une classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1183">Performs a pre-link check for all methods on a class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1184">Le <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> méthode appelle <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> sur chaque méthode pour un type donné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1184">The <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> method invokes <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> on every method for a given type.</span></span> <span data-ttu-id="37d7d-1185"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> exécute les tâches de configuration de méthode unique sans appeler chaque méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1185"><xref:System.Runtime.InteropServices.Marshal.Prelink%2A> executes one-time method setup tasks without calling each method.</span></span> <span data-ttu-id="37d7d-1186">Vous pouvez utiliser <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> uniquement pour la plateforme les appels de code non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1186">You can use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> only for platform invoke calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1187">Le paramètre <paramref name="c" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1187">The <paramref name="c" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1188">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1188">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1189">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1189">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAnsi">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1190">Alloue un objet <see cref="T:System.String" /> managé et y copie la totalité ou une partie d'une chaîne ANSI non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1190">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged ANSI string into it.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1191">Adresse du premier caractère de la chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1191">The address of the first character of the unmanaged string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1192">Copie tous les caractères jusqu'au premier caractère null d'une chaîne ANSI non managée vers un <see cref="T:System.String" /> managé, puis convertit chaque caractère ANSI en Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1192">Copies all characters up to the first null character from an unmanaged ANSI string to a managed <see cref="T:System.String" />, and widens each ANSI character to Unicode.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1193">Chaîne managée qui contient une copie de la chaîne ANSI non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1193">A managed string that holds a copy of the unmanaged ANSI string.</span>
          </span>
          <span data-ttu-id="37d7d-1194">Si <paramref name="ptr" /> est <see langword="null" />, la méthode retourne une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1194">If <paramref name="ptr" /> is <see langword="null" />, the method returns a null string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1195"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1195"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1196">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1196">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1197">Cette méthode fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1197">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1198">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> méthode pour créer une chaîne managée à partir d’une fonction non managée `char` tableau.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1198">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged `char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1199">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1199">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1200">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1200">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAnsi (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAnsi(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1201">Adresse du premier caractère de la chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1201">The address of the first character of the unmanaged string.</span>
          </span>
        </param>
        <param name="len">
          <span data-ttu-id="37d7d-1202">Nombre d'octets de la chaîne d'entrée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1202">The byte count of the input string to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1203">Alloue un objet <see cref="T:System.String" /> managé, copie un nombre spécifié de caractères d'une chaîne ANSI non managée dans celui-ci et élargit chaque caractère ANSI au format Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1203">Allocates a managed <see cref="T:System.String" />, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1204">Chaîne managée qui contient une copie de la chaîne ANSI native si la valeur du paramètre <paramref name="ptr" /> n'est pas <see langword="null" /> ; sinon, cette méthode retourne <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1204">A managed string that holds a copy of the native ANSI string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1205"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1205"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1206">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1206">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1207">Cette méthode fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1207">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1208">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> méthode pour créer une chaîne managée à partir d’une fonction non managée`char` tableau.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1208">The following example uses the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> method to create a managed string from an unmanaged`char` array.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1209">
            <paramref name="len" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1209">
              <paramref name="len" /> is less than zero.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1210">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1210">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1211">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1211">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringAuto">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1212">Alloue un <see cref="T:System.String" /> managé afin d'y copier la totalité ou une partie d'une chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1212">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged string into it.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1213">Pour les plateformes Unicode, adresse du premier caractère Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1213">For Unicode platforms, the address of the first Unicode character.</span>
          </span>
          <span data-ttu-id="37d7d-1214">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1214">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1215">Pour les plateformes ANSI, adresse du premier caractère ANSI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1215">For ANSI plaforms, the address of the first ANSI character.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1216">Alloue un objet <see cref="T:System.String" /> managé et copie tous les caractères - jusqu'au premier caractère null - d'une chaîne stockée dans de la mémoire non managée dans cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1216">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1217">Chaîne managée qui contient une copie de la chaîne non managée si la valeur du paramètre <paramref name="ptr" /> n'est pas <see langword="null" /> ; sinon, cette méthode retourne <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1217">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1218">Si la plateforme actuelle est Unicode, chaque caractère ANSI est élargi en un caractère Unicode et cette méthode appelle <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1218">If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>.</span></span> <span data-ttu-id="37d7d-1219">Sinon, cette méthode appelle <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1219">Otherwise, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span>  
  
 <span data-ttu-id="37d7d-1220"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1220"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1221">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1221">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1222"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1222"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1223">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1223">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1224">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1224">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringAuto (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringAuto(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1225">Pour les plateformes Unicode, adresse du premier caractère Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1225">For Unicode platforms, the address of the first Unicode character.</span>
          </span>
          <span data-ttu-id="37d7d-1226">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1226">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1227">Pour les plateformes ANSI, adresse du premier caractère ANSI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1227">For ANSI plaforms, the address of the first ANSI character.</span>
          </span>
        </param>
        <param name="len">
          <span data-ttu-id="37d7d-1228">Nombre de caractères à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1228">The number of characters to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1229">Alloue un <see cref="T:System.String" /> managé afin d'y copier le nombre spécifié de caractères d'une chaîne stockée dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1229">Allocates a managed <see cref="T:System.String" /> and copies the specified number of characters from a string stored in unmanaged memory into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1230">Chaîne managée qui contient une copie de la chaîne native si la valeur du paramètre <paramref name="ptr" /> n'est pas <see langword="null" /> ; sinon, cette méthode retourne <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1230">A managed string that holds a copy of the native string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1231">Sur les plateformes Unicode, cette méthode appelle <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; sur les plateformes ANSI, elle appelle <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1231">On Unicode platforms, this method calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; on ANSI platforms, it calls <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.</span></span> <span data-ttu-id="37d7d-1232">Aucune transformation n’est effectuée avant que ces méthodes sont appelées.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1232">No transformations are done before these methods are called.</span></span>  
  
 <span data-ttu-id="37d7d-1233"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1233"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1234">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1234">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1235"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> fournit les fonctionnalités inverses de <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1235"><xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1236">
            <paramref name="len" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1236">
              <paramref name="len" /> is less than zero.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1237">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1237">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1238">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1238">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringBSTR (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringBSTR(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1239">Adresse du premier caractère de la chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1239">The address of the first character of the unmanaged string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1240">Alloue un <see cref="T:System.String" /> managé pour y copier une [chaîne binaire (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1240">Allocates a managed <see cref="T:System.String" /> and copies a [binary string (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) stored in unmanaged memory into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1241">Chaîne managée qui contient une copie de la chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1241">A managed string that holds a copy of the unmanaged string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1242">Appelez cette méthode uniquement sur les chaînes allouées avec managée [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) et [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) fonctions.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1242">Call this method only on strings that were allocated with the unmanaged [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) and [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) functions.</span></span>  
  
 <span data-ttu-id="37d7d-1243"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1243"><xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1244">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1244">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1245">Cette méthode fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1245">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1246">
            <paramref name="ptr" /> est égal à <see cref="F:System.IntPtr.Zero" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1246">
              <paramref name="ptr" /> equals <see cref="F:System.IntPtr.Zero" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1247">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1247">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1248">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1248">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStringUni">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1249">Alloue un <see cref="T:System.String" /> managé afin d'y copier la totalité ou une partie d'une chaîne Unicode non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1249">Allocates a managed <see cref="T:System.String" /> and copies all or part of an unmanaged Unicode string into it.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1250">Adresse du premier caractère de la chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1250">The address of the first character of the unmanaged string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1251">Alloue un objet <see cref="T:System.String" /> managé et copie tous les caractères - jusqu'au premier caractère null - d'une chaîne Unicode non managée dans cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1251">Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from an unmanaged Unicode string into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1252">Chaîne managée qui contient une copie de la chaîne non managée si la valeur du paramètre <paramref name="ptr" /> n'est pas <see langword="null" /> ; sinon, cette méthode retourne <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1252">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1253"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> est utile pour le marshaling personnalisé ou pour une utilisation lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1253"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1254">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1254">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1255">Cette méthode fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1255">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1256">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1256">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1257">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1257">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUni (ptr As IntPtr, len As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUni(IntPtr ptr, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1258">Adresse du premier caractère de la chaîne non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1258">The address of the first character of the unmanaged string.</span>
          </span>
        </param>
        <param name="len">
          <span data-ttu-id="37d7d-1259">Nombre de caractères Unicode à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1259">The number of Unicode characters to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1260">Alloue un objet <see cref="T:System.String" /> managé et copie un nombre spécifié de caractères d'une chaîne Unicode non managée dans cet objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1260">Allocates a managed <see cref="T:System.String" /> and copies a specified number of characters from an unmanaged Unicode string into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1261">Chaîne managée qui contient une copie de la chaîne non managée si la valeur du paramètre <paramref name="ptr" /> n'est pas <see langword="null" /> ; sinon, cette méthode retourne <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1261">A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not <see langword="null" />; otherwise, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1262"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1262"><xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1263">Étant donné que cette méthode crée une copie du contenu de la chaîne non managée, vous devez libérer la chaîne d’origine comme il convient.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1263">Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</span></span> <span data-ttu-id="37d7d-1264">Cette méthode fournit les fonctionnalités opposées de la <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> et <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1264">This method provides the opposite functionality of the <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1265">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1265">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1266">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1266">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStringUTF8 (ptr As IntPtr, byteLen As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ PtrToStringUTF8(IntPtr ptr, int byteLen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="byteLen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PtrToStructure">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1267">Marshale les données d’un bloc de mémoire non managée dans un objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1267">Marshals data from an unmanaged block of memory to a managed object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure (ptr As IntPtr, structure As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PtrToStructure(IntPtr ptr, System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1268">Pointeur vers un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1268">A pointer to an unmanaged block of memory.</span>
          </span>
        </param>
        <param name="structure">
          <span data-ttu-id="37d7d-1269">Objet dans lequel les données doivent être copiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1269">The object to which the data is to be copied.</span>
          </span>
          <span data-ttu-id="37d7d-1270">Il doit s'agir d'une instance d'une classe mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1270">This must be an instance of a formatted class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1271">Marshale les données d’un bloc de mémoire non managée dans un objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1271">Marshals data from an unmanaged block of memory to a managed object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1272"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> est souvent nécessaire dans COM interop et plateforme appellent lorsque les paramètres de structure sont représentés en tant qu’un <xref:System.IntPtr?displayProperty=nameWithType> valeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1272"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="37d7d-1273">Vous ne pouvez pas utiliser cette surcharge de méthode avec des types valeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1273">You cannot use this overload method with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1274">La disposition de structure n'est ni séquentielle ni explicite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1274">Structure layout is not sequential or explicit.</span>
          </span>
          <span data-ttu-id="37d7d-1275">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1275">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1276">La structure est un type valeur boxed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1276">Structure is a boxed value type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1277">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1277">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1278">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1278">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure (ptr As IntPtr, structureType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ PtrToStructure(IntPtr ptr, Type ^ structureType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1279">Pointeur vers un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1279">A pointer to an unmanaged block of memory.</span>
          </span>
        </param>
        <param name="structureType">
          <span data-ttu-id="37d7d-1280">Type d'objet à créer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1280">The type of object to be created.</span>
          </span>
          <span data-ttu-id="37d7d-1281">Cet objet doit représenter une classe mise en forme ou une structure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1281">This object must represent a formatted class or a structure.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1282">Marshale, dans un nouvel objet managé alloué du type spécifié, les données d’un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1282">Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1283">Objet managé contenant les données vers lesquelles pointe le paramètre <paramref name="ptr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1283">A managed object containing the data pointed to by the <paramref name="ptr" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1284"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> est souvent nécessaire dans COM interop et plateforme appellent lorsque les paramètres de structure sont représentés en tant qu’un <xref:System.IntPtr?displayProperty=nameWithType> valeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1284"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref:System.IntPtr?displayProperty=nameWithType> value.</span></span> <span data-ttu-id="37d7d-1285">Vous pouvez passer un type valeur à cette méthode de surcharge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1285">You can pass a value type to this overload method.</span></span> <span data-ttu-id="37d7d-1286">Dans ce cas, l’objet retourné est une instance convertie (boxed).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1286">In this case, the returned object is a boxed instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1287">L’exemple suivant crée une structure managée, transfère en mémoire non managée, puis retransfère en mémoire managée à l’aide du <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1287">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 <span data-ttu-id="37d7d-1288">L’exemple suivant montre comment marshaler un bloc non managé de mémoire à une structure managée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1288">The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="37d7d-1289">Ce code suppose que la compilation de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1289">This code assumes 32-bit compilation.</span></span> <span data-ttu-id="37d7d-1290">Avant d’utiliser un compilateur 64 bits, remplacez <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> avec <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1290">Before using a 64-bit compiler, replace <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> with <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1291">La disposition du paramètre <paramref name="structureType" /> n'est ni séquentielle ni explicite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1291">The <paramref name="structureType" /> parameter layout is not sequential or explicit.</span>
          </span>
          <span data-ttu-id="37d7d-1292">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1292">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1293">Le paramètre <paramref name="structureType" /> est une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1293">The <paramref name="structureType" /> parameter is a generic type definition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1294">
            <paramref name="structureType" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1294">
              <paramref name="structureType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="37d7d-1295">La classe spécifiée par <paramref name="structureType" /> n'a pas de constructeur par défaut accessible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1295">The class specified by <paramref name="structureType" /> does not have an accessible default constructor.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1296">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1296">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1297">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1297">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)" />
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PtrToStructure(Of T) (ptr As IntPtr) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T PtrToStructure(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1298">Type de l'objet dans lequel les données doivent être copiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1298">The type of the object to which the data is to be copied.</span>
          </span>
          <span data-ttu-id="37d7d-1299">Il doit s'agir d'une classe ou d'une structure mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1299">This must be a formatted class or a structure.</span>
          </span>
        </typeparam>
        <param name="ptr">
          <span data-ttu-id="37d7d-1300">Pointeur vers un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1300">A pointer to an unmanaged block of memory.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1301">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1301">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1302">Marshale, dans un nouvel objet managé alloué du type spécifié par un paramètre de type générique, les données d'un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1302">Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1303">Objet managé contenant les données vers lesquelles pointe le paramètre <paramref name="ptr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1303">A managed object that contains the data that the <paramref name="ptr" /> parameter points to.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1304"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> est souvent nécessaire dans COM interop et la plateforme d’appel lorsque les paramètres de structure sont représentés en tant que <xref:System.IntPtr?displayProperty=nameWithType> valeurs.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1304"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="37d7d-1305">Vous pouvez passer un type valeur à cette surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1305">You can pass a value type to this method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1306">La disposition de <typeparamref name="T" /> n'est ni séquentielle ni explicite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1306">The layout of <typeparamref name="T" /> is not sequential or explicit.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="37d7d-1307">La classe spécifiée par <typeparamref name="T" /> n'a pas de constructeur par défaut accessible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1307">The class specified by <typeparamref name="T" /> does not have an accessible default constructor.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1308">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1308">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1309">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1309">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PtrToStructure(Of T) (ptr As IntPtr, structure As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void PtrToStructure(IntPtr ptr, T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1310">Le type de <c>structure</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1310">The type of <c>structure</c>.</span>
          </span>
          <span data-ttu-id="37d7d-1311">Il doit s'agir d'une classe formatée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1311">This must be a formatted class.</span>
          </span>
        </typeparam>
        <param name="ptr">
          <span data-ttu-id="37d7d-1312">Pointeur vers un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1312">A pointer to an unmanaged block of memory.</span>
          </span>
        </param>
        <param name="structure">
          <span data-ttu-id="37d7d-1313">Objet dans lequel les données doivent être copiées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1313">The object to which the data is to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1314">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1314">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1315">Marshale les données d'un bloc de mémoire non managée dans un objet managé d'un type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1315">Marshals data from an unmanaged block of memory to a managed object of the specified type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1316"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> est souvent nécessaire dans COM interop et la plateforme d’appel lorsque les paramètres de structure sont représentés en tant que <xref:System.IntPtr> valeurs.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1316"><xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref:System.IntPtr> values.</span></span> <span data-ttu-id="37d7d-1317">Vous ne pouvez pas utiliser cette surcharge de méthode avec des types valeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1317">You cannot use this method overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1318">La disposition de structure n'est ni séquentielle ni explicite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1318">Structure layout is not sequential or explicit.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1319">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1319">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1320">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1320">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueryInterface (pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int QueryInterface(IntPtr pUnk, Guid % iid, [Runtime::InteropServices::Out] IntPtr % ppv);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk">
          <span data-ttu-id="37d7d-1321">Interface à interroger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1321">The interface to be queried.</span>
          </span>
        </param>
        <param name="iid">
          <span data-ttu-id="37d7d-1322">Identificateur d'interface (IID) de l'interface demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1322">The interface identifier (IID) of the requested interface.</span>
          </span>
        </param>
        <param name="ppv">
          <span data-ttu-id="37d7d-1323">Lorsque cette méthode est retournée, contient une référence à l'interface retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1323">When this method returns, contains a reference to the returned interface.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1324">Demande un pointeur vers une interface spécifiée à partir d'un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1324">Requests a pointer to a specified interface from a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1325">HRESULT indiquant la réussite ou l'échec de l'appel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1325">An HRESULT that indicates the success or failure of the call.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1326">Le <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> méthode expose le [IUnknown::QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) méthode d’un objet COM, qui tente d’obtenir un pointeur d’interface spécifique.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1326">The <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> method exposes the [IUnknown::QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) method of a COM object, which attempts to obtain a specific interface pointer.</span></span> <span data-ttu-id="37d7d-1327">À l’aide de `QueryInterface` sur COM objet est identique à l’exécution d’une opération de conversion dans le code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1327">Using `QueryInterface` on a COM object is the same as performing a cast operation in managed code.</span></span> <span data-ttu-id="37d7d-1328">Appel d’un objet avec cette méthode entraîne le décompte de références incrémenter sur le pointeur d’interface avant que le pointeur est retourné.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1328">Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</span></span> <span data-ttu-id="37d7d-1329">Toujours utiliser <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> pour décrémenter le décompte de références, une fois que vous avez terminé avec le pointeur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1329">Always use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> to decrement the reference count once you have finished with the pointer.</span></span> <span data-ttu-id="37d7d-1330">Pour obtenir un <xref:System.IntPtr> valeur qui représente un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur d’interface, vous pouvez appeler <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, ou <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1330">To obtain an <xref:System.IntPtr> value that represents a [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer, you can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1331">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1331">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1332">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1332">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1333">Lit un octet unique à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1333">Reads a single byte from unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1334">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1334">Reading from unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1335">Adresse de début de lecture dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1335">The address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1336">Lit un octet unique à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1336">Reads a single byte from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1337">Octet lu dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1337">The byte read from unmanaged memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1338"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> comporte un décalage implicite de 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1338"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> has an implied offset of 0.</span></span> <span data-ttu-id="37d7d-1339">Cette méthode permet l’interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1339">This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1340">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1340">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1341">L’exemple suivant crée un bloc de mémoire non managée, écrit un octet dans la mémoire non managée, lit l’octet à partir de la mémoire non managée, puis libère la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1341">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 <span data-ttu-id="37d7d-1342">L’exemple suivant montre comment utiliser la <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> méthode lire la valeur d’un caractère non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1342">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1343">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1343">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1344">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1344">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1345">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1345">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1346">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1346">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1347">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1347">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1348">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1348">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1349">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1349">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As IntPtr, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1350">Adresse de base dans la mémoire non managée où commencer la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1350">The base address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1351">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1351">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1352">Lit un seul octet à un offset (ou index) donné dans la mémoire managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1352">Reads a single byte at a given offset (or index) from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1353">Octet lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1353">The byte read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1354"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> permet une interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1354"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1355">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1355">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1356">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1356">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 <span data-ttu-id="37d7d-1357">L’exemple suivant montre comment utiliser la <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> méthode lire la valeur d’un caractère non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1357">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> method to read the value of an unmanaged character.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1358">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1358">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1359">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1359">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1360">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1360">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadByte (ptr As Object, ofs As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReadByte(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1361">Adresse de base dans la mémoire non managée de l'objet source.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1361">The base address in unmanaged memory of the source object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1362">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1362">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1363">Lit un seul octet à un offset (ou index) donné dans la mémoire managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1363">Reads a single byte at a given offset (or index) from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1364">Octet lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1364">The byte read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1365"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> permet une interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1365"><xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1366">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1366">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1367">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1367">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1368">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1368">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-1369">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1369">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1370">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1370">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1371">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1371">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1372">Lit un entier 16 bits signé à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1372">Reads a 16-bit signed integer from unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1373">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1373">Reading from unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1374">Adresse de début de lecture dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1374">The address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1375">Lit un entier 16 bits signé à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1375">Reads a 16-bit signed integer from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1376">Entier signé 16 bits lu dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1376">The 16-bit signed integer read from unmanaged memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1377"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> comporte un décalage implicite de 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1377"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> has an implied offset of 0.</span></span> <span data-ttu-id="37d7d-1378">Cette méthode permet l’interaction directe avec un type C managé `Int16` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1378">This method enables direct interaction with an unmanaged C-style `Int16` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1379">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1379">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1380">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1380">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="37d7d-1381">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> méthode pour lire la valeur d’une fonction non managée `short` variable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1381">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1382">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1382">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1383">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1383">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1384">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1384">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1385">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1385">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1386">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1386">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1387">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1387">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1388">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1388">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As IntPtr, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1389">Adresse de base dans la mémoire non managée où commencer la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1389">The base address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1390">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1390">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1391">Lit un entier signé 16 bits à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1391">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1392">Entier signé 16 bits lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1392">The 16-bit signed integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1393"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1393"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1394">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1394">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1395">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1395">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 <span data-ttu-id="37d7d-1396">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> méthode pour lire la valeur d’une fonction non managée `short` variable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1396">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> method to read the value of an unmanaged `short` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1397">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1397">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1398">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1398">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1399">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1399">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16 (ptr As Object, ofs As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1400">Adresse de base dans la mémoire non managée de l'objet source.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1400">The base address in unmanaged memory of the source object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1401">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1401">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1402">Lit un entier signé 16 bits à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1402">Reads a 16-bit signed integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1403">Entier signé 16 bits lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1403">The 16-bit signed integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1404"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1404"><xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1405">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1405">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1406">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1406">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1407">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1407">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-1408">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1408">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1409">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1409">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1410">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1410">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1411">Lit un entier 32 bits signé à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1411">Reads a 32-bit signed integer from unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1412">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1412">Reading from unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1413">Adresse de début de lecture dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1413">The address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1414">Lit un entier 32 bits signé à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1414">Reads a 32-bit signed integer from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1415">Entier signé 32 bits lu dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1415">The 32-bit signed integer read from unmanaged memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1416"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> comporte un décalage implicite de 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1416"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> has an implied offset of 0.</span></span> <span data-ttu-id="37d7d-1417">Cette méthode permet l’interaction directe avec un type C managé `Int32` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1417">This method enables direct interaction with an unmanaged C-style `Int32` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1418">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1418">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1419">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1419">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="37d7d-1420">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> méthode pour lire la valeur d’une fonction non managée `int` variable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1420">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1421">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1421">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1422">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1422">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1423">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1423">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1424">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1424">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1425">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1425">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1426">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1426">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1427">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1427">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As IntPtr, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1428">Adresse de base dans la mémoire non managée où commencer la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1428">The base address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1429">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1429">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1430">Lit un entier signé 32 bits à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1430">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1431">Entier signé 32 bits lu dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1431">The 32-bit signed integer read from unmanaged memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1432"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> permet une interaction directe avec un tableau signé 32 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1432"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1433">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1433">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1434">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1434">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 <span data-ttu-id="37d7d-1435">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> méthode pour lire la valeur d’une fonction non managée `int` variable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1435">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> method to read the value of an unmanaged `int` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1436">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1436">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1437">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1437">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1438">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1438">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32 (ptr As Object, ofs As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1439">Adresse de base dans la mémoire non managée de l'objet source.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1439">The base address in unmanaged memory of the source object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1440">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1440">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1441">Lit un entier signé 32 bits à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1441">Reads a 32-bit signed integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1442">Entier signé 32 bits lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1442">The 32-bit signed integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1443"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> permet une interaction directe avec un tableau signé 32 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1443"><xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1444">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1444">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1445">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1445">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1446">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1446">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-1447">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1447">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1448">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1448">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1449">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1449">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1450">Lit un entier 64 bits signé à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1450">Reads a 64-bit signed integer from unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1451">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1451">Reading from unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1452">Adresse de début de lecture dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1452">The address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1453">Lit un entier 64 bits signé à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1453">Reads a 64-bit signed integer from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1454">Entier signé 64 bits lu dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1454">The 64-bit signed integer read from unmanaged memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1455"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> comporte un décalage implicite de 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1455"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> has an implied offset of 0.</span></span> <span data-ttu-id="37d7d-1456">Cette méthode permet l’interaction directe avec un type C managé `Int64` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1456">This method enables direct interaction with an unmanaged C-style `Int64` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1457">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1457">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1458">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1458">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="37d7d-1459">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> méthode pour lire la valeur d’une fonction non managée `__int64` variable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1459">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1460">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1460">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1461">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1461">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1462">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1462">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1463">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1463">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1464">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1464">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1465">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1465">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1466">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1466">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As IntPtr, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1467">Adresse de base dans la mémoire non managée où commencer la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1467">The base address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1468">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1468">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1469">Lit un entier signé 64 bits à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1469">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1470">Entier signé 64 bits lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1470">The 64-bit signed integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1471"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> permet une interaction directe avec un tableau signé 64 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1471"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1472">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1472">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1473">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1473">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 <span data-ttu-id="37d7d-1474">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> méthode pour lire la valeur d’une fonction non managée `__int64` variable.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1474">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> method to read the value of an unmanaged `__int64` variable.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1475">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1475">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1476">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1476">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1477">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1477">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64 (ptr As Object, ofs As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1478">Adresse de base dans la mémoire non managée de l'objet source.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1478">The base address in unmanaged memory of the source object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1479">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1479">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1480">Lit un entier signé 64 bits à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1480">Reads a 64-bit signed integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1481">Entier signé 64 bits lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1481">The 64-bit signed integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1482"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> permet une interaction directe avec un tableau signé 64 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1482"><xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1483">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1483">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1484">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1484">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1485">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1485">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-1486">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1486">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1487">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1487">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1488">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1488">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1489">Lit un entier natif dimensionné par processeur à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1489">Reads a processor native sized integer from unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1490">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1490">Reading from unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1491">Adresse de début de lecture dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1491">The address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1492">Lit un entier natif dimensionné par processeur dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1492">Reads a processor native-sized integer from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1493">Entier lu dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1493">The integer read from unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1494">Un entier 32 bits est retourné sur les ordinateurs 32 bits et un entier 64 bits est retourné sur les ordinateurs 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1494">A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1495"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> comporte un décalage implicite de 0.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1495"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> has an implied offset of 0.</span></span> <span data-ttu-id="37d7d-1496">Cette méthode permet l’interaction directe avec un type C managé `IntPtr` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1496">This method enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1497">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1497">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1498">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1498">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1499">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1499">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1500">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1500">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1501">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1501">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1502">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1502">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1503">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1503">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1504">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1504">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1505">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1505">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As IntPtr, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(IntPtr ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1506">Adresse de base dans la mémoire non managée où commencer la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1506">The base address in unmanaged memory from which to read.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1507">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1507">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1508">Lit un entier natif dimensionné par processeur à un offset donné dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1508">Reads a processor native sized integer at a given offset from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1509">Entier lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1509">The integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1510"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> permet une interaction directe avec un type C managé `IntPtr` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1510"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1511">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1511">Reading from unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1512">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1512">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1513">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1513">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1514">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1514">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1515">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1515">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntPtr (ptr As Object, ofs As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReadIntPtr(System::Object ^ ptr, int ofs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1516">Adresse de base dans la mémoire non managée de l'objet source.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1516">The base address in unmanaged memory of the source object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1517">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1517">An additional byte offset, which is added to the <c>ptr</c> parameter before reading.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1518">Lit un entier natif dimensionné par processeur à partir de la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1518">Reads a processor native sized integer from unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1519">Entier lu dans la mémoire non managée à l'offset donné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1519">The integer read from unmanaged memory at the given offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1520"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> permet une interaction directe avec un type C managé `IntPtr` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de lire les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1520"><xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before reading its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1521">La lecture depuis des emplacements mémoire non alignés est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1521">Reading from unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1522">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1522">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1523">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1523">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-1524">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1524">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1525">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1525">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1526">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1526">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocCoTaskMem (pv As IntPtr, cb As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv">
          <span data-ttu-id="37d7d-1527">Pointeur vers la mémoire allouée avec <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1527">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span>
          </span>
        </param>
        <param name="cb">
          <span data-ttu-id="37d7d-1528">Nouvelle taille du bloc alloué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1528">The new size of the allocated block.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1529">Redimensionne un bloc de mémoire précédemment alloué avec <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1529">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1530">Entier représentant l'adresse du bloc de mémoire réalloué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1530">An integer representing the address of the reallocated block of memory.</span>
          </span>
          <span data-ttu-id="37d7d-1531">Cette mémoire doit être libérée avec <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1531">This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1532"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> est une des deux méthodes de réallocation de mémoire dans le <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1532"><xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A> is one of two memory reallocation methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="37d7d-1533">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> est l’autre.) Le début du contenu de la mémoire réallouée est le même que le contenu d’origine ; Toutefois, l’ensemble du bloc mémoire peut être dans un autre emplacement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1533">(<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</span></span> <span data-ttu-id="37d7d-1534">Cette méthode expose le modèle COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) (fonction), qui est appelée par l’allocateur de mémoire de tâche COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1534">This method exposes the COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) function, which is referred to as the COM task memory allocator.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1535">La mémoire est insuffisante pour répondre à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1535">There is insufficient memory to satisfy the request.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1536">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1536">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1537">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1537">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReAllocHGlobal (pv As IntPtr, cb As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv">
          <span data-ttu-id="37d7d-1538">Pointeur vers la mémoire allouée avec <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1538">A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span>
          </span>
        </param>
        <param name="cb">
          <span data-ttu-id="37d7d-1539">Nouvelle taille du bloc alloué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1539">The new size of the allocated block.</span>
          </span>
          <span data-ttu-id="37d7d-1540">Ce n’est pas un pointeur ; c’est le nombre d’octets que vous demandez, cast vers type <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1540">This is not a pointer; it is the byte count you are requesting, cast to type <see cref="T:System.IntPtr" />.</span>
          </span>
          <span data-ttu-id="37d7d-1541">Si vous passez un pointeur, il est traité comme une taille.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1541">If you pass a pointer, it is treated as a size.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1542">Redimensionne un bloc de mémoire précédemment alloué avec <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1542">Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1543">Pointeur vers la mémoire réallouée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1543">A pointer to the reallocated memory.</span>
          </span>
          <span data-ttu-id="37d7d-1544">Cette mémoire doit être libérée avec <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1544">This memory must be released using <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1545"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> est une des opérations de réallocation de mémoire de deux méthodes de l’API dans la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1545"><xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> is one of two memory reallocation API methods in the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="37d7d-1546">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> est l’autre.)</span><span class="sxs-lookup"><span data-stu-id="37d7d-1546">(<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> is the other.)</span></span>  
  
 <span data-ttu-id="37d7d-1547">Cette méthode expose Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) fonction à partir de Kernel32.dll.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1547">This method exposes the Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) function from Kernel32.dll.</span></span> <span data-ttu-id="37d7d-1548">Le pointeur retourné peut différer de l’original.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1548">The returned pointer can differ from the original.</span></span> <span data-ttu-id="37d7d-1549">S’il est différent, le contenu du bloc de mémoire d’origine ont été copié sur le nouveau bloc, et le bloc de mémoire d’origine a été libéré.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1549">If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1550">La mémoire est insuffisante pour répondre à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1550">There is insufficient memory to satisfy the request.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1551">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1551">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1552">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1552">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Release (pUnk As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Release(IntPtr pUnk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">
          <span data-ttu-id="37d7d-1553">Interface à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1553">The interface to release.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1554">Décrémente le décompte de références sur l'interface spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1554">Decrements the reference count on the specified interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1555">Nouvelle valeur du décompte de références sur l'interface spécifiée par le paramètre <paramref name="pUnk" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1555">The new value of the reference count on the interface specified by the <paramref name="pUnk" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1556">Le common language runtime gère le décompte de références d’un objet COM pour vous, et évite d’avoir à utiliser cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1556">The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</span></span> <span data-ttu-id="37d7d-1557">Utilisez cette valeur uniquement pour des tests.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1557">Use this value only for testing purposes.</span></span> <span data-ttu-id="37d7d-1558">Dans de rares cas, par exemple un test un marshaleur personnalisé, il peut vous sembler nécessaires pour manipuler la durée de vie d’un objet manuellement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1558">In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</span></span> <span data-ttu-id="37d7d-1559">Seuls les programmes qui appellent <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> doit appeler <xref:System.Runtime.InteropServices.Marshal.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1559">Only programs that call <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> should call <xref:System.Runtime.InteropServices.Marshal.Release%2A>.</span></span> <span data-ttu-id="37d7d-1560">Appel de <xref:System.Runtime.InteropServices.Marshal.Release%2A> lorsque le décompte de références atteint zéro entraîne un comportement non défini.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1560">Calling <xref:System.Runtime.InteropServices.Marshal.Release%2A> after the reference count has reached zero causes undefined behavior.</span></span>  
  
 <span data-ttu-id="37d7d-1561">Vous pouvez appeler <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, ou <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> pour obtenir un <xref:System.IntPtr> valeur qui représente un [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) pointeur d’interface à libérer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1561">You can call <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, or <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> to obtain an <xref:System.IntPtr> value that represents a [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface pointer to release.</span></span> <span data-ttu-id="37d7d-1562">Vous pouvez également utiliser ces méthodes et la <xref:System.Runtime.InteropServices.Marshal.Release%2A> méthode sur des objets managés pour libérer les interfaces COM représentés par l’objet managé [Wrapper CCW](~/docs/framework/interop/com-callable-wrapper.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1562">You can also use these methods and the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method on managed objects to release the COM interfaces represented by the managed object's [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1563">L’exemple suivant montre comment récupérer un `IUnknown` interface pour un objet managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1563">The following example demonstrates how to retrieve an `IUnknown` interface for a managed object using the <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> method.</span></span> <span data-ttu-id="37d7d-1564">L’exemple libère ensuite le pointeur d’interface en appelant le <xref:System.Runtime.InteropServices.Marshal.Release%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1564">The example then releases the interface pointer by calling the <xref:System.Runtime.InteropServices.Marshal.Release%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1565">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1565">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1566">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1566">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReleaseComObject (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReleaseComObject(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="37d7d-1567">Objet COM à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1567">The COM object to release.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1568">Décrémente le décompte de références du wrapper RCW [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) associé à l’objet COM indiqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1568">Decrements the reference count of the [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) associated with the specified COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1569">Nouvelle valeur du décompte de références du wrapper RCW (Runtime Callable Wrapper) associé à <paramref name="o" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1569">The new value of the reference count of the RCW associated with <paramref name="o" />.</span>
          </span>
          <span data-ttu-id="37d7d-1570">Cette valeur est généralement zéro puisque le wrapper RCW (Runtime Callable Wrapper) ne conserve qu'une seule référence à l'objet COM inclus dans un wrapper indépendamment du nombre de clients managés qui l'appellent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1570">This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1571">Cette méthode est utilisée pour contrôler explicitement la durée de vie d’un objet COM utilisé à partir de code managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1571">This method is used to explicitly control the lifetime of a COM object used from managed code.</span></span> <span data-ttu-id="37d7d-1572">Vous devez utiliser cette méthode pour libérer l’objet COM sous-jacent qui contient des références à des ressources en temps voulu, ou lorsque les objets doivent être libérés dans un ordre spécifique.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1572">You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</span></span>  
  
 <span data-ttu-id="37d7d-1573">Chaque fois qu’un pointeur d’interface COM entre le common language runtime (CLR), il est encapsulé dans un wrapper RCW.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1573">Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</span></span>  
  
 <span data-ttu-id="37d7d-1574">Le wrapper RCW est un décompte de références est incrémenté chaque fois qu’un pointeur d’interface COM est mappé à celui-ci.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1574">The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</span></span> <span data-ttu-id="37d7d-1575">Le <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> méthode décrémente le décompte de références d’un wrapper RCW.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1575">The <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method decrements the reference count of an RCW.</span></span> <span data-ttu-id="37d7d-1576">Lorsque le décompte de références atteint zéro, le runtime libère toutes ses références sur l’objet COM non managé et lève un <xref:System.NullReferenceException?displayProperty=nameWithType> si vous tentez d’utiliser encore l’objet.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1576">When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <xref:System.NullReferenceException?displayProperty=nameWithType> if you attempt to use the object further.</span></span> <span data-ttu-id="37d7d-1577">Si la même interface COM est passée plusieurs fois à partir de non managé au code managé, le décompte de références sur le wrapper est incrémenté à chaque fois et l’appel <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> retourne le nombre de références restantes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1577">If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> returns the number of remaining references.</span></span>  
  
 <span data-ttu-id="37d7d-1578">Cette méthode vous permet de forcer une libération du nombre de référence RCW afin qu’elle soit précisément lorsque vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1578">This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</span></span> <span data-ttu-id="37d7d-1579">Toutefois, une utilisation incorrecte de <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> peut entraîner l’échec de votre application ou peut provoquer une violation d’accès.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1579">However, improper use of <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> may cause your application to fail, or may cause an access violation.</span></span>  
  
 <span data-ttu-id="37d7d-1580">Considérez un scénario dans lequel le code managé dans un domaine d’application est maintenant un RCW qui représente un composant COM.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1580">Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</span></span> <span data-ttu-id="37d7d-1581">Si vous appelez le <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> méthode sur le wrapper RCW, le code managé ne pourra pas accéder au RCW et déclenchera une <xref:System.Runtime.InteropServices.InvalidComObjectException> exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1581">If you call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the RCW, the managed code will be unable to access the RCW and will raise an <xref:System.Runtime.InteropServices.InvalidComObjectException> exception.</span></span>  
  
 <span data-ttu-id="37d7d-1582">Une erreur plus grave peut se produire si un appel au RCW s’exécute lorsque le RCW est libéré.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1582">A more serious error may occur if a call to the RCW is executing when the RCW is released.</span></span> <span data-ttu-id="37d7d-1583">Dans ce cas, il est a de fortes chances que le thread qui effectue l’appel entraîne une violation d’accès.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1583">In this case, there is a good chance that the thread making the call will cause an access violation.</span></span> <span data-ttu-id="37d7d-1584">Toutefois, la mémoire de processus peut être endommagée, et le processus peut continuer à s’exécuter jusqu'à ce qu’il échoue pour des raisons qui sont très difficiles à déboguer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1584">However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</span></span>  
  
 <span data-ttu-id="37d7d-1585">Ce risque est composé lorsque le composant COM utilisé est un singleton, pour la raison suivante : le CLR active les composants COM en appelant le modèle COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) fonction qui retourne le même pointeur d’interface chaque fois qu’elle est appelée pour des composants COM singleton.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1585">This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) function, which returns the same interface pointer every time it is called for singleton COM components.</span></span> <span data-ttu-id="37d7d-1586">Par conséquent, des éléments séparés et indépendants de code managé dans un domaine d’application peuvent utiliser le même wrapper RCW pour un composant COM singleton et si le d’eux appelle la <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> méthode sur le composant COM, l’autre sera rompue.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1586">Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method on the COM component, the other will be broken.</span></span>  
  
 <span data-ttu-id="37d7d-1587">Par conséquent, utilisez le <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> uniquement s’il est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1587">Therefore, use the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> only if it is absolutely required.</span></span> <span data-ttu-id="37d7d-1588">Si vous souhaitez appeler cette méthode pour vérifier qu’un composant COM est diffusé à une heure déterminée, envisagez d’utiliser le <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1588">If you want to call this method to ensure that a COM component is released at a determined time, consider using the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method instead.</span></span> <span data-ttu-id="37d7d-1589"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> Libère le composant COM sous-jacent, quelle que soit le nombre de fois où il a de nouveau entré le CLR.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1589"><xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> will release the underlying COM component regardless of how many times it has re-entered the CLR.</span></span> <span data-ttu-id="37d7d-1590">Le nombre de références internes du wrapper RCW est incrémenté chaque fois que le composant COM accède au CLR.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1590">The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</span></span> <span data-ttu-id="37d7d-1591">Par conséquent, vous pouvez appeler la <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> méthode dans une boucle jusqu'à ce que la valeur retournée est zéro.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1591">Therefore, you could call the <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> method in a loop until the value returned is zero.</span></span> <span data-ttu-id="37d7d-1592">Cela permet d’obtenir le même résultat que la <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1592">This achieves the same result as the <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1593">
            <paramref name="o" /> n'est pas un objet COM valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1593">
              <paramref name="o" /> is not a valid COM object.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="37d7d-1594">
            <paramref name="o" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1594">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1595">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1595">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1596">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1596">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
        <altmember cref="T:System.NullReferenceException" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReleaseThreadCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReleaseThreadCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1597">Libère le cache de thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1597">Releases the thread cache.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1598">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1598">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1599">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1599">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToBSTR (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToBSTR(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1600">Objet managé à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1600">The managed object to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1601">Alloue une [chaîne binaire (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) non managée et y copie le contenu d’un objet <see cref="T:System.Security.SecureString" /> managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1601">Allocates an unmanaged [binary string (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) and copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1602">Adresse, dans la mémoire non managée, où le paramètre <paramref name="s" /> a été copié, ou 0 si un objet null a été fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1602">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1603">Le <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> méthode est utile pour le marshaling personnalisé ou lorsque mélange de code managé et.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1603">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1604">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer le `BSTR` lorsque vous avez terminé en appelant le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1604">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1605">Le paramètre <paramref name="s" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1605">The <paramref name="s" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-1606">L’ordinateur actuel n’exécute pas Windows 2000 Service Pack 3 ou une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1606">The current computer is not running Windows 2000 Service Pack 3 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1607">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1607">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1608">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1608">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1609">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1609">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="37d7d-1610">Cette méthode est prise en charge uniquement sur les ordinateurs exécutant Windows 2000 Service Pack 3 ou version ultérieure.</span>
            <span class="sxs-lookup">
              <span data-stu-id="37d7d-1610">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1611">Objet managé à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1611">The managed object to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1612">Copie le contenu d’un objet <see cref="T:System.Security.SecureString" /> managé dans un bloc de mémoire alloué à partir de l’allocateur de tâche COM non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1612">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1613">Adresse, dans la mémoire non managée, où le paramètre <paramref name="s" /> a été copié, ou 0 si un objet null a été fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1613">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1614">Le <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> méthode est utile pour le marshaling personnalisé ou lorsque mélange de code managé et.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1614">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1615">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1615">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>.</span></span> <span data-ttu-id="37d7d-1616">Les caractères de la chaîne sont copiés en tant que caractères ANSI.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1616">The characters of the string are copied as ANSI characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1617">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> méthode à marshaler et déchiffrer le contenu d’un <xref:System.Security.SecureString> objet dans un bloc de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1617">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="37d7d-1618">Il utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> méthode à zéro et supprimer le bloc non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1618">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1619">Le paramètre <paramref name="s" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1619">The <paramref name="s" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-1620">L’ordinateur actuel n’exécute pas Windows 2000 Service Pack 3 ou une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1620">The current computer is not running Windows 2000 Service Pack 3 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1621">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1621">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1622">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1622">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1623">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1623">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="37d7d-1624">Cette méthode est prise en charge uniquement sur les ordinateurs exécutant Windows 2000 Service Pack 3 ou version ultérieure.</span>
            <span class="sxs-lookup">
              <span data-stu-id="37d7d-1624">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToCoTaskMemUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToCoTaskMemUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1625">Objet managé à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1625">The managed object to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1626">Copie le contenu d’un objet <see cref="T:System.Security.SecureString" /> managé dans un bloc de mémoire alloué à partir de l’allocateur de tâche COM non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1626">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1627">Adresse, dans la mémoire non managée, où le paramètre <paramref name="s" /> a été copié, ou 0 si un objet null a été fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1627">The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1628">Le <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> méthode est utile pour le marshaling personnalisé ou lorsque mélange de code managé et.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1628">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1629">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1629">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method.</span></span> <span data-ttu-id="37d7d-1630">Les caractères de la chaîne sont copiés en tant que caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1630">The characters of the string are copied as Unicode characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1631">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> méthode à marshaler et déchiffrer le contenu d’un <xref:System.Security.SecureString> objet dans un bloc de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1631">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="37d7d-1632">Il utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> méthode à zéro et supprimer le bloc non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1632">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1633">Le paramètre <paramref name="s" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1633">The <paramref name="s" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-1634">L’ordinateur actuel n’exécute pas Windows 2000 Service Pack 3 ou une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1634">The current computer is not running Windows 2000 Service Pack 3 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1635">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1635">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1636">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1636">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1637">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1637">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="37d7d-1638">Cette méthode est prise en charge uniquement sur les ordinateurs exécutant Windows 2000 Service Pack 3 ou version ultérieure.</span>
            <span class="sxs-lookup">
              <span data-stu-id="37d7d-1638">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocAnsi (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocAnsi(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1639">Objet managé à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1639">The managed object to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1640">Copie le contenu d’un objet <see cref="T:System.Security.SecureString" /> managé dans la mémoire non managée, avec conversion au format ANSI pendant la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1640">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> into unmanaged memory, converting into ANSI format as it copies.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1641">Adresse (dans la mémoire non managée) où le paramètre <paramref name="s" /> a été copié, ou 0 si un objet null a été fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1641">The address, in unmanaged memory, to where the <paramref name="s" /> parameter was copied, or 0 if a null object was supplied.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1642">Le <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> méthode est utile pour le marshaling personnalisé ou lorsque mélange de code managé et.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1642">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1643">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1643">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1644">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> méthode à marshaler et déchiffrer le contenu d’un <xref:System.Security.SecureString> objet dans un bloc de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1644">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="37d7d-1645">Il utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> méthode à zéro et supprimer le bloc non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1645">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1646">Le paramètre <paramref name="s" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1646">The <paramref name="s" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-1647">L’ordinateur actuel n’exécute pas Windows 2000 Service Pack 3 ou une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1647">The current computer is not running Windows 2000 Service Pack 3 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1648">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1648">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1649">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1649">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1650">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1650">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="37d7d-1651">Cette méthode est prise en charge uniquement sur les ordinateurs exécutant Windows 2000 Service Pack 3 ou version ultérieure.</span>
            <span class="sxs-lookup">
              <span data-stu-id="37d7d-1651">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SecureStringToGlobalAllocUnicode (s As SecureString) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr SecureStringToGlobalAllocUnicode(System::Security::SecureString ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1652">Objet managé à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1652">The managed object to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1653">Copie le contenu d’un objet <see cref="T:System.Security.SecureString" /> managé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1653">Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1654">Adresse, dans la mémoire non managée, où <paramref name="s" /> a été copié, ou 0 si <paramref name="s" /> est un objet <see cref="T:System.Security.SecureString" /> dont la longueur est 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1654">The address, in unmanaged memory, where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is a <see cref="T:System.Security.SecureString" /> object whose length is 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1655">Le <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> méthode est utile pour le marshaling personnalisé ou pour une utilisation lors de la combinaison de code managé et.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1655">The <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1656">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1656">Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1657">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> méthode managée `LogonUser` (fonction) pour effectuer l’emprunt d’identité avec la <xref:System.Security.SecureString> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1657">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="37d7d-1658">L’exemple utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> méthode à zéro et libérer la référence de chaîne non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1658">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1659">Le paramètre <paramref name="s" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1659">The <paramref name="s" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="37d7d-1660">L’ordinateur actuel n’exécute pas Windows 2000 Service Pack 3 ou une version ultérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1660">The current computer is not running Windows 2000 Service Pack 3 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1661">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1661">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1662">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1662">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1663">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1663">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="37d7d-1664">Cette méthode est prise en charge uniquement sur les ordinateurs exécutant Windows 2000 Service Pack 3 ou version ultérieure.</span>
            <span class="sxs-lookup">
              <span data-stu-id="37d7d-1664">This method is supported only on computers running Windows 2000 Service Pack 3 or later.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetComObjectData (obj As Object, key As Object, data As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetComObjectData(System::Object ^ obj, System::Object ^ key, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="37d7d-1665">Objet COM dans lequel stocker les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1665">The COM object in which to store the data.</span>
          </span>
        </param>
        <param name="key">
          <span data-ttu-id="37d7d-1666">Clé dans la table de hachage interne de l'objet COM dans lequel stocker les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1666">The key in the internal hash table of the COM object in which to store the data.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="37d7d-1667">Données à définir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1667">The data to set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1668">Définit des données référencées par la clé spécifiée dans l'objet COM spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1668">Sets data referenced by the specified key in the specified COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1669">
            <see langword="true" /> si les données ont été correctement définies ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1669">
              <see langword="true" /> if the data was set successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1670">Tous les objets COM encapsulés dans un [Wrapper RCW](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) ont une table de hachage associée, à laquelle <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> ajoute des données.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1670">All COM objects wrapped in a [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) have an associated hash table, to which <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> adds data.</span></span> <span data-ttu-id="37d7d-1671"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> Récupère les données à partir de la table de hachage.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1671"><xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType> retrieves data from the hash table.</span></span> <span data-ttu-id="37d7d-1672">Vous ne devez jamais appeler soit la méthode à partir de votre code.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1672">You should never have to call either method from your code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1673">
            <paramref name="obj" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1673">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1674">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1674">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1675">
            <paramref name="key" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1675">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1676">
            <paramref name="obj" /> n’est pas un objet COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1676">
              <paramref name="obj" /> is not a COM object.</span>
          </span>
          <span data-ttu-id="37d7d-1677">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1677">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1678">
            <paramref name="obj" /> est un objet [!INCLUDE[wrt](~/includes/wrt-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1678">
              <paramref name="obj" /> is a [!INCLUDE[wrt](~/includes/wrt-md.md)] object.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1679">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1679">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1680">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1680">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SizeOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1681">Retourne la taille non managée (en octets) d'une classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1681">Returns the unmanaged size, in bytes, of a class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (structure As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(System::Object ^ structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure">
          <span data-ttu-id="37d7d-1682">Objet dont la taille doit être retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1682">The object whose size is to be returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1683">Retourne la taille non managée d'un objet en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1683">Returns the unmanaged size of an object in bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1684">Taille de l'objet spécifié dans le code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1684">The size of the specified object in unmanaged code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1685">Cette méthode accepte une instance d’une structure, ce qui peut être un type référence ou un type valeur boxed.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1685">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="37d7d-1686">La disposition doit être séquentielle ou explicite.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1686">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="37d7d-1687">La taille retournée est la taille de l’objet non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1687">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="37d7d-1688">Les tailles managée et non d’un objet peuvent être différent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1688">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="37d7d-1689">Pour les types de caractères, la taille est affectée par la <xref:System.Runtime.InteropServices.CharSet> valeur appliqué à cette classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1689">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="37d7d-1690">Vous pouvez utiliser la <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> méthode pour déterminer la quantité de mémoire non managée à allouer à l’aide de la <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> et <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1690">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1691">L’exemple suivant crée une structure managée, transfère en mémoire non managée, puis transfère celui-ci vers la mémoire managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1691">The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory.</span></span> <span data-ttu-id="37d7d-1692">Cet exemple utilise la <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> méthode pour déterminer la quantité de mémoire non managée à allouer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1692">This example uses the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method to determine how much unmanaged memory to allocate.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1693">Le paramètre <paramref name="structure" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1693">The <paramref name="structure" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf (t As Type) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int SizeOf(Type ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="37d7d-1694">Type dont la taille doit être retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1694">The type whose size is to be returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1695">Retourne la taille d'un type non managé en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1695">Returns the size of an unmanaged type in bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1696">Taille du type spécifié dans le code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1696">The size of the specified type in unmanaged code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1697">Vous pouvez utiliser cette méthode lorsque vous ne disposez pas d’une structure.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1697">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="37d7d-1698">La disposition doit être séquentielle ou explicite.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1698">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="37d7d-1699">La taille retournée est la taille du type non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1699">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="37d7d-1700">Les tailles managée et non d’un objet peuvent être différent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1700">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="37d7d-1701">Pour les types de caractères, la taille est affectée par la <xref:System.Runtime.InteropServices.CharSet> valeur appliqué à cette classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1701">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1702">L'exemple suivant montre l'appel à la méthode <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1702">The following example demonstrates calling the <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> method.</span></span> <span data-ttu-id="37d7d-1703">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1703">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1704">Le paramètre <paramref name="t" /> est une définition de type générique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1704">The <paramref name="t" /> parameter is a generic type definition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1705">Le paramètre <paramref name="t" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1705">The <paramref name="t" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1706">Type dont la taille doit être retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1706">The type whose size is to be returned.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="37d7d-1707">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1707">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1708">Retourne la taille d'un type non managé en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1708">Returns the size of an unmanaged type in bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1709">Taille, en octets, du type spécifié par le paramètre de type générique <typeparamref name="T" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1709">The size, in bytes, of the type that is specified by the <typeparamref name="T" /> generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1710">Vous pouvez utiliser cette méthode lorsque vous ne disposez pas d’une structure.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1710">You can use this method when you do not have a structure.</span></span> <span data-ttu-id="37d7d-1711">La disposition doit être séquentielle ou explicite.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1711">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="37d7d-1712">La taille retournée est la taille du type non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1712">The size returned is the size of the unmanaged type.</span></span> <span data-ttu-id="37d7d-1713">Les tailles managée et non d’un objet peuvent être différent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1713">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="37d7d-1714">Pour les types de caractères, la taille est affectée par la <xref:System.Runtime.InteropServices.CharSet> valeur appliqué à cette classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1714">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) (structure As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf(T structure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1715">Le type de la <c>structure</c> paramètre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1715">The type of the <c>structure</c> parameter.</span>
          </span>
        </typeparam>
        <param name="structure">
          <span data-ttu-id="37d7d-1716">Objet dont la taille doit être retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1716">The object whose size is to be returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1717">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1717">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1718">Retourne la taille non managée en octets d'un objet d'un type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1718">Returns the unmanaged size of an object of a specified type in bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1719">Taille, en octets, de l'objet spécifié dans le code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1719">The size, in bytes, of the specified object in unmanaged code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1720">Cette méthode accepte une instance d’une structure, ce qui peut être un type référence ou un type valeur boxed.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1720">This method accepts an instance of a structure, which can be a reference type or a boxed value type.</span></span> <span data-ttu-id="37d7d-1721">La disposition doit être séquentielle ou explicite.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1721">The layout must be sequential or explicit.</span></span>  
  
 <span data-ttu-id="37d7d-1722">La taille retournée est la taille de l’objet non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1722">The size returned is the size of the unmanaged object.</span></span> <span data-ttu-id="37d7d-1723">Les tailles managée et non d’un objet peuvent être différent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1723">The unmanaged and managed sizes of an object can differ.</span></span> <span data-ttu-id="37d7d-1724">Pour les types de caractères, la taille est affectée par la <xref:System.Runtime.InteropServices.CharSet> valeur appliqué à cette classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1724">For character types, the size is affected by the <xref:System.Runtime.InteropServices.CharSet> value applied to that class.</span></span>  
  
 <span data-ttu-id="37d7d-1725">Vous pouvez utiliser la <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> méthode pour déterminer la quantité de mémoire non managée à allouer à l’aide de la <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> et <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1725">You can use the <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> method to determine how much unmanaged memory to allocate by using the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> and <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="37d7d-1726">Le paramètre <paramref name="structure" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1726">The <paramref name="structure" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToBSTR (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToBSTR(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1727">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1727">The managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1728">Alloue une chaîne [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) pour y copier le contenu d’un <see cref="T:System.String" /> managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1728">Allocates a [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) and copies the contents of a managed <see cref="T:System.String" /> into it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1729">Pointeur non managé vers le <see langword="BSTR" />, ou 0 si <paramref name="s" /> est null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1729">An unmanaged pointer to the <see langword="BSTR" />, or 0 if <paramref name="s" /> is null.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1730"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1730"><xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1731">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer le `BSTR` lorsque vous avez terminé en appelant <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1731">Because this method allocates the unmanaged memory required for a string, always free the `BSTR` when finished by calling <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-1732">Cette méthode fournit les fonctionnalités opposées de <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1732">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1733">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1733">There is insufficient memory available.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-1734">La longueur de <paramref name="s" /> est hors limites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1734">The length for <paramref name="s" /> is out of range.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1735">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1735">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1736">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1736">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1737">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1737">A managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1738">Copie le contenu d'un <see cref="T:System.String" /> managé dans un bloc de mémoire alloué à partir de l'allocateur de tâche COM non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1738">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1739">Entier représentant un pointeur vers le bloc de mémoire alloué pour la chaîne, ou 0 si <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1739">An integer representing a pointer to the block of memory allocated for the string, or 0 if <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1740"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1740"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1741">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1741">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="37d7d-1742">Cette méthode fournit les fonctionnalités opposées de <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1742">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-1743">Les caractères de la chaîne sont copiés en tant que caractères ANSI.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1743">The characters of the string are copied as ANSI characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1744">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1744">There is insufficient memory available.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-1745">Le paramètre <paramref name="s" /> dépasse la longueur maximale autorisée par le système d'exploitation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1745">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1746">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1746">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1747">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1747">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1748">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1748">A managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1749">Copie le contenu d'un <see cref="T:System.String" /> managé dans un bloc de mémoire alloué à partir de l'allocateur de tâche COM non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1749">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1750">Bloc de mémoire alloué, ou 0 si <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1750">The allocated memory block, or 0 if <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1751"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> est utile pour le marshaling personnalisé ou pour une utilisation lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1751"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1752">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1752">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.</span></span> <span data-ttu-id="37d7d-1753">Cette méthode fournit les fonctionnalités opposées de <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1753">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-1754">Les caractères de la chaîne sont copiés comme des caractères ANSI ou Unicode, en fonction du système d’exploitation sur lequel l’exécution du code.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1754">The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</span></span> <span data-ttu-id="37d7d-1755">Sur Windows 98, les caractères sont copiés en tant que caractères ANSI.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1755">On Windows 98, the characters are copied as ANSI characters.</span></span> <span data-ttu-id="37d7d-1756">Sur Windows NT 4.0, Windows 2000, Windows XP et la famille Windows Server 2003, les caractères sont copiés en tant que caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1756">On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1757">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1757">There is insufficient memory available.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-1758">La longueur de <paramref name="s" /> est hors limites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1758">The length for <paramref name="s" /> is out of range.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1759">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1759">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1760">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1760">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1761">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1761">A managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1762">Copie le contenu d'un <see cref="T:System.String" /> managé dans un bloc de mémoire alloué à partir de l'allocateur de tâche COM non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1762">Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1763">Entier représentant un pointeur vers le bloc de mémoire alloué pour la chaîne, ou 0 si s est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1763">An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1764"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> est utile pour le marshaling personnalisé ou pour une utilisation lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1764"><xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1765">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1765">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-1766">Cette méthode fournit les fonctionnalités opposées de <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1766">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37d7d-1767">Les caractères de la chaîne sont copiés en tant que caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1767">The characters of the string are copied as Unicode characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-1768">Le paramètre <paramref name="s" /> dépasse la longueur maximale autorisée par le système d'exploitation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1768">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1769">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1769">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1770">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1770">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1771">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1771">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToCoTaskMemUTF8 (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToCoTaskMemUTF8(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAnsi (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAnsi(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1772">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1772">A managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1773">Copie le contenu d’un objet <see cref="T:System.String" /> managé dans la mémoire non managée, avec conversion au format ANSI pendant la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1773">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format as it copies.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1774">Adresse, dans la mémoire non managée, où <paramref name="s" /> a été copié, ou 0 si <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1774">The address, in unmanaged memory, to where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1775"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> est utile pour le marshaling personnalisé ou lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1775"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> is useful for custom marshaling or when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1776">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1776">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="37d7d-1777"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> fournit les fonctionnalités inverses de <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1777"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-1778">Cette méthode copie les caractères null incorporés et inclut un caractère null de fin.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1778">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1779">L’exemple suivant montre comment convertir le contenu d’un objet <xref:System.String> classe mémoire non managée, puis libérer de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1779">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1780">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1780">There is insufficient memory available.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-1781">Le paramètre <paramref name="s" /> dépasse la longueur maximale autorisée par le système d'exploitation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1781">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1782">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1782">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1783">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1783">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalAuto (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalAuto(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1784">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1784">A managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1785">Copie le contenu d'un objet <see cref="T:System.String" /> managé dans la mémoire non managée, avec conversion au format ANSI le cas échéant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1785">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format if required.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1786">Adresse, dans la mémoire non managée, où la chaîne a été copiée, ou 0 si <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1786">The address, in unmanaged memory, to where the string was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1787"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> est utile pour le marshaling personnalisé ou pour une utilisation lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1787"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1788">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1788">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="37d7d-1789">Cette méthode fournit les fonctionnalités opposées de <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1789">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-1790">Cette méthode copie les caractères null incorporés et inclut un caractère null de fin.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1790">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1791">L’exemple suivant montre comment convertir le contenu d’un objet <xref:System.String> classe mémoire non managée, puis libérer de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1791">The following example demonstrates how to convert the contents of a managed <xref:System.String> class to unmanaged memory and then dispose of the unmanaged memory when done.</span></span>  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1792">Il n’y a pas suffisamment de mémoire disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1792">There is insufficient memory available.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1793">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1793">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1794">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1794">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StringToHGlobalUni (s As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr StringToHGlobalUni(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-1795">Chaîne managée à copier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1795">A managed string to be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1796">Copie le contenu d'un objet <see cref="T:System.String" /> managé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1796">Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1797">Adresse, dans la mémoire non managée, où <paramref name="s" /> a été copié, ou 0 si <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1797">The address, in unmanaged memory, to where the <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1798"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> est utile pour le marshaling personnalisé ou pour une utilisation lorsque vous mélangez du code managé et non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1798"><xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A> is useful for custom marshaling or for use when mixing managed and unmanaged code.</span></span> <span data-ttu-id="37d7d-1799">Étant donné que cette méthode alloue la mémoire non managée requise pour une chaîne, vous devez toujours libérer la mémoire en appelant <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1799">Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.</span></span> <span data-ttu-id="37d7d-1800">Cette méthode fournit les fonctionnalités opposées de <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1800">This method provides the opposite functionality of <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-1801">Cette méthode copie les caractères null incorporés et inclut un caractère null de fin.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1801">This method copies embedded null characters, and includes a terminating null character.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="37d7d-1802">La méthode n'a pas pu allouer suffisamment de mémoire de tas natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1802">The method could not allocate enough native heap memory.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="37d7d-1803">Le paramètre <paramref name="s" /> dépasse la longueur maximale autorisée par le système d'exploitation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1803">The <paramref name="s" /> parameter exceeds the maximum length allowed by the operating system.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1804">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1804">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1805">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1805">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr (structure As Object, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void StructureToPtr(System::Object ^ structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure">
          <span data-ttu-id="37d7d-1806">Objet managé contenant les données à marshaler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1806">A managed object that holds the data to be marshaled.</span>
          </span>
          <span data-ttu-id="37d7d-1807">Cet objet doit être une structure ou une instance d'une classe mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1807">This object must be a structure or an instance of a formatted class.</span>
          </span>
        </param>
        <param name="ptr">
          <span data-ttu-id="37d7d-1808">Pointeur vers un bloc de mémoire non managée qui doit être alloué avant l'appel de cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1808">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span>
          </span>
        </param>
        <param name="fDeleteOld">
          <span data-ttu-id="37d7d-1809">
            <see langword="true" /> pour appeler la méthode <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> sur le paramètre <c>ptr</c> avant que cette méthode ne copie les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1809">
              <see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method on the <c>ptr</c> parameter before this method copies the data.</span>
          </span>
          <span data-ttu-id="37d7d-1810">Le bloc doit contenir des données valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1810">The block must contain valid data.</span>
          </span>
          <span data-ttu-id="37d7d-1811">Notez que passer <see langword="false" /> lorsque le bloc de mémoire contient déjà des données peut entraîner une fuite de mémoire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1811">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1812">Marshale les données d’un objet managé dans un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1812">Marshals data from a managed object to an unmanaged block of memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1813">Si `structure` est un type valeur, il peut être convertie (boxed) ou unboxed.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1813">If `structure` is a value type, it can be boxed or unboxed.</span></span> <span data-ttu-id="37d7d-1814">Si elle est convertie (boxed), elle est unboxed avant la copie.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1814">If it is boxed, it is unboxed before copying.</span></span>  
  
 <span data-ttu-id="37d7d-1815">Une classe mise en forme est un type de référence dont la disposition est spécifiée par le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut, en tant que <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1815">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-1816"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> copie le contenu de `structure` au bloc de mémoire alloué au préalable que la `ptr` paramètre pointe vers.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1816"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="37d7d-1817">Si `structure` contient des types de référence marshaler des pointeurs d’interface COM (interfaces, classes sans mise en page, et <xref:System.Object?displayProperty=nameWithType>), les objets managés sont maintenues en service avec les nombres de références.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1817">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="37d7d-1818">Tous les autres types de référence (par exemple, les chaînes et les tableaux) sont marshalés vers la copie.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1818">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="37d7d-1819">Pour libérer ces objets gérés ou non gérés, vous devez appeler la <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> méthode avant que vous libérez le bloc de mémoire.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1819">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="37d7d-1820">Si vous utilisez la <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> méthode pour copier une autre instance pour le bloc de mémoire à une date ultérieure, spécifiez `true` pour `fDeleteOld` pour supprimer la référence de compte pour les types de référence dans l’instance précédente.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1820">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="37d7d-1821">Dans le cas contraire, les copies de typesand non managée de référence géré sont efficacement une fuite.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1821">Otherwise, the managed reference typesand unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="37d7d-1822">Le modèle global pour l’utilisation de <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> est comme suit :</span><span class="sxs-lookup"><span data-stu-id="37d7d-1822">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> is as follows:</span></span>  
  
1.  <span data-ttu-id="37d7d-1823">Le premier appel à la <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> méthode après un bloc de mémoire a été alloué, `fDeleteOld` doit être `false`, car il n’y a aucun contenu à effacer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1823">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="37d7d-1824">Spécifiez `true` pour `fDeleteOld` uniquement si le bloc contient des données valides.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1824">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="37d7d-1825">Si vous copiez une autre instance pour le bloc de mémoire, et l’objet contient des types référence, `fDeleteOld` doit être `true` pour libérer des types de référence dans l’ancien contenu.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1825">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="37d7d-1826">Si l’objet contient des types référence, vous devez appeler la <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> méthode avant que vous libérez le bloc de mémoire.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1826">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d7d-1827">Pour épingler une structure existante au lieu de copier, utiliser le <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type pour créer un handle épinglé pour la structure.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1827">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="37d7d-1828">Pour plus d’informations sur la manière d’épingler, consultez [copie et épinglage](~/docs/framework/interop/copying-and-pinning.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1828">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1829">L’exemple suivant crée une structure managée, la transfère à l’aide de la mémoire non managée la <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> (méthode), puis retransfère en mémoire managée à l’aide du <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1829">The following example creates a managed structure, transfers it to unmanaged memory using the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method, and then transfers it back to managed memory using the <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> method.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1830">
            <paramref name="structure" /> est un type référence qui n’est pas une classe mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1830">
              <paramref name="structure" /> is a reference type that is not a formatted class.</span>
          </span>
          <span data-ttu-id="37d7d-1831">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1831">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1832">
            <paramref name="structure" /> est une instance d’un type générique (dans le .NET Framework 4.5 et les versions antérieures uniquement).</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1832">
              <paramref name="structure" /> is an instance of a generic type (in the .NET Framework 4.5 and earlier versions only).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1833">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1833">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1834">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1834">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StructureToPtr(Of T) (structure As T, ptr As IntPtr, fDeleteOld As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1835">Type de l'objet managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1835">The type of the managed object.</span>
          </span>
        </typeparam>
        <param name="structure">
          <span data-ttu-id="37d7d-1836">Objet managé contenant les données à marshaler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1836">A managed object that holds the data to be marshaled.</span>
          </span>
          <span data-ttu-id="37d7d-1837">L'objet doit être une structure ou une instance d'une classe mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1837">The object must be a structure or an instance of a formatted class.</span>
          </span>
        </param>
        <param name="ptr">
          <span data-ttu-id="37d7d-1838">Pointeur vers un bloc de mémoire non managée qui doit être alloué avant l'appel de cette méthode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1838">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</span>
          </span>
        </param>
        <param name="fDeleteOld">
          <span data-ttu-id="37d7d-1839">
            <see langword="true" /> pour appeler la méthode <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> sur le paramètre <c>ptr</c> avant que cette méthode ne copie les données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1839">
              <see langword="true" /> to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> method on the <c>ptr</c> parameter before this method copies the data.</span>
          </span>
          <span data-ttu-id="37d7d-1840">Le bloc doit contenir des données valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1840">The block must contain valid data.</span>
          </span>
          <span data-ttu-id="37d7d-1841">Notez que passer <see langword="false" /> lorsque le bloc de mémoire contient déjà des données peut entraîner une fuite de mémoire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1841">Note that passing <see langword="false" /> when the memory block already contains data can lead to a memory leak.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1842">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1842">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1843">Marshale les données d'un objet managé d'un type spécifié dans un bloc de mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1843">Marshals data from a managed object of a specified type to an unmanaged block of memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1844">Une classe mise en forme est un type de référence dont la disposition est spécifiée par le <xref:System.Runtime.InteropServices.StructLayoutAttribute> d’attribut, en tant que <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1844">A formatted class is a reference type whose layout is specified by the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute, as either <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="37d7d-1845"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> copie le contenu de `structure` au bloc de mémoire alloué au préalable que la `ptr` paramètre pointe vers.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1845"><xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> copies the contents of `structure` to the pre-allocated block of memory that the `ptr` parameter points to.</span></span> <span data-ttu-id="37d7d-1846">Si `structure` contient des types de référence marshaler des pointeurs d’interface COM (interfaces, classes sans mise en page, et <xref:System.Object?displayProperty=nameWithType>), les objets managés sont maintenues en service avec les nombres de références.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1846">If `structure` contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref:System.Object?displayProperty=nameWithType>), the managed objects are kept alive with reference counts.</span></span> <span data-ttu-id="37d7d-1847">Tous les autres types de référence (par exemple, les chaînes et les tableaux) sont marshalés vers la copie.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1847">All other reference types (for example, strings and arrays) are marshaled to copies.</span></span> <span data-ttu-id="37d7d-1848">Pour libérer ces objets gérés ou non gérés, vous devez appeler la <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> méthode avant que vous libérez le bloc de mémoire.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1848">To release these managed or unmanaged objects, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> method before you free the memory block.</span></span>  
  
 <span data-ttu-id="37d7d-1849">Si vous utilisez la <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> méthode pour copier une autre instance pour le bloc de mémoire à une date ultérieure, spécifiez `true` pour `fDeleteOld` pour supprimer la référence de compte pour les types de référence dans l’instance précédente.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1849">If you use the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> method to copy a different instance to the memory block at a later time, specify `true` for `fDeleteOld` to remove reference counts for reference types in the previous instance.</span></span> <span data-ttu-id="37d7d-1850">Dans le cas contraire, les types de référence managée et les copies non gérées sont révélés efficacement.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1850">Otherwise, the managed reference types and unmanaged copies are effectively leaked.</span></span>  
  
 <span data-ttu-id="37d7d-1851">Le modèle global pour l’utilisation de <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> est comme suit :</span><span class="sxs-lookup"><span data-stu-id="37d7d-1851">The overall pattern for using <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> is as follows:</span></span>  
  
1.  <span data-ttu-id="37d7d-1852">Le premier appel à la <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> méthode après un bloc de mémoire a été alloué, `fDeleteOld` doit être `false`, car il n’y a aucun contenu à effacer.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1852">On the first call to the <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> method after a memory block has been allocated, `fDeleteOld` must be `false`, because there are no contents to clear.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="37d7d-1853">Spécifiez `true` pour `fDeleteOld` uniquement si le bloc contient des données valides.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1853">Specify `true` for `fDeleteOld` only if the block contains valid data.</span></span>  
  
2.  <span data-ttu-id="37d7d-1854">Si vous copiez une autre instance pour le bloc de mémoire, et l’objet contient des types référence, `fDeleteOld` doit être `true` pour libérer des types de référence dans l’ancien contenu.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1854">If you copy a different instance to the memory block, and the object contains reference types, `fDeleteOld` must be `true` to free reference types in the old contents.</span></span>  
  
3.  <span data-ttu-id="37d7d-1855">Si l’objet contient des types référence, vous devez appeler la <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> méthode avant que vous libérez le bloc de mémoire.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1855">If the object contains reference types, you must call the <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> method before you free the memory block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="37d7d-1856">Pour épingler une structure existante au lieu de copier, utiliser le <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type pour créer un handle épinglé pour la structure.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1856">To pin an existing structure instead of copying it, use the <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> type to create a pinned handle for the structure.</span></span> <span data-ttu-id="37d7d-1857">Pour plus d’informations sur la manière d’épingler, consultez [copie et épinglage](~/docs/framework/interop/copying-and-pinning.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1857">For details on how to pin, see [Copying and Pinning](~/docs/framework/interop/copying-and-pinning.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1858">
            <paramref name="structure" /> est un type référence qui n’est pas une classe mise en forme.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1858">
              <paramref name="structure" /> is a reference type that is not a formatted class.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1859">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1859">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1860">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1860">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemDefaultCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemDefaultCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1861">Représente la taille de caractère par défaut dans le système ; il s'agit de la valeur 2 pour les systèmes Unicode et de la valeur 1 pour les systèmes ANSI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1861">Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</span>
          </span>
          <span data-ttu-id="37d7d-1862">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1862">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37d7d-1863">L’exemple suivant illustre le <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> champ.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1863">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="37d7d-1864">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1864">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SystemMaxDBCSCharSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int SystemMaxDBCSCharSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1865">Représente la taille maximale, en octets, d'un jeu de caractères à deux octets (DBSC) pour le système d'exploitation actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1865">Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</span>
          </span>
          <span data-ttu-id="37d7d-1866">Ce champ est en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1866">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="37d7d-1867">L’exemple suivant illustre le <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> champ.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1867">The following example demonstrates the <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> field.</span></span> <span data-ttu-id="37d7d-1868">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1868">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ThrowExceptionForHR">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1869">Lève une exception avec une valeur HRESULT d'échec spécifique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1869">Throws an exception with a specific failure HRESULT value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">
          <span data-ttu-id="37d7d-1870">HRESULT correspondant à l'exception souhaitée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1870">The HRESULT corresponding to the desired exception.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1871">Lève une exception avec une valeur HRESULT d'échec spécifique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1871">Throws an exception with a specific failure HRESULT value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1872">Cette méthode crée un objet d’exception pour le HRESULT d’échec spécifié.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1872">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="37d7d-1873">Si la valeur HRESULT est 0 ou une valeur positive (code de réussite), la méthode retourne sans créer ou lever une exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1873">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="37d7d-1874">Notez que la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> méthode retourne une exception basée sur le [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface du thread actuel si elle est définie.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1874">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> method returns an exception based on the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread if one is set.</span></span> <span data-ttu-id="37d7d-1875">Dans ce cas, le `errorCode` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1875">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="37d7d-1876">Certains HRESULT d’échec mappent aux exceptions définies, alors que d’autres ne le font pas.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1876">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="37d7d-1877">Si la valeur HRESULT est mappé à une exception définie, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> crée une instance de l’exception et la lève.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1877">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="37d7d-1878">Dans le cas contraire, il crée une instance de <xref:System.Runtime.InteropServices.COMException>, initialise le champ de code d’erreur avec le HRESULT et lève une exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1878">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="37d7d-1879">Lorsque <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> est appelé, il tente de récupérer des informations supplémentaires concernant l’erreur à l’aide de managée [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) (fonction).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1879">When <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) function.</span></span>  
  
 <span data-ttu-id="37d7d-1880">Pour le mappage de chaque HRESULT à sa classe d’exception comparable dans le .NET Framework, consultez [Comment : mappage HRESULT et des Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1880">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 <span data-ttu-id="37d7d-1881">Parfois, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> peut retourner une exception à partir d’un appel COM précédent.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1881">Occasionally, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> might return an exception from a previous COM call.</span></span> <span data-ttu-id="37d7d-1882">Dans ce cas, vous pouvez utiliser la solution de contournement suivante et passer `IntPtr(-1)` comme deuxième paramètre (`errorInfo`) :</span><span class="sxs-lookup"><span data-stu-id="37d7d-1882">In this case, you can use the following workaround and pass `IntPtr(-1)` as the second parameter (`errorInfo`):</span></span>  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1883">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1883">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1884">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1884">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ThrowExceptionForHR (errorCode As Integer, errorInfo As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">
          <span data-ttu-id="37d7d-1885">HRESULT correspondant à l'exception souhaitée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1885">The HRESULT corresponding to the desired exception.</span>
          </span>
        </param>
        <param name="errorInfo">
          <span data-ttu-id="37d7d-1886">Pointeur vers l’interface [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) qui fournit plus d’informations sur l’erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1886">A pointer to the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface that provides more information about the error.</span>
          </span>
          <span data-ttu-id="37d7d-1887">Spécifiez <c>IntPtr(0)</c> pour utiliser l’interface [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) actuelle ou <c>IntPtr(-1)</c> pour ignorer l’interface [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) actuelle et construire l’exception uniquement à partir du code d’erreur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1887">You can specify <c>IntPtr(0)</c> to use the current [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface, or <c>IntPtr(-1)</c> to ignore the current [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface and construct the exception just from the error code.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1888">Lève une exception avec un HRESULT d’échec spécifique, en fonction de l’interface [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1888">Throws an exception with a specific failure HRESULT, based on the specified [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1889">Cette méthode crée un objet d’exception pour le HRESULT d’échec spécifié.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1889">This method creates an exception object for the specified failure HRESULT.</span></span> <span data-ttu-id="37d7d-1890">Si la valeur HRESULT est 0 ou une valeur positive (code de réussite), la méthode retourne sans créer ou lever une exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1890">If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</span></span>  
  
 <span data-ttu-id="37d7d-1891">Le <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> méthode libère le `errorInfo` paramètre, diminuant le modèle COM référencer nombre de la [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1891">The <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method releases the `errorInfo` parameter, decreasing the COM reference count of the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</span></span>  
  
 <span data-ttu-id="37d7d-1892">Notez que la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> méthode retourne une exception basée sur le [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface du thread actuel si elle est définie.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1892">Note that the <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> method returns an exception based on the [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface of the current thread if one is set.</span></span> <span data-ttu-id="37d7d-1893">Dans ce cas, le `errorCode` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1893">When this happens, the `errorCode` parameter is ignored.</span></span>  
  
 <span data-ttu-id="37d7d-1894">Certains HRESULT d’échec mappent aux exceptions définies, alors que d’autres ne le font pas.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1894">Some failure HRESULTs map to defined exceptions, whereas others do not.</span></span> <span data-ttu-id="37d7d-1895">Si la valeur HRESULT est mappé à une exception définie, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> crée une instance de l’exception et la lève.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1895">If the HRESULT maps to a defined exception, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> creates an instance of the exception and throws it.</span></span> <span data-ttu-id="37d7d-1896">Dans le cas contraire, il crée une instance de <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, initialise le champ de code d’erreur avec le HRESULT et lève une exception.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1896">Otherwise, it creates an instance of <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, initializes the error code field with the HRESULT, and throws that exception.</span></span> <span data-ttu-id="37d7d-1897">Le `errorInfo` paramètre est utilisé pour récupérer des informations supplémentaires concernant l’erreur.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1897">The `errorInfo` parameter is used to retrieve extra information regarding the error.</span></span>  
  
 <span data-ttu-id="37d7d-1898">Pour le mappage de chaque HRESULT à sa classe d’exception comparable dans le .NET Framework, consultez [Comment : mappage HRESULT et des Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="37d7d-1898">For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1899">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1899">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1900">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1900">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.COMException" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement (arr As Array, index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(Array ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">
          <span data-ttu-id="37d7d-1901">Tableau qui contient l'élément souhaité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1901">The array that contains the desired element.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="37d7d-1902">Index dans le paramètre <c>arr</c> de l’élément souhaité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1902">The index in the <c>arr</c> parameter of the desired element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1903">Obtient l'adresse de l'élément à l'index spécifié dans le tableau spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1903">Gets the address of the element at the specified index inside the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1904">Adresse de <paramref name="index" /> dans <paramref name="arr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1904">The address of <paramref name="index" /> inside <paramref name="arr" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1905">Le tableau doit être épinglé à l’aide un <xref:System.Runtime.InteropServices.GCHandle> avant d’être transmis à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1905">The array must be pinned using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="37d7d-1906">Pour optimiser les performances, cette méthode ne valide pas le tableau passé. Cela peut entraîner un comportement inattendu.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1906">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1907">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1907">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1908">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1908">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T) (arr As T(), index As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr UnsafeAddrOfPinnedArrayElement(cli::array &lt;T&gt; ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="37d7d-1909">Type de tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1909">The type of the array.</span>
          </span>
        </typeparam>
        <param name="arr">
          <span data-ttu-id="37d7d-1910">Tableau qui contient l'élément souhaité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1910">The array that contains the desired element.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="37d7d-1911">Index de l’élément souhaité dans le tableau <c>arr</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1911">The index of the desired element in the <c>arr</c> array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1912">[Pris en charge dans le .NET Framework 4.5.1 et versions ultérieures]</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1912">[Supported in the .NET Framework 4.5.1 and later versions]</span>
          </span>
          <span data-ttu-id="37d7d-1913">Obtient l'adresse de l'élément à l'index spécifié dans un tableau du type spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1913">Gets the address of the element at the specified index in an array of a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="37d7d-1914">Adresse de <paramref name="index" /> dans <paramref name="arr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1914">The address of <paramref name="index" /> in <paramref name="arr" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1915">Le tableau doit être épinglé à l’aide un <xref:System.Runtime.InteropServices.GCHandle> avant d’être transmis à cette méthode.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1915">The array must be pinned by using a <xref:System.Runtime.InteropServices.GCHandle> before it is passed to this method.</span></span> <span data-ttu-id="37d7d-1916">Pour optimiser les performances, cette méthode ne valide pas le tableau passé. Cela peut entraîner un comportement inattendu.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1916">For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1917">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1917">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1918">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1918">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteByte">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1919">Écrit une valeur d'octet unique dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1919">Writes a single byte value to unmanaged memory.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1920">Adresse où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1920">The address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1921">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1921">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1922">Écrit une valeur d'octet unique dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1922">Writes a single byte value to unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1923"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> permet une interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1923"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1924">L’exemple suivant crée un bloc de mémoire non managée, écrit un octet dans la mémoire non managée, lit l’octet à partir de la mémoire non managée, puis libère la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1924">The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1925">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1925">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1926">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1926">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1927">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1927">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1928">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1928">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1929">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1929">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1930">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1930">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1931">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1931">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As IntPtr, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(IntPtr ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1932">Adresse de base où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1932">The base address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1933">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1933">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1934">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1934">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1935">Écrit une valeur d'octet unique dans la mémoire non managée à l'offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1935">Writes a single byte value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1936"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> permet une interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1936"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1937">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1937">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1938">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1938">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1939">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1939">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1940">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1940">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteByte (ptr As Object, ofs As Integer, val As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteByte(System::Object ^ ptr, int ofs, System::Byte val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1941">Adresse de base dans la mémoire non managée de l'objet cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1941">The base address in unmanaged memory of the target object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1942">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1942">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1943">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1943">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1944">Écrit une valeur d'octet unique dans la mémoire non managée à l'offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1944">Writes a single byte value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1945"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> permet une interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1945"><xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1946">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1946">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-1947">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1947">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-1948">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1948">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1949">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1949">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1950">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1950">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt16">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-1951">Écrit une valeur d'entier 16 bits signé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1951">Writes a 16-bit signed integer value to unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-1952">L'écriture dans la mémoire non alignée est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1952">Writing to unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1953">Adresse où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1953">The address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1954">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1954">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1955">Écrit un caractère en tant que valeur entière 16 bits dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1955">Writes a character as a 16-bit integer value to unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1956"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1956"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1957">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1957">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1958">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1958">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1959">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1959">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1960">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1960">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1961">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1961">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1962">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1962">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1963">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1963">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1964">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1964">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1965">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1965">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1966">Adresse où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1966">The address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1967">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1967">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1968">Écrit une valeur entière 16 bits dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1968">Writes a 16-bit integer value to unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1969"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1969"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1970">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1970">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1971">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1971">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1972">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1972">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-1973">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1973">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1974">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1974">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-1975">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1975">-or-</span>
          </span>
          <span data-ttu-id="37d7d-1976">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1976">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1977">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1977">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1978">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1978">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1979">Adresse de base où écrire dans le tas natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1979">The base address in the native heap to write to.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1980">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1980">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1981">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1981">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1982">Écrit une valeur entière signée 16 bits dans la mémoire non managée à un offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1982">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1983"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1983"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1984">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1984">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1985">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1985">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1986">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1986">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1987">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1987">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1988">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1988">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As IntPtr, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(IntPtr ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1989">Adresse de base où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1989">The base address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-1990">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1990">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-1991">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1991">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-1992">Écrit une valeur entière signée 16 bits dans la mémoire non managée à l'offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1992">Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-1993"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1993"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-1994">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1994">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-1995">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-1995">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-1996">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1996">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-1997">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1997">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-1998">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1998">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, char val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-1999">Adresse de base dans la mémoire non managée de l'objet cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-1999">The base address in unmanaged memory of the target object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2000">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2000">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2001">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2001">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2002">Écrit une valeur entière signée 16 bits dans la mémoire non managée à un offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2002">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2003"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2003"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2004">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2004">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2005">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2005">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-2006">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2006">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-2007">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2007">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2008">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2008">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2009">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2009">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16 (ptr As Object, ofs As Integer, val As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16(System::Object ^ ptr, int ofs, short val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2010">Adresse de base dans la mémoire non managée de l'objet cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2010">The base address in unmanaged memory of the target object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2011">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2011">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2012">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2012">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2013">Écrit une valeur entière signée 16 bits dans la mémoire non managée à un offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2013">Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2014"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> permet une interaction directe avec un tableau signé 16 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2014"><xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2015">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2015">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2016">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2016">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-2017">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2017">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-2018">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2018">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2019">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2019">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2020">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2020">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-2021">Écrit une valeur d'entier 32 bits signé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2021">Writes a 32-bit signed integer value to unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-2022">L'écriture dans la mémoire non alignée est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2022">Writing to unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2023">Adresse où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2023">The address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2024">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2024">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2025">Écrit une valeur d'entier 32 bits signé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2025">Writes a 32-bit signed integer value to unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2026"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> permet une interaction directe avec un tableau signé 32 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2026"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2027">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2027">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2028">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2028">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2029">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2029">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-2030">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2030">-or-</span>
          </span>
          <span data-ttu-id="37d7d-2031">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2031">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-2032">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2032">-or-</span>
          </span>
          <span data-ttu-id="37d7d-2033">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2033">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2034">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2034">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2035">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2035">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As IntPtr, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(IntPtr ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2036">Adresse de base où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2036">The base address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2037">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2037">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2038">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2038">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2039">Écrit une valeur entière signée 32 bits dans la mémoire non managée à l'offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2039">Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2040"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> permet une interaction directe avec un tableau signé 32 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2040"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2041">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2041">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2042">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2042">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2043">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2043">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2044">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2044">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2045">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2045">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32 (ptr As Object, ofs As Integer, val As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32(System::Object ^ ptr, int ofs, int val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2046">Adresse de base dans la mémoire non managée de l'objet cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2046">The base address in unmanaged memory of the target object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2047">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2047">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2048">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2048">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2049">Écrit une valeur entière signée 32 bits dans la mémoire non managée à un offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2049">Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2050"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> permet une interaction directe avec un tableau signé 32 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2050"><xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2051">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2051">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2052">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2052">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-2053">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2053">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-2054">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2054">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2055">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2055">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2056">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2056">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteInt64">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-2057">Écrit une valeur d'entier 64 bits signé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2057">Writes a 64-bit signed integer value to unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-2058">L'écriture dans la mémoire non alignée est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2058">Writing to unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2059">Adresse où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2059">The address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2060">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2060">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2061">Écrit une valeur d'entier 64 bits signé dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2061">Writes a 64-bit signed integer value to unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2062"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> permet une interaction directe avec un tableau signé 64 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2062"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2063">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2063">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2064">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2064">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2065">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2065">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-2066">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2066">-or-</span>
          </span>
          <span data-ttu-id="37d7d-2067">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2067">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-2068">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2068">-or-</span>
          </span>
          <span data-ttu-id="37d7d-2069">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2069">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2070">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2070">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2071">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2071">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As IntPtr, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(IntPtr ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2072">Adresse de base de la mémoire non managée à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2072">The base address in unmanaged memory to write.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2073">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2073">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2074">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2074">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2075">Écrit une valeur entière signée 64 bits dans la mémoire non managée à un offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2075">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2076"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> permet une interaction directe avec un tableau signé 64 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2076"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2077">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2077">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2078">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2078">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2079">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2079">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2080">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2080">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2081">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2081">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64 (ptr As Object, ofs As Integer, val As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64(System::Object ^ ptr, int ofs, long val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2082">Adresse de base dans la mémoire non managée de l'objet cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2082">The base address in unmanaged memory of the target object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2083">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2083">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2084">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2084">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2085">Écrit une valeur entière signée 64 bits dans la mémoire non managée à un offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2085">Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2086"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> permet une interaction directe avec un tableau signé 64 bits non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2086"><xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2087">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2087">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2088">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2088">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-2089">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2089">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-2090">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2090">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2091">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2091">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2092">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2092">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteIntPtr">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="37d7d-2093">Écrit une valeur entière native dimensionnée par processeur dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2093">Writes a processor native-sized integer value to unmanaged memory.</span>
          </span>
          <span data-ttu-id="37d7d-2094">Les entiers 32 bits sont écrits sur les systèmes 32 bits et les entiers 64 bits sont écrits sur les systèmes 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2094">32-bit integers are written on 32-bit systems, and 64-bit integers are written on 64-bit systems.</span>
          </span>
          <span data-ttu-id="37d7d-2095">L'écriture dans la mémoire non alignée est prise en charge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2095">Writing to unaligned memory locations is supported.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2096">Adresse où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2096">The address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2097">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2097">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2098">Écrit une valeur entière native dimensionnée par processeur dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2098">Writes a processor native sized integer value into unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2099"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> permet une interaction directe avec un type C managé `IntPtr` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2099"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2100">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2100">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2101">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2101">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2102">
            <paramref name="ptr" /> n'est pas un format reconnu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2102">
              <paramref name="ptr" /> is not a recognized format.</span>
          </span>
          <span data-ttu-id="37d7d-2103">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2103">-or-</span>
          </span>
          <span data-ttu-id="37d7d-2104">
            <paramref name="ptr" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2104">
              <paramref name="ptr" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="37d7d-2105">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2105">-or-</span>
          </span>
          <span data-ttu-id="37d7d-2106">
            <paramref name="ptr" /> n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2106">
              <paramref name="ptr" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2107">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2107">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2108">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2108">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As IntPtr, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2109">Adresse de base où écrire dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2109">The base address in unmanaged memory to write to.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2110">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2110">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2111">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2111">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2112">Écrit une valeur entière native dimensionnée par processeur dans la mémoire non managée à l'offset spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2112">Writes a processor native-sized integer value to unmanaged memory at a specified offset.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2113">Cette méthode écrit un entier 32 bits sur les systèmes 32 bits et un entier 64 bits sur les systèmes 64 bits.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2113">This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</span></span>  
  
 <span data-ttu-id="37d7d-2114"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> permet une interaction directe avec un type C managé `IntPtr` tableau, ce qui évite de devoir copier un tableau non managé entier (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2114"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style `IntPtr` array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2115">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2115">Writing to unaligned memory locations is supported.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2116">L’exemple suivant montre comment lire et écrire dans un tableau non managé à l’aide de la <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> et <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2116">The following example demonstrates how to read and write to an unmanaged array using the <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> and <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> methods.</span></span>  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2117">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2117">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2118">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2118">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2119">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2119">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
        <altmember cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteIntPtr (ptr As Object, ofs As Integer, val As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteIntPtr(System::Object ^ ptr, int ofs, IntPtr val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">
          <span data-ttu-id="37d7d-2120">Adresse de base dans la mémoire non managée de l'objet cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2120">The base address in unmanaged memory of the target object.</span>
          </span>
        </param>
        <param name="ofs">
          <span data-ttu-id="37d7d-2121">Offset d’octet supplémentaire, qui est ajouté au paramètre <c>ptr</c> avant l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2121">An additional byte offset, which is added to the <c>ptr</c> parameter before writing.</span>
          </span>
        </param>
        <param name="val">
          <span data-ttu-id="37d7d-2122">Valeur à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2122">The value to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2123">Écrit une valeur entière native dimensionnée par processeur dans la mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2123">Writes a processor native sized integer value to unmanaged memory.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2124"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> permet une interaction directe avec un tableau d’octets de style C non managé, en éliminant la nécessité de copier la totalité d’un tableau non managé (à l’aide de <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) vers un tableau managé distinct avant de définir les valeurs de ses éléments.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2124"><xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) to a separate managed array before setting its element values.</span></span>  
  
 <span data-ttu-id="37d7d-2125">L'écriture dans la mémoire non alignée est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2125">Writing to unaligned memory locations is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="37d7d-2126">L'adresse de base (<paramref name="ptr" />) plus l'octet d'offset (<paramref name="ofs" />) produisent une adresse null ou non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2126">Base address (<paramref name="ptr" />) plus offset byte (<paramref name="ofs" />) produces a null or invalid address.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="37d7d-2127">
            <paramref name="ptr" /> est un objet <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2127">
              <paramref name="ptr" /> is an <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> object.</span>
          </span>
          <span data-ttu-id="37d7d-2128">Cette méthode n'accepte pas les paramètres <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2128">This method does not accept <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parameters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2129">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2129">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2130">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2130">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeBSTR (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeBSTR(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-2131">Adresse du pointeur <see langword="BSTR" /> à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2131">The address of the <see langword="BSTR" /> to free.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2132">Libère un pointeur [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) qui a été alloué à l’aide de la méthode <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2132">Frees a [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2133">Le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> méthode définit le contenu du BSTR sur zéro, puis libère le BSTR.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2133">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> method first sets the contents of the BSTR to zero, and then frees the BSTR.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2134">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2134">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2135">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2135">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-2136">Adresse de la chaîne non managée à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2136">The address of the unmanaged string to free.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2137">Libère un pointeur de chaîne non managé qui a été alloué à l'aide de la méthode <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2137">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2138">Le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> méthode zéro et puis libère la mémoire non managée qui a été allouée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-2138">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2139">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> méthode à marshaler et déchiffrer le contenu d’un <xref:System.Security.SecureString> objet dans un bloc de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2139">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="37d7d-2140">Il utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> méthode à zéro et supprimer le bloc non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2140">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2141">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2141">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2142">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2142">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-2143">Adresse de la chaîne non managée à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2143">The address of the unmanaged string to free.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2144">Libère un pointeur de chaîne non managé qui a été alloué à l'aide de la méthode <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2144">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2145">Le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> méthode zéro et puis libère la mémoire non managée qui a été allouée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-2145">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2146">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2146">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2147">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2147">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeCoTaskMemUTF8 (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeCoTaskMemUTF8(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocAnsi (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocAnsi(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-2148">Adresse de la chaîne non managée à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2148">The address of the unmanaged string to free.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2149">Libère un pointeur de chaîne non managé qui a été alloué à l'aide de la méthode <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2149">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2150">Le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> méthode zéro et puis libère la mémoire non managée qui a été allouée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-2150">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2151">L’exemple suivant utilise le <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> méthode à marshaler et déchiffrer le contenu d’un <xref:System.Security.SecureString> objet dans un bloc de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2151">The following example uses the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> method to marshal and decrypt the contents of a <xref:System.Security.SecureString> object to a block of unmanaged memory.</span></span> <span data-ttu-id="37d7d-2152">Il utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> méthode à zéro et supprimer le bloc non managé.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2152">It then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> method to zero out and dispose the unmanaged block.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2153">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2153">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2154">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2154">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ZeroFreeGlobalAllocUnicode (s As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ZeroFreeGlobalAllocUnicode(IntPtr s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="37d7d-2155">Adresse de la chaîne non managée à libérer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2155">The address of the unmanaged string to free.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="37d7d-2156">Libère un pointeur de chaîne non managé qui a été alloué à l'aide de la méthode <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2156">Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="37d7d-2157">Le <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> méthode zéro et puis libère la mémoire non managée qui a été allouée à l’aide de la <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="37d7d-2157">The <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method first zeros out and then frees unmanaged memory that was allocated using the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="37d7d-2158">L’exemple suivant montre comment utiliser le <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> méthode managée `LogonUser` (fonction) pour effectuer l’emprunt d’identité avec la <xref:System.Security.SecureString> classe.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2158">The following example demonstrates how to use the <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> method with the unmanaged `LogonUser` function to perform impersonation with the <xref:System.Security.SecureString> class.</span></span> <span data-ttu-id="37d7d-2159">L’exemple utilise ensuite la <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> méthode à zéro et libérer la référence de chaîne non managée.</span><span class="sxs-lookup"><span data-stu-id="37d7d-2159">The example then uses the <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> method to zero out and free the unmanaged string reference.</span></span>  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="37d7d-2160">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2160">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="37d7d-2161">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="37d7d-2161">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>