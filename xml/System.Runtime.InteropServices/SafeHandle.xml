<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d62707b9b460c2a6a8386dd68959d7c9d58100ef" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39782263" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ca467-101">Représente une classe wrapper pour des handles de système d'exploitation.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-101">Represents a wrapper class for operating system handles.</span>
      </span>
      <span data-ttu-id="ca467-102">Cette classe doit être héritée.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-102">This class must be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-103">Le <xref:System.Runtime.InteropServices.SafeHandle> classe fournit une finalisation critique des ressources de handle, empêchant les handles d’être récupéré prématurément par le garbage collection et d’être recyclée par Windows pour référencer des objets non managés.</span><span class="sxs-lookup"><span data-stu-id="ca467-103">The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.</span></span>  
  
 <span data-ttu-id="ca467-104">Cette rubrique comporte les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="ca467-104">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="ca467-105">[Pourquoi SafeHandle ?](#Why) </span><span class="sxs-lookup"><span data-stu-id="ca467-105">[Why SafeHandle?](#Why) </span></span>  
 <span data-ttu-id="ca467-106">[Ce que fait SafeHandle](#Does) </span><span class="sxs-lookup"><span data-stu-id="ca467-106">[What SafeHandle does](#Does) </span></span>  
 [<span data-ttu-id="ca467-107">Classes dérivées de SafeHandle</span><span class="sxs-lookup"><span data-stu-id="ca467-107">Classes derived from SafeHandle</span></span>](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a><span data-ttu-id="ca467-108">Pourquoi SafeHandle ?</span><span class="sxs-lookup"><span data-stu-id="ca467-108">Why SafeHandle?</span></span>  
 <span data-ttu-id="ca467-109">Avant .NET Framework version 2.0, du système d’exploitation tous les handles ne peuvent être encapsulés dans le <xref:System.IntPtr> objet de wrapper managé.</span><span class="sxs-lookup"><span data-stu-id="ca467-109">Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object.</span></span> <span data-ttu-id="ca467-110">Cette opération est un moyen pratique d’interagir avec du code natif, les handles pouvaient être divulgués par des exceptions asynchrones, comme un abandon inattendu de thread ou un dépassement de capacité de pile.</span><span class="sxs-lookup"><span data-stu-id="ca467-110">While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.</span></span> <span data-ttu-id="ca467-111">Ces exceptions asynchrones sont un obstacle au nettoyage des ressources de système d’exploitation, et ils peuvent se produire presque n’importe où dans votre application.</span><span class="sxs-lookup"><span data-stu-id="ca467-111">These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.</span></span>  
  
 <span data-ttu-id="ca467-112">Bien que les remplacements pour le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode autoriser le nettoyage des ressources non managées quand un objet est en cours par le garbage collector, dans certaines circonstances, objets finalisables peuvent être récupérées par le garbage collection pendant l’exécution d’une méthode dans une plateforme appeler appel.</span><span class="sxs-lookup"><span data-stu-id="ca467-112">Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.</span></span> <span data-ttu-id="ca467-113">Si un finaliseur libère le handle passé à cette plateforme appel invoke, il risque d’altération du handle.</span><span class="sxs-lookup"><span data-stu-id="ca467-113">If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.</span></span> <span data-ttu-id="ca467-114">Le handle pouvait également être récupéré pendant que votre méthode est bloquée pendant une plateforme d’appel, comme lors de la lecture d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="ca467-114">The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.</span></span>  
  
 <span data-ttu-id="ca467-115">Plus important, étant donné que Windows recycle les handles de manière agressive, un handle peut être recyclé et pointer vers une autre ressource qui peut contenir des données sensibles.</span><span class="sxs-lookup"><span data-stu-id="ca467-115">More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.</span></span> <span data-ttu-id="ca467-116">Cela est appelé une attaque de recyclage et peut potentiellement endommager les données et constituer une menace de sécurité.</span><span class="sxs-lookup"><span data-stu-id="ca467-116">This is known as a recycle attack and can potentially corrupt data and be a security threat.</span></span>  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a><span data-ttu-id="ca467-117">Ce que fait SafeHandle</span><span class="sxs-lookup"><span data-stu-id="ca467-117">What SafeHandle does</span></span>  
 <span data-ttu-id="ca467-118">Le <xref:System.Runtime.InteropServices.SafeHandle> classe simplifie plusieurs de ces problèmes de durée de vie d’objet et est intégré à platform invoke afin que les ressources de système d’exploitation ne sont pas divulguées.</span><span class="sxs-lookup"><span data-stu-id="ca467-118">The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.</span></span> <span data-ttu-id="ca467-119">Le <xref:System.Runtime.InteropServices.SafeHandle> classe résout les problèmes de durée de vie des objets en assignant et en libérant des handles sans interruption.</span><span class="sxs-lookup"><span data-stu-id="ca467-119">The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="ca467-120">Elle contient un finaliseur critique qui garantit que le handle est fermé et son exécution pendant inattendue <xref:System.AppDomain> est déchargé, même dans les cas où l’appel non managé est censé pour être dans un état endommagé.</span><span class="sxs-lookup"><span data-stu-id="ca467-120">It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.</span></span>  
  
 <span data-ttu-id="ca467-121">Étant donné que <xref:System.Runtime.InteropServices.SafeHandle> hérite <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tous les finaliseurs non critiques sont appelés avant les finaliseurs critiques.</span><span class="sxs-lookup"><span data-stu-id="ca467-121">Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers.</span></span> <span data-ttu-id="ca467-122">Les finaliseurs sont appelés sur les objets qui ne sont plus dynamiques durant le même garbage collection.</span><span class="sxs-lookup"><span data-stu-id="ca467-122">The finalizers are called on objects that are no longer live during the same garbage collection pass.</span></span> <span data-ttu-id="ca467-123">Par exemple, un <xref:System.IO.FileStream> objet peut exécuter un finaliseur normal pour nettoyer des données mises en mémoire tampon existantes sans risquer du handle soit divulgué ou recyclé.</span><span class="sxs-lookup"><span data-stu-id="ca467-123">For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.</span></span> <span data-ttu-id="ca467-124">Ce classement très faible entre les finaliseurs critiques et ne vise pas pour une utilisation générale.</span><span class="sxs-lookup"><span data-stu-id="ca467-124">This very weak ordering between critical and noncritical finalizers is not intended for general use.</span></span> <span data-ttu-id="ca467-125">Il existe essentiellement pour faciliter la migration de bibliothèques existantes en leur permettant d’utiliser <xref:System.Runtime.InteropServices.SafeHandle> sans modifier leur sémantique.</span><span class="sxs-lookup"><span data-stu-id="ca467-125">It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics.</span></span> <span data-ttu-id="ca467-126">En outre, le finaliseur critique et tout ce qu’il appelle, telles que le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> (méthode), doit être dans une région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="ca467-126">Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method, must be in a constrained execution region.</span></span> <span data-ttu-id="ca467-127">Cela impose des contraintes sur le code peut être écrit dans le graphique des appels du finaliseur.</span><span class="sxs-lookup"><span data-stu-id="ca467-127">This imposes constraints on what code can be written within the finalizer's call graph.</span></span>  
  
 <span data-ttu-id="ca467-128">Code non managé opérations automatiquement incrémenter le décompte de références de handles encapsulés par un <xref:System.Runtime.InteropServices.SafeHandle> et de décrémentation les à l’achèvement.</span><span class="sxs-lookup"><span data-stu-id="ca467-128">Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion.</span></span> <span data-ttu-id="ca467-129">Cela garantit que le handle ne sera pas recyclé ou fermé de manière inattendue.</span><span class="sxs-lookup"><span data-stu-id="ca467-129">This ensures that the handle will not be recycled or closed unexpectedly.</span></span>  
  
 <span data-ttu-id="ca467-130">Vous pouvez spécifier la propriété du handle sous-jacent lors de la construction <xref:System.Runtime.InteropServices.SafeHandle> objets en fournissant une valeur pour le `ownsHandle` argument dans le <xref:System.Runtime.InteropServices.SafeHandle> constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="ca467-130">You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor.</span></span> <span data-ttu-id="ca467-131">Ce paramètre contrôle si le <xref:System.Runtime.InteropServices.SafeHandle> objet libérera le handle, une fois que l’objet a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ca467-131">This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.</span></span>  <span data-ttu-id="ca467-132">Cela est utile pour les handles aux exigences de la durée de vie particulières ou pour consommer un handle dont durée de vie est contrôlée par quelqu'un d’autre.</span><span class="sxs-lookup"><span data-stu-id="ca467-132">This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.</span></span>  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a><span data-ttu-id="ca467-133">Classes dérivées de SafeHandle</span><span class="sxs-lookup"><span data-stu-id="ca467-133">Classes derived from SafeHandle</span></span>  
 <span data-ttu-id="ca467-134"><xref:System.Runtime.InteropServices.SafeHandle> est une classe wrapper abstraite pour les handles de système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="ca467-134"><xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles.</span></span> <span data-ttu-id="ca467-135">La dérivation de cette classe est difficile.</span><span class="sxs-lookup"><span data-stu-id="ca467-135">Deriving from this class is difficult.</span></span> <span data-ttu-id="ca467-136">Utilisez plutôt les classes dérivées dans l'espace de noms <xref:Microsoft.Win32.SafeHandles> qui fournissent des handles sécurisés pour les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="ca467-136">Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:</span></span>  
  
-   <span data-ttu-id="ca467-137">Fichiers (le <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-137">Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).</span></span>  
  
-   <span data-ttu-id="ca467-138">Fichiers mappés en mémoire (la <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-138">Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).</span></span>  
  
-   <span data-ttu-id="ca467-139">Canaux (la <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-139">Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).</span></span>  
  
-   <span data-ttu-id="ca467-140">Vues de la mémoire (la <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-140">Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).</span></span>  
  
-   <span data-ttu-id="ca467-141">Constructions de chiffrement (le <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).</span><span class="sxs-lookup"><span data-stu-id="ca467-141">Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).</span></span>  
  
-   <span data-ttu-id="ca467-142">Processus (le <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-142">Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).</span></span>  
  
-   <span data-ttu-id="ca467-143">Clés de Registre (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-143">Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).</span></span>  
  
-   <span data-ttu-id="ca467-144">Handles d’attente (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).</span><span class="sxs-lookup"><span data-stu-id="ca467-144">Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca467-145">L’exemple de code suivant crée un handle sécurisé personnalisé pour un handle de fichier de système d’exploitation, dérivant <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span><span class="sxs-lookup"><span data-stu-id="ca467-145">The following code example creates a custom safe handle for an operating system file handle, deriving from <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span></span> <span data-ttu-id="ca467-146">Il lit les octets à partir d’un fichier et affiche leurs valeurs hexadécimales.</span><span class="sxs-lookup"><span data-stu-id="ca467-146">It reads bytes from a file and displays their hexadecimal values.</span></span> <span data-ttu-id="ca467-147">Il contient également un atelier de test des erreurs qui entraîne l’abandon du thread, mais la valeur du handle est libérée.</span><span class="sxs-lookup"><span data-stu-id="ca467-147">It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.</span></span>  <span data-ttu-id="ca467-148">Lorsque vous utilisez un <xref:System.IntPtr> pour représenter des handles, le handle occasionnellement fuit en raison de l’abandon de thread asynchrone.</span><span class="sxs-lookup"><span data-stu-id="ca467-148">When using an <xref:System.IntPtr> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</span></span>  
  
 <span data-ttu-id="ca467-149">Vous devez un fichier texte dans le même dossier que l’application compilée.</span><span class="sxs-lookup"><span data-stu-id="ca467-149">You will need a text file in the same folder as the compiled application.</span></span> <span data-ttu-id="ca467-150">En supposant que vous nommez l’application « HexViewer », l’utilisation de la ligne de commande est :</span><span class="sxs-lookup"><span data-stu-id="ca467-150">Assuming that you name the application "HexViewer", the command line usage is:</span></span>  
  
 `HexViewer <filename> -Fault`  
  
 <span data-ttu-id="ca467-151">Si vous le souhaitez spécifier `-Fault` tente intentionnellement une fuite du handle en abandonnant le thread dans une certaine fenêtre.</span><span class="sxs-lookup"><span data-stu-id="ca467-151">Optionally specify `-Fault` to intentionally attempt to leak the handle by aborting the thread in a certain window.</span></span> <span data-ttu-id="ca467-152">Utilisez l’outil Windows Perform.exe pour surveiller le nombre de handles pendant l’injection d’erreurs.</span><span class="sxs-lookup"><span data-stu-id="ca467-152">Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</span></span>  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="ca467-153">pour la confiance totale pour les héritiers.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-153">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="ca467-154">Ce membre ne peut pas être hérité par du code partiellement fiable.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-154">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="ca467-155">requiert une confiance totale pour l’appelant immédiat.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-155">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="ca467-156">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-156">This member cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <span data-ttu-id="ca467-157">
        <para>Pour créer une classe dérivée de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, vous devez savoir comment créer et libérer un handle de système d’exploitation. Ce processus est différent pour différents types de handles, car certains utilisent le [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) de fonction, tandis que d’autres utilisent des fonctions plus spécifiques, telles que [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) ou [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Pour cette raison, vous devez créer une classe dérivée de <see cref="T:System.Runtime.InteropServices.SafeHandle" /> pour chaque type de handle de système d’exploitation que vous souhaitez inclure dans un wrapper dans un handle sécurisé.  Lorsque vous héritez de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, vous devez substituer les membres suivants : <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> et <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  Vous devez également fournir un constructeur par défaut qui appelle le constructeur de base avec une valeur qui représente une valeur de handle non valide, et un <see cref="T:System.Boolean" /> valeur indiquant si le handle natif est détenu par le <see cref="T:System.Runtime.InteropServices.SafeHandle" /> et doit par conséquent être libéré lorsque qui <see cref="T:System.Runtime.InteropServices.SafeHandle" /> a été supprimé.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="ca467-157">
          <para>To create a class derived from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must know how to create and free an operating system handle. This process is different for different handle types because some use the [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) function, while others use more specific functions such as [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) or [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). For this reason, you must create a derived class of <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for each operating system handle type that you want to wrap in a safe handle.  When you inherit from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must override the following members: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> and <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  You should also provide a default constructor that calls the base constructor with a value that represent an invalid handle value, and a <see cref="T:System.Boolean" /> value indicating whether the native handle is owned by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> and consequently should be freed when that <see cref="T:System.Runtime.InteropServices.SafeHandle" /> has been disposed.</para>
        </span>
      </span>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="ca467-158">Valeur d'un handle non valide (généralement 0 ou -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-158">The value of an invalid handle (usually 0 or -1).</span>
          </span>
          <span data-ttu-id="ca467-159">Votre implémentation de <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> doit retourner <see langword="true" /> pour cette valeur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-159">Your implementation of <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> should return <see langword="true" /> for this value.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="ca467-160">
            <see langword="true" /> pour laisser <see cref="T:System.Runtime.InteropServices.SafeHandle" /> libérer de manière fiable le handle pendant la phase de finalisation ; sinon, <see langword="false" /> (déconseillé).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-160">
              <see langword="true" /> to reliably let <see cref="T:System.Runtime.InteropServices.SafeHandle" /> release the handle during the finalization phase; otherwise, <see langword="false" /> (not recommended).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca467-161">Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> avec la valeur de handle non valide spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-161">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-162">Si le `ownsHandle` paramètre est `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> n’est jamais appelé ; par conséquent, il n’est pas recommandé d’utiliser cette valeur de paramètre comme votre code peut provoquer une fuite de ressources.</span><span class="sxs-lookup"><span data-stu-id="ca467-162">If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="ca467-163">La classe dérivée réside dans un assembly sans autorisation d’accès au code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-163">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="ca467-164">pour la confiance totale pour les héritiers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-164">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="ca467-165">Ce membre ne peut pas être hérité par du code partiellement fiable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-165">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="ca467-166">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-166">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="ca467-167">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-167">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-168">Marque le handle pour libérer des ressources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-168">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-169">Appel de la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode permet aux ressources d’être libérées.</span><span class="sxs-lookup"><span data-stu-id="ca467-169">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="ca467-170">Cela ne se produit pas immédiatement si d’autres threads utilisent le même objet de handle sécurisé, mais aura lieu dès que ce n’est plus le cas.</span><span class="sxs-lookup"><span data-stu-id="ca467-170">This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="ca467-171">Bien que la plupart des classes qui utilisent la <xref:System.Runtime.InteropServices.SafeHandle> classe n’êtes pas obligé de fournir un finaliseur, il est parfois nécessaire (par exemple, pour nettoyer des mémoires tampons de fichiers ou d’écrire des données en retour dans la mémoire).</span><span class="sxs-lookup"><span data-stu-id="ca467-171">Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="ca467-172">Dans ce cas, la classe peut fournir un finaliseur est assuré à exécuter avant le <xref:System.Runtime.InteropServices.SafeHandle> finaliseur critique.</span><span class="sxs-lookup"><span data-stu-id="ca467-172">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="ca467-173">Appelez le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Runtime.InteropServices.SafeHandle> objet.</span><span class="sxs-lookup"><span data-stu-id="ca467-173">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca467-174">Appelez toujours <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> avant de libérer votre dernière référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet.</span><span class="sxs-lookup"><span data-stu-id="ca467-174">Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="ca467-175">Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.InteropServices.SafeHandle> de l'objet <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-175">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-176">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-176">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-177">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-177">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-178">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-178">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <span data-ttu-id="ca467-179">
            <see langword="true" /> si l'incrémentation du compteur de références a réussi ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-179">
              <see langword="true" /> if the reference counter was successfully incremented; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca467-180">Incrémente manuellement le compteur de références sur les instances de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-180">Manually increments the reference counter on <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instances.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-181">Le <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> méthode empêche le common language runtime de récupérer la mémoire utilisée par un handle (ce qui se produit lorsque le runtime appelle le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> méthode).</span><span class="sxs-lookup"><span data-stu-id="ca467-181">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method).</span></span> <span data-ttu-id="ca467-182">Vous pouvez utiliser cette méthode pour incrémenter manuellement le nombre de références sur une <xref:System.Runtime.InteropServices.SafeHandle> instance.</span><span class="sxs-lookup"><span data-stu-id="ca467-182">You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance.</span></span> <span data-ttu-id="ca467-183"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Retourne une valeur booléenne à l’aide un `ref` paramètre (`success`) qui indique si le décompte de références a été incrémenté avec succès.</span><span class="sxs-lookup"><span data-stu-id="ca467-183"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully.</span></span> <span data-ttu-id="ca467-184">Ainsi, votre logique de programme pour revenir en arrière en cas d’échec.</span><span class="sxs-lookup"><span data-stu-id="ca467-184">This allows your program logic to back out in case of failure.</span></span> <span data-ttu-id="ca467-185">Vous devez définir `success` à `false` avant d’appeler <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-185">You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="ca467-186">Si `success` est `true`, éviter les fuites de ressources en faisant correspondre l’appel à <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> avec un appel correspondant à <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-186">If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ca467-187">Cette méthode est destinée aux utilisateurs expérimentés et doit toujours être utilisée avec précaution.</span><span class="sxs-lookup"><span data-stu-id="ca467-187">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="ca467-188">Pour éviter la fuite des ressources de handle, vous devez toujours appeler cette méthode à l’intérieur d’une région d’exécution limitée (CER), où un abandon de thread ne peut pas interrompre le traitement.</span><span class="sxs-lookup"><span data-stu-id="ca467-188">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-189">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-189">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-190">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-190">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-191">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-191">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-192">Retourne la valeur du champ <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-192">Returns the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca467-193">
            <see langword="IntPtr" /> représentant la valeur du champ <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-193">An <see langword="IntPtr" /> representing the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span>
          </span>
          <span data-ttu-id="ca467-194">Si le handle a été marqué comme étant non valide avec <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, cette méthode retourne quand même la valeur de handle d'origine, qui peut être une valeur périmée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-194">If the handle has been marked invalid with <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, this method still returns the original handle value, which can be a stale value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-195">Vous pouvez utiliser cette méthode pour récupérer la valeur de handle réel à partir d’une instance de la <xref:System.Runtime.InteropServices.SafeHandle> classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="ca467-195">You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span> <span data-ttu-id="ca467-196">Cette méthode est nécessaire pour la compatibilité descendante, car de nombreuses propriétés dans le .NET Framework retournent `IntPtr` gérer les types.</span><span class="sxs-lookup"><span data-stu-id="ca467-196">This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types.</span></span> <span data-ttu-id="ca467-197">`IntPtr` types de handle sont spécifiques à la plateforme utilisée pour représenter un pointeur ou un handle.</span><span class="sxs-lookup"><span data-stu-id="ca467-197">`IntPtr` handle types are platform-specific types used to represent a pointer or a handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ca467-198">À l’aide de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> méthode peut présenter des risques de sécurité, car, si le handle a été marqué comme étant non valide avec <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> retourne toujours la valeur de handle d’origine potentiellement périmée.</span><span class="sxs-lookup"><span data-stu-id="ca467-198">Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value.</span></span> <span data-ttu-id="ca467-199">Le handle retourné peut également être recyclé à tout moment.</span><span class="sxs-lookup"><span data-stu-id="ca467-199">The returned handle can also be recycled at any point.</span></span> <span data-ttu-id="ca467-200">Au mieux, cela signifie que le handle peut soudain cesser de fonctionner.</span><span class="sxs-lookup"><span data-stu-id="ca467-200">At best, this means the handle might suddenly stop working.</span></span> <span data-ttu-id="ca467-201">Au pire des cas, si le handle ou la ressource qui représente le handle est exposée au code non fiable, cela peut entraîner une attaque de sécurité de recyclage sur le handle réutilisé ou retourné.</span><span class="sxs-lookup"><span data-stu-id="ca467-201">At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.</span></span> <span data-ttu-id="ca467-202">Par exemple, un appelant non fiable peut interroger des données sur le handle simplement retournées et recevoir des informations pour une ressource non connexe.</span><span class="sxs-lookup"><span data-stu-id="ca467-202">For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.</span></span> <span data-ttu-id="ca467-203">Consultez le <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> et <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthodes pour plus d’informations sur l’utilisation de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> méthode de manière sûre.</span><span class="sxs-lookup"><span data-stu-id="ca467-203">See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-204">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-204">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-205">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-205">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-206">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-206">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-207">Décrémente manuellement le compteur de références sur une instance de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-207">Manually decrements the reference counter on a <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-208">Le <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthode est l’équivalent de <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-208">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="ca467-209">Vous devez toujours faire correspondre un appel à la <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthode avec un appel réussi à <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-209">You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ca467-210">Cette méthode est destinée aux utilisateurs expérimentés et doit toujours être utilisée avec précaution.</span><span class="sxs-lookup"><span data-stu-id="ca467-210">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="ca467-211">Pour éviter la fuite des ressources de handle, vous devez toujours appeler cette méthode à l’intérieur d’une région d’exécution limitée (CER), où un abandon de thread ne peut pas interrompre le traitement.</span><span class="sxs-lookup"><span data-stu-id="ca467-211">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span> <span data-ttu-id="ca467-212">Dans la même façon que sans correspondance <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> appels peuvent provoquer des fuites de ressources, sans correspondance <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> appels peuvent rendre les États de handle non valide devenir visibles à d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="ca467-212">In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads.</span></span> <span data-ttu-id="ca467-213">N’exposez pas <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> appels au code non fiable.</span><span class="sxs-lookup"><span data-stu-id="ca467-213">Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-214">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-214">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-215">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-215">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-216">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-216">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="ca467-217">Libère les ressources utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-217">Releases the resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-218">Libère toutes les ressources utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-218">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-219">Appel de la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode permet aux ressources d’être libérées.</span><span class="sxs-lookup"><span data-stu-id="ca467-219">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="ca467-220">Cela ne se produit pas immédiatement si d’autres threads sont à l’aide de la même instance du handle sécurisé, mais aura lieu dès que ce n’est plus le cas.</span><span class="sxs-lookup"><span data-stu-id="ca467-220">This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="ca467-221">Bien que la plupart des classes à l’aide de <xref:System.Runtime.InteropServices.SafeHandle> n’avez pas besoin de fournir un finaliseur, il est parfois nécessaire (par exemple, pour nettoyer des mémoires tampons de fichiers ou pour écrire des données en mémoire).</span><span class="sxs-lookup"><span data-stu-id="ca467-221">Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="ca467-222">Dans ce cas, elles peuvent fournir un finaliseur est assuré à exécuter avant le <xref:System.Runtime.InteropServices.SafeHandle> finaliseur critique.</span><span class="sxs-lookup"><span data-stu-id="ca467-222">In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="ca467-223">Appelez le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Runtime.InteropServices.SafeHandle> objet.</span><span class="sxs-lookup"><span data-stu-id="ca467-223">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="ca467-224">Le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> méthode laisse le <xref:System.Runtime.InteropServices.SafeHandle> objet dans un état inutilisable.</span><span class="sxs-lookup"><span data-stu-id="ca467-224">The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca467-225">Appelez toujours le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode avant de libérer votre dernière référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet.</span><span class="sxs-lookup"><span data-stu-id="ca467-225">Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="ca467-226">Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.InteropServices.SafeHandle> de l'objet <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-226">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-227">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-227">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-228">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-228">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-229">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="ca467-230">
            <see langword="true" /> pour une opération de suppression normale ; <see langword="false" /> pour finaliser le handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-230">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca467-231">Libère les ressources non managées utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />, en spécifiant s'il faut exécuter une opération de suppression normale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-231">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-232">Vous devez jamais appeler explicitement la <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode avec le `disposing` paramètre défini sur `false`.</span><span class="sxs-lookup"><span data-stu-id="ca467-232">You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-233">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-233">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-234">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-234">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-235">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-235">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-236">Libère toutes les ressources associées au handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-236">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-237">Le <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> méthode est le destructeur de la <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="ca467-237">The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span> <span data-ttu-id="ca467-238">Code d’application ne doit pas appeler cette méthode directement.</span><span class="sxs-lookup"><span data-stu-id="ca467-238">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-239">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-239">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-240">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-240">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-241">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-241">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca467-242">Spécifie le handle à encapsuler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-242">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-243">N’exposez pas le handle publiquement (autrement dit, en dehors de la classe dérivée).</span><span class="sxs-lookup"><span data-stu-id="ca467-243">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca467-244">Obtient une valeur indiquant si le handle est fermé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-244">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ca467-245">
            <see langword="true" /> si le handle est fermé ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-245">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-246">Le <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> méthode retourne une valeur indiquant si le <xref:System.Runtime.InteropServices.SafeHandle> handle de l’objet n’est plus associé à une ressource native.</span><span class="sxs-lookup"><span data-stu-id="ca467-246">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="ca467-247">Cela diffère de la définition de la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété, qui calcule si un handle donné est toujours considéré comme non valide.</span><span class="sxs-lookup"><span data-stu-id="ca467-247">This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="ca467-248">Le <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> méthode retourne un `true` valeur dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="ca467-248">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="ca467-249">Le <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> méthode a été appelée.</span><span class="sxs-lookup"><span data-stu-id="ca467-249">The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="ca467-250">Le <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> méthode a été appelée et il n’existe aucune référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet sur d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="ca467-250">The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-251">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-251">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-252">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-252">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-253">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-253">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ca467-254">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si la valeur du handle n'est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-254">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ca467-255">
            <see langword="true" /> si la valeur du handle n'est pas valide, sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-255">
              <see langword="true" /> if the handle value is invalid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-256">Les classes dérivées doivent implémenter le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété afin que le common language runtime peut déterminer si la finalisation critique est requise.</span><span class="sxs-lookup"><span data-stu-id="ca467-256">Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="ca467-257">Classes dérivées doivent fournir une implémentation appropriée au type général de handle, ils prennent en charge (0 ou -1 n’est pas valide).</span><span class="sxs-lookup"><span data-stu-id="ca467-257">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="ca467-258">Ces classes peuvent ensuite être dérivées davantage pour les types de handles sécurisés spécifiques.</span><span class="sxs-lookup"><span data-stu-id="ca467-258">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="ca467-259">Contrairement à la <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> propriété, qui signale si le <xref:System.Runtime.InteropServices.SafeHandle> objet a fini d’utiliser le handle sous-jacent, le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété calcule si la valeur du handle donné est toujours considéré comme non valide.</span><span class="sxs-lookup"><span data-stu-id="ca467-259">Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="ca467-260">Par conséquent, le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété retourne toujours la même valeur pour n’importe quelle valeur d’un handle.</span><span class="sxs-lookup"><span data-stu-id="ca467-260">Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca467-261">L’exemple suivant vérifie si un fichier a été ouverte avec succès.</span><span class="sxs-lookup"><span data-stu-id="ca467-261">The following example checks if a file was opened successfully.</span></span> <span data-ttu-id="ca467-262">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="ca467-262">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-263">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-263">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-264">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-264">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-265">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-265">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-266">En cas de substitution dans une classe dérivée, exécute le code nécessaire pour libérer le handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-266">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ca467-267">
            <see langword="true" /> si la libération du handle réussit ; sinon, dans le cas d’un échec catastrophique, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-267">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="ca467-268">Dans ce cas, elle génère un Assistant Débogage managé [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-268">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-269">Le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> est garanti que méthode sera appelée qu’une seule fois et uniquement si le handle est valide tel que défini par le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="ca467-269">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property.</span></span> <span data-ttu-id="ca467-270">Implémentez cette méthode dans votre <xref:System.Runtime.InteropServices.SafeHandle> les classes dérivées pour exécuter tout code qui est nécessaire pour libérer le handle.</span><span class="sxs-lookup"><span data-stu-id="ca467-270">Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="ca467-271">Étant donné que l’une des fonctions de <xref:System.Runtime.InteropServices.SafeHandle> consiste à garantir la prévention des fuites de ressources, le code dans votre implémentation de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ne doit jamais échouer.</span><span class="sxs-lookup"><span data-stu-id="ca467-271">Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="ca467-272">Le garbage collector appelle <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> une fois que les finaliseurs normaux ont été exécutés pour les objets qui ont été nettoyées en même temps.</span><span class="sxs-lookup"><span data-stu-id="ca467-272">The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time.</span></span> <span data-ttu-id="ca467-273">Le garbage collector garantit les ressources pour appeler cette méthode et que la méthode ne sera pas interrompue pendant qu’il est en cours.</span><span class="sxs-lookup"><span data-stu-id="ca467-273">The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.</span></span> <span data-ttu-id="ca467-274">Cette méthode sera préparée en tant qu’une région d’exécution limitée (CER) au moment de la construction instance (ainsi que toutes les méthodes dans son graphique des appels pouvant être déterminé statiquement).</span><span class="sxs-lookup"><span data-stu-id="ca467-274">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="ca467-275">Bien que cela empêche les interruptions d’abandon de thread, vous devez toutefois faire attention à ne pas introduire de tous les chemins d’erreur dans votre substituée <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ca467-275">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="ca467-276">En particulier, appliquez le <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> à toute méthode que vous appelez à partir d’attribut <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="ca467-276">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="ca467-277">Dans la plupart des cas, ce code doit être :</span><span class="sxs-lookup"><span data-stu-id="ca467-277">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="ca467-278">En outre, pour le nettoyage simple (par exemple, appeler l’API Win32 `CloseHandle` sur un descripteur de fichier) vous pouvez vérifier la valeur de retour pour l’appel de la plateforme unique.</span><span class="sxs-lookup"><span data-stu-id="ca467-278">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="ca467-279">Pour le nettoyage complexe, vous pouvez avoir beaucoup de logique de programme et de nombreux appels de méthode, certains d'entre eux peuvent échouer.</span><span class="sxs-lookup"><span data-stu-id="ca467-279">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="ca467-280">Vous devez vous assurer que votre logique de programme comporte du code de secours pour chacun de ces cas.</span><span class="sxs-lookup"><span data-stu-id="ca467-280">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="ca467-281">Si <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> retourne `false` pour une raison quelconque, elle génère un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistant Débogage managé.</span><span class="sxs-lookup"><span data-stu-id="ca467-281">If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  <span data-ttu-id="ca467-282">Cela vous permet de détecter les cas où votre tentative de libération de ressources échoue.</span><span class="sxs-lookup"><span data-stu-id="ca467-282">This helps you detect cases where your attempt to release resources fails.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca467-283">L’exemple de code suivant libère le handle et fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="ca467-283">The following code example releases the handle and is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-284">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-284">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-285">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-285">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-286">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-286">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="ca467-287">Handle préexistant à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-287">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ca467-288">Définit le handle au handle préexistant spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-288">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-289">Utilisez le <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> méthode uniquement si vous avez besoin prendre en charge un handle préexistant (par exemple, si le handle est retourné dans une structure), car l’infrastructure d’interopérabilité COM du .NET Framework ne prend pas en charge le marshaling de handles de sortie dans une structure.</span><span class="sxs-lookup"><span data-stu-id="ca467-289">Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-290">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-290">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-291">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-291">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-292">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-292">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ca467-293">Marque un handle comme n'étant plus utilisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-293">Marks a handle as no longer used.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca467-294">Appelez le <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> méthode uniquement lorsque vous savez que votre handle ne référence plus une ressource.</span><span class="sxs-lookup"><span data-stu-id="ca467-294">Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource.</span></span> <span data-ttu-id="ca467-295">Cette opération ne modifie pas la valeur de la <xref:System.Runtime.InteropServices.SafeHandle.handle> champ ; uniquement le handle est marqué comme étant fermé.</span><span class="sxs-lookup"><span data-stu-id="ca467-295">Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed.</span></span> <span data-ttu-id="ca467-296">Le handle peut alors contenir une valeur potentiellement périmée.</span><span class="sxs-lookup"><span data-stu-id="ca467-296">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="ca467-297">L’effet de cet appel est qu’aucune tentative est effectuée pour libérer les ressources.</span><span class="sxs-lookup"><span data-stu-id="ca467-297">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="ca467-298">Comme avec la <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> (méthode), utilisez <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> uniquement si vous avez besoin prendre en charge un handle préexistant.</span><span class="sxs-lookup"><span data-stu-id="ca467-298">As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="ca467-299">pour l’autorisation d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-299">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="ca467-300">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-300">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="ca467-301">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="ca467-301">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>