<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2df2050dc2138073d3f5a6997faff754918bedf1" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51879515" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une classe wrapper pour des handles de système d'exploitation. Cette classe doit être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle> classe fournit une finalisation critique des ressources de handle, empêchant les handles d’être récupéré prématurément par le garbage collection et d’être recyclée par Windows pour référencer des objets non managés.  
  
 Cette rubrique comporte les sections suivantes :  
  
 [Pourquoi SafeHandle ?](#Why)   
 [Ce que fait SafeHandle](#Does)   
 [Classes dérivées de SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Pourquoi SafeHandle ?  
 Avant .NET Framework version 2.0, du système d’exploitation tous les handles ne peuvent être encapsulés dans le <xref:System.IntPtr> objet de wrapper managé. Cette opération est un moyen pratique d’interagir avec du code natif, les handles pouvaient être divulgués par des exceptions asynchrones, comme un abandon inattendu de thread ou un dépassement de capacité de pile. Ces exceptions asynchrones sont un obstacle au nettoyage des ressources de système d’exploitation, et ils peuvent se produire presque n’importe où dans votre application.  
  
 Bien que les remplacements pour le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode autoriser le nettoyage des ressources non managées quand un objet est en cours par le garbage collector, dans certaines circonstances, objets finalisables peuvent être récupérées par le garbage collection pendant l’exécution d’une méthode dans une plateforme appeler appel. Si un finaliseur libère le handle passé à cette plateforme appel invoke, il risque d’altération du handle. Le handle pouvait également être récupéré pendant que votre méthode est bloquée pendant une plateforme d’appel, comme lors de la lecture d’un fichier.  
  
 Plus important, étant donné que Windows recycle les handles de manière agressive, un handle peut être recyclé et pointer vers une autre ressource qui peut contenir des données sensibles. Cela est appelé une attaque de recyclage et peut potentiellement endommager les données et constituer une menace de sécurité.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Ce que fait SafeHandle  
 Le <xref:System.Runtime.InteropServices.SafeHandle> classe simplifie plusieurs de ces problèmes de durée de vie d’objet et est intégré à platform invoke afin que les ressources de système d’exploitation ne sont pas divulguées. Le <xref:System.Runtime.InteropServices.SafeHandle> classe résout les problèmes de durée de vie des objets en assignant et en libérant des handles sans interruption. Elle contient un finaliseur critique qui garantit que le handle est fermé et son exécution pendant inattendue <xref:System.AppDomain> est déchargé, même dans les cas où l’appel non managé est censé pour être dans un état endommagé.  
  
 Étant donné que <xref:System.Runtime.InteropServices.SafeHandle> hérite <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tous les finaliseurs non critiques sont appelés avant les finaliseurs critiques. Les finaliseurs sont appelés sur les objets qui ne sont plus dynamiques durant le même garbage collection. Par exemple, un <xref:System.IO.FileStream> objet peut exécuter un finaliseur normal pour nettoyer des données mises en mémoire tampon existantes sans risquer du handle soit divulgué ou recyclé. Ce classement très faible entre les finaliseurs critiques et ne vise pas pour une utilisation générale. Il existe essentiellement pour faciliter la migration de bibliothèques existantes en leur permettant d’utiliser <xref:System.Runtime.InteropServices.SafeHandle> sans modifier leur sémantique. En outre, le finaliseur critique et tout ce qu’il appelle, telles que le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> (méthode), doit être dans une région d’exécution limitée. Cela impose des contraintes sur le code peut être écrit dans le graphique des appels du finaliseur.  
  
 Code non managé opérations automatiquement incrémenter le décompte de références de handles encapsulés par un <xref:System.Runtime.InteropServices.SafeHandle> et de décrémentation les à l’achèvement. Cela garantit que le handle ne sera pas recyclé ou fermé de manière inattendue.  
  
 Vous pouvez spécifier la propriété du handle sous-jacent lors de la construction <xref:System.Runtime.InteropServices.SafeHandle> objets en fournissant une valeur pour le `ownsHandle` argument dans le <xref:System.Runtime.InteropServices.SafeHandle> constructeur de classe. Ce paramètre contrôle si le <xref:System.Runtime.InteropServices.SafeHandle> objet libérera le handle, une fois que l’objet a été supprimé.  Cela est utile pour les handles aux exigences de la durée de vie particulières ou pour consommer un handle dont durée de vie est contrôlée par quelqu'un d’autre.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Classes dérivées de SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> est une classe wrapper abstraite pour les handles de système d’exploitation. La dérivation de cette classe est difficile. Utilisez plutôt les classes dérivées dans l'espace de noms <xref:Microsoft.Win32.SafeHandles> qui fournissent des handles sécurisés pour les éléments suivants :  
  
-   Fichiers (le <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).  
  
-   Fichiers mappés en mémoire (la <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).  
  
-   Canaux (la <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).  
  
-   Vues de la mémoire (la <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).  
  
-   Constructions de chiffrement (le <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).  
  
-   Processus (le <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).  
  
-   Clés de Registre (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).  
  
-   Handles d’attente (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).  
  
   
  
## Examples  
 L’exemple de code suivant crée un handle sécurisé personnalisé pour un handle de fichier de système d’exploitation, dérivant <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Il lit les octets à partir d’un fichier et affiche leurs valeurs hexadécimales. Il contient également un atelier de test des erreurs qui entraîne l’abandon du thread, mais la valeur du handle est libérée.  Lorsque vous utilisez un <xref:System.IntPtr> pour représenter des handles, le handle occasionnellement fuit en raison de l’abandon de thread asynchrone.  
  
 Vous devez un fichier texte dans le même dossier que l’application compilée. En supposant que vous nommez l’application « HexViewer », l’utilisation de la ligne de commande est :  
  
 `HexViewer <filename> -Fault`  
  
 Si vous le souhaitez spécifier `-Fault` tente intentionnellement une fuite du handle en abandonnant le thread dans une certaine fenêtre. Utilisez l’outil Windows Perfmon.exe pour surveiller le nombre de handles pendant l’injection d’erreurs.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Ce membre ne peut pas être hérité par du code partiellement fiable.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
    <block subset="none" type="overrides"><para>Pour créer une classe dérivée de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, vous devez savoir comment créer et libérer un handle de système d’exploitation. Ce processus est différent pour différents types de handles, car certains utilisent le [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) de fonction, tandis que d’autres utilisent des fonctions plus spécifiques, telles que [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) ou [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Pour cette raison, vous devez créer une classe dérivée de <see cref="T:System.Runtime.InteropServices.SafeHandle" /> pour chaque type de handle de système d’exploitation que vous souhaitez inclure dans un wrapper dans un handle sécurisé.  
  
Lorsque vous héritez de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, vous devez substituer les membres suivants : <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> et <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
Vous devez également fournir un constructeur par défaut qui appelle le constructeur de base avec une valeur qui représente une valeur de handle non valide, et un <see cref="T:System.Boolean" /> valeur indiquant si le handle natif est détenu par le <see cref="T:System.Runtime.InteropServices.SafeHandle" /> et doit par conséquent être libéré lorsque qui <see cref="T:System.Runtime.InteropServices.SafeHandle" /> a été supprimé.</para></block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Valeur d'un handle non valide (généralement 0 ou -1).  Votre implémentation de <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> doit retourner <see langword="true" /> pour cette valeur.</param>
        <param name="ownsHandle"><see langword="true" /> pour laisser <see cref="T:System.Runtime.InteropServices.SafeHandle" /> libérer de manière fiable le handle pendant la phase de finalisation ; sinon, <see langword="false" /> (déconseillé).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> avec la valeur de handle non valide spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `ownsHandle` paramètre est `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> n’est jamais appelé ; par conséquent, il n’est pas recommandé d’utiliser cette valeur de paramètre comme votre code peut provoquer une fuite de ressources.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">La classe dérivée réside dans un assembly sans autorisation d’accès au code non managé.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Ce membre ne peut pas être hérité par du code partiellement fiable.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marque le handle pour libérer des ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode permet aux ressources d’être libérées. Cela ne se produit pas immédiatement si d’autres threads utilisent le même objet de handle sécurisé, mais aura lieu dès que ce n’est plus le cas. Bien que la plupart des classes qui utilisent la <xref:System.Runtime.InteropServices.SafeHandle> classe n’êtes pas obligé de fournir un finaliseur, il est parfois nécessaire (par exemple, pour nettoyer des mémoires tampons de fichiers ou d’écrire des données en retour dans la mémoire). Dans ce cas, la classe peut fournir un finaliseur est assuré à exécuter avant le <xref:System.Runtime.InteropServices.SafeHandle> finaliseur critique.  
  
 Appelez le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Runtime.InteropServices.SafeHandle> objet.  
  
> [!NOTE]
>  Appelez toujours <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> avant de libérer votre dernière référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.InteropServices.SafeHandle> de l'objet <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success"><see langword="true" /> si l'incrémentation du compteur de références a réussi ; sinon, <see langword="false" />.</param>
        <summary>Incrémente manuellement le compteur de références sur les instances de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> méthode empêche le common language runtime de récupérer la mémoire utilisée par un handle (ce qui se produit lorsque le runtime appelle le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> méthode). Vous pouvez utiliser cette méthode pour incrémenter manuellement le nombre de références sur une <xref:System.Runtime.InteropServices.SafeHandle> instance. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Retourne une valeur booléenne à l’aide un `ref` paramètre (`success`) qui indique si le décompte de références a été incrémenté avec succès. Ainsi, votre logique de programme pour revenir en arrière en cas d’échec. Vous devez définir `success` à `false` avant d’appeler <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Si `success` est `true`, éviter les fuites de ressources en faisant correspondre l’appel à <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> avec un appel correspondant à <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Cette méthode est destinée aux utilisateurs expérimentés et doit toujours être utilisée avec précaution. Pour éviter la fuite des ressources de handle, vous devez toujours appeler cette méthode à l’intérieur d’une région d’exécution limitée (CER), où un abandon de thread ne peut pas interrompre le traitement.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la valeur du champ <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns><see langword="IntPtr" /> représentant la valeur du champ <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Si le handle a été marqué comme étant non valide avec <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, cette méthode retourne quand même la valeur de handle d'origine, qui peut être une valeur périmée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour récupérer la valeur de handle réel à partir d’une instance de la <xref:System.Runtime.InteropServices.SafeHandle> classe dérivée. Cette méthode est nécessaire pour la compatibilité descendante, car de nombreuses propriétés dans le .NET Framework retournent `IntPtr` gérer les types. `IntPtr` types de handle sont spécifiques à la plateforme utilisée pour représenter un pointeur ou un handle.  
  
> [!CAUTION]
>  À l’aide de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> méthode peut présenter des risques de sécurité, car, si le handle a été marqué comme étant non valide avec <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> retourne toujours la valeur de handle d’origine potentiellement périmée. Le handle retourné peut également être recyclé à tout moment. Au mieux, cela signifie que le handle peut soudain cesser de fonctionner. Au pire des cas, si le handle ou la ressource qui représente le handle est exposée au code non fiable, cela peut entraîner une attaque de sécurité de recyclage sur le handle réutilisé ou retourné. Par exemple, un appelant non fiable peut interroger des données sur le handle simplement retournées et recevoir des informations pour une ressource non connexe. Consultez le <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> et <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthodes pour plus d’informations sur l’utilisation de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> méthode de manière sûre.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décrémente manuellement le compteur de références sur une instance de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthode est l’équivalent de <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Vous devez toujours faire correspondre un appel à la <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthode avec un appel réussi à <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Cette méthode est destinée aux utilisateurs expérimentés et doit toujours être utilisée avec précaution. Pour éviter la fuite des ressources de handle, vous devez toujours appeler cette méthode à l’intérieur d’une région d’exécution limitée (CER), où un abandon de thread ne peut pas interrompre le traitement. Dans la même façon que sans correspondance <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> appels peuvent provoquer des fuites de ressources, sans correspondance <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> appels peuvent rendre les États de handle non valide devenir visibles à d’autres threads. N’exposez pas <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> appels au code non fiable.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode permet aux ressources d’être libérées. Cela ne se produit pas immédiatement si d’autres threads sont à l’aide de la même instance du handle sécurisé, mais aura lieu dès que ce n’est plus le cas. Bien que la plupart des classes à l’aide de <xref:System.Runtime.InteropServices.SafeHandle> n’avez pas besoin de fournir un finaliseur, il est parfois nécessaire (par exemple, pour nettoyer des mémoires tampons de fichiers ou pour écrire des données en mémoire). Dans ce cas, elles peuvent fournir un finaliseur est assuré à exécuter avant le <xref:System.Runtime.InteropServices.SafeHandle> finaliseur critique.  
  
 Appelez le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Runtime.InteropServices.SafeHandle> objet. Le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> méthode laisse le <xref:System.Runtime.InteropServices.SafeHandle> objet dans un état inutilisable.  
  
> [!NOTE]
>  Appelez toujours le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode avant de libérer votre dernière référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.InteropServices.SafeHandle> de l'objet <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour une opération de suppression normale ; <see langword="false" /> pour finaliser le handle.</param>
        <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />, en spécifiant s’il faut exécuter une opération de suppression normale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez jamais appeler explicitement la <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode avec le `disposing` paramètre défini sur `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources associées au handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> méthode est le destructeur de la <xref:System.Runtime.InteropServices.SafeHandle> classe. Code d’application ne doit pas appeler cette méthode directement.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le handle à encapsuler.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’exposez pas le handle publiquement (autrement dit, en dehors de la classe dérivée).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le handle est fermé.</summary>
        <value><see langword="true" /> si le handle est fermé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> méthode retourne une valeur indiquant si le <xref:System.Runtime.InteropServices.SafeHandle> handle de l’objet n’est plus associé à une ressource native. Cela diffère de la définition de la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété, qui calcule si un handle donné est toujours considéré comme non valide. Le <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> méthode retourne un `true` valeur dans les cas suivants :  
  
-   Le <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> méthode a été appelée.  
  
-   Le <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> méthode a été appelée et il n’existe aucune référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet sur d’autres threads.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si la valeur du handle n'est pas valide.</summary>
        <value><see langword="true" /> si la valeur du handle n'est pas valide, sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées doivent implémenter le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété afin que le common language runtime peut déterminer si la finalisation critique est requise. Classes dérivées doivent fournir une implémentation appropriée au type général de handle, ils prennent en charge (0 ou -1 n’est pas valide). Ces classes peuvent ensuite être dérivées davantage pour les types de handles sécurisés spécifiques.  
  
 Contrairement à la <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> propriété, qui signale si le <xref:System.Runtime.InteropServices.SafeHandle> objet a fini d’utiliser le handle sous-jacent, le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété calcule si la valeur du handle donné est toujours considéré comme non valide. Par conséquent, le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété retourne toujours la même valeur pour n’importe quelle valeur d’un handle.  
  
   
  
## Examples  
 L’exemple suivant vérifie si un fichier a été ouverte avec succès. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, exécute le code nécessaire pour libérer le handle.</summary>
        <returns><see langword="true" /> si la libération du handle réussit ; sinon, dans le cas d’un échec catastrophique, <see langword="false" />. Dans ce cas, elle génère un Assistant Débogage managé <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> est garanti que méthode sera appelée qu’une seule fois et uniquement si le handle est valide tel que défini par le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété. Implémentez cette méthode dans votre <xref:System.Runtime.InteropServices.SafeHandle> les classes dérivées pour exécuter tout code qui est nécessaire pour libérer le handle. Étant donné que l’une des fonctions de <xref:System.Runtime.InteropServices.SafeHandle> consiste à garantir la prévention des fuites de ressources, le code dans votre implémentation de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ne doit jamais échouer. Le garbage collector appelle <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> une fois que les finaliseurs normaux ont été exécutés pour les objets qui ont été nettoyées en même temps. Le garbage collector garantit les ressources pour appeler cette méthode et que la méthode ne sera pas interrompue pendant qu’il est en cours. Cette méthode sera préparée en tant qu’une région d’exécution limitée (CER) au moment de la construction instance (ainsi que toutes les méthodes dans son graphique des appels pouvant être déterminé statiquement). Bien que cela empêche les interruptions d’abandon de thread, vous devez toutefois faire attention à ne pas introduire de tous les chemins d’erreur dans votre substituée <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (méthode). En particulier, appliquez le <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> à toute méthode que vous appelez à partir d’attribut <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. Dans la plupart des cas, ce code doit être :  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 En outre, pour le nettoyage simple (par exemple, appeler l’API Win32 `CloseHandle` sur un descripteur de fichier) vous pouvez vérifier la valeur de retour pour l’appel de la plateforme unique. Pour le nettoyage complexe, vous pouvez avoir beaucoup de logique de programme et de nombreux appels de méthode, certains d'entre eux peuvent échouer. Vous devez vous assurer que votre logique de programme comporte du code de secours pour chacun de ces cas.  
  
 Si <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> retourne `false` pour une raison quelconque, elle génère un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistant Débogage managé.  Cela vous permet de détecter les cas où votre tentative de libération de ressources échoue.  
  
   
  
## Examples  
 L’exemple de code suivant libère le handle et fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c">Diagnostic des erreurs d’exécution avec les Assistants Débogage managé</related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51">releaseHandleFailed</related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Handle préexistant à utiliser.</param>
        <summary>Définit le handle au handle préexistant spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> méthode uniquement si vous avez besoin prendre en charge un handle préexistant (par exemple, si le handle est retourné dans une structure), car l’infrastructure d’interopérabilité COM du .NET Framework ne prend pas en charge le marshaling de handles de sortie dans une structure.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marque un handle comme n'étant plus utilisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> méthode uniquement lorsque vous savez que votre handle ne référence plus une ressource. Cette opération ne modifie pas la valeur de la <xref:System.Runtime.InteropServices.SafeHandle.handle> champ ; uniquement le handle est marqué comme étant fermé. Le handle peut alors contenir une valeur potentiellement périmée. L’effet de cet appel est qu’aucune tentative est effectuée pour libérer les ressources.  
  
 Comme avec la <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> (méthode), utilisez <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> uniquement si vous avez besoin prendre en charge un handle préexistant.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>