<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c4334868cde5130ed9da65bfda7e798c24b12cd" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480623" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une classe wrapper pour des handles de système d'exploitation. Cette classe doit être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.InteropServices.SafeHandle> classe fournit une finalisation critique des ressources de handle, empêchant les handles d’être récupéré prématurément par le garbage collection et d’être recyclé par Windows pour faire référence à des objets non managés.  
  
 Cette rubrique comporte les sections suivantes :  
  
 [Pourquoi SafeHandle ?](#Why)   
 [Ce que fait SafeHandle](#Does)   
 [Classes dérivées de SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Pourquoi SafeHandle ?  
 Avant le .NET Framework version 2.0, du système d’exploitation tous les handles ne peuvent être encapsulés dans le <xref:System.IntPtr> objet de wrapper managé. Alors que c’était un moyen pratique d’interagir avec le code natif, handles pourraient être divulguées par des exceptions asynchrones, comme un abandon inattendu de thread ou d’un débordement de pile. Ces exceptions asynchrones constituent un obstacle au nettoyage des ressources du système d’exploitation, et ils peuvent se produire presque n’importe où dans votre application.  
  
 Bien que les remplacements pour le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode autoriser le nettoyage des ressources non managées lorsqu’un objet est en cours par le garbage collector, dans certains cas, objets finalisables peuvent être récupérées par le garbage collection pendant l’exécution d’une méthode sur une plate-forme de code non managé appel. Si un finaliseur libère le handle passé à cette plateforme appel de code, elle peut aboutir à l’altération du handle. Le handle peut également être récupéré pendant que votre méthode est bloquée pendant une plateforme appel, comme lors de la lecture d’un fichier.  
  
 Plus important, étant donné que Windows recycle les handles de manière agressive, un handle peut être recyclé et pointer vers une autre ressource qui peut contenir des données sensibles. Il s’agit comme une attaque de recyclage et peut potentiellement endommager les données, une menace de sécurité.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>Ce que fait SafeHandle  
 La <xref:System.Runtime.InteropServices.SafeHandle> classe simplifie plusieurs de ces problèmes de durée de vie des objets et est intégré à la plate-forme appeler de sorte que les ressources du système d’exploitation ne soient pas diffusées. La <xref:System.Runtime.InteropServices.SafeHandle> classe résout les problèmes de durée de vie des objets en assignant et en libérant des handles sans interruption. Elle contient un finaliseur critique qui garantit que le handle est fermé et qu’il est garanti pour s’exécuter pendant inattendue <xref:System.AppDomain> décharge, même dans les cas où l’appel de la plateforme est censé pour être dans un état endommagé.  
  
 Étant donné que <xref:System.Runtime.InteropServices.SafeHandle> hérite <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, tous les finaliseurs non critiques sont appelés avant les finaliseurs critiques. Les finaliseurs sont appelés sur les objets qui ne sont plus actives durant le même garbage collection. Par exemple, un <xref:System.IO.FileStream> objet peut exécuter un finaliseur normal pour nettoyer les données mises en mémoire tampon existantes sans risquer du handle soit divulgué ou recyclé. Ce classement très subtil entre les finaliseurs critiques et n’est pas destiné pour une utilisation générale. Il existe principalement pour faciliter la migration de bibliothèques existantes en leur permettant d’utiliser <xref:System.Runtime.InteropServices.SafeHandle> sans modifier leur sémantique. En outre, le finaliseur critique et tout ce qu’il appelle, telles que la <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> méthode, doit être dans une région d’exécution limitée. Cela impose des contraintes sur le code qui peut être écrites dans le graphique des appels du finaliseur.  
  
 Appel de plateforme opérations automatiquement incrémenter le décompte de références de handles encapsulés par un <xref:System.Runtime.InteropServices.SafeHandle> et les décrémentent à l’achèvement. Cela garantit que le handle ne sera pas recyclé ou fermé de manière inattendue.  
  
 Vous pouvez spécifier la propriété du handle sous-jacent lors de la construction <xref:System.Runtime.InteropServices.SafeHandle> objets en fournissant une valeur pour le `ownsHandle` argument dans le <xref:System.Runtime.InteropServices.SafeHandle> constructeur de classe. Ce paramètre détermine si le <xref:System.Runtime.InteropServices.SafeHandle> objet libérera le handle après l’objet a été supprimé.  Cela est utile pour les handles avec des spécifications de durée de vie particulières ou pour consommer un handle dont durée de vie est contrôlée par une autre personne.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Classes dérivées de SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle> est une classe wrapper abstraite pour les handles de système d’exploitation. La dérivation de cette classe est difficile. Utilisez plutôt les classes dérivées dans l'espace de noms <xref:Microsoft.Win32.SafeHandles> qui fournissent des handles sécurisés pour les éléments suivants :  
  
-   Fichiers (le <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).  
  
-   Fichiers mappés en mémoire (la <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).  
  
-   Canaux (la <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).  
  
-   Vues de la mémoire (la <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).  
  
-   Constructions de chiffrement (le <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).  
  
-   Processus (la <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).  
  
-   Clés de Registre (la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).  
  
-   Handles d’attente (la <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).  
  
   
  
## Examples  
 L’exemple de code suivant crée un handle sécurisé personnalisé pour un handle de fichier de système d’exploitation, qui dérivent de <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Il lit les octets à partir d’un fichier et affiche leurs valeurs hexadécimales. Il contient également un atelier de test des erreurs qui entraîne l’abandon du thread, mais la valeur du handle est libérée.  Lorsque vous utilisez un <xref:System.IntPtr> pour représenter des handles, le handle est parfois une fuite en raison de l’abandon de thread asynchrone.  
  
 Vous devez un fichier texte dans le même dossier que l’application compilée. En supposant que vous nommez l’application « HexViewer », l’utilisation de la ligne de commande est :  
  
 `HexViewer <filename> -Fault`  
  
 Si vous le souhaitez spécifier `-Fault` pour tenter une fuite du handle en abandonnant le thread dans une certaine fenêtre. Utilisez l’outil Windows Perform.exe pour surveiller le nombre de handles pendant l’injection d’erreurs.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers de. Ce membre ne peut pas être hérité par du code partiellement fiable.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
    <block subset="none" type="overrides">
      <para>Pour créer une classe dérivée de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, vous devez savoir comment créer et libérer un handle de système d’exploitation. Ce processus est différent pour différents types de handles, car certains utilisent le [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) de fonction, tandis que d’autres utilisent des fonctions plus spécifiques, telles que [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) ou [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Pour cette raison, vous devez créer une classe dérivée de <see cref="T:System.Runtime.InteropServices.SafeHandle" /> pour chaque type de handle de système d’exploitation que vous souhaitez inclure dans un wrapper dans un handle sécurisé.  
  
 Lorsque vous héritez de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, vous devez substituer les membres suivants : <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> et <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
 Vous devez également fournir un constructeur par défaut qui appelle le constructeur de base avec une valeur qui représente une valeur de handle non valide, et un <see cref="T:System.Boolean" /> valeur indiquant si le handle natif est détenu par le <see cref="T:System.Runtime.InteropServices.SafeHandle" /> et doit par conséquent être libéré lorsque qui <see cref="T:System.Runtime.InteropServices.SafeHandle" /> a été supprimé.</para>
    </block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">Valeur d'un handle non valide (généralement 0 ou -1).  Votre implémentation de <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> doit retourner <see langword="true" /> pour cette valeur.</param>
        <param name="ownsHandle">
          <see langword="true" /> pour laisser <see cref="T:System.Runtime.InteropServices.SafeHandle" /> libérer de manière fiable le handle pendant la phase de finalisation ; sinon, <see langword="false" /> (déconseillé).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> avec la valeur de handle non valide spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `ownsHandle` paramètre est `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> n’est jamais appelé ; par conséquent, il n’est pas recommandé d’utiliser cette valeur de paramètre que votre code peut entraîner une fuite de ressources.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">La classe dérivée réside dans un assembly sans autorisation d’accès au code non managé.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers de. Ce membre ne peut pas être hérité par du code partiellement fiable.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marque le handle pour libérer des ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode permet aux ressources d’être libérées. Cela ne se produit pas immédiatement si d’autres threads utilisent le même objet de handle sécurisé, mais aura lieu dès que ce n’est plus le cas. Bien que la plupart des classes qui utilisent la <xref:System.Runtime.InteropServices.SafeHandle> classe n’avez pas besoin de fournir un finaliseur, il est parfois nécessaire (par exemple, pour vider les mémoires tampons de fichiers ou d’écrire des données en retour dans la mémoire). Dans ce cas, la classe peut fournir un finaliseur est garanti avant le <xref:System.Runtime.InteropServices.SafeHandle> finaliseur critique.  
  
 Appelez le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Runtime.InteropServices.SafeHandle> objet.  
  
> [!NOTE]
>  Appelez toujours <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> avant de libérer votre dernière référence à le <xref:System.Runtime.InteropServices.SafeHandle> objet. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.InteropServices.SafeHandle> de l'objet <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <see langword="true" /> si l'incrémentation du compteur de références a réussi ; sinon, <see langword="false" />.</param>
        <summary>Incrémente manuellement le compteur de références sur les instances de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> méthode empêche le common language runtime de récupérer la mémoire utilisée par un handle (ce qui se produit lorsque le runtime appelle la <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> méthode). Vous pouvez utiliser cette méthode pour incrémenter manuellement le décompte de références sur une <xref:System.Runtime.InteropServices.SafeHandle> instance. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Retourne une valeur booléenne à l’aide un `ref` paramètre (`success`) qui indique si le décompte de références a été incrémenté avec succès. Ainsi, votre logique de programme revenir en arrière en cas d’échec. Vous devez définir `success` à `false` avant d’appeler <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Si `success` est `true`, éviter les fuites de ressources en faisant correspondre l’appel à <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> avec un appel correspondant à <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Cette méthode est destinée aux utilisateurs expérimentés et doit toujours être utilisée avec précaution. Pour éviter la fuite des ressources de handle, appelez toujours cette méthode à l’intérieur d’une région d’exécution limitée (CER), où un abandon de thread ne peut pas interrompre le traitement.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la valeur du champ <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns>
          <see langword="IntPtr" /> représentant la valeur du champ <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Si le handle a été marqué comme étant non valide avec <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, cette méthode retourne quand même la valeur de handle d'origine, qui peut être une valeur périmée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour récupérer la valeur de handle réelle d’une instance de la <xref:System.Runtime.InteropServices.SafeHandle> classe dérivée. Cette méthode est nécessaire pour la compatibilité descendante, car le retournent de nombreuses propriétés dans le .NET Framework `IntPtr` gèrent des types. `IntPtr` types de handle sont spécifiques à la plateforme utilisée pour représenter un pointeur ou un handle.  
  
> [!CAUTION]
>  À l’aide de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> méthode peut présenter des risques de sécurité car, si le handle a été marqué comme non valide avec <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> retourne toujours la valeur de handle d’origine potentiellement périmée. Le handle retourné peut également être recyclé à tout moment. Au mieux, cela signifie que le handle peut cesser de travailler soudainement. Au pire des cas, si le handle ou la ressource qu’il représente est exposée au code non fiable, cela peut entraîner une attaque de sécurité de recyclage sur le handle réutilisé ou retourné. Par exemple, un appelant non fiable peut interroger des données sur le handle simplement retournées et recevoir des informations pour une ressource non connexe. Consultez le <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> et <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthodes pour plus d’informations sur l’utilisation de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> méthode de manière sûre.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Décrémente manuellement le compteur de références sur une instance de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthode est l’équivalent de <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Vous devez toujours faire correspondre un appel à la <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> méthode avec un appel réussi à <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Cette méthode est destinée aux utilisateurs expérimentés et doit toujours être utilisée avec précaution. Pour éviter la fuite des ressources de handle, appelez toujours cette méthode à l’intérieur d’une région d’exécution limitée (CER), où un abandon de thread ne peut pas interrompre le traitement. Dans la même façon que non appariées <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> appels peuvent provoquer des fuites de ressources, sans correspondance <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> appels peuvent rendre les États de handle non valide à deviennent accessibles à d’autres threads. N’exposez pas <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> les appels au code non fiable.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode permet aux ressources d’être libérées. Cela ne se produit pas immédiatement si d’autres threads utilisent la même instance du handle sécurisé, mais aura lieu dès que ce n’est plus le cas. Bien que la plupart des classes à l’aide de <xref:System.Runtime.InteropServices.SafeHandle> n’avez pas besoin de fournir un finaliseur, il est parfois nécessaire (par exemple, pour nettoyer des mémoires tampons de fichiers ou pour écrire des données en mémoire). Dans ce cas, ils peuvent fournir un finaliseur est assuré à exécuter avant le <xref:System.Runtime.InteropServices.SafeHandle> finaliseur critique.  
  
 Appelez le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode lorsque vous avez terminé à l’aide de la <xref:System.Runtime.InteropServices.SafeHandle> objet. Le <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> méthode laisse le <xref:System.Runtime.InteropServices.SafeHandle> objet dans un état inutilisable.  
  
> [!NOTE]
>  Appelez toujours la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode avant de libérer votre dernière référence à le <xref:System.Runtime.InteropServices.SafeHandle> objet. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Runtime.InteropServices.SafeHandle> de l'objet <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour une opération de suppression normale ; <see langword="false" /> pour finaliser le handle.</param>
        <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />, en spécifiant s'il faut exécuter une opération de suppression normale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez jamais appeler explicitement la <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode avec la `disposing` paramètre la valeur `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources associées au handle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> (méthode) est le destructeur de la <xref:System.Runtime.InteropServices.SafeHandle> classe. Code d’application ne doit pas appeler cette méthode directement.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le handle à encapsuler.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ne pas exposer le handle publiquement (autrement dit, en dehors de la classe dérivée).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le handle est fermé.</summary>
        <value>
          <see langword="true" /> si le handle est fermé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> méthode retourne une valeur indiquant si le <xref:System.Runtime.InteropServices.SafeHandle> handle de l’objet n’est plus associé à une ressource native. Cela diffère de la définition de la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété, qui calcule si un handle donné est toujours considéré comme non valide. Le <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> méthode retourne un `true` valeur dans les cas suivants :  
  
-   Le <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> méthode a été appelée.  
  
-   Le <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> méthode ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> méthode a été appelée et il n’existe aucune référence à la <xref:System.Runtime.InteropServices.SafeHandle> objet sur d’autres threads.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si la valeur du handle n'est pas valide.</summary>
        <value>
          <see langword="true" /> si la valeur du handle n'est pas valide, sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées doivent implémenter le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété afin que le common language runtime peut déterminer si la finalisation critique est requise. Classes dérivées doivent fournir une implémentation adaptée au type général de handle qu’ils prennent en charge (0 ou -1 n’est pas valide). Ces classes peuvent ensuite être dérivées davantage pour les types de handles sécurisés spécifiques.  
  
 Contrairement à la <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> propriété qui indique si le <xref:System.Runtime.InteropServices.SafeHandle> objet a fini d’utiliser le handle sous-jacent, la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété calcule si la valeur du handle donné est toujours considéré comme non valide. Par conséquent, le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété retourne toujours la même valeur pour toute valeur d’un handle.  
  
   
  
## Examples  
 L’exemple suivant vérifie si un fichier a été ouvert avec succès. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, exécute le code nécessaire pour libérer le handle.</summary>
        <returns>
          <see langword="true" /> si la libération du handle réussit ; sinon, dans le cas d’un échec catastrophique, <see langword="false" />. Dans ce cas, elle génère un Assistant Débogage managé [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> est garanti d’être appelée uniquement une fois et uniquement si le handle est valide tel que défini par la méthode le <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriété. Implémentez cette méthode dans votre <xref:System.Runtime.InteropServices.SafeHandle> les classes dérivées pour exécuter le code qui est nécessaire pour libérer le handle. Étant donné que l’une des fonctions de <xref:System.Runtime.InteropServices.SafeHandle> est de garantir la prévention des fuites de ressources, le code dans votre implémentation de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> ne doit jamais échouer. Le garbage collector appelle <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> après l’exécution des finaliseurs normales pour les objets qui ont été nettoyées en même temps. Le garbage collector garantit les ressources pour appeler cette méthode et que la méthode ne sera pas interrompue pendant qu’il est en cours. Cette méthode sera préparée comme une région d’exécution limitée (CER) au moment de la construction instance (ainsi que toutes les méthodes dans son graphique des appels pouvant être déterminé statiquement). Bien que cela empêche les interruptions d’abandon de thread, vous devez toutefois faire attention de ne pas introduire de chemins d’accès d’erreur dans votre substituée <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> (méthode). En particulier, appliquez le <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> toutes les méthodes que vous appelez à partir de l’attribut <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. Dans la plupart des cas, ce code doit être :  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 En outre, pour le nettoyage simple (par exemple, en appelant l’API Win32 `CloseHandle` sur un handle de fichier) vous pouvez vérifier la valeur de retour pour l’appel de la plate-forme unique. Pour le nettoyage complexe, vous avez peut-être beaucoup de logique de programme et de nombreux appels de méthode, dont certains peuvent échouer. Vous devez vous assurer que votre logique de programme comporte du code de secours pour chacun de ces cas.  
  
 Si <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> retourne `false` pour une raison quelconque, elle génère une [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistant Débogage managé.  Cela vous permet de détecter les cas où votre tentative de libération de ressources échoue.  
  
   
  
## Examples  
 L’exemple de code suivant libère le handle et fait partie d’un exemple plus complet fourni pour la <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Handle préexistant à utiliser.</param>
        <summary>Définit le handle au handle préexistant spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> méthode uniquement si vous avez besoin prendre en charge un handle préexistant (par exemple, si le handle est retourné dans une structure), car l’infrastructure .NET Framework COM interop ne prend pas en charge le marshaling de handles de sortie dans une structure.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marque un handle comme n'étant plus utilisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> méthode uniquement lorsque vous savez que votre handle ne référence plus une ressource. Cette opération ne modifie pas la valeur de la <xref:System.Runtime.InteropServices.SafeHandle.handle> champ ; uniquement, il marque le handle comme étant fermé. Le handle peut alors contenir une valeur potentiellement périmée. L’effet de cet appel est qu’aucune tentative est effectuée pour libérer les ressources.  
  
 Comme avec la <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> méthode, utilisez <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> uniquement si vous avez besoin prendre en charge un handle préexistant.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>