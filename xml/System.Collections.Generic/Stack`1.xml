<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9369e819b3a45edbbcd9fde740198d1375196d3f" />
    <Meta Name="ms.sourcegitcommit" Value="850a55c780d5a95b534467969add0232fd3a6125" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/07/2018" />
    <Meta Name="ms.locfileid" Value="34828892" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Spécifie le type d'éléments dans la pile.</typeparam>
    <summary>Représente une collection d’instances à taille variable de type dernier entré, premier sorti (LIFO) du même type spécifié.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> est implémenté comme un tableau.  
  
 Piles et les files d’attente sont utiles lorsque vous avez besoin de stockage temporaire pour plus d’informations ; Autrement dit, lorsque vous pouvez souhaiter ignorer un élément après la récupération de sa valeur. Utilisez <xref:System.Collections.Generic.Queue%601> si vous devez accéder aux informations dans le même ordre que celui qu’elle est stockée dans la collection. Utilisez <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> si vous avez besoin accéder aux informations dans l’ordre inverse.  
  
 Utilisez le <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> et <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> types lorsque vous avez besoin pour accéder à la collection à partir de plusieurs threads simultanément.  
  
 Une utilisation courante pour <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> consiste à conserver des États des variables pendant les appels à d’autres procédures.  
  
 Trois opérations principales peuvent être effectuées sur un <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> et ses éléments :  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> Insère un élément en haut de la <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> Supprime un élément du haut de la <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> Retourne un élément qui est en haut de la <xref:System.Collections.Generic.Stack%601> mais ne supprime ne pas de la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacité d’un <xref:System.Collections.Generic.Stack%601> est le nombre d’éléments du <xref:System.Collections.Generic.Stack%601> peut contenir. Lorsque des éléments sont ajoutés à un <xref:System.Collections.Generic.Stack%601>, la capacité est automatiquement augmentée si nécessaire, en réallouant le tableau interne. La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Si <xref:System.Collections.Generic.Stack%601.Count%2A> est inférieure à la capacité de la pile, <xref:System.Collections.Generic.Stack%601.Push%2A> est une opération o (1). Si la capacité doit être augmentée pour intégrer le nouvel élément <xref:System.Collections.Generic.Stack%601.Push%2A> devient un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A> est une opération o (1).  
  
 <xref:System.Collections.Generic.Stack%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique. L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  Un <see cref="T:System.Collections.Generic.Stack`1" /> peut prendre en charge plusieurs lecteurs simultanément, tant que la collection n’est pas modifiée.  Même dans ce cas, l’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Stack`1" /> qui est vide et possède la capacité initiale par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Stack%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Stack%601> peut contenir. Lorsque des éléments sont ajoutés à un <xref:System.Collections.Generic.Stack%601>, la capacité est automatiquement augmentée si nécessaire, en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite d’avoir à effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre ce constructeur et plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique.  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Collection à partir de laquelle copier les éléments.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Stack`1" /> qui contient des éléments copiés à partir de la collection spécifiée et qui possède une capacité suffisante pour accepter le nombre d'éléments copiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Stack%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Stack%601> peut contenir. Lorsque des éléments sont ajoutés à un <xref:System.Collections.Generic.Stack%601>, la capacité est automatiquement augmentée si nécessaire, en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite d’avoir à effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Les éléments sont copiés dans le <xref:System.Collections.Generic.Stack%601> dans le même ordre qu’ils sont lus par le <xref:System.Collections.Generic.IEnumerator%601> de la collection.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `collection`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre ce constructeur et plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique.  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre initial d'éléments que <see cref="T:System.Collections.Generic.Stack`1" /> peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Stack`1" /> qui est vide et possède une capacité égale à la plus grande valeur parmi la capacité initiale spécifiée et la capacité initiale par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Stack%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Stack%601> peut contenir. Lorsque des éléments sont ajoutés à un <xref:System.Collections.Generic.Stack%601>, la capacité est automatiquement augmentée si nécessaire, en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite d’avoir à effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les objets du <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> est définie à zéro, et les références à d’autres objets des éléments de la collection sont également libérées.  
  
 La capacité reste inchangée. Pour rétablir la capacité de la <xref:System.Collections.Generic.Stack%601>, appelez <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. La suppression vide <xref:System.Collections.Generic.Stack%601> définit la capacité de la <xref:System.Collections.Generic.Stack%601> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.Clear%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.Stack`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Détermine si le <see cref="T:System.Collections.Generic.Stack`1" /> contient un élément.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> existe dans <see cref="T:System.Collections.Generic.Stack`1" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité en utilisant le comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type de valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.Contains%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.Stack`1" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans un <c>tableau</c> auquel commencer la copie.</param>
        <summary>Copie <see cref="T:System.Collections.Generic.Stack`1" /> dans un <see cref="T:System.Array" /> unidimensionnel existant commençant à l'index de tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le tableau dans l’ordre de last-in-first-out (LIFO), similaire à celui des éléments retournés par une succession d’appels à <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">Le nombre d’éléments dans le <see cref="T:System.Collections.Generic.Stack`1" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans le <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <value>Nombre d'éléments contenus dans <see cref="T:System.Collections.Generic.Stack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité de la <xref:System.Collections.Generic.Stack%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Stack%601> peut stocker. <xref:System.Collections.Generic.Stack%601.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Generic.Stack%601>.  
  
 La capacité est toujours supérieure ou égale à <xref:System.Collections.Generic.Stack%601.Count%2A>. Si <xref:System.Collections.Generic.Stack%601.Count%2A> dépasse la capacité lors de l’ajout d’éléments, la capacité est augmentée en réallouant automatiquement le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs propriétés et méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété.  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur pour <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> pour <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> retourne le même objet jusqu'à ce que <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> soit appelé. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 Si <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur est à cette position, les appels suivants à <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> ou <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre que la <xref:System.Collections.Generic.Stack%601> classe générique est énumérable. Le `foreach` instruction (`For Each` en Visual Basic, `for each` en C++) est utilisée pour énumérer la file d’attente.  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l'objet situé en haut de <see cref="T:System.Collections.Generic.Stack`1" /> sans le supprimer.</summary>
        <returns>Objet situé en haut de <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est analogue à la méthode <xref:System.Collections.Generic.Stack%601.Pop%2A>, mais <xref:System.Collections.Generic.Stack%601.Peek%2A> ne modifie pas la <xref:System.Collections.Generic.Stack%601>.  
  
 Si type `T` est un type référence, `null` peut être placé sur le <xref:System.Collections.Generic.Stack%601> comme un espace réservé, si nécessaire.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.Peek%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Collections.Generic.Stack`1" /> est vide.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime et retourne l'objet en haut de <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Objet supprimé du haut de <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est analogue à la méthode <xref:System.Collections.Generic.Stack%601.Peek%2A>, mais <xref:System.Collections.Generic.Stack%601.Peek%2A> ne modifie pas la <xref:System.Collections.Generic.Stack%601>.  
  
 Si type `T` est un type référence, `null` peut être placé sur le <xref:System.Collections.Generic.Stack%601> comme un espace réservé, si nécessaire.  
  
 <xref:System.Collections.Generic.Stack%601> est implémenté comme un tableau. Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.Pop%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Collections.Generic.Stack`1" /> est vide.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à placer dans <see cref="T:System.Collections.Generic.Stack`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Insère un objet en haut de <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> est implémenté comme un tableau.  
  
 Si <xref:System.Collections.Generic.Stack%601.Count%2A> est déjà égale à la capacité, la capacité de le <xref:System.Collections.Generic.Stack%601> est augmentée en réallouant automatiquement le tableau interne, et les éléments existants sont copiés dans le nouveau tableau avant le nouvel élément est ajouté.  
  
 Si type `T` est un type référence, `null` peut être placé sur le <xref:System.Collections.Generic.Stack%601> comme un espace réservé, si nécessaire. Il occupe une position de la pile et est traité comme n’importe quel objet.  
  
 Si <xref:System.Collections.Generic.Stack%601.Count%2A> est inférieure à la capacité de la pile, <xref:System.Collections.Generic.Stack%601.Push%2A> est une opération o (1). Si la capacité doit être augmentée pour intégrer le nouvel élément <xref:System.Collections.Generic.Stack%601.Push%2A> devient un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.Push%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de la collection.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> retourne le même objet jusqu'à ce que <xref:System.Collections.IEnumerator.MoveNext%2A> soit appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur est à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.IEnumerator%601.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans un <c>tableau</c> auquel commencer la copie.</param>
        <summary>Copie les éléments de <see cref="T:System.Collections.ICollection" /> dans <see cref="T:System.Array" />, à partir d'un index particulier de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si le type de la source de <xref:System.Collections.ICollection> ne peut pas être casté automatiquement au type de la destination `array`, les implémentations non génériques de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> lever <xref:System.InvalidCastException>, alors que les implémentations génériques lèvent <xref:System.ArgumentException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> est multidimensionnel.  -ou- <paramref name="array" /> n’a pas d’indexation de base zéro.  -ou- Le nombre d’éléments du <see cref="T:System.Collections.ICollection" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du paramètre <paramref name="array" /> de destination.  -ou- Le type du <see cref="T:System.Collections.ICollection" /> source ne peut pas être casté automatiquement en type du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
        <value>
          <see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.Stack`1" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Dans les rares cas où des énumérations traitent des accès en écriture, vous devez verrouiller la collection pendant l’ensemble de l’énumération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Retourne un objet qui peut être utilisé pour synchroniser l’accès à la <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.Stack`1" />, cette propriété retourne toujours l'instance actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Retourne un objet qui peut être utilisé pour synchroniser l’accès à la <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection. Le code suivant illustre l’utilisation de la <xref:System.Collections.ICollection.SyncRoot%2A> propriété pour c#, C++ et Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d'une collection.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur est à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie <see cref="T:System.Collections.Generic.Stack`1" /> vers un nouveau tableau.</summary>
        <returns>Nouveau tableau contenant les copies des éléments de <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le tableau dans l’ordre de last-in-first-out (LIFO), similaire à celui des éléments retournés par une succession d’appels à <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Stack%601> classe générique, y compris le <xref:System.Collections.Generic.Stack%601.ToArray%2A> (méthode).  
  
 L’exemple de code crée une pile de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Stack%601.Push%2A> méthode pour insérer cinq chaînes dans la pile. Les éléments de la pile sont énumérés, ce qui ne modifie pas l’état de la pile. Le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode est utilisée pour afficher la première chaîne de la pile. Le <xref:System.Collections.Generic.Stack%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant sur la pile, puis le <xref:System.Collections.Generic.Stack%601.Pop%2A> méthode permet de dépiler.  
  
 Le <xref:System.Collections.Generic.Stack%601.ToArray%2A> méthode est utilisée pour créer un tableau et copie les éléments de la pile à ce dernier, puis le tableau est passé à la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, création d’une copie de la pile dans l’ordre des éléments inversée. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la pile est créée et le <xref:System.Collections.Generic.Stack%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructeur est également utilisé pour créer une copie de la pile dans l’ordre des éléments est inversé ; par conséquent, les trois éléments null figurent à la fin.  
  
 Le <xref:System.Collections.Generic.Stack%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » figure dans la première copie de la pile, après laquelle le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Stack%601.Count%2A> propriété indique que la pile est vide.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit la capacité au nombre réel d'éléments dans <see cref="T:System.Collections.Generic.Stack`1" />, si ce nombre est inférieur à 90 pour cent de la capacité actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour réduire la surcharge de mémoire d’une collection si aucun nouvel élément ne doit être ajouté à la collection. Le coût de réallocation et de copie d’un grand <xref:System.Collections.Generic.Stack%601> peut être considérable, toutefois, pour que le <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> méthode ne fait rien si la liste est à plus de 90 pour cent de la capacité. Cela évite de supporter un coût de réallocation élevé pour un gain relativement petit.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Pour réinitialiser un <xref:System.Collections.Generic.Stack%601> à son état initial, appelez le <xref:System.Collections.Generic.Stack%601.Clear%2A> méthode avant d’appeler <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> (méthode). La suppression vide <xref:System.Collections.Generic.Stack%601> définit la capacité de la <xref:System.Collections.Generic.Stack%601> à la capacité par défaut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>