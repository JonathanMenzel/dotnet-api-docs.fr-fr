<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="12ae7e38bec0335d2f8f93b62f43dfa0230fd375" /><Meta Name="ms.sourcegitcommit" Value="4bf27e77c1047a3bba61371cdc36ac5540ad07dd" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/02/2019" /><Meta Name="ms.locfileid" Value="57252046" /></Metadata><TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ISet&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="58ba9-101">Type d'éléments de l'ensemble de hachages.</span><span class="sxs-lookup"><span data-stu-id="58ba9-101">The type of elements in the hash set.</span></span></typeparam>
    <summary><span data-ttu-id="58ba9-102">Représente un ensemble de valeurs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-102">Represents a set of values.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-103">Le <xref:System.Collections.Generic.HashSet%601> classe fournit des opérations ensemblistes de hautes performances.</span><span class="sxs-lookup"><span data-stu-id="58ba9-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="58ba9-104">Un ensemble est une collection qui ne contient aucun élément en double, et dont les éléments sont dans aucun ordre particulier.</span><span class="sxs-lookup"><span data-stu-id="58ba9-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ba9-105"><xref:System.Collections.Generic.HashSet%601> implémente le <xref:System.Collections.Generic.IReadOnlyCollection%601> interface en commençant par le [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; dans les versions précédentes du .NET Framework, le <xref:System.Collections.Generic.HashSet%601> n’implémente pas cette interface.</span><span class="sxs-lookup"><span data-stu-id="58ba9-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="58ba9-106">La capacité d’un <xref:System.Collections.Generic.HashSet%601> objet est le nombre d’éléments que l’objet peut contenir.</span><span class="sxs-lookup"><span data-stu-id="58ba9-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="58ba9-107">Un <xref:System.Collections.Generic.HashSet%601> capacité de l’objet augmente automatiquement à mesure que les éléments sont ajoutés à l’objet.</span><span class="sxs-lookup"><span data-stu-id="58ba9-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="58ba9-108">Le <xref:System.Collections.Generic.HashSet%601> classe est basée sur le modèle des ensembles mathématiques et fournit de hautes performances opérations ensemblistes similaire à accéder aux clés de la <xref:System.Collections.Generic.Dictionary%602> ou <xref:System.Collections.Hashtable> collections.</span><span class="sxs-lookup"><span data-stu-id="58ba9-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="58ba9-109">En termes simples, la <xref:System.Collections.Generic.HashSet%601> classe peut être considérée comme un <xref:System.Collections.Generic.Dictionary%602> collection sans valeurs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="58ba9-110">Un <xref:System.Collections.Generic.HashSet%601> collection n’est pas triée et ne peut pas contenir des éléments en double.</span><span class="sxs-lookup"><span data-stu-id="58ba9-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="58ba9-111">Si la commande ou élément de duplication est plus importante que les performances de votre application, envisagez d’utiliser le <xref:System.Collections.Generic.List%601> classe avec le <xref:System.Collections.Generic.List%601.Sort%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="58ba9-112"><xref:System.Collections.Generic.HashSet%601> propose de nombreuses mathématiques défini des opérations, telles que l’addition (unions) et soustraction.</span><span class="sxs-lookup"><span data-stu-id="58ba9-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="58ba9-113">Le tableau suivant répertorie les <xref:System.Collections.Generic.HashSet%601> opérations et leurs équivalents mathématiques.</span><span class="sxs-lookup"><span data-stu-id="58ba9-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="58ba9-114">HashSet opération</span><span class="sxs-lookup"><span data-stu-id="58ba9-114">HashSet operation</span></span>|<span data-ttu-id="58ba9-115">Équivalent mathématique</span><span class="sxs-lookup"><span data-stu-id="58ba9-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="58ba9-116">Ajout d’union ou définie</span><span class="sxs-lookup"><span data-stu-id="58ba9-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="58ba9-117">Intersection</span><span class="sxs-lookup"><span data-stu-id="58ba9-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="58ba9-118">Soustraction de jeu</span><span class="sxs-lookup"><span data-stu-id="58ba9-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="58ba9-119">Différence symétrique</span><span class="sxs-lookup"><span data-stu-id="58ba9-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="58ba9-120">Outre les opérations ensemblistes, la <xref:System.Collections.Generic.HashSet%601> classe fournit également des méthodes pour déterminer l’égalité, le chevauchement de jeux, et si un ensemble est un sous-ensemble ou sur-ensemble d’un autre ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
<span data-ttu-id="58ba9-121">**.NET framework :** Pour très volumineux <xref:System.Collections.Generic.HashSet%601> objets, vous pouvez augmenter la capacité maximale à 2 milliards des éléments sur un système 64 bits en définissant le `enabled` attribut de la [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) élément de configuration `true` dans le environnement d’exécution.</span><span class="sxs-lookup"><span data-stu-id="58ba9-121">**.NET Framework only:** For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="58ba9-122">En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.Collections.Generic.HashSet%601> la classe implémente le <xref:System.Collections.Generic.ISet%601> interface.</span><span class="sxs-lookup"><span data-stu-id="58ba9-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="58ba9-123">HashSet et LINQ, opérations ensemblistes</span><span class="sxs-lookup"><span data-stu-id="58ba9-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="58ba9-124">LINQ fournit l’accès à la `Distinct`, `Union`, `Intersect` et `Except` opérations ensemblistes sur n’importe quelle source de données qui implémente le <xref:System.Collections.IEnumerable> ou <xref:System.Linq.IQueryable> interfaces.</span><span class="sxs-lookup"><span data-stu-id="58ba9-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="58ba9-125"><xref:System.Collections.Generic.HashSet%601> Fournit une collection plus grande et plus fiable d’opérations ensemblistes.</span><span class="sxs-lookup"><span data-stu-id="58ba9-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="58ba9-126">Par exemple, <xref:System.Collections.Generic.HashSet%601> fournit des comparaisons telles que <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> et <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="58ba9-127">La principale différence entre LINQ les opérations ensemblistes et <xref:System.Collections.Generic.HashSet%601> operations est que les opérations ensemblistes LINQ retournent toujours une nouvelle <xref:System.Collections.Generic.IEnumerable%601> collection, tandis que le <xref:System.Collections.Generic.HashSet%601> méthodes équivalentes modifient la collection actuelle.</span><span class="sxs-lookup"><span data-stu-id="58ba9-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="58ba9-128">En règle générale, si vous devez créer un nouveau jeu ou si votre application a besoin d’accéder uniquement aux opérations de l’ensemble fourni, à l’aide de LINQ opérations ensemblistes sur n’importe quel <xref:System.Collections.Generic.IEnumerable%601> collection ou un tableau sera suffisant.</span><span class="sxs-lookup"><span data-stu-id="58ba9-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="58ba9-129">Toutefois, si votre application requiert un accès aux opérations supplémentaires, ou si elle n’est pas souhaitable ou nécessaire de créer une nouvelle collection, utilisez la <xref:System.Collections.Generic.HashSet%601> classe.</span><span class="sxs-lookup"><span data-stu-id="58ba9-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="58ba9-130">Le tableau suivant présente la <xref:System.Collections.Generic.HashSet%601> opérations et leur équivalent LINQ définir des opérations.</span><span class="sxs-lookup"><span data-stu-id="58ba9-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="58ba9-131">HashSet opération</span><span class="sxs-lookup"><span data-stu-id="58ba9-131">HashSet operation</span></span>|<span data-ttu-id="58ba9-132">Équivalent LINQ</span><span class="sxs-lookup"><span data-stu-id="58ba9-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="58ba9-133">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="58ba9-134">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="58ba9-135">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="58ba9-136">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="58ba9-137">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="58ba9-138">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="58ba9-139">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="58ba9-140">N’est fourni.</span><span class="sxs-lookup"><span data-stu-id="58ba9-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-141">L’exemple suivant montre comment fusionner deux ensembles distincts.</span><span class="sxs-lookup"><span data-stu-id="58ba9-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="58ba9-142">Cet exemple crée deux <xref:System.Collections.Generic.HashSet%601> objets et les remplit avec des nombres pairs et impairs, respectivement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="58ba9-143">Une troisième <xref:System.Collections.Generic.HashSet%601> objet est créé à partir de l’ensemble qui contient les nombres pairs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="58ba9-144">L’exemple appelle ensuite la <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> (méthode), qui ajoute l’ensemble de nombres impairs au troisième ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58ba9-145">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-146">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> vide et utilise le comparateur d'égalité par défaut pour le type d'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-147">La capacité d’un <xref:System.Collections.Generic.HashSet%601> objet est le nombre d’éléments que l’objet peut contenir.</span><span class="sxs-lookup"><span data-stu-id="58ba9-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="58ba9-148">Un <xref:System.Collections.Generic.HashSet%601> capacité de l’objet augmente automatiquement à mesure que les éléments sont ajoutés à l’objet.</span><span class="sxs-lookup"><span data-stu-id="58ba9-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="58ba9-149">Ce constructeur est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-150">L’exemple suivant montre comment créer et remplir deux <xref:System.Collections.Generic.HashSet%601> objets.</span><span class="sxs-lookup"><span data-stu-id="58ba9-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="58ba9-151">Cet exemple fait partie d’un exemple plus complet fourni pour le <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="58ba9-152">Collection dont les éléments sont copiés dans le nouvel ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-152">The collection whose elements are copied to the new set.</span></span></param>
        <summary><span data-ttu-id="58ba9-153">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> qui utilise le comparateur d'égalité par défaut pour le type d'ensemble, contient des éléments copiés à partir de la collection spécifiée et possède une capacité suffisante pour accueillir le nombre d'éléments copiés.</span><span class="sxs-lookup"><span data-stu-id="58ba9-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-154">La capacité d’un <xref:System.Collections.Generic.HashSet%601> objet est le nombre d’éléments que l’objet peut contenir.</span><span class="sxs-lookup"><span data-stu-id="58ba9-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="58ba9-155">Un <xref:System.Collections.Generic.HashSet%601> capacité de l’objet augmente automatiquement à mesure que les éléments sont ajoutés à l’objet.</span><span class="sxs-lookup"><span data-stu-id="58ba9-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="58ba9-156">Si `collection` contient des doublons, le jeu contient l’un de chaque élément unique.</span><span class="sxs-lookup"><span data-stu-id="58ba9-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="58ba9-157">Aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-157">No exception will be thrown.</span></span> <span data-ttu-id="58ba9-158">Par conséquent, la taille du jeu résultant n’est pas identique à la taille de `collection`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="58ba9-159">Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `collection` paramètre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-160">L’exemple suivant montre comment créer un <xref:System.Collections.Generic.HashSet%601> collection à partir d’un ensemble existant.</span><span class="sxs-lookup"><span data-stu-id="58ba9-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="58ba9-161">Dans cet exemple, deux jeux est créés avec des entiers pairs et impairs, respectivement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="58ba9-162">Une troisième <xref:System.Collections.Generic.HashSet%601> objet est ensuite créé à partir de l’ensemble entier pair.</span><span class="sxs-lookup"><span data-stu-id="58ba9-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-163"><paramref name="collection" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-163"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="58ba9-164">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des valeurs de l'ensemble, ou <see langword="null" /> pour utiliser l'implémentation <see cref="T:System.Collections.Generic.EqualityComparer`1" /> par défaut pour le type d'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="58ba9-165">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> vide et utilise le comparateur d'égalité spécifié pour le type d'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-166">La capacité d’un <xref:System.Collections.Generic.HashSet%601> objet est le nombre d’éléments que l’objet peut contenir.</span><span class="sxs-lookup"><span data-stu-id="58ba9-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="58ba9-167">Un <xref:System.Collections.Generic.HashSet%601> capacité de l’objet augmente automatiquement à mesure que les éléments sont ajoutés à l’objet.</span><span class="sxs-lookup"><span data-stu-id="58ba9-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="58ba9-168">Ce constructeur est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="58ba9-169">Taille initiale du <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <summary><span data-ttu-id="58ba9-170">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> qui est vide, mais qui a de l’espace réservé pour des éléments <paramref name="capacity" /> et qui utilise le comparateur d’égalité par défaut pour le type de l’ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-171">Redimensionne étant relativement coûteuse (nécessitent également), il tente de réduire la nécessité de redimensionner en définissant la capacité initiale, selon la valeur de la `capacity`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="58ba9-172">Collection dont les éléments sont copiés dans le nouvel ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-172">The collection whose elements are copied to the new set.</span></span></param>
        <param name="comparer"><span data-ttu-id="58ba9-173">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des valeurs de l'ensemble, ou <see langword="null" /> pour utiliser l'implémentation <see cref="T:System.Collections.Generic.EqualityComparer`1" /> par défaut pour le type d'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="58ba9-174">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> qui utilise le comparateur d'égalité spécifié pour le type d'ensemble, contient des éléments copiés à partir de la collection spécifiée, et possède une capacité suffisante pour accueillir le nombre d'éléments copiés.</span><span class="sxs-lookup"><span data-stu-id="58ba9-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-175">La capacité d’un <xref:System.Collections.Generic.HashSet%601> objet est le nombre d’éléments que l’objet peut contenir.</span><span class="sxs-lookup"><span data-stu-id="58ba9-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="58ba9-176">Un <xref:System.Collections.Generic.HashSet%601> capacité de l’objet augmente automatiquement à mesure que les éléments sont ajoutés à l’objet.</span><span class="sxs-lookup"><span data-stu-id="58ba9-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="58ba9-177">Si `collection` contient des doublons, le jeu contient l’un de chaque élément unique.</span><span class="sxs-lookup"><span data-stu-id="58ba9-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="58ba9-178">Aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-178">No exception will be thrown.</span></span> <span data-ttu-id="58ba9-179">Par conséquent, la taille du jeu résultant n’est pas identique à la taille de `collection`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="58ba9-180">Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `collection` paramètre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-181">L’exemple suivant utilise un fourni <xref:System.Collections.Generic.IEqualityComparer%601> pour permettre les comparaisons sans respecter la casse sur les éléments d’un <xref:System.Collections.Generic.HashSet%601> collection de types de véhicules.</span><span class="sxs-lookup"><span data-stu-id="58ba9-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-182"><paramref name="collection" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-182"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="58ba9-183">Taille initiale du <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <param name="comparer"><span data-ttu-id="58ba9-184">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des valeurs du jeu, ou null (Nothing en Visual Basic) pour utiliser l’implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> par défaut pour le type de jeu.</span><span class="sxs-lookup"><span data-stu-id="58ba9-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="58ba9-185">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> qui utilise le comparateur d’égalité spécifié pour le type de jeu et dispose d’une capacité suffisante pour accueillir les éléments <paramref name="capacity" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-186">Redimensionne étant relativement coûteuse (nécessitent également), il tente de réduire la nécessité de redimensionner en définissant la capacité initiale, selon la valeur de la `capacity`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="58ba9-187">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les informations nécessaires pour sérialiser l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="58ba9-188">Structure <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient la source et la destination du flux sérialisé associé à l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-189">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> avec des données sérialisées.</span><span class="sxs-lookup"><span data-stu-id="58ba9-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-190">Ce constructeur est appelé pendant la désérialisation pour reconstituer l’objet qui est transmis sur un flux.</span><span class="sxs-lookup"><span data-stu-id="58ba9-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="58ba9-191">Pour plus d’informations, consultez [sérialisation XML et SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="58ba9-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="hashSet.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="58ba9-192">Élément à ajouter à l'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-192">The element to add to the set.</span></span></param>
        <summary><span data-ttu-id="58ba9-193">Ajoute l'élément spécifié à un ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-193">Adds the specified element to a set.</span></span></summary>
        <returns><span data-ttu-id="58ba9-194"><see langword="true" /> si l'élément est ajouté à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> ; <see langword="false" /> si l'élément est déjà présent.</span><span class="sxs-lookup"><span data-stu-id="58ba9-194"><see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-195">Si <xref:System.Collections.Generic.HashSet%601.Count%2A> est déjà égale à la capacité de la <xref:System.Collections.Generic.HashSet%601> de l’objet, la capacité est automatiquement ajustée pour prendre en compte le nouvel élément.</span><span class="sxs-lookup"><span data-stu-id="58ba9-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="58ba9-196">Si <xref:System.Collections.Generic.HashSet%601.Count%2A> est inférieure à la capacité du tableau interne, cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="58ba9-197">Si le <xref:System.Collections.Generic.HashSet%601> objet doit être redimensionné, cette méthode devient un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-198">L’exemple suivant montre comment créer et remplir deux <xref:System.Collections.Generic.HashSet%601> objets.</span><span class="sxs-lookup"><span data-stu-id="58ba9-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="58ba9-199">Cet exemple fait partie d’un exemple plus complet fourni pour le <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-200">Supprime tous les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> est défini à zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées.</span><span class="sxs-lookup"><span data-stu-id="58ba9-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="58ba9-202">La capacité reste inchangée jusqu'à un appel à <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> est effectuée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="58ba9-203">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-204">L’exemple suivant crée et remplit un <xref:System.Collections.Generic.HashSet%601> collection, puis l’efface et libère la mémoire référencée par la collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58ba9-205">Obtient <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> l'objet qui est utilisé pour déterminer l'égalité des valeurs de l'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></summary>
        <value><span data-ttu-id="58ba9-206">Objet <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> qui est utilisé pour déterminer l'égalité des valeurs de l'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-207">La récupération de la valeur de cette propriété est une opération O(1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="hashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="58ba9-208">Élément à trouver dans l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-209">Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> contient l'élément spécifié.</span><span class="sxs-lookup"><span data-stu-id="58ba9-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span></span></summary>
        <returns><span data-ttu-id="58ba9-210"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> contient l'élément spécifié ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-210"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-211">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-212">L’exemple suivant montre comment supprimer des valeurs d’un <xref:System.Collections.Generic.HashSet%601> à l’aide de la collection le <xref:System.Collections.Generic.HashSet%601.Remove%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="58ba9-213">Dans cet exemple, le <xref:System.Collections.Generic.HashSet%601.Contains%2A> méthode vérifie que le jeu contient une valeur avant de le supprimer.</span><span class="sxs-lookup"><span data-stu-id="58ba9-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58ba9-214">Copie les éléments d'une collection <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau.</span><span class="sxs-lookup"><span data-stu-id="58ba9-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="hashSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="58ba9-215">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="58ba9-216">Ce tableau doit avoir une indexation de base zéro.</span><span class="sxs-lookup"><span data-stu-id="58ba9-216">The array must have zero-based indexing.</span></span></param>
        <summary><span data-ttu-id="58ba9-217">Copie les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau.</span><span class="sxs-lookup"><span data-stu-id="58ba9-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-218">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-219"><paramref name="array" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-219"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="58ba9-220">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="58ba9-221">Ce tableau doit avoir une indexation de base zéro.</span><span class="sxs-lookup"><span data-stu-id="58ba9-221">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="58ba9-222">Index de base zéro dans le <paramref name="array" /> à partir duquel la copie commence.</span><span class="sxs-lookup"><span data-stu-id="58ba9-222">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="58ba9-223">Copie les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau, en commençant à l'index de tableau spécifié.</span><span class="sxs-lookup"><span data-stu-id="58ba9-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-224">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-225"><paramref name="array" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-225"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ba9-226"><paramref name="arrayIndex" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="58ba9-226"><paramref name="arrayIndex" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58ba9-227"><paramref name="arrayIndex" /> est supérieur à la longueur du <paramref name="array" /> de destination.</span><span class="sxs-lookup"><span data-stu-id="58ba9-227"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="58ba9-228">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="58ba9-229">Ce tableau doit avoir une indexation de base zéro.</span><span class="sxs-lookup"><span data-stu-id="58ba9-229">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="58ba9-230">Index de base zéro dans le <paramref name="array" /> à partir duquel la copie commence.</span><span class="sxs-lookup"><span data-stu-id="58ba9-230">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <param name="count"><span data-ttu-id="58ba9-231">Nombre d'éléments à copier dans <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-231">The number of elements to copy to <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="58ba9-232">Copie le nombre spécifié d'éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau, en commençant à l'index spécifié du tableau.</span><span class="sxs-lookup"><span data-stu-id="58ba9-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-233">Cette méthode est un O (`n`) opération, où `n` est `count`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-234"><paramref name="array" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-234"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ba9-235"><paramref name="arrayIndex" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="58ba9-235"><paramref name="arrayIndex" /> is less than 0.</span></span>  
  
<span data-ttu-id="58ba9-236">ou</span><span class="sxs-lookup"><span data-stu-id="58ba9-236">-or-</span></span> 
 <span data-ttu-id="58ba9-237"><paramref name="count" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="58ba9-237"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58ba9-238"><paramref name="arrayIndex" /> est supérieur à la longueur du <paramref name="array" /> de destination.</span><span class="sxs-lookup"><span data-stu-id="58ba9-238"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span>  
  
<span data-ttu-id="58ba9-239">ou</span><span class="sxs-lookup"><span data-stu-id="58ba9-239">-or-</span></span> 
 <span data-ttu-id="58ba9-240">Le nombre d'éléments dans le <paramref name="count" /> est supérieur à la quantité d'espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</span><span class="sxs-lookup"><span data-stu-id="58ba9-240"><paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58ba9-241">Obtient le nombre d'éléments contenus dans un ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-241">Gets the number of elements that are contained in a set.</span></span></summary>
        <value><span data-ttu-id="58ba9-242">Nombre d'éléments contenus dans l'ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-242">The number of elements that are contained in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-243">La capacité d’un <xref:System.Collections.Generic.HashSet%601> objet est le nombre d’éléments que l’objet peut contenir.</span><span class="sxs-lookup"><span data-stu-id="58ba9-243">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="58ba9-244">Un <xref:System.Collections.Generic.HashSet%601> capacité de l’objet augmente automatiquement à mesure que les éléments sont ajoutés à l’objet.</span><span class="sxs-lookup"><span data-stu-id="58ba9-244">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="58ba9-245">La capacité est toujours supérieure ou égale à <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-245">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="58ba9-246">Si <xref:System.Collections.Generic.HashSet%601.Count%2A> dépasse la capacité lors de l’ajout d’éléments, la capacité est définie sur le premier nombre premier qui est supérieur au double de la capacité précédente.</span><span class="sxs-lookup"><span data-stu-id="58ba9-246">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="58ba9-247">La récupération de la valeur de cette propriété est une opération O(1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-247">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-248">L’exemple suivant montre comment créer, remplir et manipuler deux <xref:System.Collections.Generic.HashSet%601> objets.</span><span class="sxs-lookup"><span data-stu-id="58ba9-248">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="58ba9-249">Dans cet exemple, les deux le contenu de l’ensemble et <xref:System.Collections.Generic.HashSet%601.Count%2A> afficher dans la console.</span><span class="sxs-lookup"><span data-stu-id="58ba9-249">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-250">Retourne un objet <see cref="T:System.Collections.IEqualityComparer" /> qui peut être utilisé pour tester l'égalité d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-250">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="58ba9-251">Objet <see cref="T:System.Collections.IEqualityComparer" /> qui peut être utilisé pour tester l'égalité profonde de l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-251">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-252">Le <xref:System.Collections.IEqualityComparer> objet vérifie l’égalité à un seul niveau ; Toutefois, vous pouvez chaîner comparateurs à des niveaux supplémentaires pour effectuer le test d’égalité approfondi.</span><span class="sxs-lookup"><span data-stu-id="58ba9-252">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="58ba9-253">Appel de cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-253">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="hashSet.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-254">Collection d'éléments à supprimer de l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-254">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-255">Supprime tous les éléments dans la collection spécifiée de l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-255">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-256">Le <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> méthode est l’équivalent de soustraction ensembliste mathématique.</span><span class="sxs-lookup"><span data-stu-id="58ba9-256">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="58ba9-257">Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments dans le `other` paramètre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-257">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-258">L’exemple suivant crée deux <xref:System.Collections.Generic.HashSet%601> collections avec chevauchement des jeux de données.</span><span class="sxs-lookup"><span data-stu-id="58ba9-258">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="58ba9-259">La plage de valeurs est ensuite supprimée de la plus grande à l’aide de set le <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-259">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-260"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-260"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.HashSet&lt;'T&gt;.Enumerator" Usage="hashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-261">Retourne un énumérateur qui itère au sein d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-261">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="58ba9-262">Objet <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> pour l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-262">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-263">Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-263">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="58ba9-264">Par conséquent, l’utilisation `foreach` est recommandé au lieu de manipuler l’énumérateur directement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-264">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="58ba9-265">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="58ba9-265">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="58ba9-266">Au départ, l'énumérateur est positionné avant le premier élément de la collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-266">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="58ba9-267">À cette position, la <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propriété n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="58ba9-267">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="58ba9-268">Par conséquent, vous devez appeler la <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-268">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="58ba9-269">Le <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propriété retourne le même objet jusqu'à ce que <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-269">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="58ba9-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="58ba9-271">Si <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-271">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="58ba9-272">Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> également retourner `false`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-272">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="58ba9-273">Si le dernier appel à <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="58ba9-273">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="58ba9-274">Vous ne pouvez pas définir <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> vers le premier élément de la collection à nouveau ; vous devez créer un nouvel objet énumérateur, à la place.</span><span class="sxs-lookup"><span data-stu-id="58ba9-274">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="58ba9-275">Un énumérateur est valide tant que la collection demeure inchangée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-275">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="58ba9-276">Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> ou <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> lève une <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-276">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="58ba9-277">Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="58ba9-277">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="58ba9-278">Pour garantir la sécurité des threads pendant l'énumération, vous pouvez verrouiller la collection tout au long de cette opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-278">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="58ba9-279">Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</span><span class="sxs-lookup"><span data-stu-id="58ba9-279">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="58ba9-280">Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.</span><span class="sxs-lookup"><span data-stu-id="58ba9-280">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="58ba9-281">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-281">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="58ba9-282">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les informations nécessaires pour sérialiser l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-282">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="58ba9-283">Structure <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient la source et la destination du flux sérialisé associé à l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-283">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-284">Implémente l'interface <see cref="T:System.Runtime.Serialization.ISerializable" /> et retourne les données requises pour sérialiser un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-284">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-285">Appel de cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-285">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-286"><paramref name="info" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-286"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="58ba9-287">pour fournir des services de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="58ba9-287">for providing serialization services.</span></span> <span data-ttu-id="58ba9-288">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-288">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="58ba9-289">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="58ba9-289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-290">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-290">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-291">Modifie l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif afin qu'il contienne uniquement les éléments qui sont présents dans cet objet et dans la collection spécifiée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-291">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-292">Si la collection représentée par le `other` paramètre est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-292">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-293">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A> et `m` est le nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-293">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-294"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-294"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-295">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-295">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-296">Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble propre à la collection spécifiée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-296">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-297"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble propre à <paramref name="other" /> ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-297"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-298">Un ensemble vide est un sous-ensemble approprié de toute autre collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-298">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="58ba9-299">Par conséquent, cette méthode retourne `true` si la collection représentée par l’actuel <xref:System.Collections.Generic.HashSet%601> objet est vide, sauf si le `other` paramètre est également un ensemble vide.</span><span class="sxs-lookup"><span data-stu-id="58ba9-299">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="58ba9-300">Cette méthode retourne toujours `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> est supérieur ou égal au nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-300">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="58ba9-301">Si la collection représentée par `other` est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-301">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-302">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A> et `m` est le nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-302">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-303">L’exemple suivant crée deux disparates <xref:System.Collections.Generic.HashSet%601> objets et les compare à l’autre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-303">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="58ba9-304">Dans cet exemple, `lowNumbers` est un sous-ensemble et un sous-ensemble approprié de `allNumbers` jusqu'à ce que `allNumbers` est modifié, à l’aide de la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (méthode), pour contenir uniquement les valeurs qui sont présentes dans les deux ensembles.</span><span class="sxs-lookup"><span data-stu-id="58ba9-304">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="58ba9-305">Une fois `allNumbers` et `lowNumbers` sont identiques, `lowNumbers` est toujours un sous-ensemble de `allNumbers` mais n’est plus un sous-ensemble approprié.</span><span class="sxs-lookup"><span data-stu-id="58ba9-305">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-306"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-306"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-307">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-307">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-308">Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble propre à la collection spécifiée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-308">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-309"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble propre à <paramref name="other" /> ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-309"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-310">Un ensemble vide est un sur-ensemble correct d’un autre regroupement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-310">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="58ba9-311">Par conséquent, cette méthode retourne `true` si la collection représentée par le `other` paramètre est vide, sauf si actuel <xref:System.Collections.Generic.HashSet%601> collection est également vide.</span><span class="sxs-lookup"><span data-stu-id="58ba9-311">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="58ba9-312">Cette méthode retourne toujours `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> est inférieur ou égal au nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-312">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="58ba9-313">Si la collection représentée par `other` est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-313">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-314">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est le nombre d’éléments dans `other` et `m` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-314">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-315">L’exemple suivant crée deux disparates <xref:System.Collections.Generic.HashSet%601> objets et les compare à l’autre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-315">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="58ba9-316">Dans cet exemple, `allNumbers` est un sur-ensemble et un sur-ensemble `lowNumbers` jusqu'à ce que `allNumbers` est modifié, à l’aide de la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (méthode), pour contenir uniquement les valeurs qui sont présentes dans les deux ensembles.</span><span class="sxs-lookup"><span data-stu-id="58ba9-316">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="58ba9-317">Une fois `allNumbers` et `lowNumbers` sont identiques, `allNumbers` est toujours un sur-ensemble de `lowNumbers` mais n’est plus un sur-ensemble correct.</span><span class="sxs-lookup"><span data-stu-id="58ba9-317">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-318"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-318"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-319">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-319">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-320">Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble de la collection spécifiée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-320">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-321"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble de <paramref name="other" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-321"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-322">Un ensemble vide est un sous-ensemble de tous les autres regroupements, y compris un ensemble vide ; Par conséquent, cette méthode retourne `true` si la collection représentée par l’actuel <xref:System.Collections.Generic.HashSet%601> objet est vide, même si le `other` paramètre est un ensemble vide.</span><span class="sxs-lookup"><span data-stu-id="58ba9-322">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="58ba9-323">Cette méthode retourne toujours `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> est supérieur au nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-323">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="58ba9-324">Si la collection représentée par `other` est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-324">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-325">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A> et `m` est le nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-325">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-326">L’exemple suivant crée deux disparates <xref:System.Collections.Generic.HashSet%601> objets et les compare à l’autre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-326">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="58ba9-327">Dans cet exemple, `lowNumbers` est un sous-ensemble et un sous-ensemble approprié de `allNumbers` jusqu'à ce que `allNumbers` est modifié, à l’aide de la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (méthode), pour contenir uniquement les valeurs qui sont présentes dans les deux ensembles.</span><span class="sxs-lookup"><span data-stu-id="58ba9-327">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="58ba9-328">Une fois `allNumbers` et `lowNumbers` sont identiques, `lowNumbers` est toujours un sous-ensemble de `allNumbers` mais n’est plus un sous-ensemble approprié.</span><span class="sxs-lookup"><span data-stu-id="58ba9-328">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-329"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-329"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-330">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-330">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-331">Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble de la collection spécifiée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-331">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-332"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble de <paramref name="other" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-332"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-333">Toutes les collections, y compris le jeu vide, sont des sur-ensembles du jeu vide.</span><span class="sxs-lookup"><span data-stu-id="58ba9-333">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="58ba9-334">Par conséquent, cette méthode retourne `true` si la collection représentée par le `other` paramètre est vide, même si en cours <xref:System.Collections.Generic.HashSet%601> objet est vide.</span><span class="sxs-lookup"><span data-stu-id="58ba9-334">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="58ba9-335">Cette méthode retourne toujours `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> est inférieur au nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-335">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="58ba9-336">Si la collection représentée par `other` est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-336">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-337">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est le nombre d’éléments dans `other` et `m` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-337">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-338">L’exemple suivant crée deux disparates <xref:System.Collections.Generic.HashSet%601> objets et les compare à l’autre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-338">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="58ba9-339">Dans cet exemple, `allNumbers` est un sur-ensemble et un sur-ensemble `lowNumbers` jusqu'à ce que `allNumbers` est modifié, à l’aide de la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> (méthode), pour contenir uniquement les valeurs qui sont présentes dans les deux ensembles.</span><span class="sxs-lookup"><span data-stu-id="58ba9-339">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="58ba9-340">Une fois `allNumbers` et `lowNumbers` sont identiques, `allNumbers` est toujours un sur-ensemble de `lowNumbers` mais n’est plus un sur-ensemble correct.</span><span class="sxs-lookup"><span data-stu-id="58ba9-340">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-341"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-341"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="58ba9-342">Source de l'événement de désérialisation.</span><span class="sxs-lookup"><span data-stu-id="58ba9-342">The source of the deserialization event.</span></span></param>
        <summary><span data-ttu-id="58ba9-343">Implémente l'interface <see cref="T:System.Runtime.Serialization.ISerializable" /> et déclenche l'événement de désérialisation une fois que la désérialisation est terminée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-343">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-344">Appel de cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-344">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="58ba9-345">L'objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associé à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actuel n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="58ba9-345">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-346">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-346">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-347">Détermine si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actuel et une collection spécifiée partagent des éléments communs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-347">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span></span></summary>
        <returns><span data-ttu-id="58ba9-348"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> et <paramref name="other" /> partagent au moins un élément commun ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-348"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-349">Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments dans `other`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-349">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-350">L’exemple suivant crée deux disparates <xref:System.Collections.Generic.HashSet%601> objets et les compare.</span><span class="sxs-lookup"><span data-stu-id="58ba9-350">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="58ba9-351">Dans cet exemple, `allNumbers` et `lowNumbers` partagent des éléments communs à l’aide de la <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-351">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-352"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-352"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="hashSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="58ba9-353">Élément à supprimer.</span><span class="sxs-lookup"><span data-stu-id="58ba9-353">The element to remove.</span></span></param>
        <summary><span data-ttu-id="58ba9-354">Supprime l'élément spécifié d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-354">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="58ba9-355"><see langword="true" /> si la recherche et la suppression de l'élément réussissent ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-355"><see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="58ba9-356">Cette méthode retourne <see langword="false" /> si <paramref name="item" /> est introuvable dans l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-356">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-357">Si le <xref:System.Collections.Generic.HashSet%601> objet ne contient pas l’élément spécifié, l’objet reste inchangé.</span><span class="sxs-lookup"><span data-stu-id="58ba9-357">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="58ba9-358">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-358">No exception is thrown.</span></span>  
  
 <span data-ttu-id="58ba9-359">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-359">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-360">L’exemple suivant montre comment supprimer des valeurs d’un <xref:System.Collections.Generic.HashSet%601> à l’aide de la collection le <xref:System.Collections.Generic.HashSet%601.Remove%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-360">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="58ba9-361">Dans cet exemple, le zéro est supprimé arbitrairement de la <xref:System.Collections.Generic.HashSet%601> collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-361">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="hashSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><span data-ttu-id="58ba9-362">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à supprimer.</span><span class="sxs-lookup"><span data-stu-id="58ba9-362">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span></span></param>
        <summary><span data-ttu-id="58ba9-363">Supprime tous les éléments qui correspondent aux conditions définies par le prédicat spécifié de la collection <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-363">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-364">Nombre d'éléments supprimés de la collection <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-364">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-365">Appel de cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-365">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-366">L’exemple suivant montre comment supprimer des valeurs d’un <xref:System.Collections.Generic.HashSet%601> à l’aide de la collection le <xref:System.Collections.Generic.HashSet%601.Remove%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-366">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="58ba9-367">Dans cet exemple, tous les entiers impairs sont supprimés de la <xref:System.Collections.Generic.HashSet%601> collection tel que spécifié par le `match` déléguer.</span><span class="sxs-lookup"><span data-stu-id="58ba9-367">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-368"><paramref name="match" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-368"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-369">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-369">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-370">Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> et la collection spécifiée contiennent les mêmes éléments.</span><span class="sxs-lookup"><span data-stu-id="58ba9-370">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span></span></summary>
        <returns><span data-ttu-id="58ba9-371"><see langword="true" /> si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est égal à <paramref name="other" /> ; sinon « false ».</span><span class="sxs-lookup"><span data-stu-id="58ba9-371"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-372">Le <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> méthode ignore les entrées en double et l’ordre des éléments dans le `other` paramètre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-372">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="58ba9-373">Si la collection représentée par `other` est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-373">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-374">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est le nombre d’éléments dans `other` et `m` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-374">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-375">L’exemple suivant crée deux disparates <xref:System.Collections.Generic.HashSet%601> objets et les compare.</span><span class="sxs-lookup"><span data-stu-id="58ba9-375">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="58ba9-376">Initialement, les deux jeux ne sont pas égales, qui est illustré à l’aide de la <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-376">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="58ba9-377">Le `allNumbers` <xref:System.Collections.Generic.HashSet%601> objet est ensuite modifié, après quoi les jeux sont égaux.</span><span class="sxs-lookup"><span data-stu-id="58ba9-377">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-378"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-378"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-379">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-379">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-380">Modifie l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif afin qu'il contienne uniquement les éléments présents dans cet objet ou dans la collection spécifiée, mais pas dans les deux à la fois.</span><span class="sxs-lookup"><span data-stu-id="58ba9-380">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-381">Si le `other` paramètre est un <xref:System.Collections.Generic.HashSet%601> collection avec le même comparateur d’égalité en cours <xref:System.Collections.Generic.HashSet%601> de l’objet, cette méthode est un O (`n`) opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-381">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="58ba9-382">Sinon, cette méthode est un O (`n` + `m`) opération, où `n` est le nombre d’éléments dans `other` et `m` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-382">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-383">L’exemple suivant crée deux <xref:System.Collections.Generic.HashSet%601> collections avec chevauchement des jeux de données.</span><span class="sxs-lookup"><span data-stu-id="58ba9-383">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="58ba9-384">Le jeu qui contient les valeurs inférieures est ensuite modifié, à l’aide de la <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> (méthode), pour contenir uniquement les valeurs qui ne figurent pas dans les deux ensembles.</span><span class="sxs-lookup"><span data-stu-id="58ba9-384">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-385"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-385"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="58ba9-386">Objet à ajouter à l'objet <see cref="T:System.Collections.Generic.ICollection`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-386">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-387">Ajoute un élément à un objet <see cref="T:System.Collections.Generic.ICollection`1" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-387">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-388">Si <xref:System.Collections.Generic.List%601.Count%2A> est inférieure à <xref:System.Collections.Generic.List%601.Capacity%2A>, cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-388">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="58ba9-389">Si la capacité doit être augmentée pour intégrer un nouvel élément, cette méthode devient un O (`n`) opération, où `n` est <xref:System.Collections.Generic.List%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-389">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58ba9-390"><see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="58ba9-390">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58ba9-391">Obtient une valeur indiquant si une collection est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="58ba9-391">Gets a value indicating whether a collection is read-only.</span></span></summary>
        <value><span data-ttu-id="58ba9-392"><see langword="true" /> si la collection est en lecture seule ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-392"><see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-393">La récupération de la valeur de cette propriété est une opération O(1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-393">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-394">Retourne un énumérateur qui itère au sein d'une collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-394">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-395">Objet <see cref="T:System.Collections.Generic.IEnumerator`1" /> qui peut être utilisé pour effectuer des itérations au sein de la collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-395">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-396">Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-396">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="58ba9-397">Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-397">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="58ba9-398">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="58ba9-398">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="58ba9-399">Au départ, l'énumérateur est positionné avant le premier élément de la collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-399">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="58ba9-400">À cette position, la <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriété n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="58ba9-400">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="58ba9-401">Par conséquent, vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-401">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="58ba9-402">Le <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriété retourne le même objet jusqu'à ce que <xref:System.Collections.IEnumerator.MoveNext%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-402">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="58ba9-403"><xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-403"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="58ba9-404">Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-404">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="58ba9-405">Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-405">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="58ba9-406">Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="58ba9-406">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="58ba9-407">Vous ne pouvez pas définir <xref:System.Collections.Generic.IEnumerator%601.Current%2A> vers le premier élément de la collection à nouveau ; vous devez créer un nouvel objet énumérateur, à la place.</span><span class="sxs-lookup"><span data-stu-id="58ba9-407">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="58ba9-408">Un énumérateur est valide tant que la collection demeure inchangée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-408">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="58ba9-409">Si des modifications sont apportées à la collection, telles que l’ajout, la modification ou la suppression d’éléments, l’énumérateur est définitivement invalidé et son comportement n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="58ba9-409">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="58ba9-410">Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="58ba9-410">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="58ba9-411">Pour garantir la sécurité des threads pendant l'énumération, vous pouvez verrouiller la collection tout au long de cette opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-411">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="58ba9-412">Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</span><span class="sxs-lookup"><span data-stu-id="58ba9-412">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="58ba9-413">Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.</span><span class="sxs-lookup"><span data-stu-id="58ba9-413">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="58ba9-414">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-414">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-415">Retourne un énumérateur qui itère au sein d'une collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-415">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="58ba9-416">Objet <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour effectuer des itérations au sein de la collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-416">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-417">Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-417">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="58ba9-418">Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-418">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="58ba9-419">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="58ba9-419">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="58ba9-420">Au départ, l'énumérateur est positionné avant le premier élément de la collection.</span><span class="sxs-lookup"><span data-stu-id="58ba9-420">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="58ba9-421"><xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.</span><span class="sxs-lookup"><span data-stu-id="58ba9-421"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="58ba9-422">À cette position, la <xref:System.Collections.IEnumerator.Current%2A> propriété n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="58ba9-422">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="58ba9-423">Par conséquent, vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-423">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="58ba9-424">Le <xref:System.Collections.IEnumerator.Current%2A> propriété retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-424">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="58ba9-425"><xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-425"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="58ba9-426">Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-426">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="58ba9-427">Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`.</span><span class="sxs-lookup"><span data-stu-id="58ba9-427">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="58ba9-428">Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="58ba9-428">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="58ba9-429">Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-429">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="58ba9-430">Un énumérateur est valide tant que la collection demeure inchangée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-430">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="58ba9-431">Si des modifications sont apportées à la collection, telles que l’ajout, la modification ou la suppression d’éléments, l’énumérateur est définitivement invalidé et son comportement n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="58ba9-431">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="58ba9-432">Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="58ba9-432">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="58ba9-433">Pour garantir la sécurité des threads pendant l'énumération, vous pouvez verrouiller la collection tout au long de cette opération.</span><span class="sxs-lookup"><span data-stu-id="58ba9-433">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="58ba9-434">Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</span><span class="sxs-lookup"><span data-stu-id="58ba9-434">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="58ba9-435">Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.</span><span class="sxs-lookup"><span data-stu-id="58ba9-435">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="58ba9-436">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="58ba9-436">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="hashSet.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58ba9-437">Affecte à la capacité d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> le nombre réel d'éléments qu'il contient, arrondi à une valeur proche spécifique à l'implémentation.</span><span class="sxs-lookup"><span data-stu-id="58ba9-437">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-438">Vous pouvez utiliser la <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> permettant de réduire un <xref:System.Collections.Generic.HashSet%601> surcharge de mémoire de l’objet une fois qu’il est connu qu’aucun nouvel élément sera être ajouté.</span><span class="sxs-lookup"><span data-stu-id="58ba9-438">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="58ba9-439">Pour effacer complètement une <xref:System.Collections.Generic.HashSet%601> d’objet et libérer toute la mémoire qu’il référencée, appelez cette méthode après avoir appelé la <xref:System.Collections.Generic.HashSet%601.Clear%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="58ba9-439">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="58ba9-440">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ba9-440">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-441">L’exemple suivant crée et remplit un <xref:System.Collections.Generic.HashSet%601> collection, puis efface la collection et libère la mémoire référencée par ce dernier.</span><span class="sxs-lookup"><span data-stu-id="58ba9-441">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="hashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue"><span data-ttu-id="58ba9-442">Valeur à rechercher.</span><span class="sxs-lookup"><span data-stu-id="58ba9-442">The value to search for.</span></span></param>
        <param name="actualValue"><span data-ttu-id="58ba9-443">Valeur de l’ensemble que la recherche a trouvée, ou valeur par défaut de T quand la recherche n’a trouvé aucune correspondance.</span><span class="sxs-lookup"><span data-stu-id="58ba9-443">The value from the set that the search found, or the default value of T when the search yielded no match.</span></span></param>
        <summary><span data-ttu-id="58ba9-444">Recherche dans l’ensemble une valeur donnée et retourne la valeur égale qu’il trouve, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="58ba9-444">Searches the set for a given value and returns the equal value it finds, if any.</span></span></summary>
        <returns><span data-ttu-id="58ba9-445">Valeur qui indique si la recherche a réussi.</span><span class="sxs-lookup"><span data-stu-id="58ba9-445">A value indicating whether the search was successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-446">Cela peut être utile lorsque vous souhaitez réutiliser une référence précédemment stockée au lieu d’une nouvellement construit (afin que le partage de plus de références peut se produire) ou pour rechercher une valeur qui a des données plus complètes à la valeur que vous avez actuellement, bien que leurs fonctions comparateur indiquer qu’ils sont égaux.</span><span class="sxs-lookup"><span data-stu-id="58ba9-446">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="58ba9-447">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</span><span class="sxs-lookup"><span data-stu-id="58ba9-447">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="58ba9-448">Modifie l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif afin qu'il contienne tous les éléments qui sont présents à la fois dans cet objet et dans la collection spécifiée.</span><span class="sxs-lookup"><span data-stu-id="58ba9-448">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ba9-449">Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments dans le `other` paramètre.</span><span class="sxs-lookup"><span data-stu-id="58ba9-449">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ba9-450">L’exemple suivant montre comment fusionner deux ensembles distincts.</span><span class="sxs-lookup"><span data-stu-id="58ba9-450">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="58ba9-451">Cet exemple crée deux <xref:System.Collections.Generic.HashSet%601> objets et les remplit avec des nombres pairs et impairs, respectivement.</span><span class="sxs-lookup"><span data-stu-id="58ba9-451">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="58ba9-452">Une troisième <xref:System.Collections.Generic.HashSet%601> objet est créé à partir de l’ensemble qui contient les nombres pairs.</span><span class="sxs-lookup"><span data-stu-id="58ba9-452">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="58ba9-453">L’exemple appelle ensuite la <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> (méthode), qui ajoute l’ensemble de nombres impairs au troisième ensemble.</span><span class="sxs-lookup"><span data-stu-id="58ba9-453">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ba9-454"><paramref name="other" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ba9-454"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
