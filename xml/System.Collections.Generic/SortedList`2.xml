<Type Name="SortedList&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedList&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6d2446c44a724deb44334cd2cd7194033586203" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37701810" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SortedList&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedList`2" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class SortedList : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Type de clés de la collection.</typeparam>
    <typeparam name="TValue">Type de valeurs de la collection.</typeparam>
    <summary>Représente une collection de paires clé/valeur triées par clé en fonction de l'implémentation <see cref="T:System.Collections.Generic.IComparer`1" /> associée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.SortedList%602> classe générique est un tableau de paires clé/valeur avec O (log `n`) extraction, où n est le nombre d’éléments dans le dictionnaire. Dans ce cas, elle est similaire à la <xref:System.Collections.Generic.SortedDictionary%602> classe générique. Les deux classes ont des modèles d’objet semblables, et les deux ont O (log `n`) extraction. Où les deux classes diffèrent est dans l’utilisation de la mémoire et la vitesse d’insertion et de suppression :  
  
-   <xref:System.Collections.Generic.SortedList%602> utilise moins de mémoire que <xref:System.Collections.Generic.SortedDictionary%602>.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602> est plus rapide d’insertion et les opérations de suppression pour les données non triées, O (log `n`) par opposition à O (`n`) pour <xref:System.Collections.Generic.SortedList%602>.  
  
-   Si la liste est remplie à la fois à partir de données triées, <xref:System.Collections.Generic.SortedList%602> est plus rapide que <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Une autre différence entre la <xref:System.Collections.Generic.SortedDictionary%602> et <xref:System.Collections.Generic.SortedList%602> classes est que <xref:System.Collections.Generic.SortedList%602> prend en charge la récupération indexée efficace des clés et valeurs via les collections retournées par la <xref:System.Collections.Generic.SortedList%602.Keys%2A> et <xref:System.Collections.Generic.SortedList%602.Values%2A> propriétés. Il n’est pas nécessaire de régénérer les listes lorsque les propriétés sont accessibles, étant donné que les listes sont juste des enveloppes pour les tableaux internes de clés et valeurs. Le code suivant illustre l’utilisation de la <xref:System.Collections.Generic.SortedList%602.Values%2A> propriété pour la récupération indexée de valeurs à partir d’une liste triée de chaînes :  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 <xref:System.Collections.Generic.SortedList%602> est implémenté comme un tableau de paires clé/valeur, trié par la clé.  Chaque élément peut être récupéré comme un <xref:System.Collections.Generic.KeyValuePair%602> objet.  
  
 Les objets de clé doivent être immuables tant qu’ils sont utilisés comme clés dans le <xref:System.Collections.Generic.SortedList%602>. Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique. Une clé ne peut pas être `null`, mais une valeur peut être, si le type des valeurs dans la liste, `TValue`, est un type référence.  
  
 <xref:System.Collections.Generic.SortedList%602> nécessite une implémentation du comparateur pour trier et effectuer des comparaisons.  Le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable%601?displayProperty=nameWithType> et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable?displayProperty=nameWithType>.  Si le type de clé `TKey` n’implémente pas ces deux interfaces, vous pouvez spécifier un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implémentation dans une surcharge de constructeur qui accepte un `comparer` paramètre.  
  
 La capacité d’un <xref:System.Collections.Generic.SortedList%602> est le nombre d’éléments du <xref:System.Collections.Generic.SortedList%602> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.SortedList%602>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne. La capacité peut être diminuée en appelant <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> ou en définissant le <xref:System.Collections.Generic.SortedList%602.Capacity%2A> propriété explicitement. Réduction de la capacité réalloue la mémoire et copie tous les éléments dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 Pour les très volumineux <xref:System.Collections.Generic.SortedList%602> objets, vous pouvez augmenter la capacité maximale à 2 milliards des éléments sur un système 64 bits en définissant le `enabled` attribut de l’élément de configuration `true` dans l’environnement d’exécution.  
  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) retourne un objet du type des éléments dans la collection. Depuis les éléments de la <xref:System.Collections.Generic.SortedList%602> sont des paires clé/valeur, le type d’élément n’est pas le type de la clé ou le type de la valeur. Au lieu de cela, le type d’élément est <xref:System.Collections.Generic.KeyValuePair%602>. Exemple :  
  
 [!code-cpp[Generic.SortedList#12](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#12)]
 [!code-csharp[Generic.SortedList#12](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#12)]
 [!code-vb[Generic.SortedList#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#12)]  
  
 La `foreach` instruction est un wrapper autour de l’énumérateur, qui permet la lecture à partir n’écrit ne pas à la collection.  
  
   
  
## Examples  
 L’exemple de code suivant crée un vide <xref:System.Collections.Generic.SortedList%602> de chaînes avec des clés de chaîne et utilise le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode pour ajouter des éléments. L’exemple montre que le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode lève un <xref:System.ArgumentException> lorsque vous tentez d’ajouter une clé dupliquée.  
  
 L’exemple utilise le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété (l’indexeur en c#) pour récupérer des valeurs, ce qui démontre qu’un <xref:System.Collections.Generic.KeyNotFoundException> est levée lorsqu’une clé demandée n’est pas présente et indiquant que la valeur associée à une clé peut être remplacée.  
  
 L’exemple montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> méthode comme un moyen plus efficace pour récupérer des valeurs si un programme doit souvent essayer des valeurs de clés qui ne sont pas dans la liste triée, et il montre comment utiliser la <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> méthode pour tester si une clé existe avant d’appeler le <xref:System.Collections.Generic.SortedList%602.Add%2A> (méthode).  
  
 L’exemple montre comment énumérer les clés et valeurs dans la liste triée et comment énumérer les clés et valeurs seules à l’aide du <xref:System.Collections.Generic.SortedList%602.Keys%2A> propriété et le <xref:System.Collections.Generic.SortedList%602.Values%2A> propriété.  
  
 Enfin, l’exemple montre le <xref:System.Collections.Generic.SortedList%602.Remove%2A> (méthode).  
  
 [!code-cpp[Generic.SortedList#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.SortedList#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#1)]
 [!code-vb[Generic.SortedList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  Un <see cref="T:System.Collections.Generic.SortedList`2" /> peut prendre en charge plusieurs lecteurs simultanément, tant que la collection n’est pas modifiée.  Même dans ce cas, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedDictionary`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IComparer`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" /> qui est vide, possède la capacité initiale par défaut et utilise le <see cref="T:System.Collections.Generic.IComparer`1" /> par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique selon le comparateur par défaut.  
  
 Ce constructeur utilise la valeur par défaut pour la capacité initiale de la <xref:System.Collections.Generic.SortedList%602>. Pour définir la capacité initiale, utilisez le <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%29> constructeur. Si la taille finale de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.SortedList%602>.  
  
 Ce constructeur utilise le comparateur par défaut `TKey`. Pour spécifier un comparateur, utilisez le <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> constructeur. Le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable%601?displayProperty=nameWithType> et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable?displayProperty=nameWithType>.  Si le type de clé `TKey` n’implémente pas ces deux interfaces, vous pouvez spécifier un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implémentation dans une surcharge de constructeur qui accepte un `comparer` paramètre.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée un vide <xref:System.Collections.Generic.SortedList%602> de chaînes avec des clés de chaîne et utilise le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode pour ajouter des éléments. L’exemple montre que le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode lève un <xref:System.ArgumentException> lorsque vous tentez d’ajouter une clé dupliquée.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser lors de la comparaison de clés.  -ou-  <see langword="null" /> pour utiliser <see cref="T:System.Collections.Generic.Comparer`1" /> par défaut pour le type de la clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" /> qui est vide, possède la capacité initiale par défaut et utilise le <see cref="T:System.Collections.Generic.IComparer`1" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique selon le comparateur spécifié.  
  
 Ce constructeur utilise la valeur par défaut pour la capacité initiale de la <xref:System.Collections.Generic.SortedList%602>. Pour définir la capacité initiale, utilisez le <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> constructeur. Si la taille finale de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.SortedList%602>.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée une liste triée avec un comparateur de non-respect de la casse pour la culture actuelle. L’exemple ajoute quatre éléments, certains avec des clés minuscules et autres avec des clés de majuscules. L’exemple essaie ensuite d’ajouter un élément avec une clé qui diffère d’une clé existante uniquement par la casse, intercepte l’exception résultante et affiche un message d’erreur. Enfin, l’exemple affiche les éléments dans l’ordre de tri respectant la casse.  
  
 [!code-csharp[Generic.SortedList.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">
          <see cref="T:System.Collections.Generic.IDictionary`2" /> dont les éléments sont copiés dans le nouveau <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" /> qui contient des éléments copiés à partir du <see cref="T:System.Collections.Generic.IDictionary`2" /> spécifié, possède une capacité suffisante pour accepter le nombre d'éléments copiés et utilise le <see cref="T:System.Collections.Generic.IComparer`1" /> par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique en fonction de la valeur par défaut comparateur ; de même, chaque clé dans la source `dictionary` doit également être unique selon le comparateur par défaut.  
  
 La capacité de la nouvelle <xref:System.Collections.Generic.SortedList%602> est défini sur le nombre d’éléments dans `dictionary`, donc aucun redimensionnement n’intervient au moment du remplissage de la liste.  
  
 Ce constructeur utilise le comparateur par défaut `TKey`. Pour spécifier un comparateur, utilisez le <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> constructeur. Le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable%601?displayProperty=nameWithType> et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable?displayProperty=nameWithType>.  Si le type de clé `TKey` n’implémente pas ces deux interfaces, vous pouvez spécifier un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implémentation dans une surcharge de constructeur qui accepte un `comparer` paramètre.  
  
 Si les données dans `dictionary` sont triées, ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `dictionary`. Dans le cas contraire, c’est un O (`n`*`n`) opération.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Collections.Generic.SortedList%602> pour créer une copie triée des informations dans un <xref:System.Collections.Generic.Dictionary%602>, en passant le <xref:System.Collections.Generic.Dictionary%602> à la <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%29> constructeur.  
  
 [!code-csharp[Generic.SortedList.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contient une ou plusieurs clés en double.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : int -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre initial d'éléments que <see cref="T:System.Collections.Generic.SortedList`2" /> peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" /> qui est vide, possède la capacité initiale spécifiée et utilise le <see cref="T:System.Collections.Generic.IComparer`1" /> par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique selon le comparateur par défaut.  
  
 La capacité d’un <xref:System.Collections.Generic.SortedList%602> est le nombre d’éléments qui le <xref:System.Collections.Generic.SortedList%602> peut contenir avant redimensionnement. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.SortedList%602>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.SortedList%602>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> ou en définissant le <xref:System.Collections.Generic.SortedList%602.Capacity%2A> propriété explicitement. Réduction de la capacité réalloue la mémoire et copie tous les éléments dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 Ce constructeur utilise le comparateur par défaut `TKey`. Pour spécifier un comparateur, utilisez le <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> constructeur. Le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable%601?displayProperty=nameWithType> et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type de la clé `TKey` implémente <xref:System.IComparable?displayProperty=nameWithType>.  Si le type de clé `TKey` n’implémente pas ces deux interfaces, vous pouvez spécifier un <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> implémentation dans une surcharge de constructeur qui accepte un `comparer` paramètre.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
   
  
## Examples  
 L’exemple de code suivant crée une liste triée avec une capacité initiale de 4 et le remplit avec 4 entrées.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">
          <see cref="T:System.Collections.Generic.IDictionary`2" /> dont les éléments sont copiés dans le nouveau <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser lors de la comparaison de clés.  -ou-  <see langword="null" /> pour utiliser <see cref="T:System.Collections.Generic.Comparer`1" /> par défaut pour le type de la clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" /> qui contient des éléments copiés à partir du <see cref="T:System.Collections.Generic.IDictionary`2" /> spécifié, possède une capacité suffisante pour accepter le nombre d'éléments copiés et utilise le <see cref="T:System.Collections.Generic.IComparer`1" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique selon le comparateur ; de même, chaque clé dans la source `dictionary` doit également être unique selon le comparateur spécifié.  
  
 La capacité de la nouvelle <xref:System.Collections.Generic.SortedList%602> est défini sur le nombre d’éléments dans `dictionary`, donc aucun redimensionnement n’intervient au moment du remplissage de la liste.  
  
 Si les données dans `dictionary` sont triées, ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `dictionary`. Dans le cas contraire, c’est un O (`n`*`n`) opération.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Collections.Generic.SortedList%602> pour créer un non-respect de la casse triée copie des informations dans un non-respect de la casse <xref:System.Collections.Generic.Dictionary%602>, en passant le <xref:System.Collections.Generic.Dictionary%602> à la <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> constructeur. Dans cet exemple, les comparateurs de non-respect de la casse sont pour la culture actuelle.  
  
 [!code-csharp[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> contient une ou plusieurs clés en double.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int capacity, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre initial d'éléments que <see cref="T:System.Collections.Generic.SortedList`2" /> peut contenir.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser lors de la comparaison de clés.  -ou-  <see langword="null" /> pour utiliser <see cref="T:System.Collections.Generic.Comparer`1" /> par défaut pour le type de la clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.SortedList`2" /> qui est vide, possède la capacité initiale spécifiée et utilise le <see cref="T:System.Collections.Generic.IComparer`1" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans un <xref:System.Collections.Generic.SortedList%602> doit être unique selon le comparateur spécifié.  
  
 La capacité d’un <xref:System.Collections.Generic.SortedList%602> est le nombre d’éléments qui le <xref:System.Collections.Generic.SortedList%602> peut contenir avant redimensionnement. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.SortedList%602>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.SortedList%602>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> ou en définissant le <xref:System.Collections.Generic.SortedList%602.Capacity%2A> propriété explicitement. Réduction de la capacité réalloue la mémoire et copie tous les éléments dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
   
  
## Examples  
 L’exemple de code suivant crée une liste triée avec une capacité initiale de 5 et un comparateur de non-respect de la casse pour la culture actuelle. L’exemple ajoute quatre éléments, certains avec des clés minuscules et autres avec des clés de majuscules. L’exemple essaie ensuite d’ajouter un élément avec une clé qui diffère d’une clé existante uniquement par la casse, intercepte l’exception résultante et affiche un message d’erreur. Enfin, l’exemple affiche les éléments dans l’ordre de tri respectant la casse.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à ajouter.</param>
        <param name="value">Valeur de l'élément à ajouter. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Ajoute un élément avec la clé et la valeur spécifiées dans <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une clé ne peut pas être `null`, mais une valeur peut être, si le type des valeurs dans la liste triée, `TValue`, est un type référence.  
  
 Vous pouvez également utiliser le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:System.Collections.Generic.SortedList%602>; par exemple, `myCollection["myNonexistentKey"] = myValue`. Toutefois, si la clé spécifiée existe déjà dans le <xref:System.Collections.Generic.SortedList%602>, ce qui affecte le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Si <xref:System.Collections.Generic.SortedList%602.Count%2A> est déjà égale à <xref:System.Collections.Generic.SortedList%602.Capacity%2A>, la capacité de la <xref:System.Collections.Generic.SortedList%602> est augmentée en réallouant automatiquement le tableau interne, et les éléments existants sont copiés vers le nouveau tableau avant le nouvel élément est ajouté.  
  
 Cette méthode est un O (`n`) opération pour les données non triées, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>. C’est un O (log `n`) opération si le nouvel élément est ajouté à la fin de la liste. Si l’insertion conduit à un redimensionnement, l’opération est O (`n`).  
  
   
  
## Examples  
 L’exemple de code suivant crée un vide <xref:System.Collections.Generic.SortedList%602> de chaînes avec des clés de chaîne et utilise le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode pour ajouter des éléments. L’exemple montre que le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode lève un <xref:System.ArgumentException> lorsque vous tentez d’ajouter une clé dupliquée.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un élément possédant la même clé existe déjà dans <see cref="T:System.Collections.Generic.SortedList`2" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre d'éléments que <see cref="T:System.Collections.Generic.SortedList`2" /> peut contenir.</summary>
        <value>Nombre initial d'éléments que <see cref="T:System.Collections.Generic.SortedList`2" /> peut contenir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> est le nombre d’éléments qui le <xref:System.Collections.Generic.SortedList%602> peut stocker. <xref:System.Collections.Generic.SortedList%602.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> est toujours supérieur ou égal à <xref:System.Collections.Generic.SortedList%602.Count%2A>. Si <xref:System.Collections.Generic.SortedList%602.Count%2A> dépasse <xref:System.Collections.Generic.SortedList%602.Capacity%2A> lors de l’ajout d’éléments, la capacité est augmentée en réallouant automatiquement le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> ou en définissant le <xref:System.Collections.Generic.SortedList%602.Capacity%2A> propriété explicitement. Lorsque la valeur de <xref:System.Collections.Generic.SortedList%602.Capacity%2A> n’est défini explicitement, le tableau interne est également réalloué pour prendre en charge de la capacité spécifiée.  
  
 Récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est un O (`n`) opération, où `n` est la nouvelle capacité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à <see cref="P:System.Collections.Generic.SortedList`2.Capacity" /> est inférieure à <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’y a pas assez de mémoire disponible sur le système.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Count%2A> est défini sur zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> reste inchangé. Pour rétablir la capacité de la <xref:System.Collections.Generic.SortedList%602>, appelez <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> ou définir le <xref:System.Collections.Generic.SortedList%602.Capacity%2A> propriété directement. Suppression vide <xref:System.Collections.Generic.SortedList%602> définit la capacité de la <xref:System.Collections.Generic.SortedList%602> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient <see cref="T:System.Collections.Generic.IComparer`1" /> pour la liste triée.</summary>
        <value>
          <see cref="T:System.IComparable`1" /> pour la <see cref="T:System.Collections.Generic.SortedList`2" /> actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.Generic.SortedList`2" /> contient une clé spécifique.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Collections.Generic.SortedList`2" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> méthode pour tester si une clé existe avant d’appeler le <xref:System.Collections.Generic.SortedList%602.Add%2A> (méthode). Il montre également comment utiliser le <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> méthode pour récupérer des valeurs, qui est un moyen efficace pour récupérer des valeurs lorsqu’un programme essaie fréquemment des clés qui ne sont pas dans la liste triée. Enfin, il montre le moyen le moins efficace pour tester si les clés existent, à l’aide de la <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété (l’indexeur en c#).  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#6)]
 [!code-csharp[Generic.SortedList#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#6)]
 [!code-vb[Generic.SortedList#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#6)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à trouver dans <see cref="T:System.Collections.Generic.SortedList`2" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Détermine si <see cref="T:System.Collections.Generic.SortedList`2" /> contient une valeur spécifique.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Collections.Generic.SortedList`2" /> contient un élément correspondant à la valeur spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> pour le type de valeur `TValue`.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si la valeur de type `TValue` implémente <xref:System.IComparable%601?displayProperty=nameWithType> et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si la valeur de type `TValue` implémente <xref:System.IComparable?displayProperty=nameWithType>.  Si la valeur de type `TValue` n’implémente aucune interface, cette méthode utilise <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, la durée d’exécution moyenne est proportionnelle à <xref:System.Collections.Generic.SortedList%602.Count%2A>. Autrement dit, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de paires clé/valeur contenues dans <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <value>Nombre de paires clé/valeur contenues dans <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> est le nombre d’éléments qui le <xref:System.Collections.Generic.SortedList%602> peut stocker. <xref:System.Collections.Generic.SortedList%602.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> est toujours supérieur ou égal à <xref:System.Collections.Generic.SortedList%602.Count%2A>. Si <xref:System.Collections.Generic.SortedList%602.Count%2A> dépasse <xref:System.Collections.Generic.SortedList%602.Capacity%2A> lors de l’ajout d’éléments, la capacité est augmentée en réallouant automatiquement le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> de type <see cref="T:System.Collections.Generic.KeyValuePair`2" /> pour <see cref="T:System.Collections.Generic.SortedList`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Le dictionnaire est maintenu dans un ordre trié à l’aide d’une arborescence interne. Chaque nouvel élément est positionné à la position de tri correct, et l’arborescence est ajustée pour maintenir l’ordre de tri chaque fois qu’un élément est supprimé. Lors de l’énumération, l’ordre de tri est conservé.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> retourne le même objet jusqu'à ce que <xref:System.Collections.IEnumerator.MoveNext%2A> soit appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.IEnumerator%601.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public int IndexOfKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfKey (key As TKey) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfKey(TKey key);" />
      <MemberSignature Language="F#" Value="member this.IndexOfKey : 'Key -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Recherche la clé spécifiée et retourne l'index de base zéro dans le <see cref="T:System.Collections.Generic.SortedList`2" /> entier.</summary>
        <returns>Index de base zéro de <paramref name="key" /> dans le <see cref="T:System.Collections.Generic.SortedList`2" /> entier, si elle existe ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une recherche binaire ; Par conséquent, cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public int IndexOfValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfValue (value As TValue) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.IndexOfValue : 'Value -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à trouver dans <see cref="T:System.Collections.Generic.SortedList`2" />.  La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Recherche la valeur spécifiée et retourne l'index de base zéro de la première occurrence dans l'ensemble du <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="value" /> dans l'ensemble du <see cref="T:System.Collections.Generic.SortedList`2" />, s'il existe ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> pour le type de valeur `TValue`.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si la valeur de type `TValue` implémente <xref:System.IComparable%601?displayProperty=nameWithType> et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si la valeur de type `TValue` implémente <xref:System.IComparable?displayProperty=nameWithType>.  Si la valeur de type `TValue` n’implémente aucune interface, cette méthode utilise <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, la durée d’exécution moyenne est proportionnelle à <xref:System.Collections.Generic.SortedList%602.Count%2A>. Autrement dit, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé dont la valeur doit être obtenue ou définie.</param>
        <summary>Obtient ou définit la valeur associée à la clé spécifiée.</summary>
        <value>Valeur associée à la clé spécifiée. Si la clé spécifiée est introuvable, une opération Get retourne <see cref="T:System.Collections.Generic.KeyNotFoundException" /> et une opération Set crée un élément à l'aide de la clé spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d'accéder à un élément spécifique de la collection à l'aide de la syntaxe suivante : `myCollection[key]`.  
  
 Une clé ne peut pas être `null`, mais une valeur peut être, si le type des valeurs dans la liste, `TValue`, est un type référence.  
  
 Si la clé est introuvable lorsqu’une valeur est récupérée, <xref:System.Collections.Generic.KeyNotFoundException> est levée. Si la clé est introuvable lorsqu’une valeur est définie, la clé et la valeur sont ajoutés.  
  
 Vous pouvez également utiliser le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:System.Collections.Generic.SortedList%602>; par exemple, `myCollection["myNonexistentKey"] = myValue`. Toutefois, si la clé spécifiée existe déjà dans le <xref:System.Collections.Generic.SortedList%602>, ce qui affecte le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.Generic.SortedList%602.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Le langage c# utilise le mot clé pour définir les indexeurs au lieu d’implémenter le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété. Visual Basic implémente <xref:System.Collections.Generic.SortedList%602.Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 Récupération de la valeur de cette propriété est un O (log `n`) opération, où n est <xref:System.Collections.Generic.SortedList%602.Count%2A>. Définition de la propriété est un O (log `n`) opération si la clé est déjà dans le <xref:System.Collections.Generic.SortedList%602>. Si la clé n’est pas dans la liste, la propriété est un O (`n`) opération pour les données non triées, ou O (log `n`) si le nouvel élément est ajouté à la fin de la liste. Si l’insertion conduit à un redimensionnement, l’opération est O (`n`).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété (l’indexeur en c#) pour récupérer des valeurs, ce qui démontre qu’un <xref:System.Collections.Generic.KeyNotFoundException> est levée lorsqu’une clé demandée n’est pas présente et indiquant que la valeur associée à une clé peut être remplacée.  
  
 L’exemple montre également comment utiliser le <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> méthode comme un moyen plus efficace pour récupérer des valeurs si un programme doit souvent essayer des valeurs de clés qui ne sont pas dans la liste triée.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#3)]
 [!code-csharp[Generic.SortedList#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#3)]
 [!code-vb[Generic.SortedList#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#3)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">La propriété est récupérée et <paramref name="key" /> n'existe pas dans la collection.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As IList(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;TKey&gt; ^ Keys { System::Collections::Generic::IList&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.IList&lt;'Key&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection contenant les clés de la <see cref="T:System.Collections.Generic.SortedList`2" />, dans un ordre trié.</summary>
        <value>
          <see cref="T:System.Collections.Generic.IList`1" /> contenant les clés de <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des clés dans le <xref:System.Collections.Generic.IList%601> est le même que l’ordre dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 Retourné <xref:System.Collections.Generic.IList%601> n’est pas une copie statique ; au lieu de cela, le <xref:System.Collections.Generic.IList%601> fait référence aux clés dans la version d’origine <xref:System.Collections.Generic.SortedList%602>. Par conséquent, remplace le <xref:System.Collections.Generic.SortedList%602> continuent d’être répercutées dans le <xref:System.Collections.Generic.IList%601>.  
  
 La collection retournée par la <xref:System.Collections.Generic.SortedList%602.Keys%2A> propriété constitue un moyen efficace pour récupérer les clés par index. Il n’est pas nécessaire de régénérer la liste lors de la propriété est accessible, car la liste est un simple wrapper pour le tableau interne de clés. Le code suivant illustre l’utilisation de la <xref:System.Collections.Generic.SortedList%602.Keys%2A> propriété pour la récupération indexée de clés à partir d’une liste triée d’éléments avec des clés de chaîne :  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment énumérer les clés de la liste triée à l’aide de la <xref:System.Collections.Generic.SortedList%602.Keys%2A> propriété et comment énumérer les clés et valeurs dans la liste triée.  
  
 L’exemple montre également comment utiliser le <xref:System.Collections.Generic.SortedList%602.Keys%2A> propriété pour une récupération indexée efficace des clés.  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.SortedList%602>.  
  
 [!code-cpp[Generic.SortedList#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#9)]
 [!code-csharp[Generic.SortedList#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#9)]
 [!code-vb[Generic.SortedList#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#9)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à supprimer.</param>
        <summary>Supprime de <see cref="T:System.Collections.Generic.SortedList`2" /> l'élément ayant la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si la suppression de l'élément réussit ; sinon, <see langword="false" />.  Cette méthode retourne également <see langword="false" /> si <paramref name="key" /> est introuvable dans le <see cref="T:System.Collections.Generic.SortedList`2" /> d'origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une recherche binaire ; Toutefois, les éléments sont montés pour remplir l’emplacement ouvert, donc cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment supprimer une paire clé/valeur à partir de la liste triée à l’aide de la <xref:System.Collections.Generic.SortedList%602.Remove%2A> (méthode).  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#10)]
 [!code-csharp[Generic.SortedList#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#10)]
 [!code-vb[Generic.SortedList#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à supprimer.</param>
        <summary>Supprime l'élément au niveau de l'index spécifié de <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une recherche binaire ; Toutefois, les éléments sont montés pour remplir l’emplacement ouvert, donc cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro.  -ou-  <paramref name="index" /> est supérieur ou égal à <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), arrayIndex As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans un <c>tableau</c> auquel commencer la copie.</param>
        <summary>Copie les éléments de <see cref="T:System.Collections.ICollection" /> dans <see cref="T:System.Array" />, à partir d'un index particulier de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si le type de la source <xref:System.Collections.ICollection> ne peut pas être casté automatiquement au type de la destination `array`, les implémentations non génériques de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> lever <xref:System.InvalidCastException>, tandis que les implémentations génériques lèvent <xref:System.ArgumentException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> est multidimensionnel.  -ou- <paramref name="array" /> n’a pas d’indexation de base zéro.  -ou- Le nombre d’éléments du <see cref="T:System.Collections.ICollection" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.  -ou- Le type du <see cref="T:System.Collections.ICollection" /> source ne peut pas être casté automatiquement en type du <paramref name="array" /> de destination.</exception>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
        <value>
          <see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.SortedList`2" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Le <xref:System.Collections.ICollection.SyncRoot%2A> propriété retourne un objet qui peut être utilisé pour synchroniser l’accès à la <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.SortedList`2" />, cette propriété retourne toujours l'instance actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération. Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Le <xref:System.Collections.ICollection.SyncRoot%2A> propriété retourne un objet qui peut être utilisé pour synchroniser l’accès à la <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection. Le code suivant illustre l’utilisation de la <xref:System.Collections.ICollection.SyncRoot%2A> propriété pour c#, C++ et Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Object" /> à utiliser comme clé de l'élément à ajouter.</param>
        <param name="value">
          <see cref="T:System.Object" /> à utiliser comme valeur de l'élément à ajouter.</param>
        <summary>Ajoute un élément avec la clé et la valeur fournies à <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également utiliser le <xref:System.Collections.IDictionary.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le dictionnaire ; par exemple, `myCollection["myNonexistentKey"] = myValue`. Toutefois, si la clé spécifiée existe déjà dans le dictionnaire, la définition du <xref:System.Collections.IDictionary.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.IDictionary.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Cette méthode est un O (`n`) opération pour les données non triées, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>. C’est un O (log `n`) opération si le nouvel élément est ajouté à la fin de la liste. Si l’insertion conduit à un redimensionnement, l’opération est O (`n`).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment accéder à la <xref:System.Collections.Generic.SortedList%602> classe via la <xref:System.Collections.IDictionary?displayProperty=nameWithType> interface. L’exemple de code crée un vide <xref:System.Collections.Generic.SortedList%602> de chaînes avec des clés de chaîne et utilise le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> méthode pour ajouter des éléments. L’exemple montre que le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> méthode lève un <xref:System.ArgumentException> lorsque vous tentez d’ajouter une clé dupliquée ou lorsqu’une clé ou une valeur de type de données incorrect est fournie.  
  
 L’exemple de code illustre l’utilisation de plusieurs autres membres de la <xref:System.Collections.IDictionary?displayProperty=nameWithType> interface.  
  
 [!code-csharp[Generic.SortedList.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> a un type qui ne peut pas être assigné au type de clé <paramref name="TKey" /> de <see cref="T:System.Collections.IDictionary" />.  -ou- <paramref name="value" /> a un type qui ne peut pas être attribué au type valeur <paramref name="TValue" /> du <see cref="T:System.Collections.IDictionary" />.  -ou- Un élément avec la même clé existe déjà dans le <see cref="T:System.Collections.IDictionary" />.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.IDictionary" /> contient un élément avec la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Collections.IDictionary" /> contient un élément avec la clé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `false` si `key` est d’un type qui n’est pas attribuable au type de clé `TKey` de la <xref:System.Collections.Generic.SortedList%602>.  
  
 Cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Contains%2A> méthode de la <xref:System.Collections.IDictionary?displayProperty=nameWithType> créent une interface avec un <xref:System.Collections.Generic.SortedList%602>. L’exemple montre que la méthode retourne `false` si une clé de type de données incorrect est fournie.  
  
 L’exemple de code fait partie d’un exemple plus complet, y compris la sortie, fournie pour le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> (méthode).  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedList.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne <see cref="T:System.Collections.IDictionaryEnumerator" /> pour l'objet <see cref="T:System.Collections.IDictionary" />.</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> pour <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IDictionaryEnumerator.Entry%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment énumérer les paires clé/valeur dans la liste triée à l’aide de la `foreach` instruction (`For Each` en Visual Basic, `for each` en C++), qui masque l’utilisation de l’énumérateur. En particulier, notez que l’énumérateur pour le <xref:System.Collections.IDictionary?displayProperty=nameWithType> interface retourne <xref:System.Collections.DictionaryEntry> objets plutôt que <xref:System.Collections.Generic.KeyValuePair%602> objets.  
  
 L’exemple de code fait partie d’un exemple plus complet, y compris la sortie, fournie pour le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> (méthode).  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.IDictionary" /> est de taille fixe.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Collections.IDictionary" /> est de taille fixe ; sinon, <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.SortedList`2" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection de taille fixe ne permet pas l’ajout ou la suppression d’éléments après sa création, mais permet la modification des éléments existants.  
  
 Une collection avec une taille fixe est simplement une collection avec un wrapper qui empêche l’ajout et suppression d’éléments. Par conséquent, si des modifications sont apportées à la collection sous-jacente, y compris l’ajout ou la suppression d’éléments, la collection de taille fixe reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IDictionary.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.IDictionary" /> est en lecture seule.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Collections.IDictionary" /> est en lecture seule ; sinon, <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.SortedList`2" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.  
  
 Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IDictionary.Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à obtenir ou définir.</param>
        <summary>Obtient ou définit l'élément à l'aide de la clé spécifiée.</summary>
        <value>Élément avec la clé spécifiée, ou <see langword="null" /> si <paramref name="key" /> ne figure pas dans le dictionnaire ou si le type de <paramref name="key" /> ne peut pas être assigné au type de clé <paramref name="TKey" /> de <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `null` si `key` est d’un type qui n’est pas attribuable au type de clé `TKey` de la <xref:System.Collections.Generic.SortedList%602>.  
  
 Cette propriété permet d'accéder à un élément spécifique de la collection à l'aide de la syntaxe suivante : `myCollection[key]`.  
  
 Vous pouvez également utiliser le <xref:System.Collections.IDictionary.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le dictionnaire ; par exemple, `myCollection["myNonexistentKey"] = myValue`. Toutefois, si la clé spécifiée existe déjà dans le dictionnaire, la définition du <xref:System.Collections.IDictionary.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.IDictionary.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Le langage c# utilise le [cela](~/docs/csharp/language-reference/keywords/this.md) mot clé pour définir les indexeurs au lieu d’implémenter le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> propriété. Visual Basic implémente <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 Récupération de la valeur de cette propriété est un O (log `n`) opération, où n est <xref:System.Collections.Generic.SortedList%602.Count%2A>. Définition de la propriété est un O (log `n`) opération si la clé est déjà dans le <xref:System.Collections.Generic.SortedList%602>. Si la clé n’est pas dans la liste, la propriété est un O (`n`) opération pour les données non triées, ou O (log `n`) si le nouvel élément est ajouté à la fin de la liste. Si l’insertion conduit à un redimensionnement, l’opération est O (`n`).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> propriété (l’indexeur en c#) de la <xref:System.Collections.IDictionary?displayProperty=nameWithType> créent une interface avec un <xref:System.Collections.Generic.SortedList%602>et les différences entre la propriété le <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> propriété.  
  
 L’exemple montre que, comme le <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> propriété, le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> propriété peut modifier la valeur associée à une clé existante et peut être utilisée pour ajouter une nouvelle paire clé/valeur si la clé spécifiée n’est pas dans la liste triée. L’exemple montre également que contrairement à la <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> propriété, le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> propriété ne lève pas d’exception si `key` ne figure pas dans la liste triée, mais retourne une référence null. Enfin, l’exemple montre que l’obtention du <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> propriété retourne une référence null si `key` n’est pas le type de données correcte et que la définition de la propriété lève une exception si `key` n’est pas le type de données correct.  
  
 L’exemple de code fait partie d’un exemple plus complet, y compris la sortie, fournie pour le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> (méthode).  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedList.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedList.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedList.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une valeur est assignée et <paramref name="key" /> a un type qui ne peut pas être assigné au type de clé <paramref name="TKey" /> de <see cref="T:System.Collections.Generic.SortedList`2" />.  -ou- Une valeur est attribuée et <paramref name="value" /> a un type qui ne peut pas être attribué au type valeur <paramref name="TValue" /> du <see cref="T:System.Collections.Generic.SortedList`2" />.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Collections.ICollection" /> contenant les clés de <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> contenant les clés de <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des clés dans le <xref:System.Collections.ICollection> est le même que l’ordre dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.IDictionary.Keys%2A> propriété de la <xref:System.Collections.IDictionary?displayProperty=nameWithType> créent une interface avec un <xref:System.Collections.Generic.SortedDictionary%602>, pour répertorier les clés dans le dictionnaire. L’exemple montre également comment énumérer les paires clé/valeur dans la liste triée ; Notez que l’énumérateur pour le <xref:System.Collections.IDictionary?displayProperty=nameWithType> interface retourne <xref:System.Collections.DictionaryEntry> objets plutôt que <xref:System.Collections.Generic.KeyValuePair%602> objets.  
  
 L’exemple de code fait partie d’un exemple plus complet, y compris la sortie, fournie pour le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> (méthode).  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedList.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à supprimer.</param>
        <summary>Supprime de <see cref="T:System.Collections.IDictionary" /> l'élément ayant la clé spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une recherche binaire ; Toutefois, les éléments sont montés pour remplir l’emplacement ouvert, donc cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Remove%2A> de la <xref:System.Collections.IDictionary?displayProperty=nameWithType> créent une interface avec un <xref:System.Collections.Generic.SortedList%602>.  
  
 L’exemple de code fait partie d’un exemple plus complet, y compris la sortie, fournie pour le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> (méthode).  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedList.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System.Collections.IDictionary.Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient <see cref="T:System.Collections.ICollection" /> contenant les valeurs de <see cref="T:System.Collections.IDictionary" />.</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> contenant les valeurs de <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des valeurs dans le <xref:System.Collections.ICollection> est le même que l’ordre dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Values%2A> propriété de la <xref:System.Collections.IDictionary?displayProperty=nameWithType> créent une interface avec un <xref:System.Collections.Generic.SortedList%602>, pour répertorier les valeurs dans la liste triée. L’exemple montre également comment énumérer les paires clé/valeur dans la liste triée ; Notez que l’énumérateur pour le <xref:System.Collections.IDictionary?displayProperty=nameWithType> interface retourne <xref:System.Collections.DictionaryEntry> objets plutôt que <xref:System.Collections.Generic.KeyValuePair%602> objets.  
  
 L’exemple de code fait partie d’un exemple plus complet, y compris la sortie, fournie pour le <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> (méthode).  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedList.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="sortedList.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit la capacité au nombre réel d'éléments dans <see cref="T:System.Collections.Generic.SortedList`2" />, si ce nombre est inférieur à 90 pour cent de la capacité actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour réduire une surcharge de mémoire d’une collection si aucun nouvel élément ne doit être ajouté à la collection. Le coût de réallocation et de copie d’un grand <xref:System.Collections.Generic.SortedList%602> peut être considérable, toutefois, par conséquent, le <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> méthode ne fait rien si la liste est à plus de 90 pour cent de la capacité. Cela évite de devoir engager un coût de réallocation élevé pour un gain relativement faible.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 Pour réinitialiser un <xref:System.Collections.Generic.SortedList%602> à son état initial, appelez le <xref:System.Collections.Generic.SortedList%602.Clear%2A> méthode avant d’appeler <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> (méthode). Suppression vide <xref:System.Collections.Generic.SortedList%602> définit la capacité de la <xref:System.Collections.Generic.SortedList%602> à la capacité par défaut.  
  
 La capacité peut également être définie à l’aide de la <xref:System.Collections.Generic.SortedList%602.Capacity%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="sortedList.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Clé dont la valeur doit être obtenue.</param>
        <param name="value">Quand cette méthode retourne une valeur, valeur associée à la clé spécifiée, si la clé est trouvée ; sinon, valeur par défaut du type du paramètre <c>value</c>. Ce paramètre est passé sans être initialisé.</param>
        <summary>Obtient la valeur associée à la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Collections.Generic.SortedList`2" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode combine les fonctionnalités de la <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> (méthode) et le <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété.  
  
 Si la clé est introuvable, la `value` paramètre Obtient la valeur par défaut appropriée pour le type de valeur `TValue`; par exemple, zéro (0) pour les types d’entiers, `false` pour les types booléens et `null` pour les types référence.  
  
 Cette méthode effectue une recherche binaire ; Par conséquent, cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 L’exemple montre comment utiliser le <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> méthode comme un moyen plus efficace pour récupérer des valeurs dans un programme qui essaye souvent des clés qui ne sont pas dans la liste triée. Contraste, l’exemple montre également comment la <xref:System.Collections.Generic.SortedList%602.Item%2A> propriété (l’indexeur en c#) lève des exceptions lorsque vous tentez de récupérer les clés qui n’existe pas.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
 [!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
 [!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As IList(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;TValue&gt; ^ Values { System::Collections::Generic::IList&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.IList&lt;'Value&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection contenant les valeurs dans <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <value>
          <see cref="T:System.Collections.Generic.IList`1" /> contenant les valeurs de <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des valeurs dans le <xref:System.Collections.Generic.IList%601> est le même que l’ordre dans le <xref:System.Collections.Generic.SortedList%602>.  
  
 Retourné <xref:System.Collections.Generic.IList%601> n’est pas une copie statique ; au lieu de cela, le <xref:System.Collections.Generic.IList%601> fait référence aux valeurs d’origine <xref:System.Collections.Generic.SortedList%602>. Par conséquent, remplace le <xref:System.Collections.Generic.SortedList%602> continuent d’être répercutées dans le <xref:System.Collections.Generic.IList%601>.  
  
 La collection retournée par la <xref:System.Collections.Generic.SortedList%602.Values%2A> propriété constitue un moyen efficace pour récupérer des valeurs par index. Il n’est pas nécessaire de régénérer la liste lors de la propriété est accessible, car la liste est un simple wrapper pour le tableau interne de valeurs. Le code suivant illustre l’utilisation de la <xref:System.Collections.Generic.SortedList%602.Values%2A> propriété pour la récupération indexée de valeurs à partir d’une liste triée de chaînes :  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 Cet exemple de code montre comment énumérer les valeurs dans la liste triée à l’aide de la <xref:System.Collections.Generic.SortedList%602.Values%2A> propriété et comment énumérer les clés et valeurs dans la liste triée.  
  
 L’exemple montre également comment utiliser le <xref:System.Collections.Generic.SortedList%602.Values%2A> propriété pour une récupération indexée efficace des valeurs.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Collections.Generic.SortedList%602> classe.  
  
 [!code-cpp[Generic.SortedList#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#8)]
 [!code-csharp[Generic.SortedList#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#8)]
 [!code-vb[Generic.SortedList#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#8)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>