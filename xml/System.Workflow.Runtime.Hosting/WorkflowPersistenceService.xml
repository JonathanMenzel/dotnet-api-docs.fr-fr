<Type Name="WorkflowPersistenceService" FullName="System.Workflow.Runtime.Hosting.WorkflowPersistenceService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c742a078c39671956d687e07cbccd410cf37853f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39821071" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WorkflowPersistenceService : System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WorkflowPersistenceService extends System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WorkflowPersistenceService&#xA;Inherits WorkflowRuntimeService" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowPersistenceService abstract : System::Workflow::Runtime::Hosting::WorkflowRuntimeService" />
  <TypeSignature Language="F#" Value="type WorkflowPersistenceService = class&#xA;    inherit WorkflowRuntimeService" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Workflow.Runtime.Hosting.WorkflowRuntimeService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Classe de base abstraite à partir de laquelle tous les services de persistance sont dérivés.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Lorsque certaines conditions se produisent pendant que le workflow s'exécute, le moteur d'exécution de workflow rend persistantes les informations d'état relatives à l'instance de workflow. Par exemple, la persistance peut se produire lorsqu'une transaction atomique se termine, que l'instance de workflow devient inactive, que l'hôte appelle la méthode <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType> sur l'instance de workflow ou qu'une instance de workflow est terminée ou se termine. Lorsque la sémantique du moteur d'exécution de workflow détermine que la persistance doit avoir lieu, le moteur d'exécution de workflow appelle les méthodes fournies par un service de persistance pour enregistrer les informations d'état relatives à l'instance de workflow. De même, lorsque le moteur d'exécution de workflow doit restaurer une instance de workflow rendue persistante auparavant, il appelle les méthodes fournies par le service de persistance pour charger ces informations d'état. Le moteur d'exécution de workflow gère toute la sémantique ayant trait au moment de l'exécution de la persistance. Le service de persistance gère l'enregistrement et le chargement des informations d'état du workflow vers ou à partir d'une banque de données.  
  
 Vous pouvez créer un service de persistance en dérivant une classe de <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService>.  Vous pouvez ajouter un service de persistance au moteur d'exécution de workflow en appelant la méthode <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> ou en effectuant une entrée appropriée dans le fichier de configuration de l'application. La classe <xref:System.Workflow.Runtime.WorkflowRuntime> doit contenir un seul service de persistance. Windows Workflow Foundation fournit la classe <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, un service de persistance prédéfini, que vous pouvez utiliser tel quel ou développer.  
  
 Le moteur d'exécution de workflow dispose d'une sémantique qui permet de verrouiller les informations d'état du workflow à utiliser dans les environnements où les services de persistance qui s'exécutent dans des processus différents peuvent avoir accès à une banque de données unique. La classe <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> fournit la capacité de prise en charge de ces fonctionnalités du moteur d'exécution de workflow en fournissant un paramètre à la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> qui spécifie si les informations d'état d'une instance de workflow doivent être déverrouillées dans la banque de données et en fournissant une méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> pour déverrouiller les informations d'état du workflow verrouillées précédemment. Dans un service de persistance qui implémente le verrouillage, un appel à la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> doit pouvoir verrouiller les informations d'état d'une instance de workflow.  
  
 Votre service de persistance doit lever une classe <xref:System.Workflow.Runtime.Hosting.PersistenceException> s'il ne peut pas enregistrer les informations d'état dans sa banque de données ni charger les informations d'état depuis sa banque de données. Le moteur d'exécution de workflow prévoit ce comportement.  
  
 Un mécanisme de traitement par lots est fourni pour les services qui utilisent un magasin fiable pour enregistrer les informations d'état du workflow. Dans ces situations, il est souvent important de maintenir la cohérence entre le magasin fiable utilisé par le service de persistance et l'état interne du moteur d'exécution de workflow. Vous pouvez ajouter des fonctionnalités définies par l'interface <xref:System.Workflow.Runtime.IPendingWork> à votre service, puis participer au traitement par lots de la transaction de workflow fournie par la classe <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> en ajoutant des modifications à votre banque de données en tant qu'éléments de travail de la propriété <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Le magasin fiable lui-même doit implémenter l'interface <xref:System.Transactions.IEnlistmentNotification> afin que les informations de workflow ne deviennent pas incorrectement persistantes en cas de restauration d'une transaction. Pour plus d'informations, consultez <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity%2A> ou <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowPersistenceService ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WorkflowPersistenceService();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Lors de l'implémentation dans une classe dérivée, initialise une nouvelle instance de la classe <see cref="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant illustre la création d'une instance de la classe `SqlWorkflowPersistenceService` (dérivée de `WorkflowPersistenceService`). Il provient de l'exemple du Kit de développement Nested Exception Handlers et provient du fichier Program.cs.  Pour plus d’informations, consultez le [Nested Exception Handlers, exemple](http://msdn.microsoft.com/library/d1da0209-842b-41c8-9b7c-0cbaa1034265).  
  
 [!code-csharp[WF_Samples#161](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#161)]
 [!code-vb[WF_Samples#161](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static byte[] GetDefaultSerializedForm (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig unsigned int8[] GetDefaultSerializedForm(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static cli::array &lt;System::Byte&gt; ^ GetDefaultSerializedForm(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="static member GetDefaultSerializedForm : System.Workflow.ComponentModel.Activity -&gt; byte[]" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">Classe <see cref="T:System.Workflow.ComponentModel.Activity" /> dont la forme sérialisée est demandée.</param>
        <summary>Récupère la forme par défaut sérialisée de la classe <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
        <returns>Forme par défaut sérialisée de la classe <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsBlocked">
      <MemberSignature Language="C#" Value="protected internal static bool GetIsBlocked (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool GetIsBlocked(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetIsBlocked (rootActivity As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool GetIsBlocked(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetIsBlocked : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Activité racine de l'instance de workflow.</param>
        <summary>Indique si l'activité donnée est bloquée.</summary>
        <returns>
          <see langword="true" /> si l'activité donnée est bloquée; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSuspendOrTerminateInfo">
      <MemberSignature Language="C#" Value="protected internal static string GetSuspendOrTerminateInfo (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig string GetSuspendOrTerminateInfo(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetSuspendOrTerminateInfo (rootActivity As Activity) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::String ^ GetSuspendOrTerminateInfo(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetSuspendOrTerminateInfo : System.Workflow.ComponentModel.Activity -&gt; string" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Activité racine de l'instance de workflow.</param>
        <summary>Récupère l'arrêt ou interrompt les informations de l'activité donnée.</summary>
        <returns>
          <see cref="T:System.String" /> qui contient l'arrêt ou interrompt les informations.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowStatus">
      <MemberSignature Language="C#" Value="protected internal static System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig valuetype System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetWorkflowStatus (rootActivity As Activity) As WorkflowStatus" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::Workflow::Runtime::WorkflowStatus GetWorkflowStatus(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetWorkflowStatus : System.Workflow.ComponentModel.Activity -&gt; System.Workflow.Runtime.WorkflowStatus" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Activité racine de l'instance de workflow.</param>
        <summary>Récupère l'état du workflow.</summary>
        <returns>Valeur d'énumération <see cref="T:System.Workflow.Runtime.WorkflowStatus" /> qui dénote l'état du workflow.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadCompletedContextActivity (Guid scopeId, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadCompletedContextActivity(valuetype System.Guid scopeId, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity(System.Guid,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadCompletedContextActivity (scopeId As Guid, outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadCompletedContextActivity(Guid scopeId, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberSignature Language="F#" Value="abstract member LoadCompletedContextActivity : Guid * System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowPersistenceService.LoadCompletedContextActivity (scopeId, outerActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeId" Type="System.Guid" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="scopeId">
          <see cref="T:System.Guid" /> de l'objectif achevé.</param>
        <param name="outerActivity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> qui représente l'activité qui englobe l'objectif achevé.</param>
        <summary>En cas d'implémentation dans une classe dérivée, recharge l'objectif achevé spécifié en mémoire.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> qui représente l'objectif achevé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le moteur d'exécution de workflow utilise <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> pour implémenter la compensation. Vous devez restaurer une copie identique de l'objectif achevé. Pour ceci, vous devez restaurer une classe <xref:System.IO.Stream> valide de la représentation de l'objectif achevé dans la banque de données. Puis, vous devez passer la classe <xref:System.IO.Stream> à l'une des méthodes surchargées de la méthode <xref:System.Workflow.ComponentModel.Activity.Load%2A> pour exécuter la désérialisation de l'objectif.  
  
 Si votre service de persistance ne peut pas charger l'objectif achevé à partir de sa banque de données, il doit lever une classe <xref:System.Workflow.Runtime.Hosting.PersistenceException> avec un message approprié.  
  
   
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `LoadCompletedContextActivity`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadWorkflowInstanceState (instanceId As Guid) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadWorkflowInstanceState(Guid instanceId);" />
      <MemberSignature Language="F#" Value="abstract member LoadWorkflowInstanceState : Guid -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowPersistenceService.LoadWorkflowInstanceState instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">
          <see cref="T:System.Guid" /> de l'activité racine de l'instance de workflow.</param>
        <summary>En cas d'implémentation dans une classe dérivée, recharge l'état spécifié de l'instance de workflow en mémoire.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> représentant l'activité racine de l'instance de workflow.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez restaurer une copie identique de l'activité. Pour ceci, vous devez restaurer une classe <xref:System.IO.Stream> valide de la représentation de l'instance de workflow dans la banque de données ; puis, vous devez passer cette classe <xref:System.IO.Stream> à l'une des méthodes <xref:System.Workflow.ComponentModel.Activity.Load%2A> surchargées pour désérialiser l'état de l'instance de workflow. Si votre service de persistance ne peut pas charger l'état de l'instance de workflow à partir de sa banque de données, il doit lever une classe <xref:System.Workflow.Runtime.Hosting.PersistenceException> avec un message approprié.  
  
 Le moteur d'exécution de workflow implémente la sémantique de verrouillage pour restreindre l'accès à l'état d'une instance de workflow enregistrée dans une banque de données. Vous pouvez y accéder par les services de persistance qui s'exécutent dans plusieurs processus. La sémantique de verrouillage est conçue pour empêcher des services de persistance qui s'exécutent dans deux processus différents de charger en même temps la même instance de workflow en mémoire. Selon le type d'environnement que votre service de persistance peut prendre en charge, vous avez la possibilité d'utiliser ces fonctionnalités. Si vous choisissez de prendre en charge la sémantique de verrouillage d'exécution et si cet état de l'instance de workflow a été verrouillé auparavant par un autre processus, vous devez alors lever une classe <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Sinon, vous devez verrouiller l'accès à l'état de l'instance de workflow dans votre banque de données. L'état de l'instance de workflow peut être déverrouillé par un appel à la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> ou à <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>, le paramètres ayant la valeur `true`.  
  
   
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `LoadWorkflowInstanceState`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#266](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#266)]
 [!code-vb[WF_Samples#266](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#266)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFromDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm (byte[] activityBytes, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm(unsigned int8[] activityBytes, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm(System.Byte[],System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function RestoreFromDefaultSerializedForm (activityBytes As Byte(), outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Workflow::ComponentModel::Activity ^ RestoreFromDefaultSerializedForm(cli::array &lt;System::Byte&gt; ^ activityBytes, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberSignature Language="F#" Value="static member RestoreFromDefaultSerializedForm : byte[] * System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.Activity" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm (activityBytes, outerActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityBytes" Type="System.Byte[]" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activityBytes">Forme sérialisée de <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <param name="outerActivity">Classe <see cref="T:System.Workflow.ComponentModel.Activity" />externe, contenant la classe <see cref="T:System.Workflow.ComponentModel.Activity" /> à restaurer.</param>
        <summary>Restaure <see cref="T:System.Workflow.ComponentModel.Activity" /> depuis sa forme sérialisée.</summary>
        <returns>
          <see cref="T:System.Workflow.ComponentModel.Activity" /> restauré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `RestoreFromDefaultSerializedForm`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveCompletedContextActivity (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveCompletedContextActivity(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveCompletedContextActivity(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="abstract member SaveCompletedContextActivity : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="workflowPersistenceService.SaveCompletedContextActivity activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> qui représente l'objectif achevé.</param>
        <summary>En cas d'implémentation dans une classe dérivée, enregistre l'objectif achevé spécifié dans une banque de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le moteur d'exécution de workflow enregistre l'état des activités d'objectif achevé pour implémentez la compensation. Vous devez appeler l'une des méthodes <xref:System.Workflow.ComponentModel.Activity.Save%2A> surchargées pour sérialiser l'`activity` dans une classe <xref:System.IO.Stream> ; vous pouvez choisir ensuite de traiter la classe encore plus <xref:System.IO.Stream> avant de l'écrire dans votre banque de données. Toutefois, lorsque le moteur d'exécution de workflow appelle la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A>, vous devez restaurer une copie identique de l'activité.  
  
 Vous devez être en mesure d'associer l'objectif achevé à son instance de workflow englobante pour marquer l'objectif comme non requis dans votre banque de données lorsque l'instance de workflow finit ou est interrompue. Par conséquent, vous devez également enregistrer la structure <xref:System.Guid> de l'instance de workflow associée à l'objectif achevé ; vous pouvez l'obtenir de la propriété <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> de la classe <xref:System.Workflow.Runtime.WorkflowInstance> associée à l'`activity`.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> utilise le <xref:System.Guid> de l'objectif achevé en tant que paramètre. Par conséquent, vous devez également enregistrer la propriété <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ContextGuid%2A> associée à l'`activity`. Cette propriété peut être référencée via le champ <xref:System.Workflow.ComponentModel.Activity.ActivityContextGuidProperty> d'`activity`.  
  
 Si vous implémentez un service de persistance qui utilise un magasin fiable, afin de maintenir la cohérence avec l’état interne du moteur d’exécution de workflow, vous devez participer au traitement par lots de la transaction du workflow pour différer l’écriture réelle dans votre magasin fiable jusqu’à un point de la validation du workflow. Pour participer au traitement par lots, ajoutez un élément de travail à la propriété <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> qui représente les modifications à apporter à la base de données et implémentez l'interface <xref:System.Workflow.Runtime.IPendingWork> dans votre service de persistance.  
  
 Si vous ne pouvez pas enregistrer l'objectif achevé sur votre banque de données, vous devez lever une classe <xref:System.Workflow.Runtime.Hosting.PersistenceException> avec un message d'erreur approprié.  
  
   
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `SaveCompletedContextActivity`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#268](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#268)]
 [!code-vb[WF_Samples#268](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#268)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity, bool unlock);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity, bool unlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState(System.Workflow.ComponentModel.Activity,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub SaveWorkflowInstanceState (rootActivity As Activity, unlock As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity, bool unlock);" />
      <MemberSignature Language="F#" Value="abstract member SaveWorkflowInstanceState : System.Workflow.ComponentModel.Activity * bool -&gt; unit" Usage="workflowPersistenceService.SaveWorkflowInstanceState (rootActivity, unlock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
        <Parameter Name="unlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Activité racine de l'instance de workflow.</param>
        <param name="unlock">
          <see langword="true" /> si l'instance de workflow ne doit pas être verrouillée ; <see langword="false" /> si l'instance de workflow doit être verrouillée.</param>
        <summary>En cas d'implémentation dans une classe dérivée, enregistrer l'état de l'instance de workflow dans un magasin de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez appeler l'une des méthodes <xref:System.Workflow.ComponentModel.Activity.Save%2A> surchargées pour sérialiser `rootActivity` dans une classe <xref:System.IO.Stream>. Vous pouvez ensuite choisir de traiter encore plus <xref:System.IO.Stream> avant de l'écrire dans votre banque de données. Toutefois, lorsque le moteur d'exécution de workflow appelle la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A>, vous devez restaurer une copie identique de l'activité racine. Si vous ne pouvez pas enregistrer l'état de l'instance de workflow dans votre banque de données, vous devez lever une classe <xref:System.Workflow.Runtime.Hosting.PersistenceException> avec un message d'erreur approprié.  
  
 Le moteur d'exécution de workflow fournit la sémantique de verrouillage pour restreindre l'accès à l'état d'une instance de workflow enregistrée dans une banque de données. Vous pouvez y accéder en exécutant les services de persistance sur plusieurs hôtes et en pointant sur la même banque de données. La sémantique de verrouillage est conçue pour empêcher les services de persistance qui s'exécutent dans deux processus différents de charger en même temps la même instance de workflow en mémoire. Selon le type d'environnement que votre service de persistance peut prendre en charge, vous avez la possibilité d'utiliser ces fonctionnalités. Si vous choisissez de prendre en charge la sémantique de verrouillage d'exécution, puis, si un service de persistance essaie d'enregistrer une instance de workflow verrouillée précédemment par un autre service de persistance, vous devez lever une classe <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Si `unlock` est `true`, vous devez déverrouiller l'accès à l'état de l'instance de workflow après l'avoir enregistrée.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> prend le <xref:System.Guid> de l'instance de workflow en tant que paramètre. Par conséquent, vous devez enregistrer ce <xref:System.Guid>. Vous pouvez également utiliser ce <xref:System.Guid> pour associer l'instance de workflow aux états enregistrés de ses objectifs achevés. Vous devez effectuer cette opération parce que vous devez être en mesure de marquer ces objectifs achevés comme non requis lorsque l'instance de workflow se termine.  
  
 Le moteur d'exécution de workflow appelle la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> une dernière fois lorsque l'instance de workflow est complétée ou interrompue. Par conséquent, si <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus%2A> est égal à <xref:System.Workflow.Runtime.WorkflowStatus.Completed> ou <xref:System.Workflow.Runtime.WorkflowStatus.Terminated>, vous pouvez supprimer sans risque l'instance de workflow et tous les objectifs achevés qui lui sont associés dans votre banque de données. Vous pouvez également vous abonner à l'événement <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> ou <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> pour déterminer si vous pouvez supprimer en toute sécurité les enregistrements associés à l'instance de workflow. La suppression réelle des enregistrements de votre banque de données dépend de votre implémentation.  
  
 Si vous implémentez un service de persistance qui utilise un magasin fiable, afin de maintenir la cohérence avec l'état interne du moteur d'exécution de workflow, vous devez ensuite participer au traitement par lots de la transaction du workflow pour différer l'écriture réelle dans votre magasin fiable jusqu'à un point de la validation du workflow. Pour participer au traitement par lots, ajoutez un élément de travail à la propriété <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> qui représente les modifications à apporter à votre banque de données et implémentez l'interface <xref:System.Workflow.Runtime.IPendingWork> dans votre service de persistance.  
  
   
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `SaveWorkflowInstanceState`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#264](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#264)]
 [!code-vb[WF_Samples#264](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#264)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadOnIdle">
      <MemberSignature Language="C#" Value="protected internal abstract bool UnloadOnIdle (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool UnloadOnIdle(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract bool UnloadOnIdle(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="abstract member UnloadOnIdle : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="workflowPersistenceService.UnloadOnIdle activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> qui représente l'objectif achevé.</param>
        <summary>Détermine si un workflow doit être déchargé lorsqu'il est inactif.</summary>
        <returns>Si <see langword="true" />, le moteur d'exécution de workflow décharge le workflow spécifié lorsqu'il devient inactif.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `UnloadOnIdle`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#270](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#270)]
 [!code-vb[WF_Samples#270](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#270)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void UnlockWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void UnlockWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub UnlockWorkflowInstanceState (rootActivity As Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void UnlockWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="abstract member UnlockWorkflowInstanceState : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="workflowPersistenceService.UnlockWorkflowInstanceState rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">Activité racine de l'instance de workflow.</param>
        <summary>En cas de substitution dans une classe dérivée, déverrouille l'état de l'instance de workflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est abstraite, donc elle ne contient pas d'implémentation par défaut du verrouillage et du déverrouillage.  
  
 Pendant que vous implémentez un service de persistance personnalisé, si vous souhaitez implémenter un jeu de verrouillage vous devez substituer cette méthode et fournir un mécanisme de déverrouillage et de verrouillage dans la méthode <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> selon la valeur du paramètre de déverrouillage.  
  
   
  
## Examples  
 L'exemple suivant illustre une implémentation de la méthode `UnlockWorkflowInstanceState`. Il provient de l'exemple de Custom Persistence Service, dans le fichier FilePersistenceService.cs. Pour plus d’informations, consultez [exemple de Service de persistance personnalisé](http://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#267](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#267)]
 [!code-vb[WF_Samples#267](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#267)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>