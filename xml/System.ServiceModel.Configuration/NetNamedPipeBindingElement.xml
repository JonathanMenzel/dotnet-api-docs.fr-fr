<Type Name="NetNamedPipeBindingElement" FullName="System.ServiceModel.Configuration.NetNamedPipeBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81778cee941a1b3038100bc4b790f0d6b8e63ccf" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39738629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetNamedPipeBindingElement : System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetNamedPipeBindingElement extends System.ServiceModel.Configuration.StandardBindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class NetNamedPipeBindingElement&#xA;Inherits StandardBindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetNamedPipeBindingElement : System::ServiceModel::Configuration::StandardBindingElement" />
  <TypeSignature Language="F#" Value="type NetNamedPipeBindingElement = class&#xA;    inherit StandardBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Configuration.StandardBindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="eef22-101">Représente un élément de configuration qui définit une liaison qui est sécurisée, fiable et optimisée pour la communication interprocessus sur ordinateur.</span>
      <span class="sxs-lookup">
        <span data-stu-id="eef22-101">Represents a configuration element that defines a binding that is secure, reliable and optimized for on-machine cross process communication.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eef22-102">Par défaut, cette liaison génère une pile d’exécution de communication avec WS-ReliableMessaging pour la fiabilité, la sécurité de transport pour la sécurité de transfert, des canaux nommés pour la remise de messages et l’encodage de message binaire.</span><span class="sxs-lookup"><span data-stu-id="eef22-102">By default, this binding generates a run-time communication stack with WS-ReliableMessaging for reliability, transport security for transfer security, named pipes for message delivery, and binary message encoding.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.NetNamedPipeBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-103">Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-103">Initializes a new instance of the <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetNamedPipeBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.NetNamedPipeBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetNamedPipeBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eef22-104">Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-104">Initializes a new instance of the <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetNamedPipeBindingElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.NetNamedPipeBindingElement.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetNamedPipeBindingElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Configuration.NetNamedPipeBindingElement : string -&gt; System.ServiceModel.Configuration.NetNamedPipeBindingElement" Usage="new System.ServiceModel.Configuration.NetNamedPipeBindingElement name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="eef22-105">Nom de configuration de la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-105">The configuration name of the binding.</span>
          </span>
          <span data-ttu-id="eef22-106">Cette valeur doit être unique parce qu’elle permet d’identifier la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-106">This value should be unique because it is used as identification for the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eef22-107">Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" /> avec le nom spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-107">Initializes a new instance of the <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" /> class with the specified name.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingElementType">
      <MemberSignature Language="C#" Value="protected override Type BindingElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BindingElementType" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.BindingElementType" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property BindingElementType As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Type ^ BindingElementType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingElementType : Type" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.BindingElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-108">Obtient le type de cet élément de configuration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-108">Gets the type of this configuration element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-109">
            <see cref="T:System.Type" /> de cet élément de configuration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-109">The <see cref="T:System.Type" /> of this configuration element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostNameComparisonMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.HostNameComparisonMode HostNameComparisonMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.HostNameComparisonMode HostNameComparisonMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.HostNameComparisonMode" />
      <MemberSignature Language="VB.NET" Value="Public Property HostNameComparisonMode As HostNameComparisonMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::HostNameComparisonMode HostNameComparisonMode { System::ServiceModel::HostNameComparisonMode get(); void set(System::ServiceModel::HostNameComparisonMode value); };" />
      <MemberSignature Language="F#" Value="member this.HostNameComparisonMode : System.ServiceModel.HostNameComparisonMode with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.HostNameComparisonMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("hostNameComparisonMode", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.HostNameComparisonMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-110">Obtient ou définit une valeur qui indique si le nom d'hôte est utilisé pour atteindre le service lors de la correspondance avec l'URI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-110">Gets or sets a value that indicates whether the hostname is used to reach the service when matching on the URI.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-111">Valeur <see cref="P:System.ServiceModel.Configuration.WSDualHttpBindingElement.HostNameComparisonMode" /> qui spécifie si le nom d'hôte est inclus lors du routage des demandes entrantes vers un URI de point de terminaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-111">A <see cref="P:System.ServiceModel.Configuration.WSDualHttpBindingElement.HostNameComparisonMode" /> value that specifies whether the hostname is included when routing incoming requests to an endpoint URI.</span>
          </span>
          <span data-ttu-id="eef22-112">La valeur par défaut est <see cref="F:System.ServiceModel.HostNameComparisonMode.StrongWildcard" />, qui ignore le nom d'hôte dans la correspondance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-112">The default value is <see cref="F:System.ServiceModel.HostNameComparisonMode.StrongWildcard" />, which ignores the hostname in the match.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeFrom">
      <MemberSignature Language="C#" Value="protected internal override void InitializeFrom (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void InitializeFrom(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.NetNamedPipeBindingElement.InitializeFrom(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void InitializeFrom(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="override this.InitializeFrom : System.ServiceModel.Channels.Binding -&gt; unit" Usage="netNamedPipeBindingElement.InitializeFrom binding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">
          <span data-ttu-id="eef22-113">Paramètres de configuration de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-113">Binding configuration settings.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eef22-114">Initialise cette configuration de liaison avec le contenu des paramètres spécifiés de configuration de liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-114">Initializes this binding configuration with the content of the specified binding configuration settings.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("maxBufferPoolSize", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.LongValidator(MinValue=0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-115">Obtient ou définit la taille maximale (en octets) du pool de mémoires tampons.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-115">Gets or sets the maximum size, in bytes, of the buffer pool.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-116">La taille maximale du pool de mémoires tampons.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-116">The maximum size of the buffer pool.</span>
          </span>
          <span data-ttu-id="eef22-117">La valeur par défaut est 524 288 octets (512 x 1024).</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-117">The default is 524,288 bytes (512 \* 1024).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eef22-118">De nombreuses parties de Windows Communication Foundation (WCF) utilisent des mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="eef22-118">Many parts of Windows Communication Foundation (WCF) use buffers.</span></span> <span data-ttu-id="eef22-119">La création et la destruction des mémoires tampons à chaque utilisation sont chères, tout comme leur nettoyage.</span><span class="sxs-lookup"><span data-stu-id="eef22-119">Creating and destroying buffers each time they are used is expensive, and garbage collection for buffers is also expensive.</span></span> <span data-ttu-id="eef22-120">Avec les pools de mémoires tampons, vous pouvez prendre une mémoire tampon du pool, l'utiliser et la retourner au pool une fois que vous avez terminé.</span><span class="sxs-lookup"><span data-stu-id="eef22-120">With buffer pools, you can take a buffer from the pool, use it, and return it to the pool once you are done.</span></span> <span data-ttu-id="eef22-121">Ainsi, la surcharge de la création et de la destruction des mémoires tampons est évitée.</span><span class="sxs-lookup"><span data-stu-id="eef22-121">Thus the overhead in creating and destroying buffers is avoided.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferSize">
      <MemberSignature Language="C#" Value="public int MaxBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferSize : int with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("maxBufferSize", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.IntegerValidator(MinValue=1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-122">Obtient ou définit une valeur qui spécifie la taille maximale, en octets, de la mémoire tampon utilisée pour stocker des messages en mémoire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-122">Gets or sets a value that specifies the maximum size, in bytes, of the buffer used to store messages in memory.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-123">Nombre maximal d'octets utilisés pour la mise en mémoire tampon des messages entrants.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-123">The maximum number of bytes that are used to buffer incoming messages in memory.</span>
          </span>
          <span data-ttu-id="eef22-124">La valeur par défaut est de 65 536 octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-124">The default value is 65,536 bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eef22-125">Cette propriété s'applique seulement aux en-têtes des messages transférés en continu.</span><span class="sxs-lookup"><span data-stu-id="eef22-125">This property only applies to the headers of streamed messages.</span></span> <span data-ttu-id="eef22-126">Cette valeur doit être au moins égale à la taille maximale possible des en-têtes SOAP qui sont lus en mode mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="eef22-126">This value should be at least the maximum possible size of the SOAP headers, which are read in buffered mode.</span></span>  
  
 <span data-ttu-id="eef22-127">Si la mémoire tampon est remplie, les données excédentaires restent dans le socket sous-jacent jusqu'à ce que de l'espace soit disponible dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="eef22-127">If the buffer is full, excess data remains in the underlying socket until the buffer has space again.</span></span>  
  
 <span data-ttu-id="eef22-128">La valeur de cette propriété doit être inférieure ou égale à MaxMessageSize et doit être supérieure à la taille des en-têtes du message sinon le canal lève une exception.</span><span class="sxs-lookup"><span data-stu-id="eef22-128">The value of this property must be less than or equal to MaxMessageSize and must be larger than the size of the headers of the message or the channel throws an exception.</span></span>  
  
 <span data-ttu-id="eef22-129">Si vous recevez une quantité de données supérieure à la quantité que vous pouvez mettre en mémoire tampon, le canal lève une exception <xref:System.ServiceModel.CommunicationException> qui contient une exception <xref:System.ServiceModel.QuotaExceededException> en tant qu'exception interne.</span><span class="sxs-lookup"><span data-stu-id="eef22-129">If you receive more data than you can buffer, the channel throws a <xref:System.ServiceModel.CommunicationException>, which contains <xref:System.ServiceModel.QuotaExceededException> as an inner exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConnections">
      <MemberSignature Language="C#" Value="public int MaxConnections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxConnections" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxConnections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxConnections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxConnections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxConnections : int with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("maxConnections", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.IntegerValidator(MinValue=0)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0">
          <AttributeName>System.Configuration.IntegerValidator(MinValue=1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-130">Obtient ou définit une valeur qui spécifie le nombre maximal de connexions sortantes et entrantes que le service crée et accepte respectivement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-130">Gets or sets a value that specifies the maximum number of outbound and inbound connections the service creates and accepts respectively.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-131">Nombre maximal de connexions sortantes et entrantes que le service crée et accepte respectivement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-131">The maximum number of outbound and inbound connections the service creates and accepts respectively.</span>
          </span>
          <span data-ttu-id="eef22-132">La valeur par défaut est 10.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-132">The default is 10.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eef22-133">Les connexions entrantes et sortantes sont comptées par rapport à une limite séparée spécifiée par cette propriété.</span><span class="sxs-lookup"><span data-stu-id="eef22-133">Incoming and outgoing connections are counted against a separate limit specified by this property.</span></span> <span data-ttu-id="eef22-134">Toute connexion dépassant cette limite est mise en file d'attente jusqu'à ce que de l'espace soit disponible en dessous de cette limite.</span><span class="sxs-lookup"><span data-stu-id="eef22-134">Any connection in excess of the limit is queued until a space below the limit becomes available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("maxReceivedMessageSize", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.LongValidator(MinValue=1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-135">Obtient et définit la taille maximale autorisée d'un message, en octets, qui peut être reçue sur un canal configuré avec cette liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-135">Gets and sets the maximum allowable message size, in bytes, that can be received on a channel configured with this binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-136">Taille maximale autorisée d'un message traitée par la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-136">The maximum allowable message size that is processed by the binding.</span>
          </span>
          <span data-ttu-id="eef22-137">La valeur par défaut est de 65 536 octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-137">The default value is 65,536 bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyConfiguration">
      <MemberSignature Language="C#" Value="protected override void OnApplyConfiguration (System.ServiceModel.Channels.Binding binding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApplyConfiguration(class System.ServiceModel.Channels.Binding binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Configuration.NetNamedPipeBindingElement.OnApplyConfiguration(System.ServiceModel.Channels.Binding)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApplyConfiguration(System::ServiceModel::Channels::Binding ^ binding);" />
      <MemberSignature Language="F#" Value="override this.OnApplyConfiguration : System.ServiceModel.Channels.Binding -&gt; unit" Usage="netNamedPipeBindingElement.OnApplyConfiguration binding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
      </Parameters>
      <Docs>
        <param name="binding">
          <span data-ttu-id="eef22-138">Liaison à appliquer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-138">The binding to be applied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eef22-139">Applique la liaison spécifiée à cette instance <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-139">Applies the specified binding to this <see cref="T:System.ServiceModel.Configuration.NetNamedPipeBindingElement" /> instance.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="protected override System.Configuration.ConfigurationPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.ConfigurationPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.Properties" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property Properties As ConfigurationPropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Configuration::ConfigurationPropertyCollection ^ Properties { System::Configuration::ConfigurationPropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Configuration.ConfigurationPropertyCollection" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-140">Obtient une instance de <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> contenant une collection d'objets <see cref="T:System.Configuration.ConfigurationProperty" /> qui peuvent être des attributs ou des objets <see cref="T:System.Configuration.ConfigurationElement" /> de cet élément de configuration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-140">Gets a <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> instance that contains a collection of <see cref="T:System.Configuration.ConfigurationProperty" /> objects that can be attributes or <see cref="T:System.Configuration.ConfigurationElement" /> objects of this configuration element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-141">Instance <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> contenant une collection d'objets <see cref="T:System.Configuration.ConfigurationProperty" /> qui peuvent être des attributs ou des objets <see cref="T:System.Configuration.ConfigurationElement" /> de cet élément de configuration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-141">A <see cref="T:System.Configuration.ConfigurationPropertyCollection" /> instance that contains a collection of <see cref="T:System.Configuration.ConfigurationProperty" /> objects that can be attributes or <see cref="T:System.Configuration.ConfigurationElement" /> objects of this configuration element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReaderQuotas">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement ReaderQuotas { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement ReaderQuotas" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.ReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReaderQuotas As XmlDictionaryReaderQuotasElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Configuration::XmlDictionaryReaderQuotasElement ^ ReaderQuotas { System::ServiceModel::Configuration::XmlDictionaryReaderQuotasElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReaderQuotas : System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.ReaderQuotas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("readerQuotas")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-142">Obtient ou définit des contraintes sur la complexité des messages SOAP pouvant être traités par les points de terminaison configurés avec cette liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-142">Gets or sets constraints on the complexity of SOAP messages that can be processed by endpoints configured with this binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-143">
            <see cref="T:System.Xml.XmlDictionaryReaderQuotas" /> spécifiant les contraintes de complexité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-143">The <see cref="T:System.Xml.XmlDictionaryReaderQuotas" /> that specifies the complexity constraints.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eef22-144">Les contraintes de complexité peuvent inclure, entre autres, une profondeur maximale d'éléments ou une longueur maximale du contenu de chaîne du message.</span><span class="sxs-lookup"><span data-stu-id="eef22-144">The complexity constraints include items such as a maximum element depth, a maximum length for string content within the message.</span></span> <span data-ttu-id="eef22-145">Les contraintes permettent de protéger l'application contre les attaques par déni de service (DoS) qui tentent d'utiliser la complexité de message pour bloquer les ressources allouées au traitement des points de terminaison.</span><span class="sxs-lookup"><span data-stu-id="eef22-145">The constraints protect against a class of denial of service (DOS) attacks that attempt to use message complexity to tie up endpoint processing resources.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Security">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Configuration.NetNamedPipeSecurityElement Security { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Configuration.NetNamedPipeSecurityElement Security" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.Security" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Security As NetNamedPipeSecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Configuration::NetNamedPipeSecurityElement ^ Security { System::ServiceModel::Configuration::NetNamedPipeSecurityElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.Configuration.NetNamedPipeSecurityElement" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.Security" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("security")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Configuration.NetNamedPipeSecurityElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-146">Obtient le type de paramètres de sécurité à utiliser avec cette liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-146">Gets the type of security settings to be used with this binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-147">
            <see cref="T:System.ServiceModel.Configuration.NetNamedPipeSecurityElement" /> qui spécifie le type de paramètres de sécurité à utiliser avec cette liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-147">The <see cref="T:System.ServiceModel.Configuration.NetNamedPipeSecurityElement" /> that specifies the type of security settings to be used with this binding.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionFlow">
      <MemberSignature Language="C#" Value="public bool TransactionFlow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionFlow" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.TransactionFlow" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionFlow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionFlow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionFlow : bool with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.TransactionFlow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("transactionFlow", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-148">Obtient ou définit une valeur Boolean qui spécifie si la liaison prend en charge le flux WS-Transactions.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-148">Gets or sets a Boolean value that specifies whether the binding supports flowing WS-Transactions.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-149">
            <see langword="true" /> si la liaison prend en charge le flux WS-Transactions ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-149">
              <see langword="true" /> if the binding supports flowing WS-Transactions; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="eef22-150">La valeur par défaut est <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-150">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionProtocol">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransactionProtocol TransactionProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.TransactionProtocol TransactionProtocol" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.TransactionProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionProtocol As TransactionProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransactionProtocol ^ TransactionProtocol { System::ServiceModel::TransactionProtocol ^ get(); void set(System::ServiceModel::TransactionProtocol ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionProtocol : System.ServiceModel.TransactionProtocol with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.TransactionProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ServiceModel.Configuration.TransactionProtocolConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("transactionProtocol", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransactionProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-151">Obtient ou définit le protocole de transaction à utiliser avec cette liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-151">Gets or sets the transaction protocol to be used with this binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-152">
            <see cref="T:System.ServiceModel.TransactionProtocol" /> qui spécifie le protocole de transaction à utiliser avec cette liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-152">A <see cref="T:System.ServiceModel.TransactionProtocol" /> that specifies the transaction protocol to be used with this binding.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransferMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransferMode TransferMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.TransferMode TransferMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Configuration.NetNamedPipeBindingElement.TransferMode" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferMode As TransferMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransferMode TransferMode { System::ServiceModel::TransferMode get(); void set(System::ServiceModel::TransferMode value); };" />
      <MemberSignature Language="F#" Value="member this.TransferMode : System.ServiceModel.TransferMode with get, set" Usage="System.ServiceModel.Configuration.NetNamedPipeBindingElement.TransferMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Configuration.ConfigurationProperty("transferMode", DefaultValue=Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransferMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="eef22-153">Obtient ou définit une valeur qui spécifie si les messages sont mis en mémoire tampon ou transmis en continu ou s'il s'agit d'une demande ou d'une réponse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-153">Gets or sets a value that specifies whether messages are buffered or streamed or a request or response.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="eef22-154">Valeur <see cref="T:System.ServiceModel.TransferMode" /> valide qui spécifie si les messages sont mis en mémoire tampon ou transmis en continu ou s'il s'agit d'une demande ou d'une réponse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="eef22-154">A valid <see cref="T:System.ServiceModel.TransferMode" /> value that specifies whether messages are buffered or streamed or a request or response.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>