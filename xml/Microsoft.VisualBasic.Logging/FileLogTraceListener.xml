<Type Name="FileLogTraceListener" FullName="Microsoft.VisualBasic.Logging.FileLogTraceListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fd87b5c87ae90cca751677a1ff302a09e3997d6b" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52216274" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileLogTraceListener : System.Diagnostics.TraceListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileLogTraceListener extends System.Diagnostics.TraceListener" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />
  <TypeSignature Language="VB.NET" Value="Public Class FileLogTraceListener&#xA;Inherits TraceListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileLogTraceListener : System::Diagnostics::TraceListener" />
  <TypeSignature Language="F#" Value="type FileLogTraceListener = class&#xA;    inherit TraceListener" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.TraceListener</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit un écouteur simple qui dirige la sortie d'enregistrement vers un fichier.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe fournit des fonctions de maintenance automatisées pour archiver les fichiers journaux en fonction des besoins, sur une base quotidienne ou par application. Cette fonctionnalité d’archivage automatique permet de réduire les responsabilités de maintenance des développeurs et administrateurs.  
  
 Une instance de <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> peuvent être ajoutés à la <xref:System.Diagnostics.Debug.Listeners%2A?displayProperty=nameWithType> ou <xref:System.Diagnostics.Trace.Listeners%2A?displayProperty=nameWithType> collections pour rediriger la sortie de l’enregistrement dans un fichier texte. Instances de cette classe peuvent également être ajoutées à `My.Application.Log` ou `My.Log` (pour les applications Web) dans les applications Visual Basic. Pour plus d’informations, consultez [procédure pas à pas : modification Where My.Application.Log Writes Information](~/docs/visual-basic/developing-apps/programming/log-info/walkthrough-changing-where-my-application-log-writes-information.md)`.`  
  
 Les principales fonctionnalités de cette classe sont :  
  
1.  *Fonctionnalité d’archivage*. Les fichiers journaux générés par cette classe sont nommés selon le nom de base et la date, ainsi que d’un nombre à distinguer le fichier journal à partir des versions successives du journal. Nouveaux fichiers journaux sont créés sur une base en fonction des besoins.  
  
     La forme explicite du nom de fichier est `baseName`[-`dateStamp`] [-`version`] .log, où :  
  
    -   Le `baseName` partie est le nom de journal fondamental, spécifié par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> propriété.  
  
    -   Le `dateStamp` partie a le format « AAAA-MM-JJ » et elle est indiquée lorsque <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> est <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> ou <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>.  
  
    -   Si plus d’un fichier journal est nécessaire avec le même `baseName` et `dateStamp`, le `version` partie, un nombre positif `Integer`, est ajouté au nom de fichier.  
  
2.  *Plusieurs instances de classe*. Si une instance de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe écrit dans un fichier qui est en cours d’utilisation :  
  
    -   La classe partage le fichier s’il est utilisé par une autre instance de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe dans le même processus.  
  
    -   La classe crée un nouveau fichier journal à l’aide du nom disponible suivant si le fichier est utilisé par un autre processus.  
  
3.  *Sécurité des threads*. Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe est thread-safe. Cela vous permet de vous permettent d’écrire en toute sécurité des messages dans le journal à partir de plusieurs threads sans utiliser de verrous.  
  
 **Emplacement du fichier journal**  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> propriété prend un <xref:Microsoft.VisualBasic.Logging.LogFileLocation> énumération pour spécifier un des répertoires standard dans lesquels écrire le fichier journal.  
  
-   Pour écrire le journal vers un autre emplacement, définissez le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> propriété à cet emplacement.  
  
 **Nom du fichier journal**  
  
-   Le nom de base pour le fichier journal est spécifié par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> propriété.  
  
-   Le nom de fichier journal actuel peut être lu à partir de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> propriété. Elle est dérivée de plusieurs autres propriétés et l’état actuel des journaux dans le système de fichiers.  
  
 **Maintenance du journal**  
  
-   La fréquence minimale pour la création de nouveaux fichiers journaux est déterminée par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> propriété. Lorsque la valeur est <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> ou <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>, un nouveau fichier journal est créé au moins une fois chaque jour ou chaque semaine et un cachet de date est incorporé dans le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> nom.  
  
-   La taille maximale (en octets) du fichier journal est déterminée par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize%2A> propriété. Si la taille du fichier journal dépasse cette taille, écrites dans le journal des messages supplémentaires sont ignorés et, selon le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> propriété, une exception est levée.  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace%2A> propriété détermine la quantité d’espace libre (en octets) doit être disponible. Cela permet de garantir que la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe ne consommera pas tout l’espace disque disponible. Utilisez le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> propriété pour spécifier le comportement du journal écrit lorsqu’il y a moins de <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace%2A> octets libres.  
  
 **Paramètres de sortie de fichier journal**  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush%2A> propriété spécifie si le flux sous-jacent doit être vidé automatiquement après chaque écriture dans le fichier journal.  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Append%2A> propriété spécifie s’il faut ajouter des messages dans le fichier journal actuel, si autorisée, ou les écrire dans un nouveau fichier journal.  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> propriété spécifie la chaîne à utiliser pour délimiter les champs dans un message de journal.  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding%2A> propriété spécifie l’encodage à utiliser lors de la création d’un nouveau fichier journal.  
  
 **Sortie du fichier journal**  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> et <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent%2A> méthodes écrivent des messages dans le fichier journal. Ces méthodes vérifient le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> propriété, ainsi que tous les journaux existants portant le même nom de base pour déterminer si un nouveau journal doit être créé.  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush%2A> méthode vide tous les messages actuellement dans la mémoire tampon de sortie dans le fichier journal.  
  
-   Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close%2A> méthode ferme le fichier journal pour qu’il peut être utilisé par d’autres processus.  
  
 **Activation de la sortie**  
  
 Vous devez activer le traçage ou de débogage pour utiliser un écouteur de suivi. La syntaxe suivante est spécifique au compilateur. Si vous utilisez des compilateurs autres que c# ou Visual Basic, consultez la documentation de votre compilateur.  
  
-   Pour activer le débogage en c#, ajoutez le `/d:DEBUG` indicateur pour la ligne de commande du compilateur lorsque vous compilez votre code, ou vous pouvez ajouter `#define DEBUG` vers le haut de votre fichier. Dans Visual Basic, ajoutez le `/d:DEBUG=True` indicateur pour la ligne de commande du compilateur.  
  
-   Pour activer le traçage en c#, ajoutez le `/d:TRACE` indicateur pour la ligne de commande du compilateur lorsque vous compilez votre code, ou ajoutez `#define TRACE` vers le haut de votre fichier. Dans Visual Basic, ajoutez le `/d:TRACE=True` indicateur pour la ligne de commande du compilateur.  
  
 Pour définir le niveau de votre écouteur, modifiez le fichier de configuration pour votre application. Dans ce fichier, vous pouvez ajouter un écouteur, définissez son type et ses paramètres, supprimer un écouteur ou effacer tous les écouteurs définis précédemment par l’application. Le fichier de configuration doit être mis en forme comme dans l’exemple suivant.  
  
 Pour exécuter cet exemple, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
```xml  
<configuration>  
    <system.diagnostics>  
        <sharedListeners>  
            <add name="FileLog"  
                type="Microsoft.VisualBasic.Logging.FileLogTraceListener,   
                      Microsoft.VisualBasic, Version=8.0.0.0,   
                      Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a,   
                      processorArchitecture=MSIL"   
                initializeData="FileLogWriter"/>  
        </sharedListeners>  
    </system.diagnostics>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush" />
    <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close" />
    <related type="Article" href="https://msdn.microsoft.com/library/ecc74f95-743c-450d-93f6-09a30db0fe4a">Procédure pas à pas : modification de l'emplacement des informations My.Application.Log</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" /> et définit le nom.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileLogTraceListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileLogTraceListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" /> avec le nom par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit le nom de l’instance de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe FileLogTraceListener à.  
  
 Vous pouvez accéder via le nom d’instance le <xref:System.Diagnostics.TraceListener.Name%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.Log" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objets (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileLogTraceListener (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileLogTraceListener(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new Microsoft.VisualBasic.Logging.FileLogTraceListener : string -&gt; Microsoft.VisualBasic.Logging.FileLogTraceListener" Usage="new Microsoft.VisualBasic.Logging.FileLogTraceListener name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <see langword="String" />. Nom de l'objet instance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" /> avec le nom fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit le nom de l’instance de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe `name`.  
  
 Vous pouvez accéder au nom de l’instance par le biais du <xref:System.Diagnostics.TraceListener.Name%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.Log" />
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="T:Microsoft.VisualBasic.Logging.FileLogTraceListener" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objets (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public bool Append { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Append" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Append" />
      <MemberSignature Language="VB.NET" Value="Public Property Append As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Append { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Append : bool with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Append" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine s'il convient d'ajouter la sortie au fichier en cours ou de l'écrire dans un nouveau fichier.</summary>
        <value>
          <see langword="Boolean" />, avec <see langword="True" /> indiquant que la sortie est ajoutée au fichier en cours et <see langword="False" /> indiquant que la sortie est écrite dans un nouveau fichier. Le paramètre par défaut de cette propriété est <see langword="True" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Append%2A> propriété est `False`, la sortie est écrite dans un nouveau fichier. Lorsque la propriété est `True`, la sortie est ajoutée au fichier actuel, sauf si :  
  
-   Le fichier de sortie est verrouillé par un autre processus. Dans ce cas, un nouveau fichier journal est créé avec un numéro de version qui est incorporé dans le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> nom.  
  
-   La taille du fichier est supérieure à ce que le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize%2A> permet de propriété. Dans ce cas, les messages supplémentaires sont ignorés et, selon le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> propriété, une exception est levée.  
  
-   Le nom de fichier existant est obsolète en fonction de la planification de la création du journal spécifiée par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> propriété. Dans ce cas, un nouveau fichier journal est créé et le cachet de date est incorporé dans le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> nom.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si l'écriture dans le flux du fichier journal vide ou non la mémoire tampon.</summary>
        <value>
          <see langword="Boolean" />, avec <see langword="True" /> indiquant que le flux est vidé après chaque écriture ; sinon, les entrées de journal sont mises en mémoire tampon et écrites plus efficacement. Le paramètre par défaut de cette propriété est <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `False` définition pour le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.AutoFlush%2A> propriété offre des performances optimales pour la plupart des applications, car il est plus efficace pour écrire plusieurs messages dans le fichier journal en même temps. Vous pouvez utiliser la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush%2A> méthode pour vider les messages actuellement dans le fichier journal de sortie de mémoire tampon. Vous pouvez également utiliser le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close%2A> (méthode), qui vide implicitement le flux avant de fermer le fichier journal.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close" />
      </Docs>
    </Member>
    <Member MemberName="BaseFileName">
      <MemberSignature Language="C#" Value="public string BaseFileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseFileName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
      <MemberSignature Language="VB.NET" Value="Public Property BaseFileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseFileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BaseFileName : string with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de base des fichiers journaux qui est utilisé pour créer le nom de fichier journal complet.</summary>
        <value>
          <see langword="String" />. Nom de base des fichiers journaux. La valeur par défaut est le nom de produit de l'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> propriété détermine le nom de base pour les fichiers journaux qui le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe écrit dans.  
  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> propriété donne le nom complet du fichier journal actuel. Il est généré selon le chemin d’accès du journal, le nom de base, la date et un nombre pour le différencier des versions différentes du journal. Nouveaux fichiers journaux sont créés sur une base en fonction des besoins.  
  
 La forme explicite du nom du fichier journal complet est `path` \\ `baseName`[-`dateStamp`] [-`iteration`] .log, où  
  
-   Le `path` partie est déterminée par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> propriété et, si cette propriété a la valeur <xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>, le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> propriété.  
  
-   Le `baseName` partie est le nom de journal fondamental, spécifié par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> propriété.  
  
-   Le `dateStamp` partie a le format « AAAA-MM-JJ » et elle est indiquée lorsque <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> a la valeur <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> ou <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>.  
  
-   Si plus d’un fichier journal est nécessaire avec le même `baseName` et `dateStamp`, le `iteration` partie, un nombre positif `Integer`, est ajouté au nom de fichier.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
        <altmember cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.Custom" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="fileLogTraceListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le flux sous-jacent du fichier journal actuel et libère toutes les ressources associées au flux actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous n’avez pas besoin d’appeler le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Close%2A> méthode explicitement, car le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe gère le flux sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomLocation">
      <MemberSignature Language="C#" Value="public string CustomLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CustomLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CustomLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CustomLocation : string with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répertoire du fichier journal lorsque la propriété <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" /> a la valeur <see cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.Custom" />.</summary>
        <value>
          <see langword="String" /> qui est le nom du répertoire du fichier journal. Le paramètre par défaut de cette propriété est le répertoire de l'utilisateur pour les données d'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> est définie, il définit également la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> propriété <xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>.  
  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> propriété lève une exception si le répertoire ne peut pas être résolu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public string Delimiter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Delimiter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Property Delimiter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Delimiter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Delimiter : string with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le séparateur utilisé pour délimiter les champs d'un message de journal.</summary>
        <value>
          <see langword="String" />, qui est le séparateur utilisé pour les champs d'un message de journal. Le paramètre par défaut de cette propriété est le caractère de tabulation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> propriété vous permet de modifier le délimiteur par défaut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiskSpaceExhaustedBehavior">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption DiskSpaceExhaustedBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption DiskSpaceExhaustedBehavior" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property DiskSpaceExhaustedBehavior As DiskSpaceExhaustedOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::Logging::DiskSpaceExhaustedOption DiskSpaceExhaustedBehavior { Microsoft::VisualBasic::Logging::DiskSpaceExhaustedOption get(); void set(Microsoft::VisualBasic::Logging::DiskSpaceExhaustedOption value); };" />
      <MemberSignature Language="F#" Value="member this.DiskSpaceExhaustedBehavior : Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine que faire lors de l'écriture dans le fichier journal si l'espace disque disponible est inférieur à celui qui est spécifié par la propriété <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />.</summary>
        <value>
          <see cref="T:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption" />. Détermine ce qu'il convient de faire lors d'une tentative d'écriture dans le fichier journal alors que l'espace disque disponible est inférieur à la valeur spécifiée par la propriété <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />, ou si la taille du fichier journal est supérieure à la valeur autorisée par la propriété <see cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption.DiscardMessages" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> propriété est définie sur <xref:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption.DiscardMessages>, les messages du journal sont ignorés si n’est pas suffisamment d’espace disque réservé. Il s’agit du comportement par défaut et empêche des applications simples d’échouer si le disque saturé.  
  
 Les applications plus robustes peuvent affecter le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A> propriété <xref:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption.ThrowException>et ajoutez `Try...Catch` blocs autour de tout le code qui écrit dans le journal.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.DiskSpaceExhaustedOption" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileLogTraceListener.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="True" /> libère les ressources managées et non managées ; <see langword="False" /> libère uniquement les ressources non managées.</param>
        <summary>Ferme le flux sous-jacent et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le paramètre `disposing` a la valeur `True`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see langword="Dispose" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see langword="Dispose" />.  
  
Cette méthode appelle la <see langword="Dispose" /> méthode de la classe de base <see langword="Dispose" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'encodage à utiliser lors de la création d'un fichier journal.</summary>
        <value>
          <see cref="T:System.Text.Encoding" />, qui est l'encodage à utiliser lors de la création d'un fichier journal. La valeur par défaut de cette propriété est <see cref="T:System.Text.UTF8Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de l’ajout de texte à un fichier journal existant, l’encodage pour ce fichier est utilisé au lieu de l’encodage spécifié par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Encoding%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.Text.UTF8Encoding" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit&#xA;override this.Flush : unit -&gt; unit" Usage="fileLogTraceListener.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide le flux sous-jacent qui écrit dans le fichier journal actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Flush%2A> méthode pour écrire des données tout en mémoire tampon dans le fichier journal actuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullLogFileName">
      <MemberSignature Language="C#" Value="public string FullLogFileName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullLogFileName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullLogFileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullLogFileName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullLogFileName : string" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom complet du fichier journal actuel.</summary>
        <value>
          <see langword="String" />, qui est le nom complet du fichier journal actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A> propriété donne le nom complet du fichier journal actuel. Il est généré selon le chemin d’accès du journal, le nom de base, la date et un nombre pour le différencier des versions différentes du journal. Nouveaux fichiers journaux sont créés sur une base en fonction des besoins.  
  
 La forme explicite du nom complet du fichier journal est `path` \\ `baseName`[-`dateStamp`] [-`iteration`] .log, où :  
  
-   Le `path` partie est déterminée par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> propriété et, si cette propriété a la valeur <xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>, le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> propriété.  
  
-   Le `baseName` partie est le nom de journal fondamental, spécifié par le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName%2A> propriété.  
  
-   Le `dateStamp` partie a le format AAAA-MM-JJ, et elle est indiquée lorsque <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> est <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily> ou <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>.  
  
-   Si plus d’un fichier journal est nécessaire avec le même `baseName` et `dateStamp`, le `iteration` partie, un nombre positif `Integer`, est ajouté au nom de fichier.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.BaseFileName" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
        <altmember cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.Custom" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      </Docs>
    </Member>
    <Member MemberName="GetSupportedAttributes">
      <MemberSignature Language="C#" Value="protected override string[] GetSupportedAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance string[] GetSupportedAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.GetSupportedAttributes" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetSupportedAttributes () As String()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override cli::array &lt;System::String ^&gt; ^ GetSupportedAttributes();" />
      <MemberSignature Language="F#" Value="abstract member GetSupportedAttributes : unit -&gt; string[]&#xA;override this.GetSupportedAttributes : unit -&gt; string[]" Usage="fileLogTraceListener.GetSupportedAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les attributs de configuration XML personnalisés pris en charge par l'écouteur Trace.</summary>
        <returns>Tableau <see langword="String" /> contenant les attributs de configuration XML reconnus par cet écouteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les attributs personnalisés de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> peut être utilisé dans le fichier de configuration XML pour contrôler le comportement d’une instance de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe. À l’aide de n’importe quel autre attribut provoque une exception de configuration.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Diagnostics.TraceSource.GetSupportedAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IncludeHostName">
      <MemberSignature Language="C#" Value="public bool IncludeHostName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeHostName" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeHostName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeHostName { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeHostName : bool with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si le nom d'hôte de l'ordinateur d'enregistrement doit être ou non inclus dans la sortie.</summary>
        <value>
          <see langword="Boolean" />. Utilise <see langword="True" /> si l'identificateur hôte doit être inclus ; sinon, utilise <see langword="False" />. La valeur par défaut est <see langword="False" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la propriété pour configurer le comportement de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> et <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.Logging.LogFileLocation Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.Logging.LogFileLocation Location" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As LogFileLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::Logging::LogFileLocation Location { Microsoft::VisualBasic::Logging::LogFileLocation get(); void set(Microsoft::VisualBasic::Logging::LogFileLocation value); };" />
      <MemberSignature Language="F#" Value="member this.Location : Microsoft.VisualBasic.Logging.LogFileLocation with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Logging.LogFileLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'emplacement des fichiers journaux.</summary>
        <value>
          <see cref="T:Microsoft.VisualBasic.Logging.LogFileLocation" />, qui est l'emplacement du fichier journal. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.Logging.LogFileLocation.LocalUserApplicationDirectory" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Location%2A> propriété à définir le chemin d’accès du journal à un des chemins d’accès prédéfinis, déterminés par le <xref:Microsoft.VisualBasic.Logging.LogFileLocation> valeurs d’énumération.  
  
|**Valeur de l’emplacement**|**Chemin d’accès**|  
|------------------------|--------------|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.CommonApplicationDirectory>|Le chemin d’accès pour les données d’application qui sont partagées entre tous les utilisateurs, avec le format :<br /><br /> `BasePath`\\`CompanyName`\\`ProductName`\\`ProductVersion`<br /><br /> Une valeur typique pour `BasePath` est :<br /><br /> C:\Documents and Settings\All Users\Application Data<br /><br /> Les valeurs de `CompanyName`, `ProductName`, et `ProductVersion` proviennent de l’assembly.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.ExecutableDirectory>|Chemin d’accès au fichier exécutable ayant démarré l’application.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.LocalUserApplicationDirectory>|Le chemin d’accès pour les données d’application d’un utilisateur, avec le format :<br /><br /> `BasePath`\\`CompanyName`\\`ProductName`\\`ProductVersion`<br /><br /> Une valeur typique pour `BasePath` est :<br /><br /> C:\Documents and Settings\\`username`\Application Data<br /><br /> Les valeurs de `CompanyName`, `ProductName`, et `ProductVersion` viennent de l’assembly.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.TempDirectory>|Le chemin d’accès du dossier temporaire du système en cours.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileLocation.Custom>|Si la chaîne spécifiée par <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.CustomLocation%2A> est pas vide, puis utilisez-le comme le chemin d’accès ; sinon, utilisez le chemin d’accès pour les données d’application d’un utilisateur.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.LogFileLocation" />
      </Docs>
    </Member>
    <Member MemberName="LogFileCreationSchedule">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption LogFileCreationSchedule { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption LogFileCreationSchedule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      <MemberSignature Language="VB.NET" Value="Public Property LogFileCreationSchedule As LogFileCreationScheduleOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::Logging::LogFileCreationScheduleOption LogFileCreationSchedule { Microsoft::VisualBasic::Logging::LogFileCreationScheduleOption get(); void set(Microsoft::VisualBasic::Logging::LogFileCreationScheduleOption value); };" />
      <MemberSignature Language="F#" Value="member this.LogFileCreationSchedule : Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine la date à inclure dans les noms des fichiers journaux.</summary>
        <value>
          <see cref="T:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption" />. Indique quelle date inclure dans les noms de fichiers journaux. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attribuer l’un de la <xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption> valeurs d’énumération pour le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.LogFileCreationSchedule%2A> propriété pour spécifier la date à inclure dans les noms des fichiers journaux.  
  
 Le format de la date est AAAA-MM-JJ. Pour plus d’informations sur le format du nom de fichier du journal, consultez <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
|**Valeur de LogFileCreationSchedule**|**Date dans le nom de fichier journal**|  
|---------------------------------------|-----------------------------------|  
|<xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Daily>|Incluez la date du jour dans le nom du fichier journal.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.None>|N'incluez pas la date dans le nom du fichier journal.|  
|<xref:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption.Weekly>|Incluez le premier jour de la semaine actuelle dans le nom du fichier journal.<br /><br /> La semaine commence le samedi.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Logging.LogFileCreationScheduleOption" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      </Docs>
    </Member>
    <Member MemberName="MaxFileSize">
      <MemberSignature Language="C#" Value="public long MaxFileSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxFileSize" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxFileSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxFileSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxFileSize : int64 with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille maximale autorisée du fichier journal, en octets.</summary>
        <value>
          <see langword="Long" />. Taille maximale autorisée pour les fichiers journaux, en octets. La valeur par défaut est 5000000.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour vous assurer que les fichiers journaux n’augmentent pas trop volumineux.  
  
 Si le fichier journal taille (en octets) est supérieure à la valeur de cette propriété, lorsque la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe tente d’écrire un message dans le journal, le message est ignoré et l’échec est silencieux ou une exception est levée en fonction de la valeur de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A>propriété. Sinon, le message est écrit dans le journal, si la quantité d’espace disque libre (en octets) est inférieure à <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Lorsque cette propriété a une valeur inférieure à 1 000.</exception>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
      </Docs>
    </Member>
    <Member MemberName="ReserveDiskSpace">
      <MemberSignature Language="C#" Value="public long ReserveDiskSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReserveDiskSpace" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property ReserveDiskSpace As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReserveDiskSpace { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ReserveDiskSpace : int64 with get, set" Usage="Microsoft.VisualBasic.Logging.FileLogTraceListener.ReserveDiskSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la quantité d'espace disque disponible (en octets) nécessaire pour que les messages puissent être écrits dans le fichier journal.</summary>
        <value>
          <see langword="Long" />. Quantité d'espace disque libre nécessaire. La valeur par défaut est 10 000 000.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour vous assurer que les fichiers journaux ne remplissent pas complètement le disque.  
  
 Si la quantité d’espace disque libre espace (en octets) est inférieure à la valeur de cette propriété, lorsque la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener> classe tente d’écrire un message dans le journal, le message est ignoré et l’échec est silencieux ou une exception est levée en fonction de la valeur de la < C2 > <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior%2A>  propriété. Sinon, le message est écrit dans le journal, si la taille du fichier journal (en octets) est supérieure à <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.MaxFileSize%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Lorsque cette propriété a une valeur inférieure à 0.</exception>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.DiskSpaceExhaustedBehavior" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceData">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les données de trace dans le fichier de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> méthodes ne sont pas destinées à être appelé par le code d’application. Ces méthodes sont appelées par les membres de la <xref:System.Diagnostics.Debug>, <xref:System.Diagnostics.Trace>, et <xref:System.Diagnostics.TraceSource> classes pour écrire des données de trace en sortie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceData (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceData(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj -&gt; unit&#xA;override this.TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj -&gt; unit" Usage="fileLogTraceListener.TraceData (eventCache, source, eventType, id, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventCache">Objet <see cref="T:System.Diagnostics.TraceEventCache" /> qui contient les informations actuelles sur l'ID de processus, l'ID de thread et la trace de la pile.</param>
        <param name="source">Nom de la source de trace qui a appelé cette méthode.</param>
        <param name="eventType">Une des valeurs d'énumération <see cref="T:System.Diagnostics.TraceEventType" />.</param>
        <param name="id">Identificateur numérique pour l'événement.</param>
        <param name="data">Données de trace à émettre.</param>
        <summary>Écrit des informations de traçage, un objet de données et des informations d'événement dans le fichier ou le flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode :  
  
1.  Met en forme les informations de données et le contexte pour la sortie.  
  
2.  Crée un nouveau fichier journal, si nécessaire.  
  
3.  Écrit les informations dans le fichier journal.  
  
 Pour plus d’informations sur la création de nouveaux fichiers journaux, consultez <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Le tableau suivant répertorie les champs de sortie dans l’ordre de qu'apparition. Les champs sont délimités par la chaîne qui le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> propriété spécifie et sont suivies d’un terminateur de ligne.  
  
|**Champ**|**Condition de sortie**|**Description**|  
|---------------|--------------------------|---------------------|  
|`source`|Toujours|la valeur de la propriété `name` ;|  
|`severity`|Toujours|Le nom de la valeur d’énumération de `eventType`.|  
|`id`|Toujours|Représentation sous forme de chaîne de `id`.|  
|`message`|Toujours|Représentation sous forme de chaîne de `data`.|  
|`callStack`|Lorsque le <xref:System.Diagnostics.TraceOptions.Callstack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.Callstack%2A> propriété du `eventCache`.|  
|`CorrelationID`|Lorsque le <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`DateTime`|Lorsque le <xref:System.Diagnostics.TraceOptions.DateTime> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.DateTime%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ProcessID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ProcessId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ThreadID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ThreadId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`Timestamp`|Lorsque le <xref:System.Diagnostics.TraceOptions.Timestamp> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`HostName`|Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> propriété est `True`.|Le nom de l’ordinateur.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <Member MemberName="TraceData">
      <MemberSignature Language="C#" Value="public override void TraceData (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, params object[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceData(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, object[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceData (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, ParamArray data As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceData(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, ... cli::array &lt;System::Object ^&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj[] -&gt; unit&#xA;override this.TraceData : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * obj[] -&gt; unit" Usage="fileLogTraceListener.TraceData (eventCache, source, eventType, id, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="data" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventCache">Objet <see cref="T:System.Diagnostics.TraceEventCache" /> qui contient les informations actuelles sur l'ID de processus, l'ID de thread et la trace de la pile.</param>
        <param name="source">Nom de la source de trace qui a appelé cette méthode.</param>
        <param name="eventType">Une des valeurs d'énumération <see cref="T:System.Diagnostics.TraceEventType" />.</param>
        <param name="id">Identificateur numérique pour l'événement.</param>
        <param name="data">Tableau d'objets à émettre comme données.</param>
        <summary>Écrit des informations de traçage, un tableau d'objets de données et des informations d'événement dans le fichier ou le flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode :  
  
1.  Met en forme les informations de données et le contexte pour la sortie,  
  
2.  Crée un nouveau fichier journal, si nécessaire,  
  
3.  Écrit les informations dans le fichier journal.  
  
 Pour plus d’informations sur la création de nouveaux fichiers journaux, consultez <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Ce tableau répertorie les champs de sortie dans l’ordre de qu'apparition. Les champs sont délimités par la chaîne qui le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> propriété spécifie et sont suivies d’un terminateur de ligne.  
  
|**Champ**|**Condition de sortie**|**Description**|  
|---------------|--------------------------|---------------------|  
|`source`|Toujours|la valeur de la propriété `name` ;|  
|`severity`|Toujours|Le nom de la valeur d’énumération de `eventType`.|  
|`id`|Toujours|Représentation sous forme de chaîne de `id`.|  
|`message`|Toujours|La chaîne qui se compose de la représentation sous forme de chaîne de chaque élément dans `data`, chacun étant séparé par <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A>.|  
|`callStack`|Lorsque le <xref:System.Diagnostics.TraceOptions.Callstack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.Callstack%2A> propriété du `eventCache`.|  
|`CorrelationID`|Lorsque le <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`DateTime`|Lorsque le <xref:System.Diagnostics.TraceOptions.DateTime> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.DateTime%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ProcessID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ProcessId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ThreadID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ThreadId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`Timestamp`|Lorsque le <xref:System.Diagnostics.TraceOptions.Timestamp> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`HostName`|Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> propriété est `True`.|Le nom de l’ordinateur.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TraceEvent">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations sur la trace et sur les événements dans le fichier ou le flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent%2A> méthodes ne sont pas destinées à être appelé par le code d’application. Ces méthodes sont appelées par les membres de la <xref:System.Diagnostics.Debug>, <xref:System.Diagnostics.Trace>, et <xref:System.Diagnostics.TraceSource> classes pour écrire des données de trace en sortie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceEvent (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceEvent(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::String ^ message);" />
      <MemberSignature Language="F#" Value="abstract member TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string -&gt; unit&#xA;override this.TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string -&gt; unit" Usage="fileLogTraceListener.TraceEvent (eventCache, source, eventType, id, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventCache">Objet <see cref="T:System.Diagnostics.TraceEventCache" /> qui contient les informations actuelles sur l'ID de processus, l'ID de thread et la trace de la pile.</param>
        <param name="source">Nom de la source de trace qui a appelé cette méthode.</param>
        <param name="eventType">Une des valeurs d'énumération <see cref="T:System.Diagnostics.TraceEventType" />.</param>
        <param name="id">Identificateur numérique pour l'événement.</param>
        <param name="message">Message à écrire.</param>
        <summary>Écrit des informations de traçage, un message et des informations d'événement dans le fichier ou le flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode :  
  
1.  Met en forme les informations de données et le contexte pour la sortie.  
  
2.  Crée un nouveau fichier journal, si nécessaire.  
  
3.  Écrit les informations dans le fichier journal.  
  
 Pour plus d’informations sur la création de nouveaux fichiers journaux, consultez <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Ce tableau répertorie les champs de sortie dans l’ordre dans lequel ils apparaissent. Les champs sont délimités par la chaîne qui le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> propriété spécifie et sont suivies d’un terminateur de ligne.  
  
|**Champ**|**Condition de sortie**|**Description**|  
|---------------|--------------------------|---------------------|  
|`source`|Toujours.|la valeur de la propriété `name` ;|  
|`severity`|Toujours.|Le nom de la valeur d’énumération de `eventType`.|  
|`id`|Toujours.|Représentation sous forme de chaîne de `id`.|  
|`message`|Toujours.|la valeur de la propriété `message` ;|  
|`callStack`|Lorsque le <xref:System.Diagnostics.TraceOptions.Callstack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.Callstack%2A> propriété du `eventCache`.|  
|`CorrelationID`|Lorsque le <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`DateTime`|Lorsque le <xref:System.Diagnostics.TraceOptions.DateTime> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.DateTime%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ProcessID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ProcessId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ThreadID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ThreadId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`Timestamp`|Lorsque le <xref:System.Diagnostics.TraceOptions.Timestamp> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`HostName`|Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> propriété est `True`.|Le nom de l’ordinateur.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <Member MemberName="TraceEvent">
      <MemberSignature Language="C#" Value="public override void TraceEvent (System.Diagnostics.TraceEventCache eventCache, string source, System.Diagnostics.TraceEventType eventType, int id, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void TraceEvent(class System.Diagnostics.TraceEventCache eventCache, string source, valuetype System.Diagnostics.TraceEventType eventType, int32 id, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub TraceEvent (eventCache As TraceEventCache, source As String, eventType As TraceEventType, id As Integer, format As String, ParamArray args As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void TraceEvent(System::Diagnostics::TraceEventCache ^ eventCache, System::String ^ source, System::Diagnostics::TraceEventType eventType, int id, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string * obj[] -&gt; unit&#xA;override this.TraceEvent : System.Diagnostics.TraceEventCache * string * System.Diagnostics.TraceEventType * int * string * obj[] -&gt; unit" Usage="fileLogTraceListener.TraceEvent (eventCache, source, eventType, id, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventCache" Type="System.Diagnostics.TraceEventCache" />
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="eventType" Type="System.Diagnostics.TraceEventType" />
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventCache">Objet <see cref="T:System.Diagnostics.TraceEventCache" /> qui contient les informations actuelles sur l'ID de processus, l'ID de thread et la trace de la pile.</param>
        <param name="source">Nom de la source de trace qui a appelé cette méthode.</param>
        <param name="eventType">Une des valeurs d'énumération <see cref="T:System.Diagnostics.TraceEventType" />.</param>
        <param name="id">Identificateur numérique pour l'événement.</param>
        <param name="format">Chaîne de format qui contient zéro élément de format ou plus, lesquels correspondent aux objets dans le tableau <paramref name="args" />.</param>
        <param name="args">
          <see langword="Object" /> Tableau qui contient zéro ou plusieurs objets à mettre en forme.</param>
        <summary>Écrit des informations de traçage, un tableau d'objets mis en forme et des informations d'événement dans le fichier ou le flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode :  
  
1.  Met en forme les informations de données et le contexte pour la sortie.  
  
2.  Crée un nouveau fichier de journal, si nécessaire.  
  
3.  Écrit les informations dans le fichier journal.  
  
 Pour plus d’informations sur la création du nouveau fichier journal, consultez <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName%2A>.  
  
 Ce tableau répertorie les champs de sortie dans l’ordre dans lequel ils apparaissent. Les champs sont délimités par la chaîne qui le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Delimiter%2A> propriété spécifie et suivie d’un terminateur de ligne.  
  
|**Champ**|**Condition de sortie**|**Description**|  
|---------------|--------------------------|---------------------|  
|`source`|Toujours|la valeur de la propriété `name` ;|  
|`severity`|Toujours|Le nom de la valeur d’énumération de `eventType`.|  
|`id`|Toujours|Représentation sous forme de chaîne de `id`.|  
|`message`|Toujours|Les données dans `args` formatés avec le `format` chaîne et à l’aide de la culture dite indifférente pour les conversions de chaînes.|  
|`callStack`|Lorsque le <xref:System.Diagnostics.TraceOptions.Callstack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.Callstack%2A> propriété du `eventCache`.|  
|`CorrelationID`|Lorsque le <xref:System.Diagnostics.TraceOptions.LogicalOperationStack> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`DateTime`|Lorsque le <xref:System.Diagnostics.TraceOptions.DateTime> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.DateTime%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ProcessID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ProcessId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.ProcessId%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`ThreadID`|Lorsque le <xref:System.Diagnostics.TraceOptions.ThreadId> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|Le <xref:System.Diagnostics.TraceEventCache.ThreadId%2A> propriété du `eventCache`.|  
|`Timestamp`|Lorsque le <xref:System.Diagnostics.TraceOptions.Timestamp> indicateur est défini dans le <xref:System.Diagnostics.TraceListener.TraceOutputOptions%2A> propriété.|La représentation sous forme de chaîne de la <xref:System.Diagnostics.TraceEventCache.Timestamp%2A> propriété du `eventCache`. La culture dite indifférente est utilisée pour la conversion de chaîne.|  
|`HostName`|Lorsque le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.IncludeHostName%2A> propriété est `True`.|Le nom de l’ordinateur.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Diagnostics.TraceListener" />
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="P:System.Diagnostics.TraceListener.TraceOutputOptions" />
        <altmember cref="T:System.Diagnostics.TraceEventCache" />
        <altmember cref="T:System.Diagnostics.TraceEventType" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Write : string -&gt; unit&#xA;override this.Write : string -&gt; unit" Usage="fileLogTraceListener.Write message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">
          <see langword="String" />. Message personnalisé à écrire.</param>
        <summary>Écrit mot à mot un message à disque, sans informations de contexte supplémentaires.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.Write%2A> méthode écrit un message spécifique dans le fichier journal, sans informations de contexte supplémentaires.  
  
 Utilisez l’une de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> méthodes à inclure les informations de contexte dans la sortie du journal.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(System::String ^ message);" />
      <MemberSignature Language="F#" Value="abstract member WriteLine : string -&gt; unit&#xA;override this.WriteLine : string -&gt; unit" Usage="fileLogTraceListener.WriteLine message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">
          <see langword="String" />. Message personnalisé à écrire.</param>
        <summary>Écrit un message mot pour mot sur le disque, suivi par la marque de fin de ligne en cours, sans informations de contexte supplémentaires.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.WriteLine%2A> méthode écrit un message spécifique dans le fichier journal, sans informations de contexte supplémentaires.  
  
 Utilisez l’une de la <xref:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData%2A> méthodes à inclure les informations de contexte dans la sortie du journal.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:Microsoft.VisualBasic.Logging.FileLogTraceListener.FullLogFileName" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Logging.FileLogTraceListener.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>