<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IBinarySerialize.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5aa6d2af7371832ccbdde5ed90bb40f43e554dba4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa6d2af7371832ccbdde5ed90bb40f43e554dba4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>Provides custom implementation for user-defined type (UDT) and user-defined aggregate serialization and deserialization.</source>
          <target state="translated">Fournit l'implémentation personnalisée du type défini par l'utilisateur et la sérialisation et la désérialisation d'agrégats définis par l'utilisateur.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>User-defined types (UDTs) and user-defined aggregates are required to define a storage format, which can be either <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></source>
          <target state="translated">Types définis par l’utilisateur (UDT) et des agrégats définis par l’utilisateur sont requis pour définir un format de stockage, qui peut être <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>or <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph>.</source>
          <target state="translated">ou <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>allows SQL Server to handle serialization and deserialization automatically, but the format has restrictions on the kind of types it can handle.</source>
          <target state="translated">permet à SQL Server gérer la sérialisation et désérialisation automatiquement, mais le format est soumise aux restrictions sur le type de types qu’il peut gérer.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>allows user-defined types and aggregates to handle their own serialization.</source>
          <target state="translated">permet de gérer leur propre sérialisation des types définis par l’utilisateur et des agrégats.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>User-defined types and aggregates must be marked with <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></source>
          <target state="translated">Agrégats et les types définis par l’utilisateur doivent être marqués avec <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>in the <ph id="ph1">`SqlUserDefinedType`</ph> or <ph id="ph2">`SqlUserDefinedAggregate`</ph> attribute, and must implement the <ph id="ph3">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize&gt;</ph> interface.</source>
          <target state="translated">dans le <ph id="ph1">`SqlUserDefinedType`</ph> ou <ph id="ph2">`SqlUserDefinedAggregate`</ph> d’attribut et vous devez implémenter la <ph id="ph3">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>Note that even with custom serialization, the total size of each instance must be under the maximum allowed limit, currently 8000 bytes.</source>
          <target state="translated">Notez que même avec la sérialisation personnalisée, la taille totale de chaque instance doit être sous la limite maximale autorisée, actuellement 8 000 octets.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.BinaryReader" /&gt;</ph> stream from which the object is deserialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.BinaryReader" /&gt;</ph> source à partir de laquelle l'objet est désérialisé.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>Generates a user-defined type (UDT) or user-defined aggregate from its binary form.</source>
          <target state="translated">Génère un type ou un agrégat défini par l'utilisateur à partir de sa forme binaire.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>The <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> method must reconstitute your object using the information written by the <ph id="ph2">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> méthode doit reconstituer votre objet à l’aide des informations écrites par le <ph id="ph2">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>The following example shows the implementation of the <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> method of a UDT, which uses a <ph id="ph2">&lt;xref:System.IO.BinaryReader&gt;</ph> to de-serialize a previously persisted UDT.</source>
          <target state="translated">L’exemple suivant illustre l’implémentation de la <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> méthode d’un UDT, qui utilise un <ph id="ph2">&lt;xref:System.IO.BinaryReader&gt;</ph> désérialiser un UDT conservée précédemment.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>This example assumes that the UDT has two data properties: <ph id="ph1">`StringValue`</ph> and <ph id="ph2">`DoubleValue`</ph>.</source>
          <target state="translated">Cet exemple suppose que l’UDT a deux propriétés de données : <ph id="ph1">`StringValue`</ph> et <ph id="ph2">`DoubleValue`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.BinaryWriter" /&gt;</ph> stream to which the UDT or user-defined aggregate is serialized.</source>
          <target state="translated">Flux <ph id="ph1">&lt;see cref="T:System.IO.BinaryWriter" /&gt;</ph> dans lequel le type ou l'agrégat défini par l'utilisateur est sérialisé.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>Converts a user-defined type (UDT) or user-defined aggregate into its binary format so that it may be persisted.</source>
          <target state="translated">Convertit un type ou un agrégat défini par l'utilisateur en son format binaire pour le rendre persistant.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>Write sufficient information to the binary stream to allow the <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> method to reconstitute your UDT or user-defined aggregate.</source>
          <target state="translated">Rédigez des informations suffisantes pour le flux binaire autorise la <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> méthode à reconstituer votre type ou l’agrégat défini par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>The following example shows the implementation of the <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> method of a UDT, which uses a <ph id="ph2">&lt;xref:System.IO.BinaryWriter&gt;</ph> to serialize the UDT in the user-defined binary format.</source>
          <target state="translated">L’exemple suivant illustre l’implémentation de la <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> méthode d’un UDT, qui utilise un <ph id="ph2">&lt;xref:System.IO.BinaryWriter&gt;</ph> pour sérialiser l’UDT dans le format binaire défini par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>The purpose of the null character padding is to ensure that the string value is completely separated from the double value, so that one UDT is compared to another in Transact-SQL code, string bytes are compared to string bytes and double bytes are compared to double bytes.</source>
          <target state="translated">L’objectif du remplissage de caractère null est pour vous assurer que la valeur de chaîne est complètement séparée de la valeur double, afin qu’un UDT est comparé à un autre dans le code Transact-SQL, les octets de chaîne sont comparés aux octets de la chaîne et octets doubles sont comparés en double octets.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>