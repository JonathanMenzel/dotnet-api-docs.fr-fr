<Type Name="SecurityBindingElement" FullName="System.ServiceModel.Channels.SecurityBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="43d8965089f57cd47884fa2fada83af461eafe03" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39964793" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityBindingElement : System.ServiceModel.Channels.BindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityBindingElement extends System.ServiceModel.Channels.BindingElement" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.SecurityBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityBindingElement&#xA;Inherits BindingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityBindingElement abstract : System::ServiceModel::Channels::BindingElement" />
  <TypeSignature Language="F#" Value="type SecurityBindingElement = class&#xA;    inherit BindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Security</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Classe abstraite qui, une fois implémentée, représente un élément de liaison qui prend en charge la sécurité des messages SOAP de canaux.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe est la classe de base pour les éléments de liaison de sécurité de message SOAP dans WCF. Il existe trois implémentations de cette classe abstraite : <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> et <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>. Ces implémentations modèlent les liaisons définies dans la spécification de stratégie WS-Security.  
  
 Une liaison personnalisée contient une collection d'éléments de liaison réorganisés dans un ordre spécifique : l'élément qui représente le haut de la pile de liaison est ajouté en premier, l'élément suivant dans la pile de liaison est ajouté en deuxième position, etc.  
  
 Pour ajouter cette classe à une liaison, procédez comme suit :  
  
1.  Créer un <xref:System.ServiceModel.Channels.BindingElementCollection>.  
  
2.  Créez un élément de liaison personnalisé placé au-dessus de cet élément de liaison dans la pile de liaison, tel que les <xref:System.ServiceModel.Channels.TransactionFlowBindingElement> et <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> facultatifs.  
  
3.  Ajoutez ces éléments dans l'ordre précédemment indiqué au <xref:System.ServiceModel.Channels.BindingElementCollection> à l'aide de la méthode <xref:System.ServiceModel.Channels.BindingElementCollection.InsertItem%2A>.  
  
4.  Créez une instance d'un élément de liaison de sécurité dérivé de <xref:System.ServiceModel.Channels.SecurityBindingElement>, tel que <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement>, <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> ou <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>.  
  
5.  Ajoutez l’élément de liaison de sécurité dérivé à la collection.  
  
6.  Ajoutez tout élément de liaison personnalisé supplémentaire à la collection, tel que <xref:System.ServiceModel.Channels.TcpTransportBindingElement>.  
  
 Pour plus d’informations sur l’utilisation d’un <xref:System.ServiceModel.Channels.SecurityBindingElement>, consultez [Modes d’authentification SecurityBindingElement](~/docs/framework/wcf/feature-details/securitybindingelement-authentication-modes.md) et [Comment : créer un personnalisé de liaison à l’aide de SecurityBindingElement](~/docs/framework/wcf/feature-details/how-to-create-a-custom-binding-using-the-securitybindingelement.md).  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé, vous devez traiter ses propriétés comme étant immuables. En appelant `set` sur certaines propriétés, vous risquez d'obtenir des résultats imprévisibles : la liaison peut se comporter comme si la propriété avait conservé sa valeur antérieure, un échec de l'exécution étant alors le seul indicateur d'un problème. <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> et <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> sont deux propriétés connues pour se comporter ainsi. D'autres propriétés peuvent également être concernées.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AllowInsecureTransport">
      <MemberSignature Language="C#" Value="public bool AllowInsecureTransport { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowInsecureTransport" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.AllowInsecureTransport" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowInsecureTransport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowInsecureTransport { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowInsecureTransport : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.AllowInsecureTransport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique s'il est possible d'envoyer des messages sécurisés en mode mixte via un transport non sécurisé tel que le protocole HTTP.</summary>
        <value>
          <see langword="true" /> s'il est possible d'envoyer des messages sécurisés en mode mixte via un transport non sécurisé ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="securityBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de fabrique de canaux.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Crée une fabrique de canal basée sur les paramètres <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> et le contexte de liaison transmis. La fabrication de canal créée est une fabrication de canal de sécurité de messages SOAP, qui comprend en interne une référence à la fabrication de canal correspondant au contexte de liaison (lequel inclut la fabrication du canal de transport).</summary>
        <returns>Fabrique de canal basée sur les paramètres <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> et le contexte de liaison transmis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fabrication de canal créée est une fabrication de canal de sécurité de messages SOAP, qui comprend en interne une référence à la fabrication de canal correspondant au contexte de liaison (lequel inclut la fabrication du canal de transport).  
  
 Cette méthode vérifie les erreurs de paramètres, puis appelle <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactoryCore%2A>. Lorsqu’elle est implémentée dans une classe dérivée, cette méthode crée une fabrique de canal, qui est utilisée pour créer un canal qui traite les messages sortants pour cette liaison.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un canal de type <paramref name="TChannel" /> n'est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactoryCore&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="protected abstract System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactoryCore&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactoryCore&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactoryCore``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function BuildChannelFactoryCore(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TChannel&gt;&#xA; abstract System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactoryCore(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member BuildChannelFactoryCore : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="securityBindingElement.BuildChannelFactoryCore context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de fabrique de canaux.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>En cas d'implémentation, crée une fabrication de canal d'un type spécifié.</summary>
        <returns>Fabrique de canaux d'un type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelFactory%2A>, qui vérifie les erreurs, appelle cette méthode. Lorsqu’elle est implémentée dans une classe dérivée, cette méthode crée une fabrique de canal, qui est utilisée pour créer un canal qui traite les messages sortants pour cette liaison.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un canal de type <paramref name="TChannel" /> n'est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="securityBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type d'écouteur de canal.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Crée un écouteur de canal basé sur les paramètres <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> et le contexte de liaison transmis.</summary>
        <returns>Écouteur de canal basé sur les paramètres <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> et le contexte de liaison transmis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fabrication de canal créée est un écouteur de canal de sécurité de messages SOAP, qui comprend en interne une référence à l’écouteur de canal correspondant au contexte de liaison, lequel inclut l’écouteur du canal de transport.  
  
 Cette méthode vérifie les erreurs de paramètres, puis appelle <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListenerCore%2A>. Lorsqu’elle est implémentée dans une classe dérivée, cette méthode crée un écouteur de canal, qui est utilisé pour créer un canal qui traite les messages entrants pour cette liaison.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un canal de type <paramref name="TChannel" /> n'est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListenerCore&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="protected abstract System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListenerCore&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListenerCore&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListenerCore``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function BuildChannelListenerCore(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel abstract System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListenerCore(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member BuildChannelListenerCore : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="securityBindingElement.BuildChannelListenerCore context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type d'écouteur de canal.</typeparam>
        <param name="context">Objet <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>En cas d'implémentation, crée un écouteur de canal d'un type spécifié.</summary>
        <returns>Écouteur de canal d'un type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityBindingElement.BuildChannelListener%2A>, qui vérifie les erreurs, appelle cette méthode. Lorsqu’elle est implémentée dans une classe dérivée, cette méthode crée un écouteur de canal, qui est utilisé pour créer un canal qui traite les messages sortants pour cette liaison.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un canal de type <paramref name="TChannel" /> n'est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="securityBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de fabrique de canaux.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Détermine si une fabrication de canal du type spécifié peut être construite.</summary>
        <returns>
          <see langword="true" /> si la fabrication de canal du type spécifié peut être créée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est recommandé d'appeler cette méthode avant d'essayer de créer une fabrication de canal.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="securityBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type d'écouteur de canal.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Détermine si un écouteur de canal du type spécifié peut être construit.</summary>
        <returns>
          <see langword="true" /> si un écouteur de canal du type spécifié peut être créé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est recommandé d'appeler cette méthode avant d'essayer de créer un écouteur de canal.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAnonymousForCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateAnonymousForCertificateBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateAnonymousForCertificateBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateAnonymousForCertificateBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateAnonymousForCertificateBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateAnonymousForCertificateBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateAnonymousForCertificateBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateAnonymousForCertificateBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour l’authentification de client anonyme et l’authentification de serveur par certificat.</summary>
        <returns>Un <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> qui détient la nouvelle liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le client et le serveur doivent être configurés hors plage avec le certificat de service.  
  
 La liaison est créée alors que <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> a la valeur <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A> et <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> a la valeur `true`.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment appeler cette méthode.  
  
 [!code-csharp[c_CustomBindingsAuthMode#3](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombindingsauthmode/cs/source.cs#3)]
 [!code-vb[c_CustomBindingsAuthMode#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_custombindingsauthmode/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateCertificateOverTransportBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité qui attend que les clients effectuent l’authentification par certificat à l’aide de la sécurité des messages SOAP. Cet élément de liaison attend que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le client doit être configuré avec un certificat qu'il utilise pour l'authentification.  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> doit être traitée comme étant immuable. Un comportement incohérent de la liaison peut se produire si cette valeur est modifiée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateCertificateOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCertificateOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateCertificateOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateCertificateOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité qui attend que les clients effectuent l’authentification par certificat à l’aide de la sécurité des messages SOAP.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet élément de liaison attend que le transport assure l’authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).  
  
 L'élément de liaison est configuré pour utiliser la propriété <xref:System.ServiceModel.MessageSecurityVersion.Default%2A> de la classe <xref:System.ServiceModel.MessageSecurityVersion>.  
  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCertificateOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement (System.ServiceModel.MessageSecurityVersion version);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateCertificateOverTransportBindingElement(class System.ServiceModel.MessageSecurityVersion version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement(System.ServiceModel.MessageSecurityVersion)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCertificateOverTransportBindingElement (version As MessageSecurityVersion) As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateCertificateOverTransportBindingElement(System::ServiceModel::MessageSecurityVersion ^ version);" />
      <MemberSignature Language="F#" Value="static member CreateCertificateOverTransportBindingElement : System.ServiceModel.MessageSecurityVersion -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateOverTransportBindingElement version" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
      </Parameters>
      <Docs>
        <param name="version">
          <see cref="T:System.ServiceModel.MessageSecurityVersion" /> pour la liaison.</param>
        <summary>Crée un élément de liaison de sécurité qui attend que les clients effectuent l’authentification par certificat à l’aide de la sécurité des messages SOAP.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet élément de liaison attend que le transport assure l’authentification du serveur ainsi que la protection des messages (par exemple, HTTPS). L'élément de liaison est configuré avec le <xref:System.ServiceModel.MessageSecurityVersion> spécifié.  
  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCertificateSignatureBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateCertificateSignatureBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateCertificateSignatureBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateSignatureBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateCertificateSignatureBindingElement () As AsymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::AsymmetricSecurityBindingElement ^ CreateCertificateSignatureBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateCertificateSignatureBindingElement : unit -&gt; System.ServiceModel.Channels.AsymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateCertificateSignatureBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.AsymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison à l’aide d’un certificat pour signer des messages. Cet élément de liaison peut être utilisé uniquement pour les échanges de messages unidirectionnels et ne peut que signer le message.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 Cet élément de liaison requiert que le client configure un certificat aux fins d’authentification.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">
          <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" /> qui représente le jeton émis sur la base d'une clé symétrique.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client à l’aide d’un jeton émis sur la base d’une clé symétrique.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les paramètres de jeton émis doivent avoir un type de clé symétrique.  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> doit être traitée comme étant immuable. Un comportement incohérent de la liaison peut se produire si cette valeur est modifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le type de clé de <paramref name="issuedTokenParameters" /> n'est pas symétrique.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenForCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForCertificateBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForCertificateBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenForCertificateBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenForCertificateBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenForCertificateBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">
          <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" /> qui représente le jeton émis basé sur la clé symétrique.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client sur la base d’un jeton émis et l’authentification du serveur sur la base du certificat de serveur.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton émis peut avoir une clé symétrique ou asymétrique. Le client et le serveur doivent être configurés avec le certificat du serveur.  
  
 La propriété <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> de la liaison créée a la `true` et sa propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> a la valeur <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A>.  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> doit être traitée comme étant immuable. Un comportement incohérent de la liaison peut se produire si cette valeur est modifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateIssuedTokenForSslBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client sur la base d’un jeton émis et l’authentification du serveur sur la base du certificat de serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton émis peut avoir une clé symétrique ou asymétrique. Le client authentifie le serveur à l'aide du protocole SSL au niveau SOAP.  
  
 Les deux surcharges utilisent un paramètre <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters>. L'une d'elle comprend un paramètre qui indique si l'annulation est requise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateIssuedTokenForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenForSslBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenForSslBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenForSslBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">Élément <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client sur la base d’un jeton émis et l’authentification du serveur sur la base du certificat de serveur.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le serveur émet un jeton de contexte de sécurité basé sur un cookie à la fin du protocole SSL.  
  
 La propriété <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> de la liaison créée a la `true` et sa propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> a la valeur <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters, bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateIssuedTokenForSslBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters, bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenForSslBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters, requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateIssuedTokenForSslBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters, bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenForSslBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters * bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement (issuedTokenParameters, requireCancellation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">Élément <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />.</param>
        <param name="requireCancellation">
          <see langword="true" /> si l'annulation est requise ; sinon, <see langword="false" />. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client sur la base d’un jeton émis et l’authentification du serveur sur la base du certificat de serveur.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> de la liaison créée a la `true` et sa propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> a la valeur <xref:System.ServiceModel.MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateIssuedTokenOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateIssuedTokenOverTransportBindingElement (System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateIssuedTokenOverTransportBindingElement(class System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters issuedTokenParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement(System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIssuedTokenOverTransportBindingElement (issuedTokenParameters As IssuedSecurityTokenParameters) As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateIssuedTokenOverTransportBindingElement(System::ServiceModel::Security::Tokens::IssuedSecurityTokenParameters ^ issuedTokenParameters);" />
      <MemberSignature Language="F#" Value="static member CreateIssuedTokenOverTransportBindingElement : System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement issuedTokenParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="issuedTokenParameters" Type="System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />
      </Parameters>
      <Docs>
        <param name="issuedTokenParameters">Élément <see cref="T:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters" />.</param>
        <summary>Crée un élément de liaison de sécurité configuré pour requérir l’authentification du client en fonction de la sécurité SOAP à l’aide d’un jeton émis. Cet élément de liaison requiert que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Security.Tokens.IssuedSecurityTokenParameters.KeyType%2A> doit être traitée comme étant immuable. Un comportement incohérent de la liaison peut se produire si cette valeur est modifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="issuedTokenParameters" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateKerberosBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateKerberosBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateKerberosBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateKerberosBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateKerberosBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateKerberosBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client sur la base du jeton Kerberos du client.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour effectuer l'authentification Kerberos, le serveur doit s'exécuter sous un compte dont le nom de principal du service est enregistré dans Active Directory. NetworkService est un tel compte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateKerberosOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateKerberosOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateKerberosOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateKerberosOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateKerberosOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateKerberosOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateKerberosOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité configuré pour requérir l'authentification du client sur la base de la sécurité SOAP à l'aide du jeton Kerberos du client. Cet élément de liaison requiert que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour effectuer l'authentification Kerberos, le serveur doit s'exécuter sous un compte dont le nom de principal du service est enregistré dans Active Directory. NetworkService est un tel compte.  
  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`. La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateMutualCertificateBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le client doit être configuré avec son certificat ainsi qu'avec le certificat du serveur. Le serveur doit être configuré avec son certificat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateMutualCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateBindingElement () As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateMutualCertificateBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateBindingElement : unit -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La liaison est configurée afin qu'une nouvelle clé symétrique aléatoire (chiffrée pour le serveur) soit générée pour chaque demande du client et soit utilisée pour protéger aussi bien la demande que la réponse du serveur. Le certificat du client est utilisé comme un jeton de prise en charge d'approbation sur la demande.  
  
 Un <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> est en fait créé.  
  
   
  
## Examples  
 L'exemple de code suivant montre comment appeler cette méthode.  
  
 [!code-csharp[c_CreateSecureSession#5](~/samples/snippets/csharp/VS_Snippets_CFX/c_createsecuresession/cs/secureservice.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMutualCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement (System.ServiceModel.MessageSecurityVersion version);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement(class System.ServiceModel.MessageSecurityVersion version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement(System.ServiceModel.MessageSecurityVersion)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateBindingElement (version As MessageSecurityVersion) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateMutualCertificateBindingElement(System::ServiceModel::MessageSecurityVersion ^ version);" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateBindingElement : System.ServiceModel.MessageSecurityVersion -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement version" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
      </Parameters>
      <Docs>
        <param name="version">Version de sécurité du message.</param>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la version est WSSecurity10, l’élément de liaison est alors configuré de sorte que la demande du client soit signée par son certificat et chiffrée avec le certificat du serveur.  
  
 Si la version est WSSecurity11, l'élément de liaison est alors configuré de sorte qu'une nouvelle clé symétrique aléatoire (chiffrée pour le serveur) soit générée pour chaque demande du client et soit utilisée pour protéger aussi bien la demande que la réponse du serveur. Le certificat du client est utilisé comme un jeton de prise en charge d'approbation sur la demande.  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> est immuable. Appeler dessus `set` ne la modifie pas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateMutualCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement (System.ServiceModel.MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateMutualCertificateBindingElement(class System.ServiceModel.MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement(System.ServiceModel.MessageSecurityVersion,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateBindingElement (version As MessageSecurityVersion, allowSerializedSigningTokenOnReply As Boolean) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateMutualCertificateBindingElement(System::ServiceModel::MessageSecurityVersion ^ version, bool allowSerializedSigningTokenOnReply);" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateBindingElement : System.ServiceModel.MessageSecurityVersion * bool -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateBindingElement (version, allowSerializedSigningTokenOnReply)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
        <Parameter Name="allowSerializedSigningTokenOnReply" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="version">Version de sécurité du message.</param>
        <param name="allowSerializedSigningTokenOnReply">
          <see langword="true" /> pour autoriser un jeton de signature sérialisé dans la réponse ; sinon <see langword="false" />.</param>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le paramètre `allowSerializedSigningTokenOnReply`, lorsqu'il a la valeur `true`, active l'interopérabilité avec les versions antérieures de WSE (Web Services Enhancements).  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> doit être traitée comme étant immuable. Un comportement incohérent de la liaison peut se produire si cette valeur est modifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateMutualCertificateDuplexBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat. Ce mode d'authentification peut être utilisé pour sécuriser les modèles d'échange de messages duplex et requiert que le service soit configuré avec le certificat du client hors plage.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateMutualCertificateDuplexBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateDuplexBindingElement () As AsymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::AsymmetricSecurityBindingElement ^ CreateMutualCertificateDuplexBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateDuplexBindingElement : unit -&gt; System.ServiceModel.Channels.AsymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.AsymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat. Ce mode d'authentification peut être utilisé pour sécuriser les modèles d'échange de messages duplex et requiert que le service soit configuré avec le certificat du client hors plage.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMutualCertificateDuplexBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement (System.ServiceModel.MessageSecurityVersion version);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.AsymmetricSecurityBindingElement CreateMutualCertificateDuplexBindingElement(class System.ServiceModel.MessageSecurityVersion version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement(System.ServiceModel.MessageSecurityVersion)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateMutualCertificateDuplexBindingElement (version As MessageSecurityVersion) As AsymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::AsymmetricSecurityBindingElement ^ CreateMutualCertificateDuplexBindingElement(System::ServiceModel::MessageSecurityVersion ^ version);" />
      <MemberSignature Language="F#" Value="static member CreateMutualCertificateDuplexBindingElement : System.ServiceModel.MessageSecurityVersion -&gt; System.ServiceModel.Channels.AsymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateMutualCertificateDuplexBindingElement version" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.AsymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.ServiceModel.MessageSecurityVersion" />
      </Parameters>
      <Docs>
        <param name="version">Version de sécurité du message.</param>
        <summary>Crée un élément de liaison de sécurité asymétrique qui est configuré pour requérir l'authentification du client et du serveur par certificat. Ce mode d’authentification peut être utilisé pour sécuriser les modèles d’échange de messages duplex et requiert que le service soit configuré avec le certificat du client hors plage.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.AsymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé en appelant cette méthode, la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion%2A> doit être traitée comme étant immuable. Un comportement incohérent de la liaison peut se produire si cette valeur est modifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="version" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSecureConversationBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour établir une conversation sécurisée entre le client et le service. Le jeton de contexte de sécurité émis à la fin du protocole de transfert de conversation sécurisé est utilisé pour sécuriser les messages.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSecureConversationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement (System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement(class System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement(System.ServiceModel.Channels.SecurityBindingElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSecureConversationBindingElement (bootstrapSecurity As SecurityBindingElement) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateSecureConversationBindingElement(System::ServiceModel::Channels::SecurityBindingElement ^ bootstrapSecurity);" />
      <MemberSignature Language="F#" Value="static member CreateSecureConversationBindingElement : System.ServiceModel.Channels.SecurityBindingElement -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement bootstrapSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bootstrapSecurity" Type="System.ServiceModel.Channels.SecurityBindingElement" />
      </Parameters>
      <Docs>
        <param name="bootstrapSecurity">
          <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> qui contient la spécification de la façon dont les messages protocolaires de conversation sont sécurisés.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour établir une conversation sécurisée entre le client et le service. Le jeton de contexte de sécurité émis à la fin du protocole de transfert de conversation sécurisé est utilisé pour sécuriser les messages. L’élément de liaison de sécurité du démarrage indique comment les messages protocolaires de conversation sont sécurisés.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’élément de liaison est configuré pour utiliser des jetons de contexte de sécurité basés sur une session.  
  
 `bootstrapSecurity` est utilisé pour indiquer la stratégie et la liaison de sécurité servant à demander un jeton de conversation sécurisé au service.  
  
 Si `bootstrapSecurity` est un <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>, l'élément de liaison renvoyé par cette méthode l'est également, et <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> a la valeur `true` ; la propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false` ; et la propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 Sinon, un <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> est renvoyé, et <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bootstrapSecurity" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSecureConversationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement (System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement(class System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement(System.ServiceModel.Channels.SecurityBindingElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSecureConversationBindingElement (bootstrapSecurity As SecurityBindingElement, requireCancellation As Boolean) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateSecureConversationBindingElement(System::ServiceModel::Channels::SecurityBindingElement ^ bootstrapSecurity, bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSecureConversationBindingElement : System.ServiceModel.Channels.SecurityBindingElement * bool -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement (bootstrapSecurity, requireCancellation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bootstrapSecurity" Type="System.ServiceModel.Channels.SecurityBindingElement" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bootstrapSecurity">
          <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> qui contient la spécification de la façon dont les messages protocolaires de conversation sont sécurisés.</param>
        <param name="requireCancellation">
          <see langword="true" /> si l'annulation est requise ; sinon, <see langword="false" />. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour établir une conversation sécurisée entre le client et le service. Le jeton de contexte de sécurité émis à la fin du protocole de transfert de conversation sécurisé est utilisé pour sécuriser les messages.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `requireCancellation` est `false`, des jetons de contexte de sécurité basés sur un cookie sont émis ; sinon, des jetons de contexte de sécurité basés sur une session sont émis.  
  
 `bootstrapSecurity` est utilisé pour indiquer la stratégie et la liaison de sécurité servant à demander `SecureConversationToken` au service.  
  
 Si `bootstrapSecurity` est un <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>, l'élément de liaison renvoyé par cette méthode est également un `TransportSecurityBindingElement`, et <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> a la valeur `true` ; la propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false` ; et la propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 Sinon, un <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> est renvoyé, et <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> a la valeur `false`.  
  
> [!NOTE]
>  Lorsque l'emprunt d'identité est requis sur [!INCLUDE[wxp](~/includes/wxp-md.md)], utilisez une session sécurisée sans jeton de contexte de sécurité. Lorsque des jetons de contexte de sécurité sont utilisés avec l'emprunt d'identité, une <xref:System.InvalidOperationException> est renvoyée. Pour plus d’informations, consultez [scénarios non pris en charge](~/docs/framework/wcf/feature-details/unsupported-scenarios.md). Pour plus d’informations sur les sessions sécurisées, consultez [des Sessions sécurisées](~/docs/framework/wcf/feature-details/secure-sessions.md).  
  
   
  
## Examples  
 L'exemple de code suivant montre comment appeler cette méthode.  
  
 [!code-csharp[c_CreateSecureSession#6](~/samples/snippets/csharp/VS_Snippets_CFX/c_createsecuresession/cs/secureservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bootstrapSecurity" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSecureConversationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement (System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation, System.ServiceModel.Security.ChannelProtectionRequirements bootstrapProtectionRequirements);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SecurityBindingElement CreateSecureConversationBindingElement(class System.ServiceModel.Channels.SecurityBindingElement bootstrapSecurity, bool requireCancellation, class System.ServiceModel.Security.ChannelProtectionRequirements bootstrapProtectionRequirements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement(System.ServiceModel.Channels.SecurityBindingElement,System.Boolean,System.ServiceModel.Security.ChannelProtectionRequirements)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSecureConversationBindingElement (bootstrapSecurity As SecurityBindingElement, requireCancellation As Boolean, bootstrapProtectionRequirements As ChannelProtectionRequirements) As SecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SecurityBindingElement ^ CreateSecureConversationBindingElement(System::ServiceModel::Channels::SecurityBindingElement ^ bootstrapSecurity, bool requireCancellation, System::ServiceModel::Security::ChannelProtectionRequirements ^ bootstrapProtectionRequirements);" />
      <MemberSignature Language="F#" Value="static member CreateSecureConversationBindingElement : System.ServiceModel.Channels.SecurityBindingElement * bool * System.ServiceModel.Security.ChannelProtectionRequirements -&gt; System.ServiceModel.Channels.SecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement (bootstrapSecurity, requireCancellation, bootstrapProtectionRequirements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bootstrapSecurity" Type="System.ServiceModel.Channels.SecurityBindingElement" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
        <Parameter Name="bootstrapProtectionRequirements" Type="System.ServiceModel.Security.ChannelProtectionRequirements" />
      </Parameters>
      <Docs>
        <param name="bootstrapSecurity">
          <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> qui contient la spécification de la façon dont les messages protocolaires de conversation sont sécurisés.</param>
        <param name="requireCancellation">
          <see langword="true" /> si l'annulation est requise ; sinon, <see langword="false" />. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <param name="bootstrapProtectionRequirements">Objet <see cref="T:System.ServiceModel.Security.ChannelProtectionRequirements" /> qui décrit les spécifications de la protection du canal.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour établir une conversation sécurisée entre le client et le service. Le jeton de contexte de sécurité émis à la fin du protocole de transfert de conversation sécurisé est utilisé pour sécuriser les messages. L’élément de liaison de sécurité du démarrage indique comment les messages protocolaires de conversation sont sécurisés.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le paramètre `bootstrapProtectionRequirements` active la personnalisation de la sécurisation des messages échangés dans le cadre du protocole de transfert de conversation sécurisé.  
  
 `bootstrapSecurity` est utilisé pour indiquer la stratégie et la liaison de sécurité servant à demander un jeton de conversation sécurisé au service.  
  
 Si `bootstrapSecurity` est un <xref:System.ServiceModel.Channels.TransportSecurityBindingElement>, l'élément de liaison renvoyé par cette méthode est également un `TransportSecurityBindingElement`, et <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> a la valeur `true` ; la propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false` ; et la propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 Sinon, un <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> est renvoyé, et <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.RequireSignatureConfirmation%2A> a la valeur `false`.  
  
> [!NOTE]
>  Lorsque l'emprunt d'identité est requis sur [!INCLUDE[wxp](~/includes/wxp-md.md)], utilisez une session sécurisée sans jeton de contexte de sécurité. Lorsque des jetons de contexte de sécurité sont utilisés avec l'emprunt d'identité, une <xref:System.InvalidOperationException> est renvoyée. Pour plus d’informations, consultez [scénarios non pris en charge](~/docs/framework/wcf/feature-details/unsupported-scenarios.md). Pour plus d’informations sur les sessions sécurisées, consultez [des Sessions sécurisées](~/docs/framework/wcf/feature-details/secure-sessions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bootstrapSecurity" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSslNegotiationBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour exécuter la négociation SSL au niveau SOAP entre le client et le serveur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSslNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement (bool requireClientCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement(bool requireClientCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSslNegotiationBindingElement (requireClientCertificate As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSslNegotiationBindingElement(bool requireClientCertificate);" />
      <MemberSignature Language="F#" Value="static member CreateSslNegotiationBindingElement : bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement requireClientCertificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireClientCertificate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireClientCertificate">
          <see langword="true" /> si un certificat client est requis pendant la négociation SSL.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour exécuter la négociation SSL au niveau SOAP entre le client et le serveur, en indiquant si un certificat client est requis.</summary>
        <returns>Un <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> qui détient la nouvelle liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton de contexte de sécurité émis après la négociation SSL est basé sur un cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSslNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement (bool requireClientCertificate, bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSslNegotiationBindingElement(bool requireClientCertificate, bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSslNegotiationBindingElement (requireClientCertificate As Boolean, requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSslNegotiationBindingElement(bool requireClientCertificate, bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSslNegotiationBindingElement : bool * bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSslNegotiationBindingElement (requireClientCertificate, requireCancellation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireClientCertificate" Type="System.Boolean" />
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireClientCertificate">
          <see langword="true" /> si un certificat client est requis pendant la négociation SSL.</param>
        <param name="requireCancellation">
          <see langword="true" /> si l'annulation est requise. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <summary>Crée un élément de liaison de sécurité symétrique qui exécute la négociation SOAP SSL, en indiquant si un certificat client et l’annulation sont requis.</summary>
        <returns>Un <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" /> qui détient la nouvelle liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton de contexte de sécurité émis après la négociation SSL est basé sur une session, auquel cas `requireCancellation` est `true` ; sinon, le jeton est basé sur un cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSspiNegotiationBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique qui exécute la négociation SOAP SSPI sur la base du package Authentification par négociation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSspiNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSspiNegotiationBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique qui exécute la négociation SOAP SSPI sur la base du package Authentification par négociation.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton de contexte de sécurité émis à la fin de la négociation SSPI est basé sur un cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSspiNegotiationBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement (bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateSspiNegotiationBindingElement(bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationBindingElement (requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateSspiNegotiationBindingElement(bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationBindingElement : bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationBindingElement requireCancellation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireCancellation">Indique si l'annulation est requise. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <summary>Crée un élément de liaison de sécurité symétrique qui exécute la négociation SOAP SSPI sur la base du package Authentification par négociation.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `requireCancellation` est `false`, le jeton de contexte de sécurité émis à la fin de la négociation SSPI est basé sur un cookie ; sinon, il est basé sur une session.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSspiNegotiationOverTransportBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité configuré pour l’authentification du client sur la base de la négociation SOAP SSPI à l’aide du package Authentification par négociation. L'élément de liaison requiert que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSspiNegotiationOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateSspiNegotiationOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité configuré pour l’authentification du client sur la base de la négociation SOAP SSPI à l’aide du package Authentification par négociation. L'élément de liaison requiert que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton de contexte de sécurité émis à la fin de la négociation SSPI est basé sur un cookie.  
  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`. La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSspiNegotiationOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement (bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateSspiNegotiationOverTransportBindingElement(bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSspiNegotiationOverTransportBindingElement (requireCancellation As Boolean) As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateSspiNegotiationOverTransportBindingElement(bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateSspiNegotiationOverTransportBindingElement : bool -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement requireCancellation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireCancellation">Indique si l'annulation est requise. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <summary>Crée un élément de liaison de sécurité configuré pour l’authentification du client sur la base de la négociation SOAP SSPI à l’aide du package Authentification par négociation. L'élément de liaison requiert que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `requireCancellation` est `false`, des jetons de contexte de sécurité basés sur un cookie sont émis ; sinon, des jetons de contexte de sécurité basés sur une session sont émis.  
  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`. La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUserNameForCertificateBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForCertificateBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForCertificateBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForCertificateBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameForCertificateBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateUserNameForCertificateBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateUserNameForCertificateBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForCertificateBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client en fonction de son nom d’utilisateur et de son mot de passe et l’authentification du serveur par certificat. L'élément de liaison créé requiert que le client soit configuré avec un certificat de service hors plage avant d'ouvrir un canal de communication avec un service.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le certificat du serveur doit être configuré hors plage sur le client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateUserNameForSslBindingElement">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client en fonction de son nom d’utilisateur et de son mot de passe et l’authentification du serveur par certificat. Le client authentifie le serveur à l'aide du protocole SSL au niveau SOAP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateUserNameForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameForSslBindingElement () As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateUserNameForSslBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateUserNameForSslBindingElement : unit -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client en fonction de son nom d’utilisateur et de son mot de passe et l’authentification du serveur par certificat. Le client authentifie le serveur à l'aide du protocole SSL au niveau SOAP.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton de contexte de sécurité émis à la fin de la négociation SSPI est basé sur un cookie.  
  
 Il n'est pas nécessaire que le client soit configuré avec le certificat de serveur car il l'obtient dans le cadre du protocole SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUserNameForSslBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement (bool requireCancellation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.SymmetricSecurityBindingElement CreateUserNameForSslBindingElement(bool requireCancellation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameForSslBindingElement (requireCancellation As Boolean) As SymmetricSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::SymmetricSecurityBindingElement ^ CreateUserNameForSslBindingElement(bool requireCancellation);" />
      <MemberSignature Language="F#" Value="static member CreateUserNameForSslBindingElement : bool -&gt; System.ServiceModel.Channels.SymmetricSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameForSslBindingElement requireCancellation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SymmetricSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireCancellation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireCancellation">Indique si l'annulation est requise. Si ce paramètre a la valeur <see langword="false" />, il active un jeton de contexte de sécurité qui s'avère utile dans les scénarios de batterie de serveurs Web car, dans ce mode, l'état de session est encodé dans le jeton de contexte de sécurité établi au lieu d'être conservé dans la mémoire du serveur.</param>
        <summary>Crée un élément de liaison de sécurité symétrique configuré pour requérir l’authentification du client en fonction de son nom d’utilisateur et de son mot de passe et l’authentification du serveur par certificat. Le client authentifie le serveur à l'aide du protocole SSL au niveau SOAP.</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.SymmetricSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `requireCancellation` est `false`, des jetons de contexte de sécurité avec état sont émis ; sinon, des jetons de contexte de sécurité sans état sont émis.  
  
 Il n'est pas nécessaire que le client soit configuré avec le certificat de serveur car il l'obtient dans le cadre du protocole SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUserNameOverTransportBindingElement">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.TransportSecurityBindingElement CreateUserNameOverTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.TransportSecurityBindingElement CreateUserNameOverTransportBindingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameOverTransportBindingElement" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateUserNameOverTransportBindingElement () As TransportSecurityBindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::TransportSecurityBindingElement ^ CreateUserNameOverTransportBindingElement();" />
      <MemberSignature Language="F#" Value="static member CreateUserNameOverTransportBindingElement : unit -&gt; System.ServiceModel.Channels.TransportSecurityBindingElement" Usage="System.ServiceModel.Channels.SecurityBindingElement.CreateUserNameOverTransportBindingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.TransportSecurityBindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément de liaison de sécurité configuré pour l’authentification du client en fonction du nom d’utilisateur et du mot de passe envoyés dans le cadre du message SOAP. L'élément de liaison requiert que le transport assure l'authentification du serveur ainsi que la protection des messages (par exemple, HTTPS).</summary>
        <returns>Objet <see cref="T:System.ServiceModel.Channels.TransportSecurityBindingElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> de la liaison créée a la valeur `true`. La propriété <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalClientSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 La propriété <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> de l'objet <xref:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings%2A> renvoyé par <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.DetectReplays%2A> a la valeur `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultAlgorithmSuite">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityAlgorithmSuite DefaultAlgorithmSuite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.SecurityAlgorithmSuite DefaultAlgorithmSuite" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.DefaultAlgorithmSuite" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultAlgorithmSuite As SecurityAlgorithmSuite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::SecurityAlgorithmSuite ^ DefaultAlgorithmSuite { System::ServiceModel::Security::SecurityAlgorithmSuite ^ get(); void set(System::ServiceModel::Security::SecurityAlgorithmSuite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultAlgorithmSuite : System.ServiceModel.Security.SecurityAlgorithmSuite with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.DefaultAlgorithmSuite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityAlgorithmSuite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les algorithmes de chiffrement de message et de clé de type WRAP.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Security.SecurityAlgorithmSuite" /> qui représente les algorithmes de chiffrement de message et de clé de type WRAP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceModel.Security.SecurityAlgorithmSuite> objet qui contient de nombreuses propriétés qui spécifient les algorithmes de sécurité qui doivent être utilisées pour la signature, chiffrement, dérivation de clé et autres opérations de chiffrement. Il détermine également les tailles de clé utilisées pour exécuter ces opérations de chiffrement.  
  
   
  
## Examples  
 Le code suivant montre comment définir cette propriété.  
  
 [!code-csharp[c_CustomBindingsAuthMode#8](~/samples/snippets/csharp/VS_Snippets_CFX/c_custombindingsauthmode/cs/source.cs#8)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur n'est pas null sur un <see langword="set" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableUnsecuredResponse">
      <MemberSignature Language="C#" Value="public bool EnableUnsecuredResponse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUnsecuredResponse" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.EnableUnsecuredResponse" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUnsecuredResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUnsecuredResponse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableUnsecuredResponse : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.EnableUnsecuredResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si WCF peut envoyer et recevoir des réponses non sécurisées aux demandes sécurisées.</summary>
        <value>
          <see langword="true" /> Si WCF peut envoyer et recevoir des réponses non sécurisées aux demandes sécurisées ; Sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndpointSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SupportingTokenParameters EndpointSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.Tokens.SupportingTokenParameters EndpointSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndpointSupportingTokenParameters As SupportingTokenParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ EndpointSupportingTokenParameters { System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EndpointSupportingTokenParameters : System.ServiceModel.Security.Tokens.SupportingTokenParameters" Usage="System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SupportingTokenParameters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le point de terminaison qui prend en charge des paramètres de jeton.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> qui représente le point de terminaison qui prend en charge les paramètres de jeton.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jetons de prise en charge fournissent des revendications supplémentaires outre celles contenues dans les jetons principaux de la liaison. La collection renvoyée par <xref:System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters%2A> contient des paramètres de jeton supplémentaires (<xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters>) pour toutes les opérations définies par un point de terminaison. Les paramètres du jeton principal sont recherchés sur <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> ou <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> (les deux héritent de la classe <xref:System.ServiceModel.Channels.SecurityBindingElement> ). Dans le cas de <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, les paramètres du jeton principal sont renvoyés par la propriété <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters%2A>. L'élément <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> comporte deux propriétés de paramètre : <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.InitiatorTokenParameters%2A> et <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.RecipientTokenParameters%2A>.  
  
> [!NOTE]
>  Les propriétés sont appelées "paramètres" car elles spécifient uniquement le type du jeton de sécurité, pas les valeurs réelles.  
>   
>  Les jetons de prise en charge peuvent se limiter au niveau du point de terminaison, auquel cas ils sont inclus dans tous les messages sécurisés envoyés par le client au service. Le service veille à ce que tous ces messages contiennent les types de jetons de prise en charge configurés par cette propriété.  
>   
>  Pour ne fournir les jetons de prise en charge que pour une opération (et non toutes les opérations sur un point de terminaison), utilisez la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="securityBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Propriété à obtenir.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" />.</param>
        <summary>Obtient un objet spécifié à l'aide du <see cref="T:System.ServiceModel.Channels.BindingContext" /> spécifié.</summary>
        <returns>Objet spécifié à partir de <see cref="T:System.ServiceModel.Channels.BindingContext" /> ou <see langword="null" /> si l'objet est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode obtient l'objet spécifié à partir de la classe de base ou à partir de l'un des ancêtres de cette classe. L'objet retourné est habituellement une collection de propriétés, par exemple, un objet qui implémente <xref:System.ServiceModel.Channels.ISecurityCapabilities>.  
  
 Si `SecurityBindingElement` ne reconnaît pas le type de propriété demandé, il délègue l'appel à l'élément de liaison qui se trouve au-dessous dans la pile d'éléments, en transmettant le paramètre de contexte de liaison. Les types de propriétés que peut fournir `SecurityBindingElement` sont <xref:System.ServiceModel.Channels.ISecurityCapabilities> et <xref:System.ServiceModel.Security.IdentityVerifier>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeTimestamp">
      <MemberSignature Language="C#" Value="public bool IncludeTimestamp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeTimestamp" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeTimestamp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeTimestamp { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeTimestamp : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'horodatage est inclus dans chaque message.</summary>
        <value>
          <see langword="true" /> si l'horodatage est inclus dans chaque message ; sinon <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A> propriété est `true` et si `DetectReplays` est `true`, WCF détecte une attaque par relecture.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyEntropyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityKeyEntropyMode KeyEntropyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Security.SecurityKeyEntropyMode KeyEntropyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyEntropyMode As SecurityKeyEntropyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::SecurityKeyEntropyMode KeyEntropyMode { System::ServiceModel::Security::SecurityKeyEntropyMode get(); void set(System::ServiceModel::Security::SecurityKeyEntropyMode value); };" />
      <MemberSignature Language="F#" Value="member this.KeyEntropyMode : System.ServiceModel.Security.SecurityKeyEntropyMode with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityKeyEntropyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la source d'entropie utilisée pour créer des clés.</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.SecurityKeyEntropyMode" /> utilisé pour créer les clés. La valeur par défaut est <see cref="F:System.ServiceModel.Security.SecurityKeyEntropyMode.CombinedEntropy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode%2A> spécifie comment la clé des jetons (<xref:System.ServiceModel.Security.Tokens.SecurityContextSecurityToken>, par exemple) émis par le service est calculée : si elle est calculée uniquement selon le matériel de clé du client, selon le matériel de clé du service uniquement ou une combinaison des deux.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalClientSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.LocalClientSecuritySettings LocalClientSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.LocalClientSecuritySettings LocalClientSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalClientSettings As LocalClientSecuritySettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::LocalClientSecuritySettings ^ LocalClientSettings { System::ServiceModel::Channels::LocalClientSecuritySettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalClientSettings : System.ServiceModel.Channels.LocalClientSecuritySettings" Usage="System.ServiceModel.Channels.SecurityBindingElement.LocalClientSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.LocalClientSecuritySettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les propriétés de liaison spécifiques aux paramètres de sécurité locaux utilisés par le client.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.LocalClientSecuritySettings" /> qui représente les propriétés de liaison spécifiques aux paramètres de sécurité locaux utilisés par le client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les paramètres sont locaux en ce sens qu’ils ne sont pas les paramètres dérivés de la stratégie de sécurité du service. Vous pouvez obtenir l'objet <xref:System.ServiceModel.Channels.LocalClientSecuritySettings> et l'utiliser pour définir les propriétés de sécurité de cette liaison.  
  
   
  
## Examples  
 Le code suivant indique comment accéder à cette propriété pour définir une propriété d'un autre objet.  
  
 [!code-csharp[c_MaxClockSkew#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_maxclockskew/cs/source.cs#1)]
 [!code-vb[c_MaxClockSkew#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/c_maxclockskew/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalServiceSettings">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.LocalServiceSecuritySettings LocalServiceSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Channels.LocalServiceSecuritySettings LocalServiceSettings" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalServiceSettings As LocalServiceSecuritySettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::LocalServiceSecuritySettings ^ LocalServiceSettings { System::ServiceModel::Channels::LocalServiceSecuritySettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalServiceSettings : System.ServiceModel.Channels.LocalServiceSecuritySettings" Usage="System.ServiceModel.Channels.SecurityBindingElement.LocalServiceSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.LocalServiceSecuritySettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les propriétés de liaison spécifiques aux paramètres de sécurité locaux utilisés par le service.</summary>
        <value>Objet <see cref="T:System.ServiceModel.Channels.LocalServiceSecuritySettings" /> qui représente les propriétés de liaison spécifiques aux paramètres de sécurité locaux utilisés par le service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les paramètres sont locaux car ils ne sont pas publiés dans le cadre de la stratégie de sécurité du service et n’affectent pas la liaison du client.  
  
 Les propriétés suivantes de l'objet <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings> peuvent aider à atténuer une attaque de sécurité par déni de service (DOS) :  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxCachedCookies%2A> : contrôle le nombre maximal de `SecurityContextToken` par heure mis en cache par le serveur après une négociation SSL ou SPNEGO.  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.IssuedCookieLifetime%2A> : contrôle la durée de vie des `SecurityContextToken` émis par le serveur après une négociation SSL ou SPNEGO. Le serveur met en cache les `SecurityContextToken`s pendant cette période.  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.MaxPendingSessions%2A> : contrôle le nombre maximal de conversations sécurisées établies au niveau du serveur mais pour lesquelles aucun message d'application n'a été traité. Ce quota empêche les clients d'établir des conversations sécurisées au niveau du service, forçant ainsi le service à conserver l'état de chaque client, sans jamais les utiliser toutefois.  
  
-   <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A> : contrôle le temps maximum pendant lequel le service garde une conversation sécurisée active sans jamais recevoir dessus un message d'application. Ce quota empêche les clients d'établir des conversations sécurisées au niveau du service, forçant ainsi le service à conserver l'état de chaque client, sans jamais les utiliser toutefois.  
  
 Dans une session de conversation sécurisée, notez que <xref:System.ServiceModel.Channels.LocalServiceSecuritySettings.InactivityTimeout%2A> et la propriété `ReceiveTimeout` sur la liaison affectent le délai d'attente de la session. Le plus court des deux détermine le dépassement du délai d'attente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageSecurityVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.MessageSecurityVersion MessageSecurityVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.MessageSecurityVersion MessageSecurityVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageSecurityVersion As MessageSecurityVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::MessageSecurityVersion ^ MessageSecurityVersion { System::ServiceModel::MessageSecurityVersion ^ get(); void set(System::ServiceModel::MessageSecurityVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageSecurityVersion : System.ServiceModel.MessageSecurityVersion with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.MessageSecurityVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.MessageSecurityVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la version de sécurité du message.</summary>
        <value>Objet <see cref="T:System.ServiceModel.MessageSecurityVersion" /> qui représente la version du message par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.MessageSecurityVersion> contient de nombreuses propriétés qui spécifient les numéros de version de différentes spécifications de sécurité utilisées lors de la sécurisation des messages échangés sur le canal.  
  
> [!NOTE]
>  Une fois qu'un objet <xref:System.ServiceModel.Channels.SecurityBindingElement> est créé, cette propriété est immuable. Appeler dessus `set` ne la modifie pas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="set" /> avec une valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="OperationSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OperationSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OperationSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OperationSupportingTokenParameters As IDictionary(Of String, SupportingTokenParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ OperationSupportingTokenParameters { System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OperationSupportingTokenParameters : System.Collections.Generic.IDictionary&lt;string, System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;" Usage="System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des paramètres du jeton de prise en charge de l’opération.</summary>
        <value>
          <see cref="T:System.Collections.Generic.IDictionary`2" /> des types <see cref="T:System.String" /> (clé) et <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> (valeur).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jetons de prise en charge fournissent des revendications supplémentaires outre celles contenues dans les jetons principaux de la liaison.  
  
 La collection renvoyée par la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters%2A> contient des paramètres de jeton supplémentaires (<xref:System.ServiceModel.Security.Tokens.SecurityTokenParameters>) pour les opérations spécifiques définies. Les paramètres du jeton principal sont recherchés sur <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement> ou <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> (les deux héritent de la classe <xref:System.ServiceModel.Channels.SecurityBindingElement> ). Dans le cas de <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement>, les paramètres du jeton principal sont renvoyés par la propriété <xref:System.ServiceModel.Channels.SymmetricSecurityBindingElement.ProtectionTokenParameters%2A>. <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement> comporte deux propriétés de paramètre : <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.InitiatorTokenParameters%2A> et <xref:System.ServiceModel.Channels.AsymmetricSecurityBindingElement.RecipientTokenParameters%2A>.  
  
> [!NOTE]
>  Les propriétés sont appelées "paramètres" car elles spécifient uniquement le type du jeton de sécurité, pas les valeurs réelles.  
  
 Les jetons de prise en charge peuvent avoir une portée différente de la liaison, dans ce cas l’opération, auquel cas ils sont inclus dans tous les messages sécurisés envoyés par le client aux services comprenant l’Action spécifiée.  
  
 Pour ne fournir les jetons de prise en charge que pour une opération (et non toutes les opérations sur un point de terminaison), utilisez la propriété <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OptionalEndpointSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.Tokens.SupportingTokenParameters OptionalEndpointSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.Tokens.SupportingTokenParameters OptionalEndpointSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OptionalEndpointSupportingTokenParameters As SupportingTokenParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ OptionalEndpointSupportingTokenParameters { System::ServiceModel::Security::Tokens::SupportingTokenParameters ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OptionalEndpointSupportingTokenParameters : System.ServiceModel.Security.Tokens.SupportingTokenParameters" Usage="System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.Tokens.SupportingTokenParameters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les paramètres de jeton de prise en charge facultatifs pour le point de terminaison du service.</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> du point de terminaison de service.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jetons de prise en charge fournissent des revendications supplémentaires outre celles contenues dans les jetons principaux de la liaison. Les jetons de prise en charge peuvent avoir une portée différente de la liaison, dans ce cas le point de terminaison. Le service ne rejette pas le message au cas où il ne contient pas de jetons correspondant aux types de jetons spécifiés dans la collection <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OptionalOperationSupportingTokenParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OptionalOperationSupportingTokenParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt; OptionalOperationSupportingTokenParameters" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OptionalOperationSupportingTokenParameters As IDictionary(Of String, SupportingTokenParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ OptionalOperationSupportingTokenParameters { System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Security::Tokens::SupportingTokenParameters ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OptionalOperationSupportingTokenParameters : System.Collections.Generic.IDictionary&lt;string, System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;" Usage="System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Security.Tokens.SupportingTokenParameters&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des paramètres optionnels du jeton de prise en charge de l’opération.</summary>
        <value>
          <see cref="T:System.Collections.Generic.IDictionary`2" /> des types <see cref="T:System.String" /> (clé) et <see cref="T:System.ServiceModel.Security.Tokens.SupportingTokenParameters" /> (valeur).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jetons de prise en charge fournissent des revendications supplémentaires outre celles contenues dans les jetons principaux de la liaison. Les jetons de prise en charge peuvent avoir une portée différente de la liaison, dans ce cas l’opération. Le service ne rejette pas le message au cas où il ne contient pas de jetons correspondant aux types de jetons spécifiés dans la collection <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalOperationSupportingTokenParameters%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectTokens">
      <MemberSignature Language="C#" Value="public bool ProtectTokens { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProtectTokens" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.ProtectTokens" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectTokens As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProtectTokens { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectTokens : bool with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.ProtectTokens" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'élément de liaison de sécurité protège les jetons.</summary>
        <value>
          <see langword="true" /> si l'élément de liaison de sécurité protège les jetons ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityHeaderLayout">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.SecurityHeaderLayout SecurityHeaderLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Channels.SecurityHeaderLayout SecurityHeaderLayout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.SecurityBindingElement.SecurityHeaderLayout" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityHeaderLayout As SecurityHeaderLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Channels::SecurityHeaderLayout SecurityHeaderLayout { System::ServiceModel::Channels::SecurityHeaderLayout get(); void set(System::ServiceModel::Channels::SecurityHeaderLayout value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityHeaderLayout : System.ServiceModel.Channels.SecurityHeaderLayout with get, set" Usage="System.ServiceModel.Channels.SecurityBindingElement.SecurityHeaderLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.SecurityHeaderLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’ordre des éléments dans l’en-tête de sécurité de cette liaison.</summary>
        <value>
          <see cref="T:System.ServiceModel.Channels.SecurityHeaderLayout" /> qui représente l'ordre des éléments dans l'en-tête de sécurité de cette liaison. La valeur par défaut est <see cref="F:System.ServiceModel.Channels.SecurityHeaderLayout.Strict" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'énumération <xref:System.ServiceModel.Channels.SecurityHeaderLayout> contient les membres suivants :  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.Strict>: Les éléments sont ajoutés à l’en-tête de sécurité conformément au principe général « déclarer avant d’utiliser ».  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.Lax> : les éléments sont ajoutés à l'en-tête de sécurité dans n'importe quel ordre mais conforme aux spécifications « WSS: SOAP Message Security ».  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.LaxTimestampFirst> : les éléments sont ajoutés à l'en-tête de sécurité dans n'importe quel ordre conforme aux spécifications « WSS : SOAP Message Security », à l'exception du premier élément dans l'en-tête de sécurité, qui doit correspondre à un élément `wsse:Timestamp`.  
  
-   <xref:System.ServiceModel.Channels.SecurityHeaderLayout.LaxTimestampLast> : les éléments sont ajoutés à l'en-tête de sécurité dans n'importe quel ordre conforme aux spécifications « WSS : SOAP Message Security », à l'exception du dernier élément dans l'en-tête de sécurité, qui doit correspondre à un élément `wsse:Timestamp`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur n'est pas une valeur <see cref="T:System.ServiceModel.Channels.SecurityHeaderLayout" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetIssuerBindingContextIfRequired">
      <MemberSignature Language="C#" Value="protected static void SetIssuerBindingContextIfRequired (System.ServiceModel.Security.Tokens.SecurityTokenParameters parameters, System.ServiceModel.Channels.BindingContext issuerBindingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetIssuerBindingContextIfRequired(class System.ServiceModel.Security.Tokens.SecurityTokenParameters parameters, class System.ServiceModel.Channels.BindingContext issuerBindingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.SetIssuerBindingContextIfRequired(System.ServiceModel.Security.Tokens.SecurityTokenParameters,System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetIssuerBindingContextIfRequired (parameters As SecurityTokenParameters, issuerBindingContext As BindingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetIssuerBindingContextIfRequired(System::ServiceModel::Security::Tokens::SecurityTokenParameters ^ parameters, System::ServiceModel::Channels::BindingContext ^ issuerBindingContext);" />
      <MemberSignature Language="F#" Value="static member SetIssuerBindingContextIfRequired : System.ServiceModel.Security.Tokens.SecurityTokenParameters * System.ServiceModel.Channels.BindingContext -&gt; unit" Usage="System.ServiceModel.Channels.SecurityBindingElement.SetIssuerBindingContextIfRequired (parameters, issuerBindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.ServiceModel.Security.Tokens.SecurityTokenParameters" />
        <Parameter Name="issuerBindingContext" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <param name="parameters">
          <see cref="T:System.ServiceModel.Security.Tokens.SecurityTokenParameters" />.</param>
        <param name="issuerBindingContext">Objet <see cref="T:System.ServiceModel.Channels.BindingContext" /> qui représente la clé de la propriété de spécification de jeton dont la valeur est le BindingContext utilisé pour parler au correspondant émetteur.</param>
        <summary>Définit la clé pour la propriété d'exigence de jeton dont la valeur est le BindingContext à utiliser pour parler au correspondant émetteur lorsque la spécification est pour un jeton émis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Réservé au système.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetKeyDerivation">
      <MemberSignature Language="C#" Value="public virtual void SetKeyDerivation (bool requireDerivedKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetKeyDerivation(bool requireDerivedKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.SetKeyDerivation(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetKeyDerivation (requireDerivedKeys As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetKeyDerivation(bool requireDerivedKeys);" />
      <MemberSignature Language="F#" Value="abstract member SetKeyDerivation : bool -&gt; unit&#xA;override this.SetKeyDerivation : bool -&gt; unit" Usage="securityBindingElement.SetKeyDerivation requireDerivedKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requireDerivedKeys" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="requireDerivedKeys">
          <see langword="true" /> pour exiger des clés dérivées ; sinon <see langword="false" />.</param>
        <summary>Définit une valeur qui indique si les clés dérivées sont requises.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple de code suivant montre comment appeler cette méthode.  
  
 [!code-csharp[c_CreateSecureSession#7](~/samples/snippets/csharp/VS_Snippets_CFX/c_createsecuresession/cs/secureservice.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.SecurityBindingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="securityBindingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Security</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie la description de cette classe.</summary>
        <returns>Description de l'instance <see cref="T:System.ServiceModel.Channels.SecurityBindingElement" /> active.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les informations renvoyées par <xref:System.ServiceModel.Channels.SecurityBindingElement.ToString%2A> comprennent les valeurs <xref:System.ServiceModel.Channels.SecurityBindingElement.DefaultAlgorithmSuite%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.EndpointSupportingTokenParameters%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.IncludeTimestamp%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.KeyEntropyMode%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.OptionalEndpointSupportingTokenParameters%2A>, <xref:System.ServiceModel.Channels.SecurityBindingElement.SecurityHeaderLayout%2A> et <xref:System.ServiceModel.Channels.SecurityBindingElement.OperationSupportingTokenParameters%2A> de l'instance active.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>