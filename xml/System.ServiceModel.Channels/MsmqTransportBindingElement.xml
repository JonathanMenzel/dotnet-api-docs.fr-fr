<Type Name="MsmqTransportBindingElement" FullName="System.ServiceModel.Channels.MsmqTransportBindingElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fd45951351fc2f31bab1a0a8b34353fb56cd801b" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53333701" /></Metadata><TypeSignature Language="C#" Value="public sealed class MsmqTransportBindingElement : System.ServiceModel.Channels.MsmqBindingElementBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MsmqTransportBindingElement extends System.ServiceModel.Channels.MsmqBindingElementBase" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.MsmqTransportBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MsmqTransportBindingElement&#xA;Inherits MsmqBindingElementBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MsmqTransportBindingElement sealed : System::ServiceModel::Channels::MsmqBindingElementBase" />
  <TypeSignature Language="F#" Value="type MsmqTransportBindingElement = class&#xA;    inherit MsmqBindingElementBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.MsmqBindingElementBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente l’élément de liaison utilisé pour spécifier les propriétés de communication de la mise en file d’attente pour un service Windows Communication Foundation (WCF) qui utilise le protocole MSMQ (Message Queuing) natif.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.ServiceModel.Channels.MsmqTransportBindingElement> permet à l'utilisateur de définir les propriétés du canal de communication mis en file d'attente. Le canal de communication mis en file d'attente utilise Message Queuing pour son transport.  
  
 Cet élément de liaison est l’élément de liaison par défaut utilisé par la liaison standard Message Queuing (<xref:System.ServiceModel.NetMsmqBinding>).  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/service.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MsmqTransportBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MsmqTransportBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Channels.MsmqTransportBindingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/service.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="msmqTransportBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Classe <see cref="T:System.ServiceModel.Channels.IOutputSessionChannel" /> ou <see cref="T:System.ServiceModel.Channels.IOutputChannel" />.</typeparam>
        <param name="context">La <see cref="T:System.ServiceModel.Channels.BindingContext" /> avec laquelle générer la fabrique de canal.</param>
        <summary>Génère une fabrique de canal à l'aide du contexte fourni.</summary>
        <returns>Fabrique de canaux Message Queuing (MSMQ) qui peut être utilisée pour créer des canaux pour envoyer des messages aux applications Message Queuing existantes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fabrique de canaux est créée et initialisée à l’aide des propriétés définies dans l’élément de liaison. Puis, la fabrique de canaux initialisée est utilisée pour créer des canaux de sortie qui peuvent être utilisés pour envoyer des messages à une file d'attente de messages.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur de contexte est null.</exception>
        <exception cref="T:System.ArgumentException">TChannel n'a pas la valeur IOutputChannel ni la valeur IOutputSessionChannel.</exception>
        <exception cref="T:System.InvalidOperationException">ExactlyOnce a la valeur true et Durable la valeur false.

ou

UseActiveDirectory a la valeur true et QueueTransferProtocol n'a pas la valeur Native.

ou

CustomDeadLetterQueue n'a pas la valeur null et DeadLetterQueue n'a pas la valeur Custom.

ou

DeadLetterQueue a la valeur Personnalisé sur Windows 2003/XP.

ou

ExactlyOnce a la valeur false et DeadLetterQueue a la valeur Personnalisé.

ou

CustomDeadLetterQueue est défini et soit l’écriture n’est pas autorisée dans la file d’attente, soit la file d’attente n’existe pas.

ou

CustomDeadLetterQueue est non transactionnel.

ou

MsmqTransportSecurity.MsmqAuthenticationMode a la valeur WindowsDomain et MSMQ est installé sans intégration ActiveDirectory.

ou

MsmqTransportSecurity.MsmqAuthenticationMode a la valeur None et MsmqTransportSecurity.MsmqProtectionLevel n'a pas la valeur None.

ou

MsmqTransportSecurity.MsmqAuthenticationMode a la valeur Certificate ou WindowsDomain et MsmqTransportSecurity.MsmqProtectionLevel a la valeur None.

ou

MsmqTransportSecurity.MsmqProtectionLevel a la valeur EncryptAndSign et UseActiveDirectory a la valeur false.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="msmqTransportBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de canal à utiliser pour générer l'écouteur de canal. Les types de canaux autorisés sont <see cref="T:System.ServiceModel.Channels.IInputSessionChannel" /> ou une classe <see cref="T:System.ServiceModel.Channels.IInputChannel" />.</typeparam>
        <param name="context">La <see cref="T:System.ServiceModel.Channels.BindingContext" /> avec laquelle générer l'écouteur de canal.</param>
        <summary>Génère un écouteur de canal à l'aide du contexte fourni.</summary>
        <returns>Écouteur de canal Message Queuing (MSMQ) qui peut être utilisé pour créer des canaux pour recevoir des messages des applications Message Queuing existantes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur de contexte est null.</exception>
        <exception cref="T:System.ArgumentException">TChannel n'a pas la valeur IInputChannel ni la valeur IInputSessionChannel.</exception>
        <exception cref="T:System.InvalidOperationException">ExactlyOnce a la valeur true et Durable la valeur false.

ou

La file d'attente n'est pas lisible.

ou

ExactlyOnce a la valeur true et la file d'attente est non transactionnelle.

ou

ExactlyOnce a la valeur false et la file d'attente est transactionnelle.

ou

ReceiveErrorHandling a la valeur Move et le nom de la file d'attente contient un « ; » dans Windows Vista.

ou

ExactlyOnce a la valeur true et ne peut pas ouvrir la sous-file d'attente de nouvel essai dans Windows Vista.

ou

ReceiveErrorHandling a la valeur Reject ou Move et la plateforme est Windows Vista.

ou

MsmqTransportSecurity.MsmqAuthenticationMode a la valeur WindowsDomain et MSMQ est installé sans intégration ActiveDirectory.

ou

MsmqTransportSecurity.MsmqAuthenticationMode a la valeur None et MsmqTransportSecurity.MsmqProtectionLevel n'a pas la valeur None.

ou

MsmqTransportSecurity.MsmqAuthenticationMode a la valeur Certificate ou WindowsDomain et MsmqTransportSecurity.MsmqProtectionLevel a la valeur None.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="msmqTransportBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de canal à utiliser pour générer l'écouteur de canal. Les types de canaux autorisés sont <see cref="T:System.ServiceModel.Channels.IOutputSessionChannel" /> ou une classe <see cref="T:System.ServiceModel.Channels.IOutputChannel" />.</typeparam>
        <param name="context">La <see cref="T:System.ServiceModel.Channels.BindingContext" /> avec laquelle générer la fabrique de canal.</param>
        <summary>Retourne une valeur Boolean qui indique si vous pouvez générer une fabrique de canaux avec le contexte fourni.</summary>
        <returns><see langword="true" /> si vous pouvez générer une fabrication de canal avec le contexte fourni ; sinon, <see langword="false" />. L'élément de liaison retourne <see langword="true" /> uniquement lorsque <paramref name="TChannel" /> a la valeur <see cref="T:System.ServiceModel.Channels.IOutputChannel" /> ou <see cref="T:System.ServiceModel.Channels.IOutputSessionChannel" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="msmqTransportBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de canal à utiliser pour générer l'écouteur de canal. Les types de canaux autorisés sont <see cref="T:System.ServiceModel.Channels.IInputSessionChannel" /> ou une classe <see cref="T:System.ServiceModel.Channels.IInputChannel" />.</typeparam>
        <param name="context">La <see cref="T:System.ServiceModel.Channels.BindingContext" /> avec laquelle générer l'écouteur de canal.</param>
        <summary>Retourne une valeur booléenne qui indique si vous pouvez générer un écouteur de canal avec le contexte fourni.</summary>
        <returns><see langword="true" /> si vous pouvez générer un écouteur de canal avec le contexte fourni ; sinon, <see langword="false" />.  
  
La liaison retourne <see langword="true" /> uniquement lorsque <paramref name="TChannel" /> a la valeur <see cref="T:System.ServiceModel.Channels.IInputChannel" /> ou <see cref="T:System.ServiceModel.Channels.IInputSessionChannel" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.MsmqTransportBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="msmqTransportBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un clone de l'élément de liaison.</summary>
        <returns>Clone de l'élément de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPoolSize">
      <MemberSignature Language="C#" Value="public int MaxPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.MaxPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPoolSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPoolSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPoolSize : int with get, set" Usage="System.ServiceModel.Channels.MsmqTransportBindingElement.MaxPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un entier qui spécifie la taille maximale du pool qui contient des objets de message Message Queuing (MSMQ) internes.</summary>
        <value>Entier qui spécifie la taille maximale du pool qui contient des objets de message Message Queuing (MSMQ) internes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mise en pool d’objets de message Message Queuing internes est utilisé pour éviter les allocations de ces objets lors de l'envoi et de la réception des messages. La taille de pool maximale est un paramètre de réglage des performances. La valeur par défaut est 8.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur est inférieure à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueTransferProtocol">
      <MemberSignature Language="C#" Value="public System.ServiceModel.QueueTransferProtocol QueueTransferProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.QueueTransferProtocol QueueTransferProtocol" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.QueueTransferProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueTransferProtocol As QueueTransferProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::QueueTransferProtocol QueueTransferProtocol { System::ServiceModel::QueueTransferProtocol get(); void set(System::ServiceModel::QueueTransferProtocol value); };" />
      <MemberSignature Language="F#" Value="member this.QueueTransferProtocol : System.ServiceModel.QueueTransferProtocol with get, set" Usage="System.ServiceModel.Channels.MsmqTransportBindingElement.QueueTransferProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.QueueTransferProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur d'énumération qui indique le transport de canal de communication mis en file d'attente que cette liaison utilise.</summary>
        <value>Valeur d'énumération <see cref="T:System.ServiceModel.QueueTransferProtocol" /> qui indique le transport utilisé pour la remise de messages entre des gestionnaires de files d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing (MSMQ) ne prend pas en charge l'adressage Active Directory lors de l'utilisation du protocole SRMP (SOAP Reliable Messaging Protocol), n'affectez donc pas la valeur <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.QueueTransferProtocol%2A> ou <xref:System.ServiceModel.QueueTransferProtocol.Srmp> à <xref:System.ServiceModel.QueueTransferProtocol.Srmp> lorsque <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory%2A> a la valeur `true`.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur ne fait pas partie des valeurs de <see cref="T:System.ServiceModel.QueueTransferProtocol" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.Channels.MsmqTransportBindingElement.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne un objet <see cref="T:System.String" /> qui contient le modèle d'adressage utilisé par cet élément de liaison de transport.</summary>
        <value><see cref="T:System.String" /> qui contient le modèle d'adressage utilisé par cet élément de liaison de transport.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.Scheme%2A> retourne la chaîne "net.msmq".  
  
 Le transport Message Queuing (MSMQ) mis en file d'attente prend en charge plusieurs modèles d'adressage, y compris net.msmq.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseActiveDirectory">
      <MemberSignature Language="C#" Value="public bool UseActiveDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseActiveDirectory" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property UseActiveDirectory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseActiveDirectory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseActiveDirectory : bool with get, set" Usage="System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Renvoie une valeur booléenne qui indique si des adresses de file d'attente doivent être converties à l'aide d'Active Directory.</summary>
        <value><see langword="true" /> si les adresses de file d'attente doivent être converties à l'aide d'Active Directory ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les adresses de file d’attente Message Queuing (MSMQ) peuvent se composer de noms de chemin d’accès ou de noms de format directs. Avec un nom de format direct, MSMQ résout le nom de la file d'attente à l'aide de DNS, NetBIOS ou IP. Avec un nom de chemin d’accès, il utilise Active Directory.  
  
 Par défaut, Windows Communication Foundation (WCF) en file d’attente de transport convertit l’URI d’une file d’attente de message à un nom de format direct. En affectant la valeur <xref:System.ServiceModel.Channels.MsmqTransportBindingElement.UseActiveDirectory%2A> à la propriété `true`, une application peut spécifier que le transport de mise en file d'attente doit résoudre le nom de l'ordinateur à l'aide d'Active Directory plutôt qu'à l'aide de DNS, NetBIOS ou IP.  
  
   
  
## Examples  
 [!code-csharp[S_UE_ImperativeNetMsmq#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_imperativenetmsmq/cs/snippets.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>