<Type Name="IInputChannel" FullName="System.ServiceModel.Channels.IInputChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae2783ef0e1dc2a8edab76bbc1b170bd2b36497e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39978804" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IInputChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IInputChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IInputChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IInputChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IInputChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IInputChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Définit l'interface qu'un canal doit implémenter pour recevoir un message.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contrat <xref:System.ServiceModel.Channels.IInputChannel> inclut des variantes synchrones et asynchrones de fonctionnalités de réception, de tentative de réception et d'attente de message.  
  
 Le modèle d'extraction est utilisé en général avec un <xref:System.ServiceModel.Channels.IInputChannel> pour recevoir des messages : vous appelez <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (pour « extraire » un message du canal) puis attendez l'arrivée d'un message. Un autre modèle d'utilisation consiste à appeler <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> ou <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> puis <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. Cette approche est commune pour les utilisations transactionnelles où vous démarrez la transaction entre les appels à <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> et <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  
  
 Un <xref:System.ServiceModel.Channels.IInputChannel> n'est pas lié nécessairement à un expéditeur unique. D'autres canaux et interfaces de canaux peuvent fournir une corrélation entre des expéditeurs particuliers et un <xref:System.ServiceModel.Channels.IInputChannel>, mais le contrat de base ne définit aucune restriction de ce type. Une implémentation peut créer un nouveau <xref:System.ServiceModel.Channels.IInputChannel> pour chaque message ou réutiliser le même <xref:System.ServiceModel.Channels.IInputChannel> pour plusieurs messages ou expéditeurs.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Débute une opération de réception asynchrone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre la réception de la demande. Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone lorsque le thread en cours peut faire l'objet d'un blocage jusqu'à ce que le message de demande soit reçu ou que l'intervalle de temps spécifié par le `timeout` soit dépassé. L'opération asynchrone est disponible avec ou sans délai d'attente explicite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <param name="state">Objet, spécifié par l'application, qui contient des informations d'état associées à l'opération asynchrone.</param>
        <summary>Commence une opération asynchrone pour recevoir un message auquel est associé un objet d'état.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à la réception asynchrone du message.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre la réception de la demande. Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone lorsque le thread en cours peut faire l'objet d'un blocage jusqu'à ce que le message de demande soit reçu ou que l'intervalle de temps spécifié par le `timeout` soit dépassé. L'opération asynchrone est disponible avec ou sans délai d'attente explicite.  
  
 Cette méthode reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération n'est pas terminée tant qu'un message n'est pas disponible dans le canal.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie la durée d'attente pour qu'un message soit disponible.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <param name="state">Objet, spécifié par l'application, qui contient des informations d'état associées à l'opération asynchrone.</param>
        <summary>Commence une opération asynchrone pour recevoir un message auquel sont associés un délai d'attente spécifié et un objet d'état.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération asynchrone de réception.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre la réception de la demande. Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone lorsque le thread en cours peut faire l'objet d'un blocage jusqu'à ce que le message de demande soit reçu ou que l'intervalle de temps spécifié par le `timeout` soit dépassé. L'opération asynchrone est disponible avec ou sans délai d'attente explicite.  
  
 L'opération ne se termine que lorsqu'un message est disponible dans le canal ou lorsque le délai d'attente a expiré.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Le <paramref name="timeout" /> spécifié est dépassé avant que l'opération soit effectuée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente spécifié est inférieur à zéro.</exception>
        <block subset="none" type="overrides">
          <para>L’opération lève une <see cref="T:System.TimeoutException" /> si spécifié <paramref name="timeout" /> est dépassé avant la fin.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceive (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceive(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceive (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceive(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceive : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginTryReceive (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie la durée d'attente pour qu'un message soit disponible.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <param name="state">Objet, spécifié par l'application, qui contient des informations d'état associées à l'opération asynchrone.</param>
        <summary>Commence une opération asynchrone pour recevoir un message auquel sont associés un délai d'attente spécifié et un objet d'état.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération asynchrone de réception.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre. Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> synchrone lorsque le thread en cours peut faire l'objet d'un blocage en répondant au message de demande ou jusqu'à ce que l'intervalle de délai d'attente soit dépassé.  
  
 L'opération ne se termine que lorsqu'un message est disponible dans le canal ou lorsque le délai d'attente a expiré.  
  
 Si vous souhaitez gérer des délais d'attente et ne pas seulement lever à nouveau ou encapsuler l'<xref:System.TimeoutException>, vous devez appeler <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> au lieu de <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  
  
 Si vous ne souhaitez pas traiter spécialement des délais d'attente, appelez uniquement <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, sinon vous perdrez des informations relatives à l'erreur.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Le <paramref name="timeout" /> spécifié est dépassé avant que l'opération soit effectuée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente spécifié est inférieur à zéro.</exception>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> de <see cref="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" /> si spécifié <paramref name="timeout" /> est dépassé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForMessage">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForMessage (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForMessage(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForMessage (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForMessage(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForMessage : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iInputChannel.BeginWaitForMessage (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie la durée d'attente pour qu'un message soit disponible.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <param name="state">Objet, spécifié par l'application, qui contient des informations d'état associées à l'opération asynchrone.</param>
        <summary>Commence une opération asynchrone d'attente de message à laquelle sont associés un délai d'attente spécifié et un objet d'état.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération asynchrone pour attendre l'arrivée d'un message.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> asynchrone si vous souhaitez que le traitement de l'application se poursuive sans attendre l'arrivée du message. Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> synchrone lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message dans la file d'attente. Le thread reste bloqué durant le `timeout` spécifié.  
  
 Cette méthode reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans le canal ou lorsque le délai d'attente a expiré.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Le <paramref name="timeout" /> spécifié est dépassé avant que l'opération soit effectuée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente spécifié est inférieur à zéro.</exception>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> si spécifié <paramref name="timeout" /> est dépassée, pas une exception de délai d’attente.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ EndReceive(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceive : IAsyncResult -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> retourné par un appel de l'une des méthodes <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />.</param>
        <summary>Termine une opération asynchrone pour recevoir un message.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.Message" /> reçu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceive">
      <MemberSignature Language="C#" Value="public bool EndTryReceive (IAsyncResult result, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceive(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceive (result As IAsyncResult, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceive(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceive : IAsyncResult *  -&gt; bool" Usage="iInputChannel.EndTryReceive (result, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> reçu.</param>
        <summary>Termine l'opération asynchrone spécifiée pour recevoir un message.</summary>
        <returns>
          <see langword="true" /> si un message est reçu avant expiration de l'intervalle de temps spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForMessage">
      <MemberSignature Language="C#" Value="public bool EndWaitForMessage (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForMessage(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForMessage (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForMessage(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForMessage : IAsyncResult -&gt; bool" Usage="iInputChannel.EndWaitForMessage result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> qui identifie l'opération <see cref="M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)" /> à terminer et à partir de laquelle il est possible de récupérer un résultat final.</param>
        <summary>Termine l'opération asynchrone spécifiée d'attente d'un message.</summary>
        <returns>
          <see langword="true" /> si un message est arrivé avant que le <paramref name="timeout" /> soit dépassé ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IInputChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'adresse sur laquelle ce canal d'entrée reçoit des messages.</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" /> sur laquelle le canal d'entrée reçoit des messages.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce canal d'entrée n'a pas d'adresse autonome (par exemple, il s'agit du côté entrée d'un canal TCP initié par le client), cette propriété a la valeur `null`.  
  
 Cette propriété peut être utilisée par les canaux de niveau supérieur à des fins de corrélation. Par exemple, si un canal de niveau supérieur implémente un message de demande-réponse dans la partie supérieure d'un <xref:System.ServiceModel.Channels.IDuplexChannel>, il peut utiliser la propriété <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> dans l'en-tête WS-Addressing ReplyTo.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette propriété :  
  
 [!code-csharp[S_UE_MessageInterceptor#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'opération ne s'est pas déroulée dans le délai d'attente imparti.</exception>
        <exception cref="T:System.ServiceModel.CommunicationException">Échec du canal d'entrée.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectAbortedException">Abandon du canal d'entrée.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">Erreur sur le canal d'entrée.</exception>
        <summary>Retourne un message reçu par le canal d'entrée, s'il y en a un de disponible avec un intervalle de temps qui est défini explicitement ou implicitement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone lorsque le thread en cours peut faire l'objet d'un blocage jusqu'à ce qu'il reçoive le message de demande ou jusqu'à ce que l'intervalle de temps spécifié par `timeout` soit dépassé. Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre la réception de la demande.  
  
 L'opération <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone est disponible avec ou sans délai d'attente explicite.  
  
 Si aucun message n'est disponible, elle reste bloquée jusqu'à ce qu'un message soit disponible ou jusqu'à ce que le délai d'attente soit dépassé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="abstract member Receive : unit -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le message reçu, le cas échéant. Si aucun message n'est disponible, elle reste bloquée pendant un intervalle de temps par défaut.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.Message" /> reçu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone lorsque le thread en cours peut faire l'objet d'un blocage jusqu'à ce qu'il reçoive le message de demande ou jusqu'à ce que l'intervalle de temps spécifié par `timeout` soit dépassé. Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre la réception de la demande.  
  
 L'opération <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone est disponible avec ou sans délai d'attente explicite.  
  
 Si aucun message n'est disponible, elle reste bloquée jusqu'à ce qu'un message soit disponible ou jusqu'à ce que le délai d'attente soit dépassé.  
  
 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> peut être appelée plusieurs fois ou de manière simultanée. Un seul appel <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> peut être effectué pour chaque message reçu.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member Receive : TimeSpan -&gt; System.ServiceModel.Channels.Message" Usage="iInputChannel.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution de l'opération de réception avant dépassement du délai d’attente et levée d'une <see cref="T:System.TimeoutException" />.</param>
        <summary>Retourne le message reçu, le cas échéant. Si aucun message n'est disponible, elle reste bloquée pendant un intervalle de temps spécifié.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.Message" /> reçu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone lorsque le thread en cours peut faire l'objet d'un blocage jusqu'à ce qu'il reçoive le message de demande ou jusqu'à ce que l'intervalle de temps spécifié par `timeout` soit dépassé. Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre la réception de la demande.  
  
 L'opération <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> synchrone est disponible avec ou sans délai d'attente explicite.  
  
 Si aucun message n'est disponible, elle reste bloquée jusqu'à ce qu'un message soit disponible ou jusqu'à ce que le délai d'attente soit dépassé.  
  
 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> peut être appelée plusieurs fois ou de manière simultanée. Un seul appel <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> peut être effectué pour chaque message reçu.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Le <paramref name="timeout" /> spécifié est dépassé avant que l'opération soit effectuée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente spécifié est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (TimeSpan timeout, out System.ServiceModel.Channels.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (timeout As TimeSpan, ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceive(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::Message ^ % message);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : TimeSpan *  -&gt; bool" Usage="iInputChannel.TryReceive (timeout, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.IAsyncResult" /> retourné par un appel de l'une des méthodes <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />.</param>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> reçu.</param>
        <summary>Tente de recevoir un message dans un intervalle de temps spécifié.</summary>
        <returns>
          <see langword="true" /> si un message est reçu avant que le <paramref name="timeout" /> soit dépassé ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous souhaitez gérer des délais d'attente et ne pas seulement lever à nouveau ou encapsuler l'<xref:System.TimeoutException>, vous devez appeler <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> au lieu de <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  
  
 Si vous ne souhaitez pas traiter spécialement des délais d'attente, appelez uniquement <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, sinon vous perdrez des informations relatives à l'erreur.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Le <paramref name="timeout" /> spécifié est dépassé avant que l'opération soit effectuée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente spécifié est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitForMessage">
      <MemberSignature Language="C#" Value="public bool WaitForMessage (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForMessage(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForMessage (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForMessage(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForMessage : TimeSpan -&gt; bool" Usage="iInputChannel.WaitForMessage timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Le <see cref="T:System.TimeSpan" /> spécifie l'intervalle de temps maximal pour attendre l'arrivée d'un message avant dépassement du délai d'attente.</param>
        <summary>Retourne une valeur qui indique si un message est arrivé dans un intervalle de temps spécifié.</summary>
        <returns>
          <see langword="true" /> si un message est arrivé avant que le <paramref name="timeout" /> soit dépassé ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel de <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> n'entraîne en aucune autre façon la réception ou le traitement d'un message.  
  
 La méthode <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> existe à l'origine pour les scénarios avec transaction où l'utilisateur souhaite recevoir le message à l'aide d'une transaction. Pour ce faire, lorsqu'il n'utilise que <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normalement, l'utilisateur doit créer la transaction puis appeler <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> et espérer que le message arrive avant que la transaction n'expire, ce qui est impossible.  
  
 À la place, l'utilisateur peut appeler <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> et spécifier le délai d'attente (même infini) qu'il souhaite, puis lorsqu'un message arrive il peut ouvrir la transaction, appeler <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> et être certain qu'il peut récupérer le message avant que la transaction n'expire.  
  
 Cette méthode est synchrone et bloque par conséquent le thread en cours jusqu'à ce qu'un message soit disponible ou que le délai spécifié expire. Utilisez <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message dans la file d'attente. Le thread reste bloqué durant le `timeout` spécifié. Si vous souhaitez que le traitement de l'application se poursuive sans attendre, utilisez la méthode <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> asynchrone.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TimeoutException">Le <paramref name="timeout" /> spécifié est dépassé avant que l'opération soit effectuée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente spécifié est inférieur à zéro.</exception>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> si spécifié <paramref name="timeout" /> est dépassée, pas une exception de délai d’attente.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>