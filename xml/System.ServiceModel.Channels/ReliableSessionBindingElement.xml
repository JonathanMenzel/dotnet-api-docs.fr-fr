<Type Name="ReliableSessionBindingElement" FullName="System.ServiceModel.Channels.ReliableSessionBindingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="35b53ab1fd9a9f44c62055447ab53bd929afbad1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39784269" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReliableSessionBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReliableSessionBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReliableSessionBindingElement&#xA;Inherits BindingElement&#xA;Implements IPolicyExportExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReliableSessionBindingElement sealed : System::ServiceModel::Channels::BindingElement, System::ServiceModel::Description::IPolicyExportExtension" />
  <TypeSignature Language="F#" Value="type ReliableSessionBindingElement = class&#xA;    inherit BindingElement&#xA;    interface IPolicyExportExtension" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente l’élément de liaison qui peut produire les canaux d’émission et de réception requis pour une session fiable entre des points de terminaison.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fournit des sessions et assure en option la remise de messages demandée. Cette session implémentée peut croiser des intermédiaires SOAP et de transport.  
  
 Chaque élément de liaison représente une étape de traitement lors de l'envoi ou de la réception des messages. Au moment de l’exécution, les éléments de liaison créent les fabrications de canal et les écouteurs nécessaires pour générer les piles de canaux sortants et entrants requis pour envoyer et recevoir des messages. Le <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> fournit une couche facultative dans la pile capable d'établir une session fiable entre des points de terminaison et de configurer le comportement de cette session.  
  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> est fourni sur les liaisons standards dans le tableau suivant.  
  
|Liaison|Par défaut|  
|-------------|-------------|  
|<xref:System.ServiceModel.NetTcpBinding>|Off|  
|<xref:System.ServiceModel.WSHttpBinding>|Off|  
|<xref:System.ServiceModel.WSDualHttpBinding>|Activé (obligatoire)|  
  
   
  
## Examples  
 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> peut être ajouté à toute liaison personnalisée. Cet ajout est effectué à l'aide des éléments de configuration suivants.  
  
```  
<bindings>  
    <customBinding>  
        <binding configurationName="ReliabilityHTTP">  
            <reliableSession/>  
        </binding>  
    </customBinding>  
</bindings>  
```  
  
 L'exemple de code suivant indique comment utiliser <xref:System.ServiceModel.Channels.ReliableSessionBindingElement> dans le code.  
  
 [!code-csharp[S_Imperative#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_imperative/cs/service.cs#1)]
 [!code-vb[S_Imperative#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_imperative/vb/service.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReliableSessionBindingElement (bool ordered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool ordered) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ordered As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReliableSessionBindingElement(bool ordered);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Channels.ReliableSessionBindingElement : bool -&gt; System.ServiceModel.Channels.ReliableSessionBindingElement" Usage="new System.ServiceModel.Channels.ReliableSessionBindingElement ordered" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ordered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ordered">
          <see langword="true" /> si les messages doivent être remis dans l'ordre dans lequel ils sont envoyés ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ServiceModel.Channels.ReliableSessionBindingElement" /> qui spécifie si la remise des messages doit conserver l'ordre dans lequel les messages sont envoyés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcknowledgementInterval">
      <MemberSignature Language="C#" Value="public TimeSpan AcknowledgementInterval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AcknowledgementInterval" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgementInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AcknowledgementInterval { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgementInterval : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.TimeSpan), "00:00:00.2")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'intervalle d'attente d'une destination avant l'envoi d'un accusé de réception à la source de message sur les canaux fiables créés par la fabrication.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'attente d'un service avant l'envoi d'un accusé de réception à la source de message. La valeur par défaut est de 2 secondes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La destination qui reçoit des messages sur un canal fiable regroupe les accusés de réception correspondants dans un message unique afin de réduire le trafic réseau et d'augmenter la densité des informations sur les messages. Le regroupement est mieux adapté à mesure que le trafic augmente. La destination n'essaie pas d'envoyer un accusé de réception pour chaque message reçu dès que possible, mais elle patiente plutôt pendant un certain temps, elle regroupe les accusés de réception reçus pendant cet intervalle, puis elle les envoie tous ensemble. Le premier message reçu fait exception ; il est accepté aussitôt qu'il est remis. En outre, si des sessions fiables sont utilisées avec des connexions HTTP uniques, comme c'est le cas, par exemple, avec <xref:System.ServiceModel.WSHttpBinding> mais pas <xref:System.ServiceModel.WSDualHttpBinding>, ce paramètre n'est alors pas utilisé.  
  
 La valeur définie avec la propriété <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.AcknowledgementInterval%2A> est une recommandation pour l'infrastructure et non une limite définitive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure ou égale à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelFactory(Of TChannel) (context As BindingContext) As IChannelFactory(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override System::ServiceModel::Channels::IChannelFactory&lt;TChannel&gt; ^ BuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelFactory&lt;'Channel&gt;" Usage="reliableSessionBindingElement.BuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de canal construit par la fabrique.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> contenant les informations nécessaires pour générer les fabriques qui peuvent produire des canaux de type <c>TChannel</c>.</param>
        <summary>Retourne une fabrique qui crée un canal d'un type spécifié prenant en charge une session fiable.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> de type <see cref="T:System.ServiceModel.Channels.IChannel" /> initialisé à partir du <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.IChannel> produit par la fabrique est de type `TChannel`. Les types de `TChannel` pris en charge sur le client dépendent des types de canaux sous-jacents qui se connectent au service. Le tableau suivant indique les types de canaux de session fiable qui sont pris en charge comme une fonction des canaux sous-jacents.  
  
|Prise en charge des types `TChannel` de session fiable par les types de canaux sous-jacents|IRequestChannel|IRequestSessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|---------------------|----------------------------|--------------------|---------------------------|  
|IOutputSessionChannel|Oui|Oui|Oui|Oui|  
|IRequestSessionChannel|Oui|Oui|Non|Non|  
|IDuplexSessionChannel|Non|Non|Oui|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> n'est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As IChannelListener(Of TChannel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override System::ServiceModel::Channels::IChannelListener&lt;TChannel&gt; ^ BuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.BuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; System.ServiceModel.Channels.IChannelListener&lt;'Channel (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)&gt; (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.BuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Le <see cref="T:System.ServiceModel.Channels.IChannel" /> que l'écouteur doit accepter.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> contenant les informations nécessaires pour générer les écouteurs qui peuvent accepter les canaux de type <c>TChannel</c>.</param>
        <summary>Retourne un écouteur qui accepte un canal d'un type spécifié prenant en charge une session fiable.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> de type <see cref="T:System.ServiceModel.Channels.IChannel" /> initialisé à partir de <paramref name="context" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceModel.Channels.IChannel> accepté par l'écouteur est de type `TChannel`. Les types de `TChannel` pris en charge sur le serveur hébergeant le service dépendent des types de canaux sous-jacents utilisés pour se connecter au client. Le tableau suivant indique les types de canaux de session fiable qui sont pris en charge comme une fonction des canaux sous-jacents.  
  
|Prise en charge des types `TChannel` de session fiable par les types de canaux sous-jacents|IReplyChannel|IReplySessionChannel|IDuplexChannel|IDuplexSessionChannel|  
|-------------------------------------------------------------------------------|-------------------|--------------------------|--------------------|---------------------------|  
|IInputSessionChannel|Oui|Oui|Oui|Oui|  
|IReplySessionChannel|Oui|Oui|Non|Non|  
|IDuplexSessionChannel|Non|Non|Oui|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TChannel" /> n'est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelFactory(Of TChannel) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; override bool CanBuildChannelFactory(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelFactory : System.ServiceModel.Channels.BindingContext -&gt; bool" Usage="reliableSessionBindingElement.CanBuildChannelFactory context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Type de canal construit par la fabrique.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> contenant les informations nécessaires pour générer les fabriques qui peuvent produire des canaux de type <c>TChannel</c>.</param>
        <summary>Retourne une valeur qui indique si la fabrique de canal peut être construite pour le canal et le contexte fournis qui prennent en charge une session fiable.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> de type <paramref name="TChannel" /> peut être construit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne la valeur `true` ou `false` pour un `TChannel` conformément à la table de valeurs présentée dans <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelFactory%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanBuildChannelListener(Of TChannel As {Class, IChannel}) (context As BindingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TChannel&gt;&#xA; where TChannel : class, System::ServiceModel::Channels::IChannel override bool CanBuildChannelListener(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.CanBuildChannelListener : System.ServiceModel.Channels.BindingContext -&gt; bool (requires 'Channel : null and 'Channel :&gt; System.ServiceModel.Channels.IChannel)" Usage="reliableSessionBindingElement.CanBuildChannelListener context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">Le <see cref="T:System.ServiceModel.Channels.IChannel" /> que l’écouteur de canal, si de build, accepte.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> contenant les informations nécessaires pour générer les écouteurs qui peuvent accepter les canaux de type <c>TChannel</c>.</param>
        <summary>Retourne une valeur qui indique si l'écouteur de canal peut être construit pour le canal et le contexte fournis qui prennent en charge une session fiable.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.ServiceModel.Channels.ChannelListenerBase`1" /> qui peut produire un <see cref="T:System.ServiceModel.Channels.IChannel" /> du type <paramref name="TChannel" /> peut être construit par l'élément de liaison ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les piles de canaux sont créées en principe à l’aide d’un modèle de fabrication, plus précisément à l’aide de liaisons. Lors de l’envoi de message, une liaison est utilisée pour générer une fabrique de canal, qui génère à son tour une pile de canaux et retourne une référence au canal figurant en haut de la pile. L'application peut utiliser ensuite ce canal pour envoyer des messages. De même que lors de la réception de messages, une liaison est utilisée pour construire un écouteur de canal qui écoute les messages entrants. L'écouteur de canal envoie des messages à l'application qui écoute en créant des piles de canaux et en remettant à l'application une référence au canal supérieur.  
  
 Cette méthode retourne la valeur `true` ou `false` pour un `TChannel` conformément à la table de valeurs présentée dans <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.BuildChannelListener%60%601%28System.ServiceModel.Channels.BindingContext%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Clone () As BindingElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElement ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.ServiceModel.Channels.BindingElement" Usage="reliableSessionBindingElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie de l'élément de liaison de session fiable actuel.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.BindingElement" /> qui est un clone de l'élément de liaison actuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowControlEnabled">
      <MemberSignature Language="C#" Value="public bool FlowControlEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlowControlEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowControlEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FlowControlEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.FlowControlEnabled : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.FlowControlEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le contrôle de flux est activé pour la session fiable.</summary>
        <value>
          <see langword="true" /> si le contrôle de flux est activé pour la session fiable ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contrôle de flux est un mécanisme que les sessions fiables implémentent pour garantir que les expéditeurs n'envoient pas plus de messages qu'un destinataire ne peut gérer. Les destinataires ont une mémoire tampon de messages qui est utilisée pour s'adapter aux rafales de messages et aux messages hors-service. Ils indiquent aux expéditeurs la quantité d'espace restante dans cette mémoire tampon dans chacun de leurs accusés de réception. Les expéditeurs peuvent utiliser cette information pour cesser d'envoyer de nouveaux messages lorsque le destinataire n'a plus d'espace dans sa mémoire tampon.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperty(Of T As Class) (context As BindingContext) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class override T GetProperty(System::ServiceModel::Channels::BindingContext ^ context);" />
      <MemberSignature Language="F#" Value="override this.GetProperty : System.ServiceModel.Channels.BindingContext -&gt; 'T (requires 'T : null)" Usage="reliableSessionBindingElement.GetProperty context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type de propriété récupéré.</typeparam>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.BindingContext" /> contenant les informations nécessaires pour récupérer le canal de type <c>T</c>.</param>
        <summary>Obtient une propriété du type spécifié à partir de son contexte de liaison.</summary>
        <returns>Propriété de type <paramref name="T" /> avec le <paramref name="context" /> spécifié ou <see langword="null" /> si aucune propriété de type <paramref name="T" /> n'est trouvée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InactivityTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan InactivityTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan InactivityTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property InactivityTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan InactivityTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.InactivityTimeout : TimeSpan with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.TimeSpan), "00:10:00")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un intervalle de temps pendant lequel un service reste inactif avant sa fermeture.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> qui spécifie l'intervalle de temps pendant lequel un service reste inactif avant sa fermeture. La valeur par défaut est 10 minutes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'activité sur un canal est définie telle que la réception d'un message d'application ou d'infrastructure. Ce délai d'inactivité contrôle la durée maximale d'activation d'une session inactive. Si un délai supérieur à <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.InactivityTimeout%2A> s'écoule sans activité, la session est abandonnée par l'infrastructure et une erreur est retournée sur le canal. La session fiable est détruite unilatéralement.  
  
 Si l'application émettrice n'a pas de messages à envoyer, la session fiable ne retourne aucune erreur due à l'inactivité ; un mécanisme d'activation la maintient au contraire active indéfiniment. Notez que le répartiteur peut abandonner la session fiable de façon indépendante si aucun message d'application n'est envoyé ou reçu. Ainsi, le délai d'attente d'inactivité expire en général si les conditions du réseau sont telles qu'aucun message n'est reçu ou en cas d'échec de l'expéditeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure ou égale à zéro ou supérieure à <see cref="F:System.Int32.MaxValue" /> ou <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPendingChannels">
      <MemberSignature Language="C#" Value="public int MaxPendingChannels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPendingChannels" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPendingChannels As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPendingChannels { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPendingChannels : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxPendingChannels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(4)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal de canaux qui peuvent rester en attente dans une même session fiable.</summary>
        <value>Nombre maximal de canaux en attente. La valeur par défaut est 4.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les canaux sont en attente lorsqu'ils attendent d'être acceptés. Une fois que cette limite est atteinte, aucun canal n'est créé et mis en attente tant que cette valeur ne baisse pas (en acceptant des canaux en attente). Cette limite s'applique à chaque écouteur.  
  
 Lorsque le seuil est atteint et qu'une application distante essaie d'établir une nouvelle session fiable, la demande est refusée et l'opération d'ouverture initiale notifie l'erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure ou égale à zéro ou supérieure à 16384.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxRetryCount">
      <MemberSignature Language="C#" Value="public int MaxRetryCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxRetryCount" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRetryCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxRetryCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRetryCount : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal des tentatives de transfert d'un message pendant la session fiable.</summary>
        <value>Nombre maximal des tentatives de retransfert d'un message. La valeur minimale par défaut est 1 ; la valeur maximale est <see cref="F:System.Int32.MaxValue" /> ; et la valeur par défaut est 8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un message est considéré comme devant être transféré si sa remise au destinataire a été acceptée par le destinataire.  
  
 Si, pour un message ayant été transmis, aucun accusé de réception n'a été reçu après un certain temps, l'infrastructure retransmet automatiquement le message. L'infrastructure essaie d'envoyer le message à <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxRetryCount%2A> reprises au maximum. La non réception d'un accusé de réception avant l'atteinte de ce seuil est considérée comme un échec de communication fatal, qui entraîne le déclenchement d'un événement d'échec du canal.  
  
 L'infrastructure utilise un algorithme de réduction de puissance exponentiel pour déterminer quand retransmettre, selon un délai aller-retour moyen calculé. Le délai initial entre deux tentatives est calculé sur la base du délai aller-retour mesuré à partir de l'établissement de la session. L'algorithme de retransmission multiplie par deux le délai à chaque tentative, ce qui induit l'écoulement de 8,5 minutes environ entre la première et la dernière tentative de retransmission. Le délai de la première tentative de retransmission est ajusté au délai aller-retour calculé et le décalage créé par ces tentatives varie en conséquence. Cela permet au délai de retransmission de s'adapter dynamiquement aux conditions de réseau variables.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure ou égale à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxTransferWindowSize">
      <MemberSignature Language="C#" Value="public int MaxTransferWindowSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxTransferWindowSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxTransferWindowSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxTransferWindowSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxTransferWindowSize : int with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le plus grand nombre de messages qui peuvent exister dans la mémoire tampon d'envoi ou de réception.</summary>
        <value>Plus grand nombre de messages qui peuvent être mis en mémoire tampon. La valeur minimale est 1 ; la valeur maximale est 4096 ; et la valeur par défaut est 32.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la propriété <xref:System.ServiceModel.Channels.ReliableSessionBindingElement.MaxTransferWindowSize%2A> peut être définie à la fois sur l'expéditeur et le destinataire. Cette valeur est incluse dans la stratégie de liaison de WSDL, par conséquent si vous utilisez le [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) pour construire votre client, il a la même valeur. Sinon, elle prend toute valeur que vous définissez sur le client.  
  
 Lorsque cette limite est atteinte sur l'expéditeur, des appels supplémentaires à envoyer sont bloqués. Lorsque cette limite est atteinte sur le destinataire, les nouveaux messages qui arrivent sur le canal sous-jacent ne sont pas acceptés.  
  
 Une session fiable utilise un protocole de fenêtrage qui contribue à améliorer l'utilisation du réseau. La quantité de données à mettre en mémoire tampon est directement dérivée de la taille de la fenêtre de transmission. Lors du réglage de cette valeur, notez que la fenêtre de transmission optimale est mise en rapport avec la bande passante et la latence de manière simple. La taille de fenêtre maximale idéale correspond à la bande passante multipliée par la latence. Toute valeur inférieure donne une utilisation du réseau inférieure à 100 % ; toute valeur supérieure se solde par un gaspillage d'espace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur définie est inférieure ou égale à 1 ou supérieure à 4096.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ordered">
      <MemberSignature Language="C#" Value="public bool Ordered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Ordered" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberSignature Language="VB.NET" Value="Public Property Ordered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Ordered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Ordered : bool with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.Ordered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la remise des messages doit se faire dans l'ordre d'envoi des messages.</summary>
        <value>
          <see langword="true" /> si les messages doivent être remis dans l'ordre dans lequel ils sont envoyés ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir des messages distribués en ordre, il convient également d'affecter à <xref:System.ServiceModel.ConcurrencyMode> la valeur <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableMessagingVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ReliableMessagingVersion ReliableMessagingVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ReliableMessagingVersion As ReliableMessagingVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ReliableMessagingVersion ^ ReliableMessagingVersion { System::ServiceModel::ReliableMessagingVersion ^ get(); void set(System::ServiceModel::ReliableMessagingVersion ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReliableMessagingVersion : System.ServiceModel.ReliableMessagingVersion with get, set" Usage="System.ServiceModel.Channels.ReliableSessionBindingElement.ReliableMessagingVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.ServiceModel.ReliableMessagingVersion), "WSReliableMessagingFebruary2005")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ReliableMessagingVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la version de WS-ReliableMessaging spécifiée par l’élément de liaison.</summary>
        <value>Instance dérivée de <see cref="T:System.ServiceModel.ReliableMessagingVersion" /> qui représente la version du protocole WS-ReliableMessaging utilisé par l'élément de configuration.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe actuellement deux versions du protocole WS-ReliableMessaging pris en charge par Windows Communication Foundation (WCF) : WS-ReliableMessaging1.1 et WS-ReliableMessagingFebruary2005. La version par défaut est WS-ReliableMessagingFebruary2005.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.ReliableSessionBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberSignature Language="VB.NET" Value="Sub ExportPolicy (exporter As MetadataExporter, context As PolicyConversionContext) Implements IPolicyExportExtension.ExportPolicy" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System::ServiceModel::Description::MetadataExporter ^ exporter, System::ServiceModel::Description::PolicyConversionContext ^ context) = System::ServiceModel::Description::IPolicyExportExtension::ExportPolicy;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">
          <see cref="T:System.ServiceModel.Description.MetadataExporter" /> qui exporte les informations de liaison dans l'élément de liaison de session fiable en éléments WSDL.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> qui fournit les mappages d'éléments WSDL exportés à la description des points de terminaison.</param>
        <summary>Mappe les informations contenues dans l’élément de liaison de session fiable dans les éléments WSDL qui permettent à un point de terminaison distant d’accéder au service avec une session fiable.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>