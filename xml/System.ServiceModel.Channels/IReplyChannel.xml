<Type Name="IReplyChannel" FullName="System.ServiceModel.Channels.IReplyChannel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="398f71026759bf7de615512f4feee56d48febe38" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39854137" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IReplyChannel : System.ServiceModel.Channels.IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReplyChannel implements class System.ServiceModel.Channels.IChannel, class System.ServiceModel.ICommunicationObject" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IReplyChannel" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReplyChannel&#xA;Implements IChannel" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReplyChannel : System::ServiceModel::Channels::IChannel" />
  <TypeSignature Language="F#" Value="type IReplyChannel = interface&#xA;    interface IChannel&#xA;    interface ICommunicationObject" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Définit l'interface qu'un canal doit implémenter pour se trouver du côté réception d'une communication demande-réponse entre des points de terminaison de messagerie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'interface <xref:System.ServiceModel.Channels.IReplyChannel> inclut des variantes synchrones et asynchrones d'une méthode <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> qui retourne un <xref:System.ServiceModel.Channels.RequestContext> qui peut être utilisé pour construire des réponses aux demandes reçues.  
  
 Le contrat inclut des variantes synchrones et asynchrones de fonctionnalités de réception, de tentative de réception et d’attente de message.  
  
 Un <xref:System.ServiceModel.Channels.IReplyChannel> n'est pas lié nécessairement à un expéditeur unique. D'autres canaux et interfaces de canaux fournissent une corrélation entre l'expéditeur et le canal de réponse, mais le contrat de base ne définit aucune restriction de ce type.  
  
 Le modèle d'extraction est utilisé avec un <xref:System.ServiceModel.Channels.IReplyChannel> pour recevoir des messages. Ce modèle consiste à appeler <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> (ou l'une de ses variantes) puis d'attendre l'arrivée d'un message.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération asynchrone pour recevoir une demande disponible.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceiveRequest : AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginReceiveRequest (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la réception asynchrone qu'une opération de demande exécute.</param>
        <param name="state">Objet, spécifié par l'application, qui contient les informations d'état associées à la réception asynchrone d'une opération de demande.</param>
        <summary>Commence une opération asynchrone pour recevoir une demande disponible avec un délai d'attente par défaut.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à la réception asynchrone de la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.AsyncCallback%2CSystem.Object%29> méthode implémente le modèle standard pour appeler <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest> en mode asynchrone. Le délai d'attente par défaut est 1 minute. Si un délai d'attente de réception a pour valeur la liaison utilisée pour configurer la connexion, cette valeur est alors utilisée. Utilisez <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> si vous souhaitez spécifier un délai d'attente explicite avec l'appel qui substitue ces autres valeurs.  
  
 Si le message de demande reçu dépasse la taille maximale du message autorisée par la liaison utilisée, une <xref:System.ServiceModel.QuotaExceededException> est levée. La taille maximale du message est définie par la propriété <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>. La valeur par défaut est 65 536 octets.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReceiveRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginReceiveRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie la durée d'attente de réception d'une demande disponible.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la réception asynchrone qu'une opération de demande exécute.</param>
        <param name="state">Objet, spécifié par l'application, qui contient les informations d'état associées à la réception asynchrone d'une opération de demande.</param>
        <summary>Commence une opération asynchrone pour recevoir une demande disponible avec un délai d'attente spécifié.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à la réception asynchrone de la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ServiceModel.Channels.IReplyChannel.BeginReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> méthode implémente le modèle standard pour appeler <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%28System.TimeSpan%29> en mode asynchrone. Le délai d’attente affecté à cette méthode substitue un délai d’attente de réception affecté à la liaison qui est utilisée pour configurer la connexion.  
  
 Si le message de demande reçu dépasse la taille maximale du message autorisée par la liaison utilisée, une <xref:System.ServiceModel.QuotaExceededException> est levée. La taille maximale du message est définie par la propriété <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>. La valeur par défaut est 65 536 octets.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTryReceiveRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTryReceiveRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginTryReceiveRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTryReceiveRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginTryReceiveRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginTryReceiveRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution de l'opération de demande de réception avant dépassement du délai d’attente et retour de <see langword="false" />.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la réception asynchrone qu'une opération de demande exécute.</param>
        <param name="state">Objet, spécifié par l'application, qui contient les informations d'état associées à la réception asynchrone d'une opération de demande.</param>
        <summary>Commence une opération asynchrone pour recevoir un message de demande auquel sont associés un délai d'attente spécifié et un objet d'état.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération de demande de réception asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode asynchrone <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> lorsque vous souhaitez que le traitement de l'application se poursuive sans attendre. Utilisez l'une des méthodes <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> synchrones lorsque le thread en cours peut faire l'objet d'un blocage en répondant au message de demande ou jusqu'à ce que l'intervalle de délai d'attente soit dépassé.  
  
 Cette méthode reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans le canal ou lorsque le délai d'attente a expiré.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> si spécifié <paramref name="timeout" /> est dépassé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BeginWaitForRequest">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWaitForRequest (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWaitForRequest(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWaitForRequest (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginWaitForRequest(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWaitForRequest : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="iReplyChannel.BeginWaitForRequest (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie la durée d'attente de réception d'une demande disponible.</param>
        <param name="callback">Le délégué <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la réception asynchrone qu'une opération de demande exécute.</param>
        <param name="state">Objet, spécifié par l'application, qui contient les informations d'état associées à la réception asynchrone d'une opération de demande.</param>
        <summary>Commence une opération de demande asynchrone à laquelle sont associés un délai d'attente spécifié et un objet d'état.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui fait référence à l'opération asynchrone pour attendre l'arrivée d'un message de demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la méthode <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> synchrone lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message de demande dans la file d'attente. Le thread reste bloqué durant le `timeout` spécifié.  
  
 Cette méthode reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message de demande est disponible dans le canal ou lorsque le délai d'attente a expiré.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#10)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> si spécifié <paramref name="timeout" /> est dépassé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext EndReceiveRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext EndReceiveRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndReceiveRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveRequest (result As IAsyncResult) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ EndReceiveRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReceiveRequest : IAsyncResult -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.EndReceiveRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="Overload:System.ServiceModel.Channels.IInputChannel.BeginReceive" />.</param>
        <summary>Termine une opération asynchrone pour recevoir une demande disponible.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> utilisé pour construire une réponse à la demande.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le message de demande reçu dépasse la taille maximale du message autorisée par la liaison utilisée, une <xref:System.ServiceModel.QuotaExceededException> est levée. La taille maximale du message est définie par la propriété <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>. La valeur par défaut est 65 536 octets.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’opération doit lever une <see cref="T:System.TimeoutException" /> si spécifié <paramref name="timeout" /> est dépassé avant la fin de l’opération.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndTryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool EndTryReceiveRequest (IAsyncResult result, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndTryReceiveRequest(class System.IAsyncResult result, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndTryReceiveRequest(System.IAsyncResult,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndTryReceiveRequest (result As IAsyncResult, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndTryReceiveRequest(IAsyncResult ^ result, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberSignature Language="F#" Value="abstract member EndTryReceiveRequest : IAsyncResult *  -&gt; bool" Usage="iReplyChannel.EndTryReceiveRequest (result, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> retourné par un appel à la méthode <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> reçu.</param>
        <summary>Termine l'opération asynchrone spécifiée pour recevoir un message de demande.</summary>
        <returns>
          <see langword="true" /> si un message de demande est reçu avant expiration de l'intervalle de temps spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWaitForRequest">
      <MemberSignature Language="C#" Value="public bool EndWaitForRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndWaitForRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.EndWaitForRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWaitForRequest (result As IAsyncResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndWaitForRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWaitForRequest : IAsyncResult -&gt; bool" Usage="iReplyChannel.EndWaitForRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> qui identifie l'opération <see cref="M:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest(System.TimeSpan,System.AsyncCallback,System.Object)" /> à terminer et à partir de laquelle il est possible de récupérer un résultat final.</param>
        <summary>Termine l'opération asynchrone spécifiée d'attente d'un message de demande.</summary>
        <returns>
          <see langword="true" /> si une demande est reçue avant expiration de l'intervalle de temps spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalAddress">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EndpointAddress LocalAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EndpointAddress LocalAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalAddress As EndpointAddress" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EndpointAddress ^ LocalAddress { System::ServiceModel::EndpointAddress ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalAddress : System.ServiceModel.EndpointAddress" Usage="System.ServiceModel.Channels.IReplyChannel.LocalAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EndpointAddress</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'adresse sur laquelle ce canal de réponse reçoit des messages.</summary>
        <value>
          <see cref="T:System.ServiceModel.EndpointAddress" /> sur laquelle ce canal de réponse reçoit des messages.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant illustre comment implémenter cette propriété :  
  
 [!code-csharp[S_UE_MessageInterceptor#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveRequest">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le contexte de la demande reçu, si disponible</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest () As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest();" />
      <MemberSignature Language="F#" Value="abstract member ReceiveRequest : unit -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.ReceiveRequest " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le contexte de la demande reçu, si disponible. Sinon, attend qu'il y en ait un de disponible.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> utilisé pour construire des réponses.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> encapsule le message de demande et un mécanisme pour répondre à ce message.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> peut être appelée plusieurs fois ou de manière simultanée. Un seul appel <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> est effectué par demande reçue.  
  
 Si le message de demande reçu dépasse la taille maximale du message autorisée par la liaison utilisée, une <xref:System.ServiceModel.QuotaExceededException> est levée. La taille maximale du message est définie par la propriété <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>. La valeur par défaut est 65 536 octets.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveRequest">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Channels.RequestContext ReceiveRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.RequestContext ReceiveRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveRequest (timeout As TimeSpan) As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Channels::RequestContext ^ ReceiveRequest(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member ReceiveRequest : TimeSpan -&gt; System.ServiceModel.Channels.RequestContext" Usage="iReplyChannel.ReceiveRequest timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.RequestContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution de la réception d'une opération de demande avant dépassement du délai d’attente et retour de <see langword="false" />.</param>
        <summary>Retourne le contexte de la demande reçu, si disponible. Sinon, attend qu'il y en ait un de disponible.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> utilisé pour construire des réponses.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.RequestContext> encapsule le message de demande et un mécanisme pour répondre à ce message.  
  
 <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> peut être appelée plusieurs fois ou de manière simultanée. Un seul appel <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> est effectué par demande reçue.  
  
 Si le message de demande reçu dépasse la taille maximale du message autorisée par la liaison utilisée, une <xref:System.ServiceModel.QuotaExceededException> est levée. La taille maximale du message est définie par la propriété <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A>. La valeur par défaut est 65 536 octets.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveRequest">
      <MemberSignature Language="C#" Value="public bool TryReceiveRequest (TimeSpan timeout, out System.ServiceModel.Channels.RequestContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveRequest(valuetype System.TimeSpan timeout, [out] class System.ServiceModel.Channels.RequestContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest(System.TimeSpan,System.ServiceModel.Channels.RequestContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveRequest (timeout As TimeSpan, ByRef context As RequestContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReceiveRequest(TimeSpan timeout, [Runtime::InteropServices::Out] System::ServiceModel::Channels::RequestContext ^ % context);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveRequest : TimeSpan *  -&gt; bool" Usage="iReplyChannel.TryReceiveRequest (timeout, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="context" Type="System.ServiceModel.Channels.RequestContext" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution de la réception d'une opération de demande avant dépassement du délai d’attente et retour de <see langword="false" />.</param>
        <param name="context">
          <see cref="T:System.ServiceModel.Channels.RequestContext" /> reçu.</param>
        <summary>Retourne une valeur qui indique si une demande est reçue avant qu'un intervalle de temps spécifié ne soit écoulé.</summary>
        <returns>
          <see langword="true" /> si un message de demande est reçu avant expiration de l'intervalle de temps spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.ServiceModel.Channels.IReplyChannel.TryReceiveRequest%28System.TimeSpan%2CSystem.ServiceModel.Channels.RequestContext%40%29> lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message de demande dans la file d'attente. Le thread reste bloqué durant le `timeout` spécifié. Si vous souhaitez que le traitement de l'application se poursuive sans attendre, utilisez la méthode <xref:System.ServiceModel.Channels.IReplyChannel.BeginTryReceiveRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> asynchrone.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> si spécifié <paramref name="timeout" /> est dépassé.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WaitForRequest">
      <MemberSignature Language="C#" Value="public bool WaitForRequest (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitForRequest(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IReplyChannel.WaitForRequest(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForRequest (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForRequest(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitForRequest : TimeSpan -&gt; bool" Usage="iReplyChannel.WaitForRequest timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui spécifie le délai d'exécution d'une opération de demande avant dépassement du délai d’attente et retour de <see langword="false" />.</param>
        <summary>Retourne une valeur qui indique si un message de demande est reçu avant qu'un intervalle de temps spécifié ne soit écoulé.</summary>
        <returns>
          <see langword="true" /> si une demande est reçue avant expiration de l'intervalle de temps spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'appel de <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> n'entraîne en aucune façon la réception ou le traitement d'un message de demande.  
  
 La méthode <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> existe à l'origine pour les scénarios avec transaction où l'utilisateur souhaite recevoir le message à l'aide d'une transaction. Pour ce faire, lorsqu'il n'utilise que <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> normalement, l'utilisateur doit créer la transaction puis appeler <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> et espérer que le message arrive avant que la transaction n'expire, ce qui est impossible.  
  
 À la place, l'utilisateur peut appeler <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> et spécifier le délai d'attente (même infini), puis lorsqu'un message arrive il peut ouvrir la transaction, appeler <xref:System.ServiceModel.Channels.IReplyChannel.ReceiveRequest%2A> et être certain qu'il peut récupérer le message avant que la transaction n'expire.  
  
 Utilisez <xref:System.ServiceModel.Channels.IReplyChannel.WaitForRequest%28System.TimeSpan%29> lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message dans la file d'attente. Le thread reste bloqué durant le `timeout` spécifié. Si vous souhaitez que le traitement de l'application se poursuive sans attendre, utilisez la méthode <xref:System.ServiceModel.Channels.IReplyChannel.BeginWaitForRequest%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> asynchrone.  
  
   
  
## Examples  
 Le code suivant illustre comment implémenter cette méthode :  
  
 [!code-csharp[S_UE_MessageInterceptor#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingchannellistener.cs#9)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’opération retourne <see langword="false" /> si spécifié <paramref name="timeout" /> est dépassé.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>