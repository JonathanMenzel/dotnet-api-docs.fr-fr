<Type Name="ICommand" FullName="System.Windows.Input.ICommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="46d592b6b521ba743fa81bd1aea4f89ba331f470" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37562138" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ICommand" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICommand" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.ICommand" />
  <TypeSignature Language="VB.NET" Value="Public Interface ICommand" />
  <TypeSignature Language="C++ CLI" Value="public interface class ICommand" />
  <TypeSignature Language="F#" Value="type ICommand = interface" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Définit une commande.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.RoutedCommand> et <xref:System.Windows.Input.RoutedUICommand> deux implémentations de la <xref:System.Windows.Input.ICommand> dans l’interface [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].  
  
## <a name="icommand-in-windows-runtime-apps"></a>ICommand dans Windows Runtime des applications  
 Le <xref:System.Windows.Input.ICommand> interface est le contrat de code pour les commandes qui sont écrits dans les applications .NET pour Windows Runtime. Ces commandes fournissent le comportement d’exécution de commandes pour les éléments d’interface utilisateur comme un XAML de Runtime Windows `Button` et en particulier un `AppBarButton`. Si vous définissez des commandes pour les applications Windows Runtime vous utilisez essentiellement les mêmes techniques que vous utiliseriez pour la définition de commandes pour une application .NET. Implémenter la commande en définissant une classe qui implémente <xref:System.Windows.Input.ICommand> et mettre en œuvre plus précisément le <xref:System.Windows.Input.ICommand.Execute%2A> (méthode).  
  
 XAML pour Windows Runtime ne prend pas en charge x`:Static`, afin de ne pas tenter d’utiliser le `x:Static` extension de balisage si la commande est utilisée à partir de Windows Runtime XAML. En outre, le Runtime de Windows n’a pas de toutes les bibliothèques commande prédéfinie, donc la syntaxe XAML illustrée ici ne s’appliquent pas réellement dans le cas où vous êtes implémentant l’interface et la définition de la commande pour l’utilisation de Windows Runtime.  
  
<a name="xamlTextUsage_ICommand"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
 \<*propriété d’objet*= «*predefinedCommandName*« / >  
  
 \- ou -  
  
 \<*propriété d’objet*= «*predefinedCommandName.predefinedCommandName*« / >  
  
 \- ou -  
  
 \<*propriété d’objet*= « { *customClassName.customCommandName*} "/ >  
  
<a name="xamlValues_ICommand"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *predefinedClassName*  
 Une des classes de commande prédéfinies.  
  
 *predefinedCommandName*  
 Une des commandes prédéfinies.  
  
 *customClassName*  
 Une classe personnalisée qui contient la commande personnalisée. Classes personnalisées requièrent généralement un `xlmns` de préfixe de mappage ; consultez [espaces de noms XAML et mappage Namespace pour WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
 *customCommandName*  
 Une commande personnalisée.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="public bool CanExecute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanExecute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.CanExecute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanExecute (parameter As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanExecute(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member CanExecute : obj -&gt; bool" Usage="iCommand.CanExecute parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Données utilisées par la commande.  Si la commande n’exige pas que des données soient passées, cet objet peut avoir la valeur <see langword="null" />.</param>
        <summary>Définit la méthode qui détermine si la commande peut s'exécuter dans son état actuel.</summary>
        <returns>
          <see langword="true" /> si cette commande peut être exécutée ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, une source de commande appelle le <xref:System.Windows.Input.ICommand.CanExecute%2A> méthode lorsque le <xref:System.Windows.Input.ICommand.CanExecuteChanged> événement est déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="CanExecuteChanged">
      <MemberSignature Language="C#" Value="event EventHandler CanExecuteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CanExecuteChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.ICommand.CanExecuteChanged" />
      <MemberSignature Language="VB.NET" Value="Event CanExecuteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CanExecuteChanged;" />
      <MemberSignature Language="F#" Value="member this.CanExecuteChanged : EventHandler " Usage="member this.CanExecuteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque des modifications influent sur l'exécution de la commande.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalement, une source de commande appelle <xref:System.Windows.Input.ICommand.CanExecute%2A> sur la commande lorsque cet événement se produit.  
  
 En règle générale, si la commande ne peut pas s’exécuter, la source de commande désactive.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.Execute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member Execute : obj -&gt; unit" Usage="iCommand.Execute parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Données utilisées par la commande.  Si la commande n’exige pas que des données soient passées, cet objet peut avoir la valeur <see langword="null" />.</param>
        <summary>Définit la méthode à appeler lorsque la commande est invoquée.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
  </Members>
</Type>