<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c701543cf78be82eeaa3f9705791e280a033479a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36507812" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente une liaison entre un <see cref="T:System.Windows.Input.InputGesture" /> et une commande. La commande peut être un <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier que l’entrée d’utilisateur appelle une commande en créant un <xref:System.Windows.Input.InputBinding>. Lorsque l’utilisateur effectue l’entrée spécifiée, le <xref:System.Windows.Input.ICommand> qui est définie sur le <xref:System.Windows.Input.InputBinding.Command%2A> propriété est exécutée.  
  
 Vous pouvez spécifier que le <xref:System.Windows.Input.InputBinding> appelle une commande qui est définie sur un objet en créant une liaison sur le <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, et <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriétés. Cela vous permet de définir une commande personnalisée et l’associer à l’entrée d’utilisateur. Pour plus d’informations, consultez le deuxième exemple dans la section Exemples.  
  
 Un <xref:System.Windows.Input.InputBinding> peut être défini sur un objet spécifique ou au niveau de la classe en enregistrant un <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> avec la <xref:System.Windows.Input.CommandManager>.  
  
 La <xref:System.Windows.Input.InputBinding> classe proprement dite ne prend pas en charge l’utilisation de XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et peuvent donc définir des propriétés de la classe dérivée qui sont héritées de <xref:System.Windows.Input.InputBinding> avec une utilisation de XAML. Existant deux <xref:System.Windows.Input.InputBinding>-classes dérivées qui peuvent être instanciés en XAML et peuvent définir des propriétés en XAML sont <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>. La propriété classique dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] de programmation qui est définie en XAML et prend un ou plusieurs <xref:System.Windows.Input.InputBinding> objets sous forme de valeurs est la <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> propriété.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Utilisation d'éléments objet XAML  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Input.KeyBinding> pour lier un <xref:System.Windows.Input.KeyGesture> à la <xref:System.Windows.Input.ApplicationCommands.Open%2A> commande. Lors de la combinaison de touches est effectuée, la commande Ouvrir est appelée.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Les exemples suivants montrent comment lier une commande personnalisée à <xref:System.Windows.Input.InputBinding> objets. Ces exemples créent une application qui permet à l’utilisateur modifier la couleur d’arrière-plan en effectuant l’une des actions suivantes :  
  
-   En cliquant sur un bouton.  
  
-   En appuyant sur CTRL + C.  
  
-   Clic droit sur un <xref:System.Windows.Controls.StackPanel> (en dehors de la <xref:System.Windows.Controls.ListBox>).  
  
 Le premier exemple crée une classe nommée `SimpleDelegateCommand`. Cette classe accepte un délégué afin que l’objet de création de la commande peut définir l’action qui se produit lorsque la commande est exécutée. `SimpleDelegateCommand` définit également des propriétés qui spécifient ce que la clé et de la souris entrée appelle la commande. `GestureKey` et `GestureModifier` spécifier l’entrée de clavier ; `MouseGesture` Spécifie l’entrée de la souris.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 L’exemple suivant crée et initialise le `ColorChangeCommand`, qui est un `SimpleDelegateCommand`. L’exemple définit également la méthode qui s’exécute lorsque la commande est appelée et définit les `GestureKey`, `GestureModifier`, et `MouseGesture` propriétés. Une application appelle la `InitializeCommand` méthode lorsque le programme commence, comme dans le constructeur d’un <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Enfin, l’exemple suivant crée l’interface utilisateur. L’exemple ajoute un <xref:System.Windows.Input.KeyBinding> et un <xref:System.Windows.Input.MouseBinding> à un <xref:System.Windows.Controls.StackPanel> qui contient un <xref:System.Windows.Controls.Button> et un <xref:System.Windows.Controls.ListBox>. Lorsque l’utilisateur sélectionne un élément dans le <xref:System.Windows.Controls.ListBox>, il ou elle peut modifier la couleur d’arrière-plan à la couleur sélectionnée. Dans chaque cas, le `CommandParameter` propriété est liée à l’élément sélectionné dans le <xref:System.Windows.Controls.ListBox>et le `Command` propriété est liée à la `ColorChangeCommand`. Le <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, et <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> propriétés sont liées aux propriétés correspondantes la `SimpleDelegateCommand` classe.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Input.InputBinding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Fournit l'initialisation de base pour les classes dérivées de <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> n’est pas techniquement une classe abstraite, mais le constructeur par défaut est délibérément accès protégé. Cela a pour effet de fabrication <xref:System.Windows.Input.InputBinding> une classe « abstraite » pour le code XAML. Il existe des propriétés dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] qui ont des utilisations de code XAML qui attendent des objets de type <xref:System.Windows.Input.InputBinding>, mais vous ne pouvez pas spécifier un <xref:System.Windows.Input.InputBinding> instance en XAML. Au lieu de cela, vous pouvez spécifier une des spécifique au périphérique <xref:System.Windows.Input.InputBinding> classes dérivées en tant que valeurs, par exemple <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si vous implémentez un personnalisé <see cref="T:System.Windows.Input.InputBinding" /> qui prend en charge une utilisation de XAML, utilisez ce constructeur pour l’initialisation de base.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Commande à associer à <c>gesture</c>.</param>
        <param name="gesture">Mouvement d'entrée à associer à <c>command</c>.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Input.InputBinding" /> avec la commande et le mouvement d'entrée spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous êtes un développeur de logiciels à l’aide des classes de liaison d’entrée existantes, vous généralement pas utilisez ce constructeur, même si vous définissez des commandes personnalisées. Au lieu de cela, vous utilisez des constructeurs de classes dérivées (<xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>), ou vous utilisez ce constructeur comme instanciation de base d’une classe personnalisée. Bien que la <xref:System.Windows.Input.InputBinding> classe prend en charge des périphériques d’entrée différents en principe, dans la pratique, vous devez choisir quel périphérique sera représenté par la liaison d’entrée. Vous ne pouvez définir qu’un seul <xref:System.Windows.Input.InputBinding.Gesture%2A> valeur sur la liaison d’entrée et les mouvements sont spécifiques au périphérique.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser ce constructeur pour associer un <xref:System.Windows.Input.KeyGesture> avec un <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcomand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcomand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="command" /> ou <paramref name="gesture" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Copie les valeurs de base (non animées) des propriétés de l'objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Copie les valeurs actuelles des propriétés de l'objet spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Input.ICommand" /> associé à cette liaison d’entrée.</summary>
        <value>Commande associée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Input.InputBinding> classe ne prend pas en charge l’utilisation de XAML, car elle n’expose pas un constructeur public par défaut (elle possède un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et peuvent donc utiliser des propriétés qui sont héritées de <xref:System.Windows.Input.InputBinding>. Existant deux <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciés en XAML et peuvent définir des propriétés avec les utilisations de code XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> fait référence à un convertisseur de type qui permet à certaines préexistant <xref:System.Windows.Input.ICommand> implémentations pour spécifier des valeurs sous la forme d’une chaîne. Ce comportement de conversion de type définit la forme de valeur d’attribut de cette propriété. Vous pouvez également lier le <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, et <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriétés à un <xref:System.Windows.Input.ICommand> qui est défini sur un objet. Cela vous permet de définir une commande personnalisée et l’associer à l’entrée d’utilisateur. Pour plus d’informations, consultez le deuxième exemple de <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
 <`inputBindingDerivedClass` `Command`="<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `iCommandImplementation`  
 Une implémentation d’un objet de <xref:System.Windows.Input.ICommand> qui prend en charge la syntaxe d’élément objet (possède un constructeur public par défaut).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Input.KeyBinding> pour lier un <xref:System.Windows.Input.KeyGesture> à la <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> commande. Lors de la combinaison de touches est effectuée, la commande Ouvrir est appelée.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Input.InputBinding.Command" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les données spécifiques à la commande pour une commande particulière.</summary>
        <value>Données spécifiques à la commande. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Input.InputBinding.CommandParameter%2A> propriété est utilisée pour passer des informations spécifiques à la commande lorsqu’elle est exécutée. Le type de données est défini par la commande. De nombreuses commandes n’attendent pas de paramètres de commande ; pour ces commandes, tous les paramètres de commande passés seront ignorés.  
  
 Si la commande qui est associée à une liaison d’entrée est un <xref:System.Windows.Input.RoutedCommand>, le <xref:System.Windows.Input.InputBinding.CommandParameter%2A> de la liaison d’entrée est passé à la <xref:System.Windows.Input.RoutedCommand> gestionnaires via la <xref:System.Windows.Input.ExecutedRoutedEventArgs> et le <xref:System.Windows.Input.CanExecuteRoutedEventArgs> les données d’événement lors du traitement de la commande.  
  
 Le type de données et l’objectif du paramètre de commande sont définis différemment pour chaque commande et peuvent être `null`. Vous pouvez lier le <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, et <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriétés à un <xref:System.Windows.Input.ICommand> qui est défini sur un objet. Cela vous permet de définir une commande personnalisée et l’associer à l’entrée d’utilisateur. Pour plus d’informations, consultez le deuxième exemple de <xref:System.Windows.Input.InputBinding>.  
  
 La <xref:System.Windows.Input.InputBinding> classe ne prend pas en charge l’utilisation de XAML, car elle n’expose pas un constructeur public par défaut (elle possède un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et par conséquent, peut définir les propriétés qui sont héritées de <xref:System.Windows.Input.InputBinding> avec l’utilisation de XAML. Existant deux <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciés en XAML et peuvent définir des propriétés en XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `commandParameterString`  
 Chaîne qui est traitée par une commande particulière. Les chaînes sont le type commun utilisé pour les paramètres de commande, car ils peuvent être facilement définies en XAML. Pour le format de chaîne attendu et son objectif, consultez la documentation relative à la commande spécifique qui est associée à la liaison d’entrée. De nombreuses commandes n’attendent pas de paramètres.  
  
 `commandParameterObject`  
 Un objet qui est traité par une commande particulière. Tous les [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] commandes utilisent des chaînes. Par conséquent, cette syntaxe d’élément de propriété est uniquement pertinente pour les scénarios de commande personnalisée. Pour prendre en charge cette syntaxe, la `commandParameterObject` objet doit prendre également en charge la syntaxe d’élément objet (doit disposer d’un constructeur public par défaut).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Input.InputBinding.Command" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'élément cible de la commande.</summary>
        <value>Cible de la commande. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans l’exécution des commandes système, Windows Presentation Foundation le <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriété sur une <xref:System.Windows.Input.ICommandSource> objet est applicable uniquement lorsque la <xref:System.Windows.Input.ICommand> est un <xref:System.Windows.Input.RoutedCommand>. Si <xref:System.Windows.Input.InputBinding.CommandTarget%2A> est défini sur <xref:System.Windows.Input.ICommandSource> et si la commande correspondante n’est pas <xref:System.Windows.Input.RoutedCommand>, la cible de commande est ignorée.  
  
 Lorsqu’il est utilisé avec un <xref:System.Windows.Input.RoutedCommand>, la cible de commande est l’objet sur lequel le <xref:System.Windows.Input.CommandManager.Executed> et <xref:System.Windows.Input.CommandManager.CanExecute> sont déclenchés. Si le <xref:System.Windows.Input.InputBinding.CommandTarget%2A> propriété n’est pas définie, l’élément avec le focus clavier est utilisé comme cible.  
  
 La <xref:System.Windows.Input.InputBinding> classe proprement dite ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et par conséquent peut définir les propriétés qui sont héritées de <xref:System.Windows.Input.InputBinding> avec une utilisation de XAML. Existant deux <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciés en XAML et peuvent définir des propriétés en XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `bindingToTarget`  
 Chaîne qui utilise un type de syntaxe de liaison qui peut retourner une référence d’objet à un fichier nommé élément. Consultez la section Notes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance de <see cref="T:System.Windows.Input.InputBinding" />.</summary>
        <returns>Nouvel objet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Input.InputGesture" /> associé à cette liaison d’entrée.</summary>
        <value>Combinaison associée. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mouvement d’entrée est l’action qui appelle la commande. Exemples de mouvements d’entrée dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sont <xref:System.Windows.Input.KeyGesture> et <xref:System.Windows.Input.MouseGesture>. A <xref:System.Windows.Input.KeyGesture> est une combinaison d’un <xref:System.Windows.Input.Key> et un ensemble de <xref:System.Windows.Input.ModifierKeys>. A <xref:System.Windows.Input.MouseGesture> est une combinaison d’un <xref:System.Windows.Input.MouseAction> et un ensemble de <xref:System.Windows.Input.ModifierKeys>.  
  
 La <xref:System.Windows.Input.InputBinding> classe proprement dite ne prend pas en charge l’utilisation XAML, car elle n’expose pas un constructeur public par défaut (un constructeur par défaut, mais il est protégé). Toutefois, les classes dérivées peuvent exposer un constructeur public et affecter ainsi les propriétés qui sont héritées de <xref:System.Windows.Input.InputBinding> avec une utilisation de XAML. Existant deux <xref:System.Windows.Input.InputBinding> sont des classes dérivées qui peuvent être instanciés en XAML et peuvent définir des propriétés en XAML <xref:System.Windows.Input.KeyBinding> et <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`="<xref:System.Windows.Input.KeyGesture>"/>  
  
 \- ou -  
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`="<xref:System.Windows.Input.MouseGesture>"/>  
  
 \- ou -  
  
 <`inputBindingDerivedClass` `Gesture`="<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 `inputBindingDerivedClass`  
 Une classe dérivée de <xref:System.Windows.Input.InputBinding> qui prend en charge la syntaxe d’élément objet, tel que <xref:System.Windows.Input.KeyBinding> ou <xref:System.Windows.Input.MouseBinding>. Consultez la section Notes.  
  
 `inputGestureImplementation`  
 Classe de dérivée personnalisée <xref:System.Windows.Input.InputGesture> qui prend en charge la syntaxe d’élément objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Windows.Input.KeyBinding> pour lier un <xref:System.Windows.Input.KeyGesture> à un <xref:System.Windows.Input.RoutedCommand>. Lorsque le <xref:System.Windows.Input.KeyGesture> appuyé sur ALT + L, la <xref:System.Windows.Input.ApplicationCommands.Close%2A> commande est appelée.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Convertit l'instance en clone figé du <see cref="T:System.Windows.Freezable" /> spécifié à l'aide des valeurs de propriétés (non animées) de base.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Convertit l'instance actuelle en un clone figé du <see cref="T:System.Windows.Freezable" /> spécifié. Si l’objet a des propriétés de dépendance animées, leurs valeurs animées actuelles sont copiées.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>