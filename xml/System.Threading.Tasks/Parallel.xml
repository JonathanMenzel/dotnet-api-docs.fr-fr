<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2e5877b668a67baf4ed3de602d3e7d81869f3db6" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53297175" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ef828-101">Fournit une prise en charge pour les boucles et les régions parallèles.</span><span class="sxs-lookup"><span data-stu-id="ef828-101">Provides support for parallel loops and regions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-102">Le <xref:System.Threading.Tasks.Parallel> classe fournit des remplacements parallèles de données basées sur une bibliothèque pour les opérations courantes telles que les boucles, pour chaque boucle et exécution d’un ensemble d’instructions.</span><span class="sxs-lookup"><span data-stu-id="ef828-102">The <xref:System.Threading.Tasks.Parallel> class provides library-based data parallel replacements for common operations such as for loops, for each loops, and execution of a set of statements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-103">Cet exemple montre plusieurs approches pour implémenter une boucle parallèle à l’aide de plusieurs constructions de langage.</span><span class="sxs-lookup"><span data-stu-id="ef828-103">This example demonstrates several approaches to implementing a parallel loop using multiple language constructs.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ef828-104">Tous les membres publics et protégés de <see cref="T:System.Threading.Tasks.Parallel" /> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-104">All public and protected members of <see cref="T:System.Threading.Tasks.Parallel" /> are thread-safe and may be used concurrently from multiple threads.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="ef828-105">Parallélisme de données (bibliothèque parallèle de tâches)</span><span class="sxs-lookup"><span data-stu-id="ef828-105">Data Parallelism (Task Parallel Library)</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="ef828-106">Exemples de programmation parallèle avec .NET Framework</span><span class="sxs-lookup"><span data-stu-id="ef828-106">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ef828-107">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle des itérations peuvent s'exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-107">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-108">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-108">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-109">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-109">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-110">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-110">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-111">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-111">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-112">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-112">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-113">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-113">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-114">Il est fourni avec deux arguments :</span><span class="sxs-lookup"><span data-stu-id="ef828-114">It is provided with two arguments:</span></span>  
  
-   <span data-ttu-id="ef828-115">Un <xref:System.Int32> valeur qui représente le nombre d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-115">An <xref:System.Int32> value that represents the iteration count.</span></span>  
  
-   <span data-ttu-id="ef828-116">Un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisé pour quitter la boucle prématurément.</span><span class="sxs-lookup"><span data-stu-id="ef828-116">A <xref:System.Threading.Tasks.ParallelLoopState> instance that can be used to break out of the loop prematurely.</span></span> <span data-ttu-id="ef828-117">Le <xref:System.Threading.Tasks.ParallelLoopState> objet est créé par le compilateur ; elle ne peut pas être instanciée dans le code utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef828-117">The <xref:System.Threading.Tasks.ParallelLoopState> object is created by the compiler; it cannot be instantiated in user code.</span></span>  
  
 <span data-ttu-id="ef828-118">Appelant le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> méthode informe le `for` opération itérations après celle en cours n’êtes pas obligé d’exécuter.</span><span class="sxs-lookup"><span data-stu-id="ef828-118">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to execute.</span></span> <span data-ttu-id="ef828-119">Toutefois, toutes les itérations avant actuel une sera toujours doivent être exécutées si elles ne sont déjà fait.</span><span class="sxs-lookup"><span data-stu-id="ef828-119">However, all iterations before the current one will still have to be executed if they haven't already.</span></span>  
  
 <span data-ttu-id="ef828-120">Par conséquent, l’appel <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> est similaire à l’utilisation d’une opération d’arrêt dans un conventionnel `for` boucle dans un langage comme C#, mais il n’est pas un substitut parfait : Par exemple, il n’est aucune garantie que les itérations une fois que l’objet actuel ne s’exécuteront pas.</span><span class="sxs-lookup"><span data-stu-id="ef828-120">Therefore, calling <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="ef828-121">Si l’exécution de toutes les itérations avant que l’objet actuel n’est pas nécessaire, utilisez le <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> méthode au lieu d’utiliser <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="ef828-121">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="ef828-122">Appel <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informe le `for` boucle qu’elle peut abandonner tous les autres itérations, qu’ils soient avant ou après l’itération actuelle, car tous les requis travail auront déjà été complétée.</span><span class="sxs-lookup"><span data-stu-id="ef828-122">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="ef828-123">Toutefois, comme avec <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, il n’existe aucune garantie concernant les autres itérations seront exécutera pas.</span><span class="sxs-lookup"><span data-stu-id="ef828-123">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="ef828-124">Si une boucle se termine prématurément, le <xref:System.Threading.Tasks.ParallelLoopResult> structure retournée contient les informations pertinentes sur l’achèvement de la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-124">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="ef828-125">Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-125">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-126">L’exemple suivant exécute jusqu'à 100 itérations d’une boucle en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-126">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="ef828-127">Chaque itération s’interrompt pendant un intervalle aléatoire compris entre 1 et 1 000 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="ef828-127">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="ef828-128">Une valeur générée de manière aléatoire détermine sur quelle itération de la boucle la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="ef828-128">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="ef828-129">Comme la sortie de l’exemple, aucune itération dont l’index est supérieur à la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> début de valeur de propriété après l’appel à la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ef828-129">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="ef828-130">Étant donné que les itérations de la boucle sont encore susceptibles d’être l’exécution lorsque le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> méthode est appelée, les appels de chaque itération le <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> propriété pour vérifier si une autre itération a appelé le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="ef828-130">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ef828-131">Si la valeur de propriété est `true`, l’itération vérifie la valeur de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> propriété et, si elle est supérieure à la valeur d’index de l’itération actuelle, retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ef828-131">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-132">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-132">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-133">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-133">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-134">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-134">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-135">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-135">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-136">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-136">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-137">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-137">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-138">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle des itérations peuvent s'exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-138">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ef828-139">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-139">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-140">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-140">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-141">Il est fourni avec le nombre d’itérations (<xref:System.Int32>) en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="ef828-141">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="ef828-142">Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-142">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-143">L’exemple suivant utilise la <xref:System.Threading.Tasks.Parallel.For%2A> méthode 100 appels d’un délégué qui génère des octets aléatoires de valeurs et calcule leur somme.</span><span class="sxs-lookup"><span data-stu-id="ef828-143">The following example uses the <xref:System.Threading.Tasks.Parallel.For%2A> method for 100 invocations of a delegate that generates random byte values and computes their sum.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-144">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-144">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-145">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-145">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-146">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-146">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-147">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-147">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-148">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-148">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-149">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-149">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-150">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-150">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-151">Structure <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> qui contient des informations indiquant quelle partie de la boucle est terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-151">A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure that contains information on what portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-152">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-152">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-153">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>) et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.</span><span class="sxs-lookup"><span data-stu-id="ef828-153">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="ef828-154">Appelant le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> méthode informe le `for` opération itérations après celle en cours n’êtes pas obligé d’être exécutées, mais toutes les itérations avant celui en cours.</span><span class="sxs-lookup"><span data-stu-id="ef828-154">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to be executed, but all iterations before the current one do.</span></span>  
  
 <span data-ttu-id="ef828-155">Par conséquent, l’appel de Break est semblable à l’utilisation d’une opération d’arrêt dans un conventionnel `for` boucle dans un langage comme C#, mais il n’est pas un substitut parfait : Par exemple, il n’est aucune garantie que les itérations une fois que l’objet actuel ne s’exécuteront pas.</span><span class="sxs-lookup"><span data-stu-id="ef828-155">Therefore, calling Break is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="ef828-156">Si l’exécution de toutes les itérations avant que l’objet actuel n’est pas nécessaire, utilisez le <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> méthode au lieu d’utiliser <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="ef828-156">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="ef828-157">Appel <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informe le `for` boucle qu’elle peut abandonner tous les autres itérations, qu’ils soient avant ou après l’itération actuelle, car tous les requis travail auront déjà été complétée.</span><span class="sxs-lookup"><span data-stu-id="ef828-157">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="ef828-158">Toutefois, comme avec <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, il n’existe aucune garantie concernant les autres itérations seront exécutera pas.</span><span class="sxs-lookup"><span data-stu-id="ef828-158">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="ef828-159">Si une boucle se termine prématurément, le <xref:System.Threading.Tasks.ParallelLoopResult> structure retournée contient les informations pertinentes sur l’achèvement de la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-159">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="ef828-160">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-160">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-161">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-161">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-162">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-162">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-163">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-163">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-164">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-164">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-165">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-165">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-166">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-166">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-167">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s'exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-167">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ef828-168">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-168">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-169">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-169">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-170">Il est fourni avec le nombre d’itérations (<xref:System.Int64>) en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="ef828-170">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="ef828-171">Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-171">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-172">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-172">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-173">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-173">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-174">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-174">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-175">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-175">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-176">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-176">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-177">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-177">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-178">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-178">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-179">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-179">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-180">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-180">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-181">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-181">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-182">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int32>) et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.</span><span class="sxs-lookup"><span data-stu-id="ef828-182">It is provided with the following parameters: the iteration count (<xref:System.Int32>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="ef828-183">Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-183">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-184"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-184">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-185">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-185">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-186">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-186">-or-</span></span> 
<span data-ttu-id="ef828-187">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-187">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-188">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-188">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-189">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-189">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-190">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-190">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-191">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-191">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-192">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-192">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-193">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-193">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-194">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-194">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-195">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle et les options de la boucle peuvent être configurées.</span><span class="sxs-lookup"><span data-stu-id="ef828-195">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ef828-196">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-196">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-197">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-197">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-198">Il est fourni avec le nombre d’itérations (<xref:System.Int32>) en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="ef828-198">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="ef828-199">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-199">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-200">L’exemple suivant montre comment annuler une boucle parallèle :</span><span class="sxs-lookup"><span data-stu-id="ef828-200">The following example shows how to cancel a parallel loop:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-201"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-201">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-202">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-202">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-203">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-203">-or-</span></span> 
<span data-ttu-id="ef828-204">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-204">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-205">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-205">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-206">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-206">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-207">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-207">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-208">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-208">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-209">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-209">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-210">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-210">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-211">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-211">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-212">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-212">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic)  loop with 64-bit indexes in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-213">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-213">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-214">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-214">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-215">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>) et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.</span><span class="sxs-lookup"><span data-stu-id="ef828-215">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="ef828-216">Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-216">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-217">L’exemple suivant montre comment utiliser le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode avec un <xref:System.Threading.Tasks.ParallelOptions> objet :</span><span class="sxs-lookup"><span data-stu-id="ef828-217">The following example shows how to use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method with a <xref:System.Threading.Tasks.ParallelOptions> object:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-218"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-218">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-219">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-219">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-220">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-220">-or-</span></span> 
<span data-ttu-id="ef828-221">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-221">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-222">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-222">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-223">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-223">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-224">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-224">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="ef828-225">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-225">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-226">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-226">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-227">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-227">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-228">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-228">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-229">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s’exécuter en parallèle et les options de la boucle peuvent être configurées.</span><span class="sxs-lookup"><span data-stu-id="ef828-229">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ef828-230">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-230">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-231">Prend en charge des index 64 bits.</span><span class="sxs-lookup"><span data-stu-id="ef828-231">Supports 64-bit indexes.</span></span> <span data-ttu-id="ef828-232">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-232">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-233">Il est fourni avec le nombre d’itérations (<xref:System.Int64>) en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="ef828-233">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="ef828-234">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-234">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-235">L’exemple suivant montre comment utiliser <xref:System.Threading.Tasks.ParallelOptions> pour spécifier un planificateur de tâches personnalisé :</span><span class="sxs-lookup"><span data-stu-id="ef828-235">The following example shows how to use <xref:System.Threading.Tasks.ParallelOptions> to specify a custom task scheduler:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-236"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-236">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-237">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-237">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-238">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-238">-or-</span></span> 
<span data-ttu-id="ef828-239">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-239">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-240">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-240">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-241">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-241">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-242">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-242">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ef828-243">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-243">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ef828-244">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-244">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-245">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-245">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-246">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-246">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-247">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-247">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-248">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-248">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-249">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-249">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-250">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-250">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-251">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-251">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-252">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-252">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ef828-253">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-253">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-254">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-254">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-255">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-255">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-256">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-256">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-257">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-257">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-258">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-258">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-259">Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-259">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-260">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-260">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ef828-261">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-261">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="ef828-262">Pour obtenir un exemple qui utilise cette méthode, consultez [Comment : Écrire une boucle Parallel.For avec des Variables locales de Thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-262">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-263">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-263">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-264">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-264">-or-</span></span> 
<span data-ttu-id="ef828-265">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-265">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-266">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-266">-or-</span></span> 
<span data-ttu-id="ef828-267">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-267">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-268">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-268">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-269">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-269">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ef828-270">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-270">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ef828-271">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-271">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-272">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-272">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-273">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-273">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-274">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-274">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-275">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-275">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-276">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits et des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-276">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic)  loop with 64-bit indexes and thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-277">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-277">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-278">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-278">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-279">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur la même tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-279">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="ef828-280">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-280">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-281">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-281">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-282">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-282">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-283">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-283">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-284">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-284">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-285">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-285">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-286">Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-286">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-287">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-287">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ef828-288">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-288">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="ef828-289">Pour obtenir un exemple qui utilise cette méthode, consultez [Comment : Écrire une boucle Parallel.For avec des Variables locales de Thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-289">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-290">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-290">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-291">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-291">-or-</span></span> 
<span data-ttu-id="ef828-292">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-292">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-293">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-293">-or-</span></span> 
<span data-ttu-id="ef828-294">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-294">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-295">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-295">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-296">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-296">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ef828-297">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-297">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ef828-298">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-298">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-299">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-299">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-300">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-300">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-301">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-301">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-302">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-302">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-303">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-303">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-304">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-304">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic)  loop with thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-305">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-305">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-306">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-306">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-307">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur la même tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-307">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="ef828-308">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-308">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-309">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-309">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-310">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-310">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-311">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-311">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-312">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-312">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-313">Ce délégué peut être appelé simultanément sur plusieurs threads ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-313">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-314">Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-314">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-315">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-315">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ef828-316">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-316">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-317">L’exemple suivant utilise des variables locales de thread pour calculer la somme des résultats de nombreuses opérations de longue durée.</span><span class="sxs-lookup"><span data-stu-id="ef828-317">The following example uses thread-local variables to compute the sum of the results of many lengthy operations.</span></span> <span data-ttu-id="ef828-318">Cet exemple limite le degré de parallélisme à quatre.</span><span class="sxs-lookup"><span data-stu-id="ef828-318">This example limits the degree of parallelism to four.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-319">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-319">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-320">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-320">-or-</span></span> 
<span data-ttu-id="ef828-321">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-321">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-322">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-322">-or-</span></span> 
<span data-ttu-id="ef828-323">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-323">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-324">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-324">-or-</span></span> 
<span data-ttu-id="ef828-325">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-325">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-326"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-326">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-327">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-327">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-328">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-328">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-329">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-329">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="ef828-330">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-330">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="ef828-331">Index de début, inclus.</span><span class="sxs-lookup"><span data-stu-id="ef828-331">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="ef828-332">Index de fin, exclusif.</span><span class="sxs-lookup"><span data-stu-id="ef828-332">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-333">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-333">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-334">Délégué de fonction qui retourne l'état initial des données locales pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-334">The function delegate that returns the initial state of the local data for each thread.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-335">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-335">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-336">Délégué qui exécute une dernière action sur l'état local de chaque thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-336">The delegate that performs a final action on the local state of each thread.</span></span></param>
        <summary><span data-ttu-id="ef828-337">Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits et des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-337">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes and thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-338">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-338">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-339">Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="ef828-339">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="ef828-340">Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-340">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ef828-341">Le `localInit` délégué est appelé une fois pour chaque thread qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-341">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those threads.</span></span> <span data-ttu-id="ef828-342">Ces états initiaux sont passés à la première `body` appels sur chaque thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-342">These initial states are passed to the first `body` invocations on each thread.</span></span> <span data-ttu-id="ef828-343">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-343">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-344">Enfin, le dernier appel du corps sur chaque thread renvoie une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-344">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-345">Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-345">The `localFinally` delegate is invoked once per thread to perform a final action on each thread's local state.</span></span> <span data-ttu-id="ef828-346">Ce délégué peut être appelé simultanément sur plusieurs threads ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-346">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-347">Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-347">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-348">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-348">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="ef828-349">Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.</span><span class="sxs-lookup"><span data-stu-id="ef828-349">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-350">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-350">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-351">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-351">-or-</span></span> 
<span data-ttu-id="ef828-352">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-352">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-353">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-353">-or-</span></span> 
<span data-ttu-id="ef828-354">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-354">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-355">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-355">-or-</span></span> 
<span data-ttu-id="ef828-356">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-356">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-357"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-357">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-358">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-358">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-359">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-359">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-360">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-360">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ef828-361">Exécute une opération <see langword="foreach" /> (<see langword="For Each " /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-361">Executes a <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) operation in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-362">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-362">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-363">Partitionneur classable qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-363">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-364">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-364">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-365">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-365">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-366">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-366">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-367">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-367">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-368">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-368">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-369">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-369">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-370">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-370">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-371">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-371">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-372">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-372">-or-</span></span> 
<span data-ttu-id="ef828-373">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-373">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-374">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans le partitionneur classable <paramref name="source" /> retourne la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-374">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-375">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-375">-or-</span></span> 
<span data-ttu-id="ef828-376">La propriété <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> dans le partitionneur classable de source retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-376">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the source orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-377">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-377">-or-</span></span> 
<span data-ttu-id="ef828-378">Toutes les méthodes dans le partitionneur classable source retournent <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-378">Any methods in the source orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-379">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-379">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-380">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-380">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-381">Partitionneur qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-381">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-382">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-382">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-383">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-383">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-384">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-384">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-385">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-385">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-386">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-386">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-387">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-387">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-388">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-388">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-389">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-389">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-390">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-390">-or-</span></span> 
<span data-ttu-id="ef828-391">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-391">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-392">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-392">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-393">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-393">-or-</span></span> 
<span data-ttu-id="ef828-394">Une méthode du partitioneur <paramref name="source" /> retourne <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-394">A method in the <paramref name="source" /> partitioner returns <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-395">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-395">-or-</span></span> 
<span data-ttu-id="ef828-396">La méthode <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> dans le <paramref name="source" /> ne retourne pas le nombre correct de partitions.</span><span class="sxs-lookup"><span data-stu-id="ef828-396">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-397">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-397">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-398">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-398">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-399">Partitionneur qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-399">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-400">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-400">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-401">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-401">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ef828-402">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-402">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-403">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-403">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-404">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-404">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-405">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-405">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-406">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-406">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-407">L’exemple suivant montre comment implémenter un partitionneur de plage pour une utilisation avec <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="ef828-407">The following example shows how to implement a range partitioner for use with <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-408">L’argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-408">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-409">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-409">-or-</span></span> 
<span data-ttu-id="ef828-410">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-410">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-411">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-411">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-412">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-412">-or-</span></span> 
<span data-ttu-id="ef828-413">Exception levée lorsque toutes les méthodes dans le partitionneur <paramref name="source" /> retournent la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-413">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-414">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-414">-or-</span></span> 
<span data-ttu-id="ef828-415">La méthode <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> dans le <paramref name="source" /> ne retourne pas le nombre correct de partitions.</span><span class="sxs-lookup"><span data-stu-id="ef828-415">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-416">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-416">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-417">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-417">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-418">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-418">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-419">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-419">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-420">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des index 64 bits sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-420">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-421">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-421">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-422">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-422">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-423">Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et l’index de l’élément actuel (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="ef828-423">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-424">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-424">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-425">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-425">-or-</span></span> 
<span data-ttu-id="ef828-426">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-426">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-427">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-427">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-428">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-428">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-429">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-429">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-430">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-430">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-431">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-431">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-432">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-432">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-433">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-433">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-434">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-434">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-435">Il est fourni avec les paramètres suivants : l’élément actuel et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.</span><span class="sxs-lookup"><span data-stu-id="ef828-435">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-436">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-436">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-437">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-437">-or-</span></span> 
<span data-ttu-id="ef828-438">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-438">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-439">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-439">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-440">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-440">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-441">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-441">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-442">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-442">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-443">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-443">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-444">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-444">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="ef828-445">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-445">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-446">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-446">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-447">Il est fourni avec l’élément actuel en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="ef828-447">It is provided with the current element as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-448">L’exemple suivant utilise la <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> méthode pour compter le nombre de caractères d’autre qu’un espace blanc dans un fichier texte et des voyelles.</span><span class="sxs-lookup"><span data-stu-id="ef828-448">The following example uses the <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> method to count the number of vowels and non-white-space characters in a text file.</span></span> <span data-ttu-id="ef828-449">Dans ce cas, le <xref:System.Threading.Tasks.ParallelLoopResult> valeur retournée par la méthode est ignoré.</span><span class="sxs-lookup"><span data-stu-id="ef828-449">In this case, the <xref:System.Threading.Tasks.ParallelLoopResult> value returned by the method is ignored.</span></span> <span data-ttu-id="ef828-450">Notez que, étant donné que les opérations peuvent s’exécuter en parallèle, vous devez vous assurer que l’incrémentation les variables de compteur est une opération atomique, et que plusieurs threads n’essayez pas à accéder aux variables compteur simultanément.</span><span class="sxs-lookup"><span data-stu-id="ef828-450">Note that, because operations can run in parallel, you must ensure that incrementing the counter variables is an atomic operation, and that multiple threads do not attempt to access the counter variables simultaneously.</span></span> <span data-ttu-id="ef828-451">Pour cela, l’exemple utilise le `lock` instruction (c#) et la `SyncLock` instruction (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ef828-451">For this purpose, the example uses the `lock` statement (in C#) and the `SyncLock` statement (in Visual Basic).</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-452">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-452">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-453">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-453">-or-</span></span> 
<span data-ttu-id="ef828-454">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-454">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-455">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-455">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-456">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-456">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-457">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-457">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-458">Partitionneur classable qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-458">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-459">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-459">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-460">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-460">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-461">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-461">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-462">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-462">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-463">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-463">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-464">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-464">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-465">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-465">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-466">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-466">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-467"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</span><span class="sxs-lookup"><span data-stu-id="ef828-467">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-468">L’argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-468">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-469">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-469">-or-</span></span> 
<span data-ttu-id="ef828-470">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-470">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-471">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-471">-or-</span></span> 
<span data-ttu-id="ef828-472">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-472">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-473">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-473">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-474">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans le partitionneur classable <paramref name="source" /> retourne la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-474">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-475">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-475">-or-</span></span> 
<span data-ttu-id="ef828-476">La propriété <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> dans le partitionneur classable <paramref name="source" /> retourne la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-476">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-477">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-477">-or-</span></span> 
<span data-ttu-id="ef828-478">L'exception levée lorsque toute méthode dans l'OrderablePartitioner <paramref name="source" /> retourne une valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-478">The exception that is thrown when any methods in the <paramref name="source" /> orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-479">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-479">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-480">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-480">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-481">Partitionneur qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-481">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-482">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-482">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-483">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-483">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-484">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-484">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-485">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-485">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-486">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-486">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-487">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-487">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-488">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-488">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-489">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-489">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-490"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-490">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-491">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-491">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-492">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-492">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-493">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-493">-or-</span></span> 
<span data-ttu-id="ef828-494">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-494">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-495">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-495">-or-</span></span> 
<span data-ttu-id="ef828-496">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-496">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-497">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-497">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-498">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-498">-or-</span></span> 
<span data-ttu-id="ef828-499">Exception levée lorsque toutes les méthodes dans le partitionneur <paramref name="source" /> retournent la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-499">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-500">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-500">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-501">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-501">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-502">Partitionneur qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-502">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-503">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-503">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-504">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-504">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-505">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle et les options de la boucle peuvent être configurées.</span><span class="sxs-lookup"><span data-stu-id="ef828-505">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ef828-506">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-506">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-507">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-507">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-508">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-508">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-509">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-509">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-510">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-510">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-511"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-511">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-512">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-512">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-513">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-513">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-514">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-514">-or-</span></span> 
<span data-ttu-id="ef828-515">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-515">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-516">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-516">-or-</span></span> 
<span data-ttu-id="ef828-517">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-517">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-518">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-518">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="ef828-519">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-519">-or-</span></span> 
<span data-ttu-id="ef828-520">Exception levée lorsque toutes les méthodes dans le partitionneur <paramref name="source" /> retournent la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-520">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-521">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-521">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-522">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-522">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-523">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-523">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-524">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-524">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-525">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-525">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-526">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des index 64 bits sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-526">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-527">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-527">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-528">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-528">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-529">Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et l’index de l’élément actuel (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="ef828-529">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-530"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</span><span class="sxs-lookup"><span data-stu-id="ef828-530">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-531">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-531">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-532">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-532">-or-</span></span> 
<span data-ttu-id="ef828-533">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-533">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-534">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-534">-or-</span></span> 
<span data-ttu-id="ef828-535">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-535">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-536">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-536">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-537">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-537">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-538">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-538">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-539">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-539">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-540">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-540">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-541">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-541">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-542">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-542">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-543">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-543">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-544">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-544">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-545">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-545">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-546">Il est fourni avec les paramètres suivants : l’élément actuel et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.</span><span class="sxs-lookup"><span data-stu-id="ef828-546">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-547"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</span><span class="sxs-lookup"><span data-stu-id="ef828-547">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-548">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-548">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-549">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-549">-or-</span></span> 
<span data-ttu-id="ef828-550">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-550">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-551">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-551">-or-</span></span> 
<span data-ttu-id="ef828-552">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-552">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-553">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-553">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-554">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-554">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-555">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-555">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-556">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-556">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-557">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-557">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-558">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-558">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-559">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-559">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="ef828-560">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et les options de la boucle peuvent être configurées.</span><span class="sxs-lookup"><span data-stu-id="ef828-560">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="ef828-561">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-561">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-562">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-562">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-563">Il est fourni avec l’élément actuel en tant que paramètre.</span><span class="sxs-lookup"><span data-stu-id="ef828-563">It is provided with the current element as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-564"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</span><span class="sxs-lookup"><span data-stu-id="ef828-564">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-565">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-565">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-566">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-566">-or-</span></span> 
<span data-ttu-id="ef828-567">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-567">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-568">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-568">-or-</span></span> 
<span data-ttu-id="ef828-569">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-569">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-570">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-570">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-571">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-571">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-572">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-572">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-573">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-573">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-574">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-574">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-575">Partitionneur classable qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-575">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-576">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-576">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-577">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-577">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-578">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-578">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-579">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-579">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-580">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-580">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-581">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-581">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-582">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-582">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-583">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-583">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-584">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-584">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ef828-585">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-585">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-586">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-586">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-587">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-587">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-588">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-588">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-589">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-589">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-590">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-590">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-591">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-591">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-592">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-592">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-593">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-593">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-594">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-594">-or-</span></span> 
<span data-ttu-id="ef828-595">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-595">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-596">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-596">-or-</span></span> 
<span data-ttu-id="ef828-597">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-597">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-598">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-598">-or-</span></span> 
<span data-ttu-id="ef828-599">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-599">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-600">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-600">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-601">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-601">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-602">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-602">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-603">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-603">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-604">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-604">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-605">Partitionneur qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-605">The partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-606">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-606">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-607">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-607">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-608">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-608">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-609">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-609">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-610">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-610">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-611">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-611">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-612">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-612">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-613">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-613">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-614">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-614">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ef828-615">Le `localInit` délégué est appelé une fois pour chaque thread qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-615">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-616">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-616">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-617">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-617">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-618">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-618">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-619">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-619">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-620">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-620">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-621">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-621">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-622">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-622">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-623">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-623">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-624">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-624">-or-</span></span> 
<span data-ttu-id="ef828-625">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-625">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-626">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-626">-or-</span></span> 
<span data-ttu-id="ef828-627">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-627">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-628">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-628">-or-</span></span> 
<span data-ttu-id="ef828-629">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-629">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-630">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-630">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-631">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-631">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-632">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-632">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-633">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-633">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-634">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-634">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-635">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-635">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-636">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-636">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-637">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-637">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-638">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-638">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-639">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-639">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-640">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-640">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-641">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-641">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-642">Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément, les index de l’élément actuel (<xref:System.Int64>) et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-642">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ef828-643">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-643">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-644">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-644">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-645">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-645">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-646">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-646">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-647">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-647">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-648">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-648">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-649">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-649">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-650">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-650">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-651">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-651">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-652">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-652">-or-</span></span> 
<span data-ttu-id="ef828-653">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-653">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-654">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-654">-or-</span></span> 
<span data-ttu-id="ef828-655">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-655">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-656">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-656">-or-</span></span> 
<span data-ttu-id="ef828-657">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-657">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-658">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-658">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-659">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-659">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-660">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-660">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-661">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-661">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-662">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-662">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-663">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-663">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-664">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-664">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-665">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-665">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-666">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-666">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-667">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-667">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-668">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-668">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-669">Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-669">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ef828-670">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-670">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-671">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-671">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-672">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-672">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-673">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-673">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-674">Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-674">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-675">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-675">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-676">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-676">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-677">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-677">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-678">L’exemple suivant montre comment utiliser un <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode avec l’état local :</span><span class="sxs-lookup"><span data-stu-id="ef828-678">The following example shows how to use a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method with local state:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-679">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-679">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-680">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-680">-or-</span></span> 
<span data-ttu-id="ef828-681">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-681">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-682">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-682">-or-</span></span> 
<span data-ttu-id="ef828-683">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-683">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-684">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-684">-or-</span></span> 
<span data-ttu-id="ef828-685">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-685">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-686">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-686">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-687">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-687">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-688">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-688">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-689">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-689">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-690">Partitionneur classable qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-690">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-691">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-691">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-692">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-692">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-693">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-693">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-694">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-694">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-695">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des index 64 bits et des données locales de thread sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-695">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes and  with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel , loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-696">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-696">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-697">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-697">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-698">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-698">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-699">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-699">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-700">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-700">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ef828-701">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-701">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-702">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-702">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-703">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-703">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-704">Enfin, le dernier appel du corps sur chaque thread renvoie une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-704">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-705">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-705">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-706">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-706">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-707">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-707">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-708">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-708">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-709">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-709">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-710">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-710">-or-</span></span> 
<span data-ttu-id="ef828-711">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-711">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-712">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-712">-or-</span></span> 
<span data-ttu-id="ef828-713">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-713">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-714">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-714">-or-</span></span> 
<span data-ttu-id="ef828-715">L'argument <paramref name="localInit" /> ou <paramref name="localFinally" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-715">The <paramref name="localInit" /> or <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-716">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-716">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-717">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-717">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-718"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-718">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-719">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-719">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-720">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-720">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-721">Type des éléments dans <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-721">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-722">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-722">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-723">Partitionneur qui contient la source de données d'origine.</span><span class="sxs-lookup"><span data-stu-id="ef828-723">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-724">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-724">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-725">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-725">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-726">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-726">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-727">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-727">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-728">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-728">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation  with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-729">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-729">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-730">Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement.</span><span class="sxs-lookup"><span data-stu-id="ef828-730">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="ef828-731">Par exemple, les petits corps de boucles tire parti du partitionnement de la plage.</span><span class="sxs-lookup"><span data-stu-id="ef828-731">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="ef828-732">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique.</span><span class="sxs-lookup"><span data-stu-id="ef828-732">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="ef828-733">Cette surcharge est fournie pour les scénarios avec les petits corps de boucles qui pourraient tirer profit de partitionnement par plage statique.</span><span class="sxs-lookup"><span data-stu-id="ef828-733">This overload is provided for scenarios with small loop bodies that might benefit from static range partitioning.</span></span> <span data-ttu-id="ef828-734">Partitionneurs doivent prendre en charge des partitions dynamiques.</span><span class="sxs-lookup"><span data-stu-id="ef828-734">Partitioners must support dynamic partitions.</span></span>  <span data-ttu-id="ef828-735">Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : Implémenter des Partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-735">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="ef828-736">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-736">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-737">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-737">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-738">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-738">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-739">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-739">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-740">Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-740">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-741">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-741">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-742">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-742">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-743">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-743">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-744">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-744">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-745">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-745">-or-</span></span> 
<span data-ttu-id="ef828-746">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-746">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-747">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-747">-or-</span></span> 
<span data-ttu-id="ef828-748">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-748">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-749">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-749">-or-</span></span> 
<span data-ttu-id="ef828-750">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-750">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-751">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-751">-or-</span></span> 
<span data-ttu-id="ef828-752">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-752">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ef828-753">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-753">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-754">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-754">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-755"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-755">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-756">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-756">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-757">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-757">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-758">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-758">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-759">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-759">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-760">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-760">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-761">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-761">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-762">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-762">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-763">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-763">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-764">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-764">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-765">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread et des index 64 bits sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-765">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data and 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-766">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-766">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-767">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-767">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-768">Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément, les index de l’élément actuel (<xref:System.Int64>) et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-768">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ef828-769">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-769">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-770">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-770">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-771">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-771">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-772">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-772">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-773">Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-773">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-774">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-774">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-775">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-775">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-776">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-776">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-777">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-777">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-778">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-778">-or-</span></span> 
<span data-ttu-id="ef828-779">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-779">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-780">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-780">-or-</span></span> 
<span data-ttu-id="ef828-781">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-781">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-782">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-782">-or-</span></span> 
<span data-ttu-id="ef828-783">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-783">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-784">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-784">-or-</span></span> 
<span data-ttu-id="ef828-785">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-785">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-786"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-786">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-787">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-787">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-788">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-788">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-789">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-789">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="ef828-790">Type des données contenues dans la source.</span><span class="sxs-lookup"><span data-stu-id="ef828-790">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="ef828-791">Type des données locales de thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-791">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="ef828-792">Source de données énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-792">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="ef828-793">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-793">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="ef828-794">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-794">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="ef828-795">Délégué appelé une fois par itération.</span><span class="sxs-lookup"><span data-stu-id="ef828-795">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="ef828-796">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-796">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="ef828-797">Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s’exécuter en parallèle, les options de la boucle peuvent être configurées et l’état de la boucle peut être surveillé et manipulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-797">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="ef828-798">Structure qui contient des informations sur la partie de la boucle terminée.</span><span class="sxs-lookup"><span data-stu-id="ef828-798">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-799">Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable.</span><span class="sxs-lookup"><span data-stu-id="ef828-799">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="ef828-800">Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="ef828-800">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="ef828-801">Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-801">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="ef828-802">Ces états initiaux sont passés à la première `body` appels sur chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-802">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="ef828-803">Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant.</span><span class="sxs-lookup"><span data-stu-id="ef828-803">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="ef828-804">Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer.</span><span class="sxs-lookup"><span data-stu-id="ef828-804">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="ef828-805">Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="ef828-805">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="ef828-806">Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.</span><span class="sxs-lookup"><span data-stu-id="ef828-806">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="ef828-807">Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches.</span><span class="sxs-lookup"><span data-stu-id="ef828-807">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="ef828-808">Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.</span><span class="sxs-lookup"><span data-stu-id="ef828-808">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-809">L'argument <paramref name="source" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-809">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-810">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-810">-or-</span></span> 
<span data-ttu-id="ef828-811">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-811">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-812">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-812">-or-</span></span> 
<span data-ttu-id="ef828-813">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-813">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-814">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-814">-or-</span></span> 
<span data-ttu-id="ef828-815">L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-815">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-816">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-816">-or-</span></span> 
<span data-ttu-id="ef828-817">L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-817">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-818"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</span><span class="sxs-lookup"><span data-stu-id="ef828-818">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-819">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-819">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-820">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="ef828-820">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="ef828-821">Boucles parallèles</span><span class="sxs-lookup"><span data-stu-id="ef828-821">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ef828-822">Exécute chacune des actions fournies, éventuellement en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-822">Executes each of the provided actions, possibly in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions"><span data-ttu-id="ef828-823">Tableau des <see cref="T:System.Action" /> à exécuter.</span><span class="sxs-lookup"><span data-stu-id="ef828-823">An array of <see cref="T:System.Action" /> to execute.</span></span></param>
        <summary><span data-ttu-id="ef828-824">Exécute chacune des actions fournies, éventuellement en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-824">Executes each of the provided actions, possibly in parallel.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-825">Cette méthode peut être utilisée pour exécuter un ensemble d’opérations, potentiellement en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-825">This method can be used to execute a set of operations, potentially in parallel.</span></span>  
  
 <span data-ttu-id="ef828-826">Aucune garantie n’est donnée sur l’ordre dans lequel les opérations s’exécutent, ou si elles s’exécutent en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-826">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="ef828-827">Cette méthode ne retourne pas jusqu'à ce que chacune des opérations fournies est terminée, indépendamment de si la saisie semi-automatique se produit en raison de l’arrêt normal ou exceptionnel.</span><span class="sxs-lookup"><span data-stu-id="ef828-827">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="ef828-828">Pour plus d’informations, consultez [Comment : utiliser parallel_invoke pour exécuter des opérations parallèles](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-828">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ef828-829">Cet exemple montre comment utiliser le <xref:System.Threading.Tasks.Parallel.Invoke%2A> méthode avec d’autres méthodes, les délégués anonymes et les expressions lambda.</span><span class="sxs-lookup"><span data-stu-id="ef828-829">This example demonstrates how to use the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method with other methods, anonymous delegates, and lambda expressions.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-830">L'argument <paramref name="actions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-830">The <paramref name="actions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-831">L'exception levée lorsque toute action dans le tableau <paramref name="actions" /> lève une exception.</span><span class="sxs-lookup"><span data-stu-id="ef828-831">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ef828-832">Le tableau <paramref name="actions" /> contient un élément <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-832">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions"><span data-ttu-id="ef828-833">Objet qui configure le comportement de cette opération.</span><span class="sxs-lookup"><span data-stu-id="ef828-833">An object that configures the behavior of this operation.</span></span></param>
        <param name="actions"><span data-ttu-id="ef828-834">Tableau des actions à exécuter.</span><span class="sxs-lookup"><span data-stu-id="ef828-834">An array of actions to execute.</span></span></param>
        <summary><span data-ttu-id="ef828-835">Exécute chacune des actions fournies, éventuellement en parallèle, sauf si l'opération est annulée par l'utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef828-835">Executes each of the provided actions, possibly in parallel, unless the operation is cancelled by the user.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ef828-836">Cette méthode peut être utilisée pour exécuter un ensemble d’opérations, potentiellement en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-836">This method can be used to execute a set of operations, potentially in parallel.</span></span> <span data-ttu-id="ef828-837">Le jeton d’annulation passé avec la <xref:System.Threading.Tasks.ParallelOptions> structure permet à l’appelant annuler l’opération entière.</span><span class="sxs-lookup"><span data-stu-id="ef828-837">The cancellation token passed in with the <xref:System.Threading.Tasks.ParallelOptions> structure enables the caller to cancel the entire operation.</span></span> <span data-ttu-id="ef828-838">Pour plus d’informations, consultez [Annulation dans les threads managés](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-838">For more information, see [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="ef828-839">Aucune garantie n’est donnée sur l’ordre dans lequel les opérations s’exécutent, ou si elles s’exécutent en parallèle.</span><span class="sxs-lookup"><span data-stu-id="ef828-839">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="ef828-840">Cette méthode ne retourne pas jusqu'à ce que chacune des opérations fournies est terminée, indépendamment de si la saisie semi-automatique se produit en raison de l’arrêt normal ou exceptionnel.</span><span class="sxs-lookup"><span data-stu-id="ef828-840">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="ef828-841">Pour plus d’informations, consultez [Comment : utiliser parallel_invoke pour exécuter des opérations parallèles](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="ef828-841">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="ef828-842">Objet <see cref="T:System.Threading.CancellationToken" /> dans <paramref name="parallelOptions" /> est défini.</span><span class="sxs-lookup"><span data-stu-id="ef828-842">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> is set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ef828-843">L'argument <paramref name="actions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-843">The <paramref name="actions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ef828-844">ou</span><span class="sxs-lookup"><span data-stu-id="ef828-844">-or-</span></span> 
<span data-ttu-id="ef828-845">L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-845">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="ef828-846">L'exception levée lorsque toute action dans le tableau <paramref name="actions" /> lève une exception.</span><span class="sxs-lookup"><span data-stu-id="ef828-846">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ef828-847">Le tableau <paramref name="actions" /> contient un élément <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ef828-847">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ef828-848">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="ef828-848">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>