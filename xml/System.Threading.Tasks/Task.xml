<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Task.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d920b17ab80db20fab0e3101b745858eade81dd1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d920b17ab80db20fab0e3101b745858eade81dd1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Represents an asynchronous operation.</source>
          <target state="translated">Représente une opération asynchrone.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class represents a single operation that does not return a value and that usually executes asynchronously.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> classe représente une opération unique qui ne retourne pas une valeur et qui généralement exécute de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects are one of the central components of the  <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> first introduced in the .NET Framework 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> les objets sont un des composants central de la <bpt id="p1">[</bpt>modèle asynchrone basé sur des tâches<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> introduite dans .NET Framework 4.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because the work performed by a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property, as well as the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> properties, to determine the   state of a task.</source>
          <target state="translated">Étant donné que le travail effectué par un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet généralement exécute de façon asynchrone sur un thread de pool de threads plutôt que de façon synchrone sur le thread d’application principal, vous pouvez utiliser la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriété, ainsi que le <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, et <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> propriétés, pour déterminer l’état d’une tâche.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Most commonly, a lambda expression is used to specify the work that the task is to perform.</source>
          <target state="translated">En règle générale, une expression lambda est utilisée pour spécifier le travail à effectuer la tâche.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For operations that return values, you use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class.</source>
          <target state="translated">Pour les opérations qui retournent des valeurs, vous utilisez la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In this section:</source>
          <target state="translated">Dans cette section :</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Task instantiation examples<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Exemples d’instanciation de tâche<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Creating and executing a task<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Création et exécution d’une tâche<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Separating task creation and execution<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Séparation de la création de tâches et de l’exécution<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Waiting for one or more tasks to complete<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>En attente d’une ou plusieurs tâches<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Tasks and culture<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Tâches et à la culture<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>For debugger developers<ept id="p1">](#Debugger)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Pour les développeurs de débogueur<ept id="p1">](#Debugger)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task instantiation</source>
          <target state="translated">Instanciation de la tâche</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates and executes four tasks.</source>
          <target state="translated">L’exemple suivant crée et exécute des quatre tâches.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Three tasks execute an <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate named <ph id="ph2">`action`</ph>, which accepts an argument of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Trois tâches exécutent un <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> délégué nommé <ph id="ph2">`action`</ph>, qui accepte un argument de type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A fourth task executes a lambda expression (an <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate) that is defined inline in the call to the task creation method.</source>
          <target state="translated">Une quatrième tâche exécute une expression lambda (un <ph id="ph1">&lt;xref:System.Action&gt;</ph> délégué) qui est définie en ligne dans l’appel à la méthode de création de tâche.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Each task is instantiated and run in a different way:</source>
          <target state="translated">Chaque tâche est instanciée et exécutée dans une autre façon :</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t1`</ph> is instantiated by calling a Task class constructor, but is started by calling its <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> method only after task <ph id="ph3">`t2`</ph> has started.</source>
          <target state="translated">Tâche <ph id="ph1">`t1`</ph> est instancié en appelant un constructeur de classe de tâche, mais est lancée en appelant son <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> méthode uniquement après la tâche <ph id="ph3">`t2`</ph> a démarré.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t2`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Tâche <ph id="ph1">`t2`</ph> est instanciée et démarrée dans un seul appel de méthode en appelant le <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t3`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">Tâche <ph id="ph1">`t3`</ph> est instanciée et démarrée dans un seul appel de méthode en appelant le <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t4`</ph> is executed synchronously on the main thread by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method.</source>
          <target state="translated">Tâche <ph id="ph1">`t4`</ph> est exécutée de façon synchrone sur le thread principal en appelant le <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because task <ph id="ph1">`t4`</ph> executes synchronously, it executes on the main application thread.</source>
          <target state="translated">Étant donné que tâche <ph id="ph1">`t4`</ph> exécute de façon synchrone, il s’exécute sur le thread d’application principal.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The remaining tasks execute asynchronously typically on one or more thread pool threads.</source>
          <target state="translated">Les tâches restantes exécutent de façon asynchrone en général sur un ou plusieurs threads de pool.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Creating and executing a task</source>
          <target state="translated">Création et exécution d’une tâche</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances may be created in a variety of ways.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances peuvent être créées de plusieurs façons.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The most common approach, which is available starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, is to call the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method.</source>
          <target state="translated">L’approche la plus courante, qui est disponible à partir de la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, consiste à appeler la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a simple way to start a task using default values and without requiring additional parameters.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> méthode offre un moyen simple pour démarrer une tâche à l’aide des valeurs par défaut et sans nécessiter des paramètres supplémentaires.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to start a task that loops and then displays the number of loop iterations:</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> méthode pour lancer une tâche qui effectue une boucle, puis affiche le nombre d’itérations de boucle :</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>An alternative, and the most common method to start a task in <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, is the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Une alternative et la méthode la plus courante pour démarrer une tâche dans <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, est la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> propriété retourne un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method let you specify parameters to pass to the task creation options and a task scheduler.</source>
          <target state="translated">Les surcharges de la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> méthode vous permettre de spécifier les paramètres à passer à un planificateur de tâches et les options de création de la tâche.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method to start a task.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> méthode pour lancer une tâche.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is functionally equivalent to the code in the previous example.</source>
          <target state="translated">Il est fonctionnellement équivalent au code dans l’exemple précédent.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more complete examples, see <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</source>
          <target state="translated">Pour obtenir des exemples plus complètes, consultez <bpt id="p1">[</bpt>basé sur des tâches de programmation asynchrone<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Separating task creation and execution</source>
          <target state="translated">Séparation de la création de tâches et de l’exécution</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class also provides constructors that initialize the task but that do not schedule it for execution.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> classe fournit également des constructeurs qui initialisent la tâche mais qui ne la planifient pas pour l’exécution.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For performance reasons, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> method to schedule the task for execution at a later time.</source>
          <target state="translated">Pour des raisons de performances, le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> (méthode) est le mécanisme recommandé pour la création et la planification des tâches de calculs, mais pour les scénarios où la création et la planification doivent être séparés, vous pouvez utiliser les constructeurs et appeler le <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> (méthode) pour planifier la tâche pour l’exécution à une date ultérieure.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Waiting for one or more tasks to complete</source>
          <target state="translated">En attente d’une ou plusieurs tâches</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</source>
          <target state="translated">Étant donné que les tâches généralement exécutent de façon asynchrone sur un thread de pool de threads, le thread qui crée et démarre la tâche continue l’exécution, dès que la tâche a été instanciée.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</source>
          <target state="translated">Dans certains cas, lorsque le thread appelant est le thread d’application principal, l’application peut se terminer avant la tâche réellement commence l’exécution.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</source>
          <target state="translated">Dans d’autres, la logique de votre application peut nécessiter que le thread appelant poursuivre l’exécution uniquement lorsqu’une ou plusieurs tâches a terminé son exécution.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a <ph id="ph1">`Wait`</ph> method to wait for one or more tasks to complete.</source>
          <target state="translated">Vous pouvez synchroniser l’exécution du thread appelant et asynchrone des tâches qu’il lance en appelant un <ph id="ph1">`Wait`</ph> méthode pour attendre une ou plusieurs tâches à effectuer.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>To wait for a single task to complete, you can call its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour attendre qu’une seule tâche se termine, vous pouvez appeler son <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A call to the  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method blocks the calling thread until the single class instance has completed execution.</source>
          <target state="translated">Un appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode bloque le thread appelant jusqu'à ce que l’instance de classe unique a terminé son exécution.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example calls the parameterless <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method to wait unconditionally until a task completes.</source>
          <target state="translated">L’exemple suivant appelle sans paramètre <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> méthode doit attendre de manière inconditionnelle jusqu'à ce qu’une tâche se termine.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The task simulates work by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to sleep for two seconds.</source>
          <target state="translated">La tâche simule le travail en appelant le <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> méthode en veille pendant deux secondes.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also conditionally wait for a task to complete.</source>
          <target state="translated">Vous pouvez également de manière conditionnelle attendre une tâche se termine.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> méthodes bloquent le thread appelant jusqu'à ce que la tâche se termine ou un intervalle de délai d’attente est écoulé, selon ce qui se produit en premier.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</source>
          <target state="translated">Étant donné que l’exemple suivant démarre une tâche qui se met en veille pendant deux secondes, mais définit une valeur de délai d’attente d’une seconde, le thread appelant se bloque jusqu'à ce que le délai d’attente expire et avant la tâche de fin de l’exécution.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also supply a cancellation token by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> and  <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> methods.</source>
          <target state="translated">Vous pouvez également fournir un jeton d’annulation en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>If the  token's <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, the wait is cancelled; if it becomes true while the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method terminates.</source>
          <target state="translated">Si du jeton <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> propriété est <ph id="ph2">`true`</ph>, l’attente est annulée ; si elle prend la valeur true lors de la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</source>
          <target state="translated">Dans certains cas, vous souhaiterez attendre pour la première d’une série de l’exécution de tâches à effectuer, mais ne soins de tâches qu’il est.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For this purpose, you can call one of the overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour cela, vous pouvez appeler une des surcharges de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</source>
          <target state="translated">L’exemple suivant crée trois tâches, chacune d’elles se met en veille pour un intervalle déterminent par un générateur de nombres aléatoires.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method waits for the first task to complete.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> méthode attend que la première tâche se termine.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The example then displays information about the status of all three tasks.</source>
          <target state="translated">L’exemple affiche ensuite des informations sur l’état de tous les trois tâches.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also wait for all of a series of tasks to complete by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez également attendre que tous d’une série de tâches à effectuer en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates ten tasks, waits for all ten to complete, and then displays their status.</source>
          <target state="translated">L’exemple suivant crée dix tâches, attend que toutes les dix se termine, puis affiche leur état.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the <ph id="ph1">`Wait`</ph> method, as the following example shows.</source>
          <target state="translated">Notez que lorsque vous attendez une ou plusieurs tâches à effectuer, toutes les exceptions levées dans les tâches en cours d’exécution sont propagées sur le thread qui appelle la <ph id="ph1">`Wait`</ph> méthode, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It launches 12 tasks, three of which complete normally and three of which throw an exception.</source>
          <target state="translated">Il lance des 12 tâches, dont trois se terminer normalement et trois des qui lève une exception.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</source>
          <target state="translated">Le reste des six tâches, trois sont annulés avant le début de trois sont annulées lors de leur exécution.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Exceptions are thrown in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method call and are handled by a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Les exceptions sont levées le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> appel de méthode et sont gérées par un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information on exception handling in task-based asynchronous operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions dans les opérations asynchrones basées sur des tâches, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Tasks and culture</source>
          <target state="translated">Tâches et à la culture</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Starting with desktop apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the thread that creates and invokes a task becomes part of the thread's context.</source>
          <target state="translated">Depuis les applications de bureau qui ciblent le <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, la culture du thread qui crée et appelle une tâche devient partie intégrante le contexte du thread.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</source>
          <target state="translated">Autrement dit, indépendamment de la culture actuelle du thread sur lequel la tâche s’exécute, la culture en cours de la tâche est la culture du thread appelant.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For apps that target versions of the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the task is the culture of the thread on which the task executes.</source>
          <target state="translated">Pour les applications qui ciblent des versions du .NET Framework antérieures à la <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, la culture de la tâche est la culture du thread sur lequel la tâche s’exécute.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information, see the "Culture and task-based asynchronous operations" section in the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Culture et opérations asynchrones basées sur une tâche » dans la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> rubrique.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Store apps follow the Windows Runtime in setting and getting the default culture.</source>
          <target state="translated">Suivez les applications du Windows Store Windows Runtime dans le paramètre et l’obtention de la culture par défaut.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For debugger developers</source>
          <target state="translated">Pour les développeurs de débogueur</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</source>
          <target state="translated">Pour les développeurs implémentent des débogueurs personnalisés, plusieurs membres internes et privés de tâche peuvent être utiles de (ils peuvent changer d’une version à l’autre).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_taskId`</ph> field serves as the backing store for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the <ph id="ph3">`s_taskIdCounter`</ph> counter is used to retrieve the next available ID for a task).</source>
          <target state="translated">Le <ph id="ph1">`m_taskId`</ph> champ sert de magasin de stockage pour le <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> propriété, toutefois l’accès à ce champ directement à partir d’un débogueur peut être plus efficace que l’accès à la même valeur via la méthode d’accesseur Get de la propriété (la <ph id="ph3">`s_taskIdCounter`</ph> compteur est permet de récupérer le prochain ID disponible pour une tâche).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Similarly, the <ph id="ph1">`m_stateFlags`</ph> field stores information about the current lifecycle stage of the task, information also accessible through the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">De même, la <ph id="ph1">`m_stateFlags`</ph> champ stocke des informations sur l’étape du cycle de vie actuelle de la tâche, informations également accessibles via la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_action`</ph> field stores a reference to the task's delegate, and the <ph id="ph2">`m_stateObject`</ph> field stores the async state passed to the task by the developer.</source>
          <target state="translated">Le <ph id="ph1">`m_action`</ph> champ stocke une référence au délégué de la tâche et le <ph id="ph2">`m_stateObject`</ph> champ stocke l’état asynchrone passé à la tâche par le développeur.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Finally, for debuggers that parse stack frames, the <ph id="ph1">`InternalWait`</ph> method serves a potential marker for when a task is entering a wait operation.</source>
          <target state="translated">Enfin, pour les débogueurs qui analysent des frames de pile, le <ph id="ph1">`InternalWait`</ph> méthode sert un marqueur potentiel pour une tâche entre quand une opération d’attente.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>All members of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, except for <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Tous les membres de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, à l’exception de <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Initialise un nouveau <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action.</source>
          <target state="translated">Initialise un nouveau <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action spécifiée.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to create tasks that retrieve the filenames in specified directories.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructeur pour créer des tâches qui récupèrent les noms de fichiers dans les répertoires spécifiés.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Toutes les tâches d’écrivent les noms de fichiers dans un seul <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">L’exemple appelle ensuite la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> pour s’assurer que toutes les tâches terminées et affiche le nombre total de noms de fichiers écrits dans le <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example is identical, except that it used the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to instantiate and run the task in a single operation.</source>
          <target state="translated">L’exemple suivant est identique, sauf qu’il a utilisé la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> méthode pour instancier et exécuter la tâche en une seule opération.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The method returns the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that represents the task.</source>
          <target state="translated">La méthode retourne la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet qui représente la tâche.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that the new  task will observe.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> que la nouvelle tâche observera.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</source>
          <target state="translated">Initialise un nouveau <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action spécifiée et <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Cancellation in Managed Threads<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>parallélisme des tâches (bibliothèque parallèle de tâches)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> et <bpt id="p2">[</bpt>l’annulation dans les Threads managés<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> constructeur pour créer une tâche qui parcourt les fichiers dans le répertoire C:\Windows\System32.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">L’expression lambda appelle la <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> méthode pour ajouter des informations sur chaque fichier à un <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chaque détachée tâche imbriquée appelée par le <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> boucle vérifie l’état du jeton d’annulation et, si l’annulation est demandée, appelle le <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception est gérée dans un <ph id="ph3">`catch`</ph> bloquer lorsque le thread appelant appelle la <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method is then called to start the task.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> méthode est alors appelée pour démarrer la tâche.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> utilisé pour personnaliser le comportement de la tâche.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          <target state="translated">Initialise une nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action et les options de création spécifiées.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objet représentant les données que l'action doit utiliser.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and state.</source>
          <target state="translated">Initialise un nouveau <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action et l'état spécifiés.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The following example defines an array of 6-letter words.</source>
          <target state="translated">L’exemple suivant définit un tableau de mots de la lettre de 6.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Each word is then passed as an argument to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> constructor, whose <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</source>
          <target state="translated">Chaque mot est ensuite passé comme argument à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> constructeur, dont <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> délégué brouille les caractères du mot, puis affiche le mot d’origine et sa version cryptée.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that the new task will observe.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que la nouvelle tâche observera.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> utilisé pour personnaliser le comportement de la tâche.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          <target state="translated">Initialise une nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action et les options de création spécifiées.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Task Cancellation<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>parallélisme des tâches (bibliothèque parallèle de tâches)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> et <bpt id="p2">[</bpt>l’annulation de tâche<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objet représentant les données que l'action doit utiliser.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que la nouvelle tâche observera.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">Initialise une nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action, l'état et les options spécifiés.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objet représentant les données que l'action doit utiliser.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> utilisé pour personnaliser le comportement de la tâche.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">Initialise une nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action, l'état et les options spécifiés.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Délégué qui représente le code à exécuter dans la tâche.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objet représentant les données que l'action doit utiliser.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe..</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que la nouvelle tâche observera.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> utilisé pour personnaliser le comportement de la tâche.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">Initialise une nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> avec l'action, l'état et les options spécifiés.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet et lancer une tâche est en appelant la méthode statique <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">Le seul avantage offert par ce constructeur est qu’il permet l’instanciation d’objet d’être séparé de l’invocation de la tâche.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="action" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Gets the state object supplied when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> was created, or null if none was supplied.</source>
          <target state="translated">Obtient l'objet d'état fourni quand la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été créée, ou null si aucune n'a été fournie.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that represents the state data that was passed in to the task when it was created.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> représentant les données d'état passées à la tâche lors de sa création.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Cast the object back to the original type to retrieve its data.</source>
          <target state="translated">Effectuer un cast de l’objet vers le type d’origine pour récupérer ses données.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Gets a task that has already completed successfully.</source>
          <target state="translated">Obtient une tâche qui s’est déjà terminée correctement.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>The successfully completed task.</source>
          <target state="translated">Tâche terminée avec succès.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>This property returns a task whose <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">Cette propriété retourne une tâche dont <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> est définie sur <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>To create task that returns a value and runs to completion, call the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method.</source>
          <target state="translated">Pour créer la tâche qui retourne une valeur et s’exécute jusqu'à son achèvement, appelez le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Repeated attempts to retrieve this property value may not always return the same instance.</source>
          <target state="translated">Des tentatives répétées pour récupérer la valeur de cette propriété ne retournent pas toujours la même instance.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to attempt to marshal the continuation back to the original context captured; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> en cas de tentative de marshaling de la continuation vers le contexte d'origine capturé ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>Configures an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Configure un élément awaiter utilisé pour attendre cette <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>An object used to await this task.</source>
          <target state="translated">Objet utilisé pour attendre cette tâche.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The following example defines a task that populates an array with 100 random date and time values.</source>
          <target state="translated">L’exemple suivant définit une tâche qui remplit un tableau avec 100 aléatoire valeurs de date et heure.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>It uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method to select the earliest and the latest date values once the array is fully populated.</source>
          <target state="translated">Elle utilise le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> méthode pour sélectionner plus tôt et les dernières valeurs de date, une fois que le tableau est entièrement rempli.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Because a console application may terminate before the continuation task executes, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method is called to ensure that the continuation finishes executing before the example ends.</source>
          <target state="translated">Car une application de console peut se fermer avant l’exécution de la tâche de continuation, la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> méthode est appelée pour vous assurer que la continuation termine l’exécution avant la fin de l’exemple.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>For an additional example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir un exemple supplémentaire, consultez <bpt id="p1">[</bpt>chaînage des tâches à l’aide de tâches de Continuation<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An action to run when the task completes.</source>
          <target state="translated">Action à exécuter quand la tâche se termine.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l’exécution, la tâche achevée et l’objet d’état fourni par l’appelant sont passés comme arguments au délégué.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objet représentant les données que l'action de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>A new continuation task.</source>
          <target state="translated">Nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou en cours de fermeture au début en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Creates a continuation that receives a cancellation token and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui reçoit un jeton d'annulation et s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé le jeton a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Action à exécuter selon le <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>spécifié.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes when the target task completes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">Crée une continuation qui s'exécute quand la tâche cible se termine conformément au <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères de continuation spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The following example demonstrates using <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> to specify that a continuation task should run synchronously when the antecedent task completes.</source>
          <target state="translated">L’exemple suivant montre comment utiliser <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> pour spécifier qu’une tâche de continuation doit s’exécuter simultanément lorsque la tâche antécédente est terminée.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>(If the specified task has already completed by the time <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> is called, the synchronous continuation will run on the thread calling <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</source>
          <target state="translated">(Si la tâche spécifiée a déjà été effectué par le temps <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> est appelée, synchrones s’exécute sur la thread appelant la méthode <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">La continuation utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objet représentant les données que l'action de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui reçoit des informations d'état fournies par l'appelant et un jeton d'annulation, et qui s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objet représentant les données que l'action de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation executes based on a set of specified conditions.</source>
          <target state="translated">La continuation s'exécute selon un ensemble de conditions spécifiées.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères de continuation spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objet représentant les données que l'action de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">La continuation utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Action à exécuter selon le <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>spécifié.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes when the target task competes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">Crée une continuation qui s'exécute quand la tâche cible se termine conformément au <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives a cancellation token and uses a specified scheduler.</source>
          <target state="translated">La continuation reçoit un jeton d'annulation et utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</source>
          <target state="translated">Voici un exemple d’utilisation de ContinueWith pour exécuter des travaux en arrière-plan et sur l’utilisateur threads d’interface.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé le jeton a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Action à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objet représentant les données que l'action de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui reçoit des informations d'état fournies par l'appelant et un jeton d'annulation, et qui s'exécute quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation executes based on a set of specified conditions and uses a specified scheduler.</source>
          <target state="translated">La continuation s'exécute selon un ensemble de conditions spécifiées et utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A new continuation task.</source>
          <target state="translated">Nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The following example shows how to use the ContinueWith method:</source>
          <target state="translated">L’exemple suivant montre comment utiliser la méthode ContinueWith :</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objet représentant les données que la fonction de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The continuation receives a cancellation token.</source>
          <target state="translated">La continuation reçoit un jeton d'annulation.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé le jeton a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run according to the condition specified in <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Fonction à exécuter selon la condition spécifiée dans <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute en fonction des options de continuation spécifiées et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères de continuation spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">La continuation utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objet représentant les données que la fonction de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The continuation receives caller-supplied state information and a cancellation token.</source>
          <target state="translated">La continuation reçoit des informations d'état fournies par l'appelant et un jeton d'annulation.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objet représentant les données que la fonction de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui s'exécute en fonction des options de continuation de tâche spécifiées quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation receives caller-supplied state information.</source>
          <target state="translated">La continuation reçoit des informations d'état fournies par l'appelant.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères de continuation spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objet représentant les données que la fonction de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crée une continuation qui s'exécute de façon asynchrone quand la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and uses a specified scheduler.</source>
          <target state="translated">La continuation reçoit des informations d'état fournies par l'appelant et utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de fonctionne correctement jusqu'à son achèvement, provoquer une erreur en raison d’une exception non gérée ou sortir tôt en raison de l’annulation.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions.<ept id="p1">&lt;/c&gt;</ept></source>
          <target state="translated">Fonction à exécuter selon le <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>spécifié.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute en fonction des options de continuation spécifiées et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation is passed a cancellation token and uses a specified scheduler.</source>
          <target state="translated">La continuation reçoit un jeton d'annulation et utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following example shows how to use the ContinueWith method with continuation options:</source>
          <target state="translated">L’exemple suivant montre comment utiliser la méthode ContinueWith avec les options de continuation :</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> qui a créé le jeton a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur null.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Type du résultat produit par la continuation.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Fonction à exécuter quand <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se termine.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objet représentant les données que la fonction de continuation doit utiliser.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> qui sera assigné à la nouvelle tâche de continuation.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Options applicables quand la continuation est planifiée et qui en régissent le comportement.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Cela inclut des critères, tels que <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, ainsi que des options d'exécution, telles que <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> à associer à la tâche de continuation et à utiliser pour son exécution.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crée une continuation qui s'exécute en fonction des options de continuation de tâche spécifiées quand le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cible se termine et retourne une valeur.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</source>
          <target state="translated">La continuation reçoit des informations d'état fournies par l'appelant et un jeton d'annulation et elle utilise un planificateur spécifié.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nouvelle <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuation.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si les critères spécifiés par le biais du <ph id="ph1">`continuationOptions`</ph> paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> spécifie une valeur non valide pour <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated">Obtient les <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> utilisées pour créer cette tâche.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> utilisées pour créer cette tâche.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Returns the ID of the currently executing <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Retourne l'ID de la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en cours d'exécution.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>An integer that was assigned by the system to the currently-executing task.</source>
          <target state="translated">Entier assigné par le système à la tâche en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> is a <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> est un <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) propriété qui est utilisée pour obtenir l’identificateur de la tâche en cours d’exécution à partir du code qui s’exécute la tâche.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>It differs from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, which returns the identifier of a particular <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instance.</source>
          <target state="translated">Il diffère de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> propriété, qui retourne l’identificateur d’un particulier <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>If you attempt to retrieve the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> value from outside the code that a task is executing, the property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si vous tentez de récupérer le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> comprise en dehors du code qui s’exécute une tâche, la propriété retourne <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Notez que bien que les collisions sont très rares, les identificateurs de tâche ne sont pas garantis être unique.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete after a time delay.</source>
          <target state="translated">Crée une tâche qui ne se termine qu’après un certain délai.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre avant la fin de la tâche retournée ou -1 pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Creates a task that completes after a time delay.</source>
          <target state="translated">Crée une tâche qui se termine après un certain délai.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Tâche qui représente le délai.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method is typically used to delay the operation of all or part of a task for a specified time interval.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> méthode est généralement utilisée pour retarder le fonctionnement de tous les ou une partie d’une tâche pour un intervalle de temps spécifié.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Most commonly, the time delay is introduced:</source>
          <target state="translated">En règle générale, le délai est introduit :</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>At the beginning of the task, as the following example shows.</source>
          <target state="translated">Au début de la tâche, comme l’exemple suivant montre.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Sometime while the task is executing.</source>
          <target state="translated">Alors que la tâche est en cours d’exécution.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes as a child task within a task, as the following example shows.</source>
          <target state="translated">Dans ce cas, l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> méthode exécute une tâche enfant au sein d’une tâche, comme le montre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Note that since the task that calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes asynchronously, the parent task must wait for it to complete by using the <ph id="ph2">`await`</ph> keyword.</source>
          <target state="translated">Notez que depuis la tâche qui appelle le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> méthode s’exécute de façon asynchrone, la tâche parente doit attendre qu’elle se termine à l’aide de la <ph id="ph2">`await`</ph> (mot clé).</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>After the specified time delay, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Après le délai spécifié, la tâche est terminée dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Cette méthode dépend de l’horloge système.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le <ph id="ph1">`millisecondsDelay`</ph> argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre une utilisation simple de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> est inférieur à -1.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          <target state="translated">Intervalle de temps à attendre avant la fin de la tâche retournée ou <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>Creates a task that completes after a specified time interval.</source>
          <target state="translated">Crée une tâche qui se termine après un intervalle de temps spécifié.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Tâche qui représente le délai.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>After the specified time delay, the task is completed in <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Après le délai spécifié, la tâche est terminée dans <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Pour les scénarios d’utilisation et des exemples supplémentaires, consultez la documentation pour le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Cette méthode dépend de l’horloge système.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le <ph id="ph1">`delay`</ph> argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre une utilisation simple de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> représente un intervalle de temps négatif autre que <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> de l’argument <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre avant la fin de la tâche retournée ou -1 pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          <target state="translated">Jeton d’annulation qui sera vérifié avant de terminer la tâche retournée.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a time delay.</source>
          <target state="translated">Crée une tâche pouvant être annulée qui se termine après un certain délai.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Tâche qui représente le délai.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si le jeton d’annulation est signalé avant le délai spécifié, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> résultats de l’exception et que la tâche est terminée dans le <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">Sinon, la tâche est terminée dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état une fois que le délai spécifié écoulé.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Pour les scénarios d’utilisation et des exemples supplémentaires, consultez la documentation pour le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Cette méthode dépend de l’horloge système.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le <ph id="ph1">`millisecondsDelay`</ph> argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one second delay.</source>
          <target state="translated">L’exemple suivant démarre une tâche qui inclut un appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode avec un délai d’une seconde.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">Avant que l’intervalle de délai s’écoule, le jeton est annulé.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">La sortie de l’exemple montre que, par conséquent, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> est levée et les tâches <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> est définie sur <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> est inférieur à -1.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          <target state="translated">Intervalle de temps à attendre avant la fin de la tâche retournée ou <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          <target state="translated">Jeton d’annulation qui sera vérifié avant de terminer la tâche retournée.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a specified time interval.</source>
          <target state="translated">Crée une tâche pouvant être annulée qui se termine après un intervalle de temps spécifié.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Tâche qui représente le délai.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si le jeton d’annulation est signalé avant le délai spécifié, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> résultats de l’exception et que la tâche est terminée dans le <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">Sinon, la tâche est terminée dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état une fois que le délai spécifié écoulé.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Pour les scénarios d’utilisation et des exemples supplémentaires, consultez la documentation pour le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Cette méthode dépend de l’horloge système.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le <ph id="ph1">`delay`</ph> argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one-and-a-half second delay.</source>
          <target state="translated">L’exemple suivant démarre une tâche qui inclut un appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode avec un délai de deuxième-et-a-moitié.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">Avant que l’intervalle de délai s’écoule, le jeton est annulé.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">La sortie de l’exemple montre que, par conséquent, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> est levée et les tâches <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> est définie sur <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</source>
          <target state="translated">Notez que cet exemple contient une condition d’engorgement potentiels : il dépend de la tâche exécute de façon asynchrone le délai d’attente lorsque le jeton est annulé.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Although the 1.5 second delay from the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method makes that assumption likely, it is nevertheless possible that the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method could return before the token is cancelled.</source>
          <target state="translated">Bien que la seconde 1,5 différer de l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode effectue cette hypothèse probable, il est néanmoins possible que l’appel à la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode pourrait retourner avant que le jeton est annulé.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>In that case, the example produces the following output:</source>
          <target state="translated">Dans ce cas, l’exemple génère la sortie suivante :</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> représente un intervalle de temps négatif autre que <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> de l’argument <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">Le <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> fourni a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> la classe implémente le <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> , car il utilise en interne des ressources qui implémentent également l’interface <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">Toutefois, en particulier si votre application cible le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> ou une version ultérieure, il n’est pas nécessaire d’appeler <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> , sauf si les performances ou le test de l’évolutivité indique que, en fonction de vos modèles d’utilisation, les performances de votre application sont améliorée en supprimant des tâches.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>ai-je besoin pour les supprimer de tâches ?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> dans le blog programmation parallèle avec .NET.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          <target state="translated">La tâche n’est pas dans un des états finaux : <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>A Boolean value that indicates whether this method is being called due to a call to <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>.</source>
          <target state="translated">Valeur booléenne qui indique si cette méthode est appelée en raison d'un appel à <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Disposes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, releasing all of its unmanaged resources.</source>
          <target state="translated">Supprime la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, en libérant toutes ses ressources non managées.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> la classe implémente le <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> , car il utilise en interne des ressources qui implémentent également l’interface <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">Toutefois, en particulier si votre application cible le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> ou une version ultérieure, il n’est pas nécessaire d’appeler <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> , sauf si les performances ou le test de l’évolutivité indique que, en fonction de vos modèles d’utilisation, les performances de votre application sont améliorée en supprimant des tâches.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>ai-je besoin pour les supprimer de tâches ?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> dans le blog programmation parallèle avec .NET.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          <target state="translated">La tâche n’est pas dans un des états finaux : <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph> ou <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Unlike most of the members of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class, this method is not thread-safe.</source>
          <target state="translated">Contrairement à la plupart des membres de la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> (classe), cette méthode n’est pas thread-safe.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated">Obtient le <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> qui a provoqué l'arrêt prématuré de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed successfully or has not yet thrown any exceptions, this will return <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée avec succès ou n'a pas encore levé d'exception, la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> est retournée.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>The <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> qui a provoqué la fin prématurée de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> or in accesses to the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Tâches qui lèvent des exceptions non gérées stockent l’exception résultante et la propagent encapsulé dans un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> dans les appels à <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> ou dans les accès à la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</source>
          <target state="translated">Les exceptions non observées au moment où que l’instance de tâche est le garbage collecté seront propagées sur le thread finaliseur.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Exception Handling (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations et obtenir un exemple, consultez <bpt id="p1">[</bpt>la gestion des exceptions (bibliothèque parallèle de tâches)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Provides access to factory methods for creating and configuring <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> instances.</source>
          <target state="translated">Fournit l'accès aux méthodes de fabrique pour la création d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> et de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>A factory object that can create a variety of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects.</source>
          <target state="translated">Objet de fabrique pouvant créer une variété d'objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> et <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>This property returns a default instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> class that is identical to the one created by calling the parameterless <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Cette propriété retourne une instance par défaut de la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> classe qui est identique à celui créé par l’appel sans paramètre <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It has the following property values:</source>
          <target state="translated">Elle comporte des valeurs de propriété suivantes :</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Value</source>
          <target state="translated">Value</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source><ph id="ph1">`null`</ph>, or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">`null`</ph>, ou <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The most common use of this property is to create and start a new task in a single call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’utilisation la plus courante de cette propriété consiste à créer et démarrer une nouvelle tâche dans un seul appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> method provides the easiest way to create a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object with default configuration values.</source>
          <target state="translated">En commençant par le <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, le <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> méthode fournit le moyen le plus simple pour créer un <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet avec les valeurs de configuration par défaut.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The following example uses the static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> property to make two calls to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant utilise la méthode statique <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> propriété afin que les deux appels à la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</source>
          <target state="translated">La première remplit un tableau avec les noms des fichiers dans le répertoire Mes documents de l’utilisateur, tandis que la seconde remplit un tableau avec les noms des sous-répertoires du répertoire Mes documents de l’utilisateur.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> (méthode), qui affiche des informations sur le nombre de fichiers et des répertoires dans les deux tableaux une fois les deux premières tâches effectuées à l’exécution.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          <target state="translated">Jeton d’annulation avec lequel terminer la tâche.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          <target state="translated">Crée une <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> qui s'est terminée en raison de l'annulation avec un jeton d'annulation spécifié.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          <target state="translated">Tâche annulée.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">L’annulation n’a pas été demandée pour <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> ; sa propriété <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> est <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Type du résultat retourné par la tâche.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          <target state="translated">Jeton d’annulation avec lequel terminer la tâche.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          <target state="translated">Crée une <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> qui s'est terminée en raison de l'annulation avec un jeton d'annulation spécifié.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          <target state="translated">Tâche annulée.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">L’annulation n’a pas été demandée pour <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> ; sa propriété <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> est <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The exception with which to complete the task.</source>
          <target state="translated">Exception avec laquelle terminer la tâche.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that has completed with a specified exception.</source>
          <target state="translated">Crée une <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> qui s'est terminée avec une exception spécifiée.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The faulted task.</source>
          <target state="translated">Tâche ayant échoué.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">Cette méthode crée un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> dont l’objet <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriété <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> et dont <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propriété contient <ph id="ph5">`exception`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">La méthode est généralement utilisée lorsque vous savez immédiatement que le travail qui exécute une tâche lève une exception avant l’exécution d’un chemin d’accès du code plus de temps.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> overload.</source>
          <target state="translated">Pour obtenir un exemple, consultez la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Type du résultat retourné par la tâche.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The exception with which to complete the task.</source>
          <target state="translated">Exception avec laquelle terminer la tâche.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed with a specified exception.</source>
          <target state="translated">Crée une <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> qui s'est terminée avec une exception spécifiée.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The faulted task.</source>
          <target state="translated">Tâche ayant échoué.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">Cette méthode crée un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> dont l’objet <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriété <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> et dont <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propriété contient <ph id="ph5">`exception`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">La méthode est généralement utilisée lorsque vous savez immédiatement que le travail qui exécute une tâche lève une exception avant l’exécution d’un chemin d’accès du code plus de temps.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The example provides an illustration.</source>
          <target state="translated">Cet exemple en fournit une illustration.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">L’exemple suivant est un utilitaire de ligne de commande qui calcule le nombre d’octets dans les fichiers dans chaque annuaire dont le nom est passé comme argument de ligne de commande.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> method to create a faulted task if a particular subdirectory does not exist.</source>
          <target state="translated">Au lieu de l’exécution d’un plus long chemin d’accès de code qui instancie un <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> de l’objet et récupère la valeur de son <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> propriété pour chaque fichier dans le répertoire, l’exemple appelle simplement la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> méthode pour créer une tâche ayant échoué si un particulier sous-répertoire n’existe pas.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Type du résultat retourné par la tâche.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The result to store into the completed task.</source>
          <target state="translated">Résultat à enregistrer dans la tâche terminée.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed successfully with the specified result.</source>
          <target state="translated">Crée une <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> qui s'est terminée correctement avec le résultat spécifié.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The successfully completed task.</source>
          <target state="translated">Tâche terminée avec succès.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph3">`result`</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">Cette méthode crée un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> dont l’objet <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propriété <ph id="ph3">`result`</ph> et dont <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriété est <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The method is commonly used when the return value of a task is immediately known without executing a longer code path.</source>
          <target state="translated">La méthode est généralement utilisée lorsque la valeur de retour d’une tâche est connue immédiatement sans exécuter un chemin d’accès du code plus de temps.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The example provides an illustration.</source>
          <target state="translated">Cet exemple en fournit une illustration.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>To create a Task object that does not return a value, retrieve the Task object from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> property.</source>
          <target state="translated">Pour créer un objet de tâche qui ne retourne pas de valeur, récupérer l’objet de tâche à partir de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">L’exemple suivant est un utilitaire de ligne de commande qui calcule le nombre d’octets dans les fichiers dans chaque annuaire dont le nom est passé comme argument de ligne de commande.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method to create a task whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is zero (0) if a directory has no files.</source>
          <target state="translated">Au lieu de l’exécution d’un plus long chemin d’accès de code qui instancie un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> de l’objet et récupère la valeur de sa <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> propriété pour chaque fichier dans le répertoire, l’exemple appelle simplement la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> méthode pour créer une tâche dont <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propriété est zéro (0) si un répertoire ne comporte aucun fichier.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>Gets an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Obtient un élément awaiter utilisé pour attendre cette <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>An awaiter instance.</source>
          <target state="translated">Instance d'élément awaiter.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>This method is intended for compiler use rather than for use in application code.</source>
          <target state="translated">Cette méthode est conçue pour une utilisation du compilateur plutôt que pour une utilisation dans le code d’application.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Id">
          <source>Gets an ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">Obtient un ID pour cette instance de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>The identifier that is assigned by the system to this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">Entier assigné par le système à cette instance de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</source>
          <target state="translated">ID de tâche sont assignés à la demande et ne représentent pas nécessairement l’ordre dans la tâche instances sont créées.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Notez que bien que les collisions sont très rares, les identificateurs de tâche ne sont pas garantis être unique.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>To get the task ID of the currently executing task from within code that that task is executing, use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> property.</source>
          <target state="translated">Pour obtenir l’ID de tâche de la tâche en cours d’exécution dans le code de cette tâche est en cours d’exécution, utilisez le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has completed execution due to being canceled.</source>
          <target state="translated">Indique si cette instance de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est exécutée avec succès suite à une annulation.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed due to being canceled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la tâche s'est terminée suite à son annulation ; sinon <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will complete in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state under any of the following conditions:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> se termine dans le <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état si l’une des conditions suivantes :</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> was marked for cancellation before the task started executing,</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> a été marqué pour l’annulation avant le début de l’exécution, de la tâche</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by throwing an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> that bears the same <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">La tâche a accepté la demande d’annulation sur son déjà signalé <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> en levant une <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> qui porte le même <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by calling the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">La tâche a accepté la demande d’annulation sur son déjà signalé <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> en appelant le <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> méthode sur le <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">La récupération de la valeur de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has completed.</source>
          <target state="translated">Indique si cette <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la tâche s'est terminée ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> will return <ph id="ph2">`true`</ph> when the task is in one of the three final states: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> retournera <ph id="ph2">`true`</ph> lorsque la tâche est dans un des trois états définitifs : <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, ou <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">La récupération de la valeur de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Gets whether the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed due to an unhandled exception.</source>
          <target state="translated">Indique si la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée suite à une exception non gérée.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has thrown an unhandled exception; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la tâche a levé une exception non gérée ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the task's <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> is equal to <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, and its <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property will be non-null.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> est <ph id="ph2">`true`</ph>, de la tâche <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> est égal à <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>et son <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propriété sera non null.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">La récupération de la valeur de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Queues the specified work to run on the ThreadPool and returns a task or <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> handle for that work.</source>
          <target state="translated">Met en file d'attente le travail spécifié à exécuter dans le ThreadPool et retourne une tâche ou un handle de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> pour ce travail.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a set of overloads that make it easy to start a task by using default values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> méthode fournit un ensemble de surcharges qui la rendent facile de démarrer une tâche à l’aide des valeurs par défaut.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is a lightweight alternative to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> overloads.</source>
          <target state="translated">Il s’agit d’une alternative légère à la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> surcharges.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Travail à exécuter de façon asynchrone</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> qui représente ce travail.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>A task that represents the work queued to execute in the ThreadPool.</source>
          <target state="translated">Tâche qui représente le travail mis en file d'attente à exécuter dans le ThreadPool.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method allows you to create and execute a task in a single method call and is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> méthode vous permet de créer et exécuter une tâche dans un seul appel de méthode et une solution plus simple pour le <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Il crée une tâche avec les valeurs par défaut suivantes :</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Son jeton d’annulation est <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> valeur de propriété est <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Elle utilise le Planificateur de tâches par défaut.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example defines a <ph id="ph1">`ShowThreadInfo`</ph> method  that displays the <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> of the current thread.</source>
          <target state="translated">L’exemple suivant définit un <ph id="ph1">`ShowThreadInfo`</ph> méthode qui affiche le <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> du thread actuel.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It is called directly from the application thread, and is called from the <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">Elle est appelée directement depuis le thread d’application et est appelé à partir de la <ph id="ph1">&lt;xref:System.Action&gt;</ph> délégué transmis à la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</source>
          <target state="translated">L’exemple suivant est similaire au précédent, sauf qu’elle utilise une expression lambda pour définir le code à exécuter la tâche.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The examples show that the asynchronous task executes on a different thread than the main application thread.</source>
          <target state="translated">Les exemples montrent que la tâche asynchrone s’exécute sur un autre thread que le thread d’application principal.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that the task completes and displays its output before the application ends.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode garantit que la tâche se termine et affiche sa sortie avant la fin de l’application.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Otherwise, it is possible that the <ph id="ph1">`Main`</ph> method will complete before the task finishes.</source>
          <target state="translated">Dans le cas contraire, il est possible que le <ph id="ph1">`Main`</ph> méthode se termine avant que la tâche se termine.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</source>
          <target state="translated">Il définit un tableau des noms de répertoires et démarre une tâche distincte pour récupérer les noms de fichier dans chaque répertoire.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Toutes les tâches d’écrivent les noms de fichiers dans un seul <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">L’exemple appelle ensuite la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> pour s’assurer que toutes les tâches terminées et affiche le nombre total de noms de fichiers écrits dans le <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="action" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The work to execute asynchronously</source>
          <target state="translated">Travail à exécuter de façon asynchrone</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Met en file d’attente le travail spécifié à exécuter sur le pool de threads et retourne un proxy pour la tâche retournée par <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Tâche qui représente un proxy de la tâche retournée par <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="function" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Travail à exécuter de façon asynchrone</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token that can be used to cancel the work</source>
          <target state="translated">Jeton d’annulation qui peut être utilisé pour annuler le travail.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> qui représente ce travail.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          <target state="translated">Un jeton d’annulation permet l’annulation du travail.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A task that represents the work queued to execute in the thread pool.</source>
          <target state="translated">Tâche qui représente le travail mis en file d’attente à exécuter dans le pool de threads.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">Si l’annulation est demandée avant le début de la tâche d’exécution, la tâche ne s’exécute pas.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">Au lieu de cela, elle est définie sur le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état et lève un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode constitue une alternative plus simple à la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Il crée une tâche avec les valeurs par défaut suivantes :</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> valeur de propriété est <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Elle utilise le Planificateur de tâches par défaut.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode pour créer une tâche qui parcourt les fichiers dans le répertoire C:\Windows\System32.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">L’expression lambda appelle la <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> méthode pour ajouter des informations sur chaque fichier à un <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Chaque détachée tâche imbriquée appelée par le <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> boucle vérifie l’état du jeton d’annulation et, si l’annulation est demandée, appelle le <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception est gérée dans un <ph id="ph3">`catch`</ph> bloquer lorsque le thread appelant appelle la <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="action" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associée au <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously.</source>
          <target state="translated">Travail à exécuter de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work.</source>
          <target state="translated">Jeton d'annulation qui doit être utilisé pour annuler le travail.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Met en file d’attente le travail spécifié à exécuter sur le pool de threads et retourne un proxy pour la tâche retournée par <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Tâche qui représente un proxy de la tâche retournée par <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="function" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associée au <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">Type du résultat retourné par la tâche de proxy.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The work to execute asynchronously</source>
          <target state="translated">Travail à exécuter de façon asynchrone</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Met en file d’attente le travail spécifié à exécuter dans le pool de threads et retourne un proxy pour le <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> retourné par <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> qui représente un proxy de la <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> retournée par <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="function" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The return type of the task.</source>
          <target state="translated">Type de retour de la tâche.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The work to execute asynchronously.</source>
          <target state="translated">Travail à exécuter de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> qui représente ce travail.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>A task object that represents the work queued to execute in the thread pool.</source>
          <target state="translated">Objet de tâche qui représente le travail mis en file d’attente à exécuter dans le pool de threads.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> méthode constitue une alternative plus simple à la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Il crée une tâche avec les valeurs par défaut suivantes :</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Son jeton d’annulation est <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> valeur de propriété est <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Elle utilise le Planificateur de tâches par défaut.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The following example counts the approximate number of words in text files that represent published books.</source>
          <target state="translated">L’exemple suivant compte le nombre approximatif de mots dans des fichiers texte qui représentent des livres publiés.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</source>
          <target state="translated">Chaque tâche est responsable de l’ouverture d’un fichier, lire tout son contenu de manière asynchrone et calculer le nombre de mots à l’aide d’une expression régulière.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> méthode est appelée pour vous assurer que toutes les tâches terminées avant d’afficher le nombre de mots de chaque ouvrage sur la console.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The regular expression <ph id="ph1">`\p{P}*\s+`</ph> matches zero, one, or more punctuation characters followed by one or more whitespace characters.</source>
          <target state="translated">L’expression régulière <ph id="ph1">`\p{P}*\s+`</ph> correspond à zéro, un ou plusieurs caractères de ponctuation suivis d’un ou plusieurs caractères d’espace blanc.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It assumes that the total number of matches equals the approximate word count.</source>
          <target state="translated">Il suppose que le nombre total de correspondances est égale au nombre de word approximative.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="function" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">Type du résultat retourné par la tâche de proxy.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Travail à exécuter de façon asynchrone</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          <target state="translated">Jeton d'annulation qui doit être utilisé pour annuler le travail</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Met en file d’attente le travail spécifié à exécuter dans le pool de threads et retourne un proxy pour le <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> retourné par <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> qui représente un proxy de la <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> retournée par <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="function" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associée au <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The result type of the task.</source>
          <target state="translated">Type de résultat de la tâche.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Travail à exécuter de façon asynchrone</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          <target state="translated">Jeton d'annulation qui doit être utilisé pour annuler le travail</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> qui représente ce travail.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          <target state="translated">Un jeton d’annulation permet l’annulation du travail.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents the work queued to execute in the thread pool.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> qui représente le travail mis en file d’attente à exécuter dans le pool de threads.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">Si l’annulation est demandée avant le début de la tâche d’exécution, la tâche ne s’exécute pas.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">Au lieu de cela, elle est définie sur le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état et lève un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> méthode constitue une alternative plus simple à la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Il crée une tâche avec les valeurs par défaut suivantes :</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Son <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> valeur de propriété est <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Elle utilise le Planificateur de tâches par défaut.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">L’exemple suivant crée des 20 tâches en boucle jusqu'à ce qu’un compteur est incrémenté à une valeur de 2 millions.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">Lorsque les 10 premières tâches atteint 2 millions, le jeton d’annulation est annulé et toutes les tâches dont les compteurs n’ont pas atteint 2 millions sont annulées.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example shows possible output.</source>
          <target state="translated">L’exemple montre les résultats éventuels.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</source>
          <target state="translated">Au lieu d’utiliser le <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> propriété pour examiner toutes les exceptions, l’exemple itère au sein de toutes les tâches pour déterminer qui ont abouti et qui ont été annulé.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For those that have completed, it displays the value returned by the task.</source>
          <target state="translated">Pour ceux qui ont été effectuées, il affiche la valeur retournée par la tâche.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Because cancellation is cooperative, each task can decide how to respond to cancellation.</source>
          <target state="translated">Étant donné que l’annulation est coopérative, chaque tâche peut décider comment répondre à l’annulation.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</source>
          <target state="translated">L’exemple suivant est similaire à la première, sauf que, une fois que le jeton est annulé, les tâches de retourner le nombre d’itérations ils terminées, au lieu de lever une exception.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example still must handle the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</source>
          <target state="translated">L’exemple doit toujours gérer les <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception, étant donné que toutes les tâches qui n’ont pas démarré lors de l’annulation est demandée lèvent toujours une exception.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="function" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associée au <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Exécute de façon synchrone la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur le <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Exécute de façon synchrone la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur le <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</source>
          <target state="translated">En règle générale, les tâches sont exécutées de façon asynchrone sur un thread de pool de threads et ne bloquent pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method are associated with the current <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> and are run on the calling thread.</source>
          <target state="translated">Tâches exécutées en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> méthode associés actuel <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> et sont exécutées sur le thread appelant.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</source>
          <target state="translated">Si le planificateur cible ne prend pas en charge l’exécution de cette tâche sur le thread appelant, la tâche sera planifiée pour l’exécution sur le planificateur et bloque le thread appelant jusqu'à ce que la tâche a terminé son exécution.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Even though the task runs synchronously, the calling thread should still call <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to handle any exceptions that the task might throw.</source>
          <target state="translated">Même si la tâche s’exécute de façon synchrone, le thread appelant doit toujours appeler <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> pour gérer les exceptions susceptibles de lever la tâche.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>For more information on exception handling, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">Tâches exécutées en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> méthode sont instanciés en appelant un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">La tâche à exécuter de façon synchrone doit être dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>A task may be started and run only once.</source>
          <target state="translated">Une tâche peut être démarrée et exécuter une seule fois.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">Toute tentative pour planifier une tâche une deuxième fois entraîne une exception.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The following example compares a task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method with one executed asynchronously.</source>
          <target state="translated">L’exemple suivant compare une tâche exécutée en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> méthode avec une exécution asynchrone.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</source>
          <target state="translated">Dans les deux cas, les tâches exécutent des expressions lambda identiques qui affichent l’ID de tâche et l’ID du thread sur lequel la tâche s’exécute.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task calculates the sum of the integers between 1 and 1,000,000.</source>
          <target state="translated">La tâche calcule la somme des entiers compris entre 1 et 1 000 000.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>As the output from the example shows, the task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method runs on the application thread, while the asynchronous task does not.</source>
          <target state="translated">Comme le montre la sortie de l’exemple, la tâche est exécutée en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> méthode s’exécute sur le thread d’application n’est pas le cas de la tâche asynchrone.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">L’instance <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> n’est pas dans un état valide pour être démarrée.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler on which to attempt to run this task inline.</source>
          <target state="translated">Planificateur sur lequel tenter d'exécuter cette tâche inline.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> provided.</source>
          <target state="translated">Exécute de façon synchrone le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur le <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> fourni.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">Tâches exécutées en appelant le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> méthode sont instanciés en appelant un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> constructeur de classe.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">La tâche à exécuter de façon synchrone doit être dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>A task may be started and run only once.</source>
          <target state="translated">Une tâche peut être démarrée et exécuter une seule fois.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">Toute tentative pour planifier une tâche une deuxième fois entraîne une exception.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</source>
          <target state="translated">Si le planificateur cible ne prend pas en charge l’exécution de cette tâche sur le thread actuel, la tâche sera planifiée pour l’exécution sur le planificateur et bloque le thread actuel jusqu'à ce que la tâche a terminé son exécution.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Because of this, the calling thread does not need to call a method such as <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to ensure that the task has completed execution.</source>
          <target state="translated">Pour cette raison, le thread appelant n’avez pas besoin d’appeler une méthode telle que <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> pour vous assurer que la tâche a terminé son exécution.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>For more information on exception handling for task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions pour les opérations de tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">L’instance <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> n’est pas dans un état valide pour être démarrée.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Démarre <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Démarre la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, en planifiant son exécution selon le <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>A task may be started and run only once.</source>
          <target state="translated">Une tâche peut être démarrée et exécuter une seule fois.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">Toute tentative pour planifier une tâche entraîne une exception.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> is used to execute a task that has been created by calling one of the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructors.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> est utilisée pour exécuter une tâche qui a été créée en appelant une de le <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructeurs.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</source>
          <target state="translated">En règle générale, cela lorsque vous avez besoin de séparer la création de la tâche à partir de son exécution, par exemple quand vous exécutez de manière conditionnelle les tâches que vous avez créée.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour les cas les plus courants dans lesquels vous n’avez pas besoin de séparer l’instanciation de tâche à partir de l’exécution, nous vous recommandons d’appeler une surcharge de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to instantiate a new <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that displays its task ID and managed thread ID and then executes a loop.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructeur pour instancier un nouvel <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet qui affiche sa tâche ID et l’ID de thread managé, puis exécute une boucle.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method to execute the task.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> méthode à exécuter la tâche.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Since this is a console app, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is necessary to prevent the app from terminating before the task finishes execution.</source>
          <target state="translated">Comme il s’agit d’une application console, l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode est nécessaire pour empêcher l’arrêt avant la fin de la tâche d’exécution de l’application.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">L’instance <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> n’est pas dans un état valide pour être démarrée.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> with which to associate and execute this task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> avec lequel associer et exécuter cette tâche.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the specified <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Démarre la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, en planifiant son exécution sur le <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>A task may only be started and run only once.</source>
          <target state="translated">Une tâche peut uniquement être démarrée et qu’une seule exécution.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">Toute tentative pour planifier une tâche entraîne une exception.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des exceptions levées par des opérations de la tâche, consultez <bpt id="p1">[</bpt>la gestion des exceptions<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> n’est pas dans un état valide pour être démarrée.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">L’instance <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimée.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler was unable to queue this task.</source>
          <target state="translated">Le Planificateur n’a pas pu mettre cette tâche en file d’attente.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Status">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task.</source>
          <target state="translated">Obtient le <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> de cette tâche.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> actuel de cette instance de tâche.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">La récupération de la valeur de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> and <bpt id="p2">[</bpt>How to: Cancel a Task and Its Children<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</source>
          <target state="translated">Pour plus d’informations et obtenir un exemple, consultez <bpt id="p1">[</bpt>chaînage des tâches à l’aide de tâches de Continuation<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> et <bpt id="p2">[</bpt>Comment : annuler une tâche et ses enfants<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">L’exemple suivant crée des 20 tâches en boucle jusqu'à ce qu’un compteur est incrémenté à une valeur de 2 millions.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">Lorsque les 10 premières tâches atteint 2 millions, le jeton d’annulation est annulé et toutes les tâches dont les compteurs n’ont pas atteint 2 millions sont annulées.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The example then examines the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property of each task to indicate whether it completed successfully or was cancelled.</source>
          <target state="translated">L’exemple examine ensuite le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propriété de chaque tâche pour indiquer s’il s’est terminée correctement ou a été annulée.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For those that completed, it displays the value returned by the task.</source>
          <target state="translated">Pour ceux qui s’est terminée, il affiche la valeur retournée par la tâche.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated">Obtient un <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> qui peut être utilisé en attendant la fin de la tâche.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> qui peut être utilisé pour attendre la fin de la tâche.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Using the wait functionality provided by <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> is preferable to using <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> for similar functionality.</source>
          <target state="translated">À l’aide de la fonctionnalité d’attente fournie par <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> est préférable à l’utilisation de <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> pour une fonctionnalité similaire.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>For more information, see the "Waiting on Tasks" section in <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Using TPL with Other Asynchronous Patterns<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez la section « En attente de tâches » dans <bpt id="p1">[</bpt>basé sur des tâches de programmation asynchrone<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> et <bpt id="p2">[</bpt>bibliothèque parallèle de tâches à l’aide avec d’autres modèles asynchrones<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source>Gets an indication of whether the operation completed synchronously.</source>
          <target state="translated">Obtient une indication précisant si l’opération s’est terminée de manière synchrone.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation completed synchronously; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'opération s'est terminée de manière synchrone ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> is a synchronization method that causes the calling thread to wait until the current task has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> est une méthode de synchronisation qui oblige le thread appelant à attendre la fin de la tâche en cours.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</source>
          <target state="translated">Si l’exécution de la tâche en cours n’a pas démarré, la méthode Wait tente de supprimer la tâche du planificateur et de l’exécuter en ligne sur le thread actuel.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</source>
          <target state="translated">S’il est impossible de le faire, ou si la tâche en cours a déjà commencé l’exécution, elle bloque le thread appelant jusqu'à ce que la tâche se termine.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information, see <bpt id="p1">[</bpt>Task.Wait and "Inlining"<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Task.Wait et la fonctionnalité « inline »<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> dans le blog programmation parallèle avec .NET.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to: Wait on One or More Tasks to Complete<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</source>
          <target state="translated">Pour plus d’informations et obtenir un exemple, consultez <bpt id="p1">[</bpt>Comment : attendre une ou plusieurs tâches<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">L’exemple suivant démarre une tâche qui génère un million des entiers aléatoires compris entre 0 et 100 et calcule leur moyenne.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method to ensure that the task completes before the application terminates.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> pour s’assurer que la tâche se termine avant l’arrêt de l’application.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</source>
          <target state="translated">Dans le cas contraire, car il s’agit d’une application console, l’exemple se terminerait avant que la tâche peut calculer et afficher la moyenne.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The task was canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient un objet <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Une exception a été levée pendant l’exécution de la tâche.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient des informations sur l’exception ou les exceptions.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified number of milliseconds.</source>
          <target state="translated">Attend la fin de l'exécution de la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en un nombre de millisecondes spécifié.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'exécution de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée dans le délai imparti ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> est une méthode de synchronisation qui oblige le thread appelant à attendre pour l’instance actuelle de la tâche à effectuer jusqu'à ce qu’une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task completes successfully.</source>
          <target state="translated">La tâche se termine avec succès.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">La tâche est annulée ou lève une exception.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">Dans ce cas, vous gérez un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> propriété contient des détails sur l’exception ou des exceptions.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">L’intervalle défini par <ph id="ph1">`millisecondsTimeout`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Dans ce cas, le thread actuel reprend l’exécution et la méthode retourne <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">L’exemple suivant démarre une tâche qui génère des entiers aléatoires cinq millions comprise entre 0 et 100 et calcule leur moyenne.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> méthode pour attendre l’application terminée dans 150 millisecondes.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">Si l’application s’exécute normalement, la tâche affiche la somme et la moyenne des nombres aléatoires qui il a généré.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">Si l’intervalle de délai d’attente est écoulé, l’exemple affiche un message avant sa fermeture.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task was canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient un objet <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Une exception a été levée pendant l’exécution de la tâche.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient des informations sur l’exception ou les exceptions.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          <target state="translated">Jeton d’annulation à observer en attendant que la tâche se termine.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The wait terminates if a cancellation token is canceled before the task completes.</source>
          <target state="translated">L'attente se termine si un jeton d'annulation est annulé avant la fin de la tâche.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> méthode crée une attente annulable ; autrement dit, il oblige le thread en cours d’attente jusqu'à ce qu’une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task completes.</source>
          <target state="translated">La tâche se termine.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The cancellation token is canceled.</source>
          <target state="translated">Le jeton d’annulation est annulé.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">L’annulation de la <ph id="ph1">`cancellationToken`</ph> jeton d’annulation n’a aucun effet sur la tâche en cours d’exécution, sauf si elle a également été passé le jeton d’annulation et est prêt à gérer l’annulation.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled.</source>
          <target state="translated">En passant le <ph id="ph1">`cancellationToken`</ph> objet à cette méthode permet simplement de l’attente d’être annulée.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation simple d’un jeton d’annulation pour annuler l’attente de la fin d’une tâche.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A task is launched, calls the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</source>
          <target state="translated">Une tâche est lancé, appelle le <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> méthode pour annuler toute la source de jeton jetons d’annulation, puis les retards pendant cinq secondes.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Note that the task itself has not been passed the cancellation token and is not cancelable.</source>
          <target state="translated">Notez que la tâche elle-même n’a pas été passée le jeton d’annulation et n’est pas annulable.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The application thread calls the task's <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> is thrown.</source>
          <target state="translated">Le thread de l’application appelle la tâche <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> méthode pour attendre la tâche se termine, mais que l’attente est annulée une fois que le jeton d’annulation est annulé et un <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> est levée.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The exception handler reports the exception and then sleeps for six seconds.</source>
          <target state="translated">Le Gestionnaire d’exceptions signale l’exception et puis se met en veille pendant six secondes.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>As the output from the example shows, that delay allows the task to complete in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Comme le montre la sortie de l’exemple, ce délai permet à la tâche à exécuter dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> a été annulé.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task has been disposed.</source>
          <target state="translated">La tâche a été supprimée.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient un objet <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Une exception a été levée pendant l’exécution de la tâche.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient des informations sur l’exception ou les exceptions.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified time interval.</source>
          <target state="translated">Attend la fin de l'exécution de la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> dans un intervalle de temps spécifié.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'exécution de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée dans le délai imparti ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> est une méthode de synchronisation qui oblige le thread appelant à attendre pour l’instance actuelle de la tâche à effectuer jusqu'à ce qu’une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task completes successfully.</source>
          <target state="translated">La tâche se termine avec succès.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">La tâche est annulée ou lève une exception.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">Dans ce cas, vous gérez un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> propriété contient des détails sur l’exception ou des exceptions.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The interval defined by <ph id="ph1">`timeout`</ph> elapses.</source>
          <target state="translated">L’intervalle défini par <ph id="ph1">`timeout`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Dans ce cas, le thread actuel reprend l’exécution et la méthode retourne <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">L’exemple suivant démarre une tâche qui génère des entiers aléatoires cinq millions comprise entre 0 et 100 et calcule leur moyenne.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">L’exemple utilise le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> méthode pour attendre l’application terminée dans 150 millisecondes.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">Si l’application s’exécute normalement, la tâche affiche la somme et la moyenne des nombres aléatoires qui il a généré.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">Si l’intervalle de délai d’attente est écoulé, l’exemple affiche un message avant sa fermeture.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task was canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient un objet <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Une exception a été levée pendant l’exécution de la tâche.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient des informations sur l’exception ou les exceptions.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          <target state="translated">Jeton d’annulation à observer en attendant que la tâche se termine.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</source>
          <target state="translated">L'attente se termine si un intervalle de délai est écoulé ou si un jeton d'annulation est annulé avant la fin de la tâche.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'exécution de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée dans le délai imparti ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> est une méthode de synchronisation qui oblige le thread appelant à attendre pour l’instance actuelle de la tâche à effectuer jusqu'à ce qu’une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task completes successfully.</source>
          <target state="translated">La tâche se termine avec succès.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">La tâche est annulée ou lève une exception.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">Dans ce cas, vous gérez un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> propriété contient des détails sur l’exception ou des exceptions.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> cancellation token is canceled.</source>
          <target state="translated">Le <ph id="ph1">`cancellationToken`</ph> jeton d’annulation est annulé.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">Dans ce cas, l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode lève une exception une <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">L’intervalle défini par <ph id="ph1">`millisecondsTimeout`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Dans ce cas, le thread actuel reprend l’exécution et la méthode retourne <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">L’annulation de la <ph id="ph1">`cancellationToken`</ph> jeton d’annulation n’a aucun effet sur la tâche en cours d’exécution, sauf si elle a également été passé le jeton d’annulation et est prêt à gérer l’annulation.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled based on some condition.</source>
          <target state="translated">En passant le <ph id="ph1">`cancellationToken`</ph> objet à cette méthode permet simplement l’attente d’être annulée en fonction sur une condition.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> méthode pour fournir une valeur de délai d’attente et l’annulation du jeton qui peut mettre fin à l’attente de la fin d’une tâche.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A new thread is started and executes the <ph id="ph1">`CancelToken`</ph> method, which pauses and then calls the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel the cancellation tokens.</source>
          <target state="translated">Un nouveau thread est démarré et qu’il exécute la <ph id="ph1">`CancelToken`</ph> (méthode), qui met en pause et appelle ensuite la <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> méthode pour annuler les jetons d’annulation.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A task is then launched and delays for 5 seconds.</source>
          <target state="translated">Une tâche est alors lancée et un délai de 5 secondes.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode est alors appelée pour attendre la fin de la tâche et est fournie à la fois une valeur de délai brèves et un jeton d’annulation.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</source>
          <target state="translated">Notez que la sortie précise à partir de l’exemple dépend de si l’attente a été annulée en raison du jeton d’annulation ou parce que l’intervalle de délai s’est écoulé.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> a été annulé.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          <target state="translated">La tâche a été annulée.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient un objet <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Une exception a été levée pendant l’exécution de la tâche.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La collection <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contient des informations sur l’exception ou les exceptions.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The following example starts 10 tasks, each of which is passed an index as a state object.</source>
          <target state="translated">L’exemple suivant démarre 10 tâches, chacune d’elles est passé à un index en tant qu’un objet d’état.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Tasks with an index from two to five throw exceptions.</source>
          <target state="translated">Tâches ayant un index de deux à cinq lever des exceptions.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method wraps all exceptions in an <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> object and propagates it to the calling thread.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> méthode encapsule toutes les exceptions dans une <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> de l’objet et les propage vers le thread appelant.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> ont été supprimés.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> est un tableau vide.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été annulée.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> exception contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> exception in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si une tâche a été annulée, l’exception <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contient une exception <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> dans sa collection <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Une exception a été levée pendant l’exécution d’au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          <target state="translated">Attend la fin de l'exécution de tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis en un nombre de millisecondes spécifié.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'exécution de toutes les instances <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée dans le délai imparti ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> ont été supprimés.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été annulée.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si une tâche a été annulée, <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contient <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> dans sa collection <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Une exception a été levée pendant l’exécution d’au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> est un tableau vide.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> à observer en attendant que les tâches se terminent.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          <target state="translated">Attend la fin de l'exécution de tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis sauf si l'attente est annulée.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated">Le <ph id="ph1">`cancellationToken`</ph> argument est utilisé pour annuler l’opération d’attente.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> as noted above.</source>
          <target state="translated">L’annulation des tâches est une opération distincte et est signalée par le <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> comme indiqué ci-dessus.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> a été annulé.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été annulée.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si une tâche a été annulée, <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contient <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> dans sa collection <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Une exception a été levée pendant l’exécution d’au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> est un tableau vide.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> ont été supprimés.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for all of the provided cancellable <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          <target state="translated">Attend la fin de l'exécution de tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> pouvant être annulés fournis dans un intervalle de temps spécifié.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'exécution de toutes les instances <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée dans le délai imparti ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> ont été supprimés.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été annulée.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si une tâche a été annulée, <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contient <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> dans sa collection <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Une exception a été levée pendant l’exécution d’au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> est un tableau vide.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> à observer en attendant que les tâches se terminent.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</source>
          <target state="translated">Attend la fin de l'exécution de tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis en un nombre de millisecondes spécifié ou jusqu'à ce que l'attente soit annulée.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'exécution de toutes les instances <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> s'est terminée dans le délai imparti ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated">Le <ph id="ph1">`cancellationToken`</ph> argument est utilisé pour annuler l’opération d’attente.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> noted above.</source>
          <target state="translated">L’annulation des tâches est une opération distincte et est signalée par le <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> indiqués ci-dessus.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Un ou plusieurs objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> ont été supprimés.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été annulée.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si une tâche a été annulée, <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contient <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> dans sa collection <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Une exception a été levée pendant l’exécution d’au moins une des instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> est un tableau vide.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> a été annulé.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de l'un des objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Attend la fin de l'exécution de l'un des objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The index of the completed <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object in the <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> array.</source>
          <target state="translated">Index de l’objet <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> terminé dans le tableau <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</source>
          <target state="translated">L’exemple suivant démarre cinq tâches, chacune d’elles se met en veille pour un minimum de 50 millisecondes ou à un maximum de 1,050 millisecondes.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> method then waits for any of the tasks to complete.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> méthode puis attend les fin des tâches.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</source>
          <target state="translated">L’exemple affiche l’ID de tâche de la tâche qui s’est terminée de l’attente, ainsi que l’état actuel de toutes les tâches.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          <target state="translated">Attend la fin de l'exécution de l'un des objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis en un nombre de millisecondes spécifié.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated">Index de la tâche achevée dans l'argument de tableau <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> ou -1, si le délai a expiré.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> à observer en attendant qu'une tâche se termine.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          <target state="translated">Attend la fin de l'exécution de l'un des objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis sauf si l'attente est annulée.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument.</source>
          <target state="translated">Index de la tâche achevée dans l'argument de tableau <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> a été annulé.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le nombre de millièmes de secondes à attendre ou <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente -1 millième de seconde, pour attendre indéfiniment.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          <target state="translated">Attend la fin de l'exécution de n'importe lequel des objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis dans un intervalle de temps spécifié.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated">Index de la tâche achevée dans l'argument de tableau <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> ou -1, si le délai a expiré.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est un nombre négatif différent de -1 milliseconde, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> sur lesquelles attendre.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Nombre de millisecondes à attendre, ou <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) pour un délai d'attente infini.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> à observer en attendant qu'une tâche se termine.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</source>
          <target state="translated">Attend la fin de l'exécution de l'un des objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> fournis en un nombre de millisecondes spécifié ou jusqu'à ce qu'un jeton d'annulation soit annulé.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated">Index de la tâche achevée dans l'argument de tableau <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> ou -1, si le délai a expiré.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">L’argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contient un élément Null.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> a été annulé.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when all of the supplied tasks have completed.</source>
          <target state="translated">Crée une tâche qui s’achève quand toutes les tâches fournies sont terminées.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an enumerable collection have completed.</source>
          <target state="translated">Crée une tâche qui s'achève quand tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> d'une collection énumérable sont terminés.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de toutes les tâches fournies.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">Les surcharges de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> méthode qui retourne un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet sont généralement appelées lorsque vous intéressez dans l’état d’un ensemble de tâches ou dans les exceptions levées par un ensemble de tâches.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> méthode ne bloque pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si une des tâches fournies est terminée dans un état d’erreur, la tâche retournée également prendra un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches fournies ayant renvoyé des erreurs, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches ayant renvoyé des erreurs et aucune des tâches ont été annulées, la tâche obtenue se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si les fourni tableau/énumérables ne contient aucune tâche, la tâche retournée immédiatement adopte un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état avant d’être retournée à l’appelant.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">L’exemple suivant crée un ensemble de tâches qui ping les URL dans un tableau.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">Les tâches sont stockées dans un <ph id="ph1">`List&lt;Task&gt;`</ph> collection qui est passée à la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">Après l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode garantit que tous les threads sont terminés, l’exemple examine la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer si toutes les tâches ont généré une erreur.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">La collection de <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an array have completed.</source>
          <target state="translated">Crée une tâche qui s'achève quand tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> d'un tableau sont terminés.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de toutes les tâches fournies.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">Les surcharges de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> méthode qui retourne un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objet sont généralement appelées lorsque vous intéressez dans l’état d’un ensemble de tâches ou dans les exceptions levées par un ensemble de tâches.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> méthode ne bloque pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si une des tâches fournies est terminée dans un état d’erreur, la tâche retournée également prendra un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches fournies ayant renvoyé des erreurs, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches ayant renvoyé des erreurs et aucune des tâches ont été annulées, la tâche obtenue se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si les fourni tableau/énumérables ne contient aucune tâche, la tâche retournée immédiatement adopte un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état avant d’être retournée à l’appelant.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">L’exemple suivant crée un ensemble de tâches qui ping les URL dans un tableau.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is converted to an array and passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">Les tâches sont stockées dans un <ph id="ph1">`List&lt;Task&gt;`</ph> collection qui est convertie en un tableau et passée à la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">Après l’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> méthode garantit que tous les threads sont terminés, l’exemple examine la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer si toutes les tâches ont généré une erreur.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">Le tableau de <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">Type de la tâche terminée.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an enumerable collection have completed.</source>
          <target state="translated">Crée une tâche qui s'achève quand tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> d'une collection énumérable sont terminés.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de toutes les tâches fournies.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> méthode ne bloque pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">Toutefois, un appel à retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> propriété ne bloque le thread appelant.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si une des tâches fournies est terminée dans un état d’erreur, la tâche retournée également prendra un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches fournies ayant renvoyé des erreurs, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches ayant renvoyé des erreurs et aucune des tâches ont été annulées, la tâche obtenue se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propriété de la tâche retournée est fixée à un tableau contenant tous les résultats des tâches fournies dans le même ordre, telles qu’elles ont été fournies (par exemple, si l’entrée des tâches tableau contenu t1, t2, t3, la tâche de sortie <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propriété retournera un <ph id="ph3">`TResult[]`</ph> où <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If the <ph id="ph1">`tasks`</ph> argument contains no tasks, the returned task will immediately transition to a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si le <ph id="ph1">`tasks`</ph> argument ne contient pas de tâches, la tâche retournée passe immédiatement à un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état avant d’être retournée à l’appelant.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">Retourné <ph id="ph1">`TResult[]`</ph> sera un tableau d’éléments de 0.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">L’exemple suivant crée dix tâches, chacune d’elles instancie un générateur de nombres aléatoires qui crée les 1 000 nombres aléatoires compris entre 1 et 1 000 et calcule leur moyenne.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> méthode permet de retarder l’instanciation de générateurs de nombres aléatoires afin qu’ils ne sont pas créés avec les mêmes valeurs initiales.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> méthode retourne ensuite un <ph id="ph2">&lt;xref:System.Int64&gt;</ph> tableau qui contient la moyenne calculée par chaque tâche.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">Ceux-ci sont ensuite utilisées pour calculer la moyenne globale.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">Dans ce cas, les dix tâches individuelles sont stockés dans un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implémente l'interface <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">La collection de <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">Type de la tâche terminée.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an array have completed.</source>
          <target state="translated">Crée une tâche qui s'achève quand tous les objets <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> d'un tableau sont terminés.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de toutes les tâches fournies.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">L’appel à <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> méthode ne bloque pas le thread appelant.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">Toutefois, un appel à retourné <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> propriété ne bloque le thread appelant.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si une des tâches fournies est terminée dans un état d’erreur, la tâche retournée également prendra un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches fournies ayant renvoyé des erreurs, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si aucune des tâches ayant renvoyé des erreurs et aucune des tâches ont été annulées, la tâche obtenue se termine dans le <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> de la tâche retournée est défini sur un tableau contenant tous les résultats des tâches fournies dans le même ordre, telles qu’elles ont été fournies (par exemple, si l’entrée des tâches tableau contenu t1, t2, t3, la tâche de sortie <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> retournera un <ph id="ph3">`TResult[]`</ph> où <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si les fourni tableau/énumérables ne contient aucune tâche, la tâche retournée immédiatement adopte un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> état avant d’être retournée à l’appelant.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">Retourné <ph id="ph1">`TResult[]`</ph> sera un tableau d’éléments de 0.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">L’exemple suivant crée dix tâches, chacune d’elles instancie un générateur de nombres aléatoires qui crée les 1 000 nombres aléatoires compris entre 1 et 1 000 et calcule leur moyenne.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">`Task&lt;Int64&gt;`</ph> array.</source>
          <target state="translated">Dans ce cas, les dix tâches individuelles sont stockés dans un <ph id="ph1">`Task&lt;Int64&gt;`</ph> tableau.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> méthode permet de retarder l’instanciation de générateurs de nombres aléatoires afin qu’ils ne sont pas créés avec les mêmes valeurs initiales.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">L’appel à la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> méthode retourne ensuite un <ph id="ph2">&lt;xref:System.Int64&gt;</ph> tableau qui contient la moyenne calculée par chaque tâche.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">Ceux-ci sont ensuite utilisées pour calculer la moyenne globale.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">Le tableau de <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crée une tâche qui s’achève quand l’une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crée une tâche qui s’achève quand l’une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de l’une des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">Le résultat de la tâche retour est la tâche qui s’est terminée.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tâche retournée s’achève quand une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state  with its Result set to the first task to complete.</source>
          <target state="translated">La tâche retournée se terminera toujours dans le <ph id="ph1">`RanToCompletion`</ph> état avec son jeu de résultats pour la première tâche à effectuer.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">Cela est vrai même si la première tâche se termine s’est terminée sur le <ph id="ph1">`Canceled`</ph> ou <ph id="ph2">`Faulted`</ph> état.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matrice <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche null ou était vide.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crée une tâche qui s’achève quand l’une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de l’une des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">Le résultat de la tâche retour est la tâche qui s’est terminée.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tâche retournée s’achève quand une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state   with its <ph id="ph2">`Result`</ph> set to the first task to complete.</source>
          <target state="translated">La tâche retournée se terminera toujours dans le <ph id="ph1">`RanToCompletion`</ph> état avec son <ph id="ph2">`Result`</ph> définie à la première tâche à effectuer.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">Cela est vrai même si la première tâche se termine s’est terminée sur le <ph id="ph1">`Canceled`</ph> ou <ph id="ph2">`Faulted`</ph> état.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> avait la valeur null.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matrice <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche null ou était vide.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">Type de la tâche terminée.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crée une tâche qui s’achève quand l’une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de l’une des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">Le résultat de la tâche retour est la tâche qui s’est terminée.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tâche retournée s’achève quand une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">La tâche retournée se terminera toujours dans l’état RanToCompletion avec son jeu de résultats pour la première tâche à effectuer.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">Cela est vrai même si la fin de la première tâche à exécuter dans l’état annulé ou Faulted.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> était <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matrice <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche null ou était vide.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">Type de la tâche terminée.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tâches restantes à exécuter avant la fin.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crée une tâche qui s’achève quand l’une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tâche qui représente l’achèvement de l’une des tâches fournies.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">Le résultat de la tâche retour est la tâche qui s’est terminée.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tâche retournée s’achève quand une des tâches fournies est terminée.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">La tâche retournée se terminera toujours dans l’état RanToCompletion avec son jeu de résultats pour la première tâche à effectuer.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">Cela est vrai même si la fin de la première tâche à exécuter dans l’état annulé ou Faulted.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          <target state="translated">L'argument <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> avait la valeur null.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matrice <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenait une tâche null ou était vide.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Creates an awaitable task that asynchronously yields back to the current context when awaited.</source>
          <target state="translated">Crée une tâche pouvant être attendue qui se produit de manière asynchrone dans le contexte actuel pendant l’attente.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</source>
          <target state="translated">Contexte qui, quand il est attendu, reviendra de façon asynchrone au contexte qui était le sien au moment de l'attente.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> is non-null, it is treated as the current context.</source>
          <target state="translated">Si le <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> actuel n'a pas la valeur null, il est traité comme le contexte actuel.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</source>
          <target state="translated">Sinon, le Planificateur de tâches associé à la tâche en cours d’exécution est traité comme le contexte actuel.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>You can use <ph id="ph1">`await Task.Yield();`</ph> in an asynchronous method to force the method to complete asynchronously.</source>
          <target state="translated">Vous pouvez utiliser <ph id="ph1">`await Task.Yield();`</ph> dans une méthode asynchrone pour forcer la méthode se termine de façon asynchrone.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If there is a current synchronization context (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object), this will post the remainder of the method’s execution back to that context.</source>
          <target state="translated">S’il existe un contexte de synchronisation actuel (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> objet), cela permet de valider le reste de reprendre l’exécution la méthode dans ce contexte.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>However, the context will decide how to prioritize this work relative to other work that may be pending.</source>
          <target state="translated">Toutefois, le contexte décidera des priorités de ce travail par rapport à d’autres tâches qui peuvent être en attente.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</source>
          <target state="translated">Le contexte de synchronisation qui est présent sur un thread d’interface utilisateur dans la plupart des environnements de l’interface utilisateur de priorité souvent travail validée dans le contexte supérieur de l’entrée et le travail de rendu.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For this reason, do not rely on <ph id="ph1">`await Task.Yield();`</ph> to keep a UI responsive.</source>
          <target state="translated">Pour cette raison, ne comptez pas sur <ph id="ph1">`await Task.Yield();`</ph> pour conserver une interface utilisateur réactive.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For more information, see the entry <bpt id="p1">[</bpt>Useful Abstractions Enabled with ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Pour plus d’informations, consultez l’entrée <bpt id="p1">[</bpt>utile Abstractions activée avec la méthode ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> dans le blog programmation parallèle avec .NET.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>