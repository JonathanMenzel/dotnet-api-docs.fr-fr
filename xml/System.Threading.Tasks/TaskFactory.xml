<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0840b5646b82fa6e7833718724b56dd16676c685" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52232234" /></Metadata><TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskFactory" />
  <TypeSignature Language="F#" Value="type TaskFactory = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Prend en charge la création et la planification d'objets <see cref="T:System.Threading.Tasks.Task" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework fournit deux fabriques pour la création et la planification des tâches :  
  
-   Le <xref:System.Threading.Tasks.TaskFactory> (classe), ce qui crée <xref:System.Threading.Tasks.Task> et <xref:System.Threading.Tasks.Task%601> objets. Vous pouvez appeler des surcharges de cette méthode pour créer et exécuter une tâche qui nécessite des arguments personnalisés.  
  
    > [!WARNING]
    >  En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode fournit le moyen le plus simple pour créer une tâche avec la valeur par défaut des valeurs de configuration et la démarrer immédiatement.  
  
-   Le <xref:System.Threading.Tasks.TaskFactory%601> (classe), ce qui crée <xref:System.Threading.Tasks.Task%601> objets.  
  
 Le <xref:System.Threading.Tasks.TaskFactory> classe permet d’effectuer les opérations suivantes :  
  
-   Créer une tâche et démarrer immédiatement en appelant le <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> (méthode).  
  
    > [!WARNING]
    >  En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode fournit le moyen le plus simple pour créer une tâche avec la valeur par défaut des valeurs de configuration et la démarrer immédiatement.  
  
-   Créer une tâche qui démarre lorsque l’une des tâches dans un tableau est terminée en appelant le <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> (méthode).  
  
-   Créer une tâche qui démarre lorsque toutes les tâches dans un tableau s’est terminé en appelant le <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> (méthode).  
  
 La méthode statique <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> propriété retourne une valeur par défaut <xref:System.Threading.Tasks.TaskFactory%601> objet. Vous pouvez également appeler une de la <xref:System.Threading.Tasks.TaskFactory> classe constructeurs pour configurer le <xref:System.Threading.Tasks.Task> objets qui la <xref:System.Threading.Tasks.TaskFactory> classe crée. L’exemple suivant configure un nouveau <xref:System.Threading.Tasks.TaskFactory> objet pour créer des tâches qui ont un jeton d’annulation spécifié, les options de création de tâche, les options de continuation et un planificateur de tâches personnalisé.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 Dans la plupart des cas, vous n’avez pas instancier un nouvel <xref:System.Threading.Tasks.TaskFactory> instance. Au lieu de cela, vous pouvez utiliser le <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propriété, qui retourne un objet de fabrique qui utilise les valeurs par défaut. Vous pouvez ensuite appeler ses méthodes pour démarrer de nouvelles tâches ou définir les continuations de tâches. Pour obtenir une illustration, consultez l’exemple.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode statique <xref:System.Threading.Tasks.Task.Factory%2A> propriété afin que les deux appels à la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (méthode). La première remplit un tableau avec les noms des fichiers dans le répertoire Mes documents, tandis que la seconde remplit un tableau avec les noms des sous-répertoires du répertoire Mes documents de l’utilisateur. Il appelle ensuite la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> (méthode), qui affiche des informations sur le nombre de fichiers et des répertoires dans les deux tableaux après les deux premières tâches terminées à l’exécution.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres publics et protégés de <see cref="T:System.Threading.Tasks.TaskFactory" /> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Tasks.TaskFactory" />.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une instance de <see cref="T:System.Threading.Tasks.TaskFactory" /> avec la configuration par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Threading.Tasks.TaskFactory> instance avec une configuration par défaut. Le <xref:System.Threading.Tasks.TaskCreationOptions> propriété est initialisée avec <xref:System.Threading.Tasks.TaskCreationOptions.None>, le <xref:System.Threading.Tasks.TaskContinuationOptions> propriété est initialisée avec <xref:System.Threading.Tasks.TaskContinuationOptions.None>et le <xref:System.Threading.Tasks.TaskScheduler> propriété est initialisée au planificateur actuel (consultez <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory cancellationToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné aux tâches créées par ce <see cref="T:System.Threading.Tasks.TaskFactory" />, sauf si un autre CancellationToken est explicitement spécifié lors de l'appel de méthodes de fabrique.</param>
        <summary>Initialise une instance de <see cref="T:System.Threading.Tasks.TaskFactory" /> avec la configuration spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée un <xref:System.Threading.Tasks.TaskFactory> instance avec une configuration par défaut. Le <xref:System.Threading.Tasks.TaskCreationOptions> propriété est initialisée avec <xref:System.Threading.Tasks.TaskCreationOptions.None>, le <xref:System.Threading.Tasks.TaskContinuationOptions> propriété est initialisée avec <xref:System.Threading.Tasks.TaskContinuationOptions.None>et le <xref:System.Threading.Tasks.TaskScheduler> propriété est initialisée au planificateur actuel (consultez <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory scheduler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> à utiliser pour planifier des tâches créées avec ce TaskFactory. Une valeur Null indique que le TaskScheduler actif doit être utilisé.</param>
        <summary>Initialise une instance de <see cref="T:System.Threading.Tasks.TaskFactory" /> avec la configuration spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec ce constructeur, le <xref:System.Threading.Tasks.TaskCreationOptions> propriété est initialisée avec <xref:System.Threading.Tasks.TaskCreationOptions.None>, le <xref:System.Threading.Tasks.TaskContinuationOptions> propriété est initialisée avec <xref:System.Threading.Tasks.TaskContinuationOptions.None>et le <xref:System.Threading.Tasks.TaskScheduler> propriété est initialisée avec `scheduler`, sauf si elle a la valeur null, auquel cas le la propriété est initialisée au planificateur actuel (consultez <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (creationOptions, continuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> par défaut à utiliser lors de la création de tâches avec ce TaskFactory.</param>
        <param name="continuationOptions"><see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> par défaut à utiliser lors de la création de tâches de continuation avec ce TaskFactory.</param>
        <summary>Initialise une instance de <see cref="T:System.Threading.Tasks.TaskFactory" /> avec la configuration spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec ce constructeur, le <xref:System.Threading.Tasks.TaskCreationOptions> propriété est initialisée avec `creationOptions`, le <xref:System.Threading.Tasks.TaskContinuationOptions> propriété est initialisée avec `continuationOptions`et le <xref:System.Threading.Tasks.TaskScheduler> propriété est initialisée au planificateur actuel (consultez <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> non valide. Pour plus d’informations, consultez les Notes relatives à <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- ou - 
L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (cancellationToken, creationOptions, continuationOptions, scheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> par défaut qui sera assigné aux tâches créées par ce <see cref="T:System.Threading.Tasks.TaskFactory" />, sauf si un autre CancellationToken est explicitement spécifié lors de l'appel de méthodes de fabrique.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> par défaut à utiliser lors de la création de tâches avec ce TaskFactory.</param>
        <param name="continuationOptions"><see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> par défaut à utiliser lors de la création de tâches de continuation avec ce TaskFactory.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> par défaut à utiliser pour planifier des tâches créées avec ce TaskFactory. Une valeur Null indique que TaskScheduler.Current doit être utilisé.</param>
        <summary>Initialise une instance de <see cref="T:System.Threading.Tasks.TaskFactory" /> avec la configuration spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec ce constructeur, le <xref:System.Threading.Tasks.TaskCreationOptions> propriété est initialisée avec `creationOptions`, le <xref:System.Threading.Tasks.TaskContinuationOptions> propriété est initialisée avec `continuationOptions`et le <xref:System.Threading.Tasks.TaskScheduler> propriété est initialisée avec `scheduler`, sauf si elle a la valeur null, auquel cas le la propriété est initialisée au planificateur actuel (consultez <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> non valide. Pour plus d’informations, consultez les Notes relatives à <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
- ou - 
L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : System.Threading.CancellationToken" Usage="System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le jeton d’annulation par défaut pour cette fabrique de tâches.</summary>
        <value>Jeton d’annulation de tâches par défaut pour cette fabrique de tâches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur par défaut <xref:System.Threading.CancellationToken> qui sera assigné à toutes les tâches créées par cette fabrique, sauf si un autre <xref:System.Threading.CancellationToken> valeur est explicitement spécifiée pendant l’appel de méthodes de fabrique.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.ContinuationOptions : System.Threading.Tasks.TaskContinuationOptions" Usage="System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les options de continuation de tâches par défaut pour cette fabrique de tâches.</summary>
        <value>Options de continuation de tâches par défaut pour cette fabrique de tâches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de propriété est utilisée pour créer toutes les tâches de continuation, à moins que les autres options sont spécifiées explicitement pendant les appels aux méthodes de cette fabrique.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d’action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> méthode s’exécute le `continuationAction` délégué lorsque toutes les tâches dans le `tasks` tableau terminées, quelle que soit leur état d’achèvement.  
  
 Les exceptions levées par des tâches dans le `tasks` tableau ne sont pas disponibles pour la tâche de continuation via la gestion structurée des exceptions. Vous pouvez déterminer les exceptions levées en examinant le <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> propriété de chaque tâche dans le `tasks` tableau. Pour utiliser structurée des exceptions pour gérer les exceptions levées par des tâches dans le `tasks` de tableau, appelez le <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant lance des tâches distinctes qui utilisent une expression régulière pour compter le nombre de mots dans un ensemble de fichiers texte. Le <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> méthode est utilisée pour lancer une tâche qui affiche le nombre total de mots lorsque toutes les tâches d’antécédent s’est terminé.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 L’appel à la tâche de continuation <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> méthode ne permet pas à gérer les exceptions levées par les tâches d’antécédent, donc l’exemple examine la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriété de chaque tâche antécédente pour déterminer si la tâche a réussi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [\], Action (tâche\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D% 2CSystem.Threading.CancellationToken%29 > méthode exécute le `continuationAction` délégué lorsque toutes les tâches dans le `tasks` tableau terminées, quelle que soit leur état d’achèvement.  
  
   
  
## Examples  
 L’exemple suivant crée un jeton d’annulation, qu’il passe à séparer les tâches qui utilisent une expression régulière pour compter le nombre de mots dans un ensemble de fichiers texte. Le jeton d’annulation est défini si un fichier est introuvable. Le [\], Action (tâche\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A > méthode est utilisée pour lancer une tâche qui affiche le nombre total de mots lorsque toutes les tâches d’antécédent s’est terminé. Si le jeton d’annulation est défini, ce qui indique qu’une ou plusieurs tâches ont été annulées, il gère la <xref:System.AggregateException> exception et affiche un message d’erreur.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d’action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation.</param>
        <param name="scheduler">Objet utilisé pour planifier la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d’action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d’action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <param name="scheduler">Objet utilisé pour planifier la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <param name="scheduler">Objet utilisé pour planifier la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé à la tâche créée.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand toutes les tâches du tableau <paramref name="tasks" /> sont terminées.</param>
        <param name="cancellationToken">Jeton d’annulation à associer à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Combinaison d’opérations de bits des valeurs d’énumération qui contrôlent le comportement de la nouvelle tâche de continuation. Les membres NotOn* et OnlyOn* ne sont pas pris en charge.</param>
        <param name="scheduler">Objet utilisé pour planifier la nouvelle tâche de continuation.</param>
        <summary>Crée une tâche de continuation qui démarre lorsqu'un ensemble de tâches spécifiées est terminé.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> est vide ou contient une valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Un élément du tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser `ContinueWhenAny` et `ContinueWhenAll`:  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’un des éléments du tableau <paramref name="tasks" /> a été éliminé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> contient une valeur <see langword="null" />.  
  
- ou - 
Le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L’un des éléments du tableau <paramref name="tasks" /> a été éliminé.  
  
- ou - 
 <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Le tableau <paramref name="tasks" /> a la valeur <see langword="null" />.  
  
- ou - 
L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="tasks" /> contient une valeur <see langword="null" />.  
  
- ou - 
Le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationAction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="continuationOptions" /> spécifie une valeur TaskContinuationOptions non valide.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> de continuation créée.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationAction" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationAction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationAction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationAction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="continuationOptions" /> spécifie une valeur TaskContinuationOptions non valide.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationAction">Délégué d'action à exécuter quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> de continuation créée.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationAction" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="continuationOptions" /> spécifie une valeur TaskContinuationOptions non valide.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.  
  
- ou - 
Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Exception levée lorsque l'un des éléments dans le tableau <paramref name="tasks" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="continuationOptions" /> spécifie une valeur TaskContinuationOptions non valide.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Type du résultat du <paramref name="tasks" /> antécédent.</typeparam>
        <typeparam name="TResult">Type du résultat retourné par le délégué <paramref name="continuationFunction" /> et associé au <see cref="T:System.Threading.Tasks.Task`1" /> créé.</typeparam>
        <param name="tasks">Tableau de tâches à partir duquel continuer lorsqu'une tâche se termine.</param>
        <param name="continuationFunction">Délégué de fonction à exécuter en mode asynchrone quand une tâche du tableau <paramref name="tasks" /> est terminée.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Valeur <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task`1" /> de continuation créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> de continuation qui démarrera quand l'une des tâches de l'ensemble fourni se terminera.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * et OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>, qui contraignent pour lequel <xref:System.Threading.Tasks.TaskStatus> une continuation doit être exécutée, les États ne sont pas conformes avec ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée lorsque le tableau <paramref name="tasks" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="continuationFunction" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentException">Exception levée lorsque le tableau <paramref name="tasks" /> contient une valeur Null.  
  
- ou - 
Exception levée lorsque le tableau <paramref name="tasks" /> est vide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les options de création de tâches par défaut pour cette fabrique de tâches.</summary>
        <value>Options de création de tâches par défaut pour cette fabrique de tâches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de propriété est utilisée pour créer toutes les tâches, à moins que les autres options sont spécifiées explicitement pendant les appels aux méthodes de cette fabrique.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">IAsyncResult dont l'achèvement doit déclencher le traitement du <paramref name="endMethod" />.</param>
        <param name="endMethod">Délégué d'action qui traite le <paramref name="asyncResult" /> terminé.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> qui exécute une action de la méthode End quand un <see cref="T:System.IAsyncResult" /> spécifié se termine.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Le <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> surcharges qui prennent un `asyncResult` paramètre ne sont pas aussi efficace que les surcharges qui prennent un `beginMethod` paramètre. Si les performances sont un problème, utilisez les surcharges qui fournissent le `beginMethod` / `endMethod` modèle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="asyncResult" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur.  Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">IAsyncResult dont l'achèvement doit déclencher le traitement du <paramref name="endMethod" />.</param>
        <param name="endMethod">Délégué d'action qui traite le <paramref name="asyncResult" /> terminé.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> qui exécute une action de la méthode End quand un <see cref="T:System.IAsyncResult" /> spécifié se termine.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Le <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> surcharges qui prennent un `asyncResult` paramètre ne sont pas aussi efficace que les surcharges qui prennent un `beginMethod` paramètre. Si les performances sont un problème, utilisez les surcharges qui fournissent le `beginMethod` / `endMethod` modèle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="asyncResult" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`. Le <xref:System.Threading.Tasks.TaskCreationOptions> valeurs <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> et <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> sont tous mutuellement. Dans les méthodes FromAsync, soit `LongRunning` ou `AttachedToParent` lèvera une <xref:System.ArgumentOutOfRangeException> levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">IAsyncResult dont l'achèvement doit déclencher le traitement du <paramref name="endMethod" />.</param>
        <param name="endMethod">Délégué d'action qui traite le <paramref name="asyncResult" /> terminé.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la tâche qui exécute la méthode End.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> qui exécute une action de la méthode End quand un <see cref="T:System.IAsyncResult" /> spécifié se termine.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Le <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> surcharges qui prennent un `asyncResult` paramètre ne sont pas aussi efficace que les surcharges qui prennent un `beginMethod` paramètre. Si les performances sont un problème, utilisez les surcharges qui fournissent le `beginMethod` / `endMethod` modèle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="asyncResult" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">IAsyncResult dont l'achèvement doit déclencher le traitement du <paramref name="endMethod" />.</param>
        <param name="endMethod">Délégué de fonction qui traite l'<paramref name="asyncResult" /> terminé.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui exécute une fonction de méthode End quand un <see cref="T:System.IAsyncResult" /> spécifié se termine.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Le <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> surcharges qui prennent un `asyncResult` paramètre ne sont pas aussi efficace que les surcharges qui prennent un `beginMethod` paramètre. Si les performances sont un problème, utilisez les surcharges qui fournissent le `beginMethod` / `endMethod` modèle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="asyncResult" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">IAsyncResult dont l'achèvement doit déclencher le traitement du <paramref name="endMethod" />.</param>
        <param name="endMethod">Délégué de fonction qui traite l'<paramref name="asyncResult" /> terminé.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui exécute une fonction de méthode End quand un <see cref="T:System.IAsyncResult" /> spécifié se termine.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Le <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> surcharges qui prennent un `asyncResult` paramètre ne sont pas aussi efficace que les surcharges qui prennent un `beginMethod` paramètre. Si les performances sont un problème, utilisez les surcharges qui fournissent le `beginMethod` / `endMethod` modèle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="asyncResult" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">IAsyncResult dont l'achèvement doit déclencher le traitement du <paramref name="endMethod" />.</param>
        <param name="endMethod">Délégué de fonction qui traite l'<paramref name="asyncResult" /> terminé.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la tâche qui exécute la méthode End.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui exécute une fonction de méthode End quand un <see cref="T:System.IAsyncResult" /> spécifié se termine.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Le <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> surcharges qui prennent un `asyncResult` paramètre ne sont pas aussi efficace que les surcharges qui prennent un `beginMethod` paramètre. Si les performances sont un problème, utilisez les surcharges qui fournissent le `beginMethod` / `endMethod` modèle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="asyncResult" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du troisième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg3">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg3">Troisième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du troisième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg3">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg3">Troisième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du troisième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg3">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg3">Troisième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Type du deuxième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Type du troisième argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg3">Type du premier argument passé au délégué de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">Délégué qui commence l'opération asynchrone.</param>
        <param name="endMethod">Délégué qui termine l'opération asynchrone.</param>
        <param name="arg1">Premier argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg2">Deuxième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="arg3">Troisième argument passé au délégué de <paramref name="beginMethod" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="beginMethod" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement de la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui représente une paire de méthodes Begin et End conformes au modèle de programmation asynchrone.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> créée qui représente l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `beginMethod` délégué est démarré sur le thread qui <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> s’exécute sur. Cette méthode lève les exceptions levées par le `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="beginMethod" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="endMethod" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Utilisation de la bibliothèque parallèle de tâches (TPL) avec d’autres modèles asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheduler : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le Planificateur de tâches par défaut pour cette fabrique de tâches.</summary>
        <value>Planificateur de tâches par défaut pour cette fabrique de tâches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de propriété utilisée pour planifier toutes les tâches, sauf si un autre planificateur est explicitement spécifié pendant les appels aux méthodes de cette fabrique.  
  
 Si cette valeur de propriété est `null`, la valeur de la <xref:System.Threading.Tasks.TaskScheduler.Current%2A> propriété est utilisée.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode est la méthode recommandée pour lancer une tâche liée aux calculs. Utilisez le <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> méthode uniquement lorsque vous avez besoin d’un contrôle précis pour une tâche de longue durée, liés au calcul. Cela inclut des scénarios dans lesquels vous souhaitez contrôler les éléments suivants :  
  
-   Options de création de tâches. Les tâches créées par le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode par défaut sont créés avec la <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option. Pour remplacer ce comportement, ou pour fournir d’autres <xref:System.Threading.Tasks.TaskCreationOptions> options, appeler un <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> de surcharge.  
  
-   Passage de paramètres. Les surcharges de la <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode ne vous permettent pas de passer un paramètre au délégué de tâche. Les surcharges de la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> méthode effectue.  
  
-   Planificateur de tâches. Les surcharges de la <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode utiliser le Planificateur de tâches par défaut. Pour contrôler le Planificateur de tâches, appeler un <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> surcharge avec un `scheduler` paramètre. Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <summary>Crée et lance une tâche.</summary>
        <returns>Tâche démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> est fonctionnellement équivalent à la création d’une tâche en utilisant un de ses constructeurs, puis en appelant le <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> méthode pour planifier la tâche pour l’exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> un moyen rapide d’appeler la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> avec les paramètres par défaut. Notez, toutefois, qu’il existe une différence de comportement entre les deux méthodes concernant : <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> par défaut n’autorise pas les enfants tâches démarrées avec le <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option d’attachement de l’actuelle <xref:System.Threading.Tasks.Task> de l’instance, tandis que <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> est. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> méthode à appeler à plusieurs reprises un <xref:System.Action> délégué qui génère un nombre aléatoire, il interprète comme un point de code Unicode, le convertit en une unité de code UTF16 encodé et affiche des informations sur le résultat ou les caractères.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel `StartNew` est fonctionnellement équivalent à la création d’une tâche à l’aide d’un de ses constructeurs et les appeler ensuite <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> un moyen rapide d’appeler la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> avec les paramètres par défaut. Notez, toutefois, qu’il existe une différence de comportement entre les deux méthodes concernant : <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> par défaut n’autorise pas les enfants tâches démarrées avec le <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option d’attachement de l’actuelle <xref:System.Threading.Tasks.Task> de l’instance, tandis que <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> est. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> méthode pour créer une tâche qui effectue une itération de fichiers dans le répertoire C:\Windows\System32. L’expression lambda appelle la <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode pour ajouter des informations sur chaque fichier à un <xref:System.Collections.Generic.List%601> objet. Chaque détachée tâche imbriquée appelée par le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> boucle vérifie l’état du jeton d’annulation et, si l’annulation est demandée, appelle le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> méthode lève une exception une <xref:System.OperationCanceledException> exception est gérée dans un `catch` bloquer lorsque le thread appelant appelle la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="action" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task" /> créé.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’une tâche à l’aide d’un de ses constructeurs et les appeler ensuite <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="action" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="action" /> doit utiliser.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task> à l’aide d’un de ses constructeurs, puis en appelant le <xref:System.Threading.Tasks.Task.Start%2A> méthode à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de mots de la lettre de 6. Chaque mot est ensuite transmise à un <xref:System.Action%601> délégué, qui brouille le mot et affiche le mot d’origine et sa version brouillée.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Notez que l’exemple initialise un seul générateur de nombres aléatoires, ce qui est protégé par un verrou. Pour la nécessité d’un verrou, consultez « La sécurité thread et de la classe System.Random » dans le <xref:System.Random> rubrique de la classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="action" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="action" /> doit utiliser.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné au nouveau <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’une tâche à l’aide d’un de ses constructeurs et les appeler ensuite <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de mots de la lettre de 6. Chaque mot est ensuite transmise à un <xref:System.Action%601> délégué, qui brouille le mot et affiche le mot d’origine et sa version brouillée.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Notez que l’exemple initialise un seul générateur de nombres aléatoires, ce qui est protégé par un verrou. Pour la nécessité d’un verrou, consultez « La sécurité thread et de la classe System.Random » dans le <xref:System.Random> rubrique de la classe. Pour gérer la possibilité d’une corruption du Générateur de nombres aléatoires, un jeton d’annulation est passé à la tâche. Si deux nombres aléatoires est égale à zéro, la méthode suppose que le Générateur de nombres aléatoires est endommagé et qu’il définit le jeton d’annulation. Avant de trier les `chars` tableau qui contient les six caractères dans un mot, les appels de méthode le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> méthode lève un <xref:System.OperationCanceledException> si le jeton a été annulé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="action" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="action" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task" /> créé.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’une tâche à l’aide d’un de ses constructeurs et les appeler ensuite <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="action" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné au nouveau <see cref="T:System.Threading.Tasks.Task" /></param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task" /> créé.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’une tâche à l’aide d’un de ses constructeurs et les appeler ensuite <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="action" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">Délégué d'action à exécuter de façon asynchrone.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="action" /> doit utiliser.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task" /> créé.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task" /> créée.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’une tâche à l’aide d’un de ses constructeurs et les appeler ensuite <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez [Task.Run vs Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="action" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez appeler la <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> un moyen rapide d’appeler la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Notez, toutefois, qu’il existe une différence de comportement entre les deux méthodes concernant : <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> par défaut n’autorise pas les enfants tâches démarrées avec le <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option d’attachement de l’actuelle <xref:System.Threading.Tasks.Task%601> de l’instance, tandis que <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> est. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
   
  
## Examples  
 L’exemple suivant est une application d’addition simple qui génère deux nombres aléatoires et invite l’utilisateur à entrer leur somme. Ensuite, il indique que la réponse est correcte ou, si la réponse de l’utilisateur n’est pas un nombre valid, invite l’utilisateur à entrer à nouveau un nombre valide. Le <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> est utilisé pour créer le <xref:System.Threading.Tasks.Task%601> les objets qui retournent les nombres aléatoires à ajouter.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="function" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="function" /> doit utiliser.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné au nouveau <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> un moyen rapide d’appeler la méthode <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> avec les paramètres par défaut. Notez, toutefois, qu’il existe une différence de comportement entre les deux méthodes concernant : <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> par défaut n’autorise pas les enfants tâches démarrées avec le <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option d’attachement de l’actuelle <xref:System.Threading.Tasks.Task%601> de l’instance, tandis que <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> est. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
   
  
## Examples  
 L’exemple suivant utilise deux tâches pour calculer la séquence de Fibonacci se terminant par F100 = F100-1 + F100-2 avec des valeurs de départ F1 = 1, F2 = 1 et F1 = 0, F2 = 1. Environ la moitié du temps, un jeton d’annulation est défini comme les opérations s’exécutent. La sortie de l’exemple montre le résultat si les deux tâches se terminent avec succès et si le jeton est annulé.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task`1" /> créé.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="function" /> doit utiliser.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné au nouveau <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="function" /> doit utiliser.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task`1" /> créé.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task`1" /> créé.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat disponible via le <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Délégué de fonction qui retourne le résultat à venir qui sera mis à disposition via <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Objet contenant des données que le délégué <paramref name="function" /> doit utiliser.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <param name="creationOptions">Valeur TaskCreationOptions qui contrôle le comportement du <see cref="T:System.Threading.Tasks.Task`1" /> créé.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> utilisé pour planifier la <see cref="T:System.Threading.Tasks.Task`1" /> créée.</param>
        <summary>Crée et lance un <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task`1" /> démarrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de StartNew est fonctionnellement équivalent à la création d’un <xref:System.Threading.Tasks.Task%601> à l’aide d’un de ses constructeurs, puis en appelant <xref:System.Threading.Tasks.Task.Start%2A> à planifier son exécution.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Run%2A> méthode avec un <xref:System.Action> objet comme un moyen rapide d’appeler <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> avec les paramètres par défaut. Pour plus d’informations et des exemples de code, consultez l’entrée [Task.Run vs. Task.Factory.StartNew](https://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">Exception levée quand l’argument <paramref name="function" /> a la valeur Null.  
  
- ou - 
Exception levée quand l’argument <paramref name="scheduler" /> a la valeur Null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Exception levée lorsque l'argument <paramref name="creationOptions" /> spécifie une valeur TaskCreationOptions non valide. Pour plus d'informations, consultez la section Notes de la rubrique <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
  </Members>
</Type>