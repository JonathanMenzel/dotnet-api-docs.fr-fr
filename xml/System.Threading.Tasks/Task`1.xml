<Type Name="Task&lt;TResult&gt;" FullName="System.Threading.Tasks.Task&lt;TResult&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0672afde2f885feadb0e6572c0374c7b21c72595" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58746028" /></Metadata><TypeSignature Language="C#" Value="public class Task&lt;TResult&gt; : System.Threading.Tasks.Task" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task`1&lt;TResult&gt; extends System.Threading.Tasks.Task" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Task(Of TResult)&#xA;Inherits Task" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class Task : System::Threading::Tasks::Task" />
  <TypeSignature Language="F#" Value="type Task&lt;'Result&gt; = class&#xA;    inherit Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Threading.Tasks.Task</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TResult">Type du résultat produit par ce <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
    <summary>Représente une opération asynchrone qui peut retourner une valeur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task%601> classe représente une opération unique qui retourne une valeur et qui généralement exécute de façon asynchrone. <xref:System.Threading.Tasks.Task%601> les objets sont l’un des composants centrales de la [modèle asynchrone basé sur les tâches](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) introduite dans .NET Framework 4. Étant donné que le travail effectué par un <xref:System.Threading.Tasks.Task%601> objet généralement exécute de façon asynchrone sur un thread de pool de threads plutôt que de façon synchrone sur le thread principal de l’application, vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Status%2A> propriété, ainsi que le <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, et <xref:System.Threading.Tasks.Task.IsFaulted%2A> propriétés, pour déterminer l’état d’une tâche. En règle générale, une expression lambda est utilisée pour spécifier le travail de la tâche consiste à effectuer.  
  
 <xref:System.Threading.Tasks.Task%601> instances peuvent être créées de plusieurs façons. L’approche la plus courante, qui est disponible à partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], consiste à appeler la méthode statique <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> (méthode). Ces méthodes fournissent un moyen simple pour démarrer une tâche à l’aide des valeurs par défaut et sans l’acquisition des paramètres supplémentaires. L’exemple suivant utilise la <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> méthode pour démarrer une tâche qui effectue une itération, puis affiche le nombre d’itérations de boucle :  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task\`1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/run1.vb#6)]  
  
 Une alternative et la méthode la plus courante pour démarrer une tâche dans le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], consiste à appeler la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propriété retourne un <xref:System.Threading.Tasks.TaskFactory> objet et le <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> propriété retourne un <xref:System.Threading.Tasks.TaskFactory%601> objet. Les surcharges de leur `StartNew` méthode vous permettre de passer des arguments, définir les options de création de tâche, et spécifier un planificateur de tâches. L’exemple suivant utilise la <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> méthode pour démarrer une tâche. Il est fonctionnellement équivalent au code dans l’exemple précédent.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task\`1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/startnew1.vb#7)]  
  
 Pour obtenir des exemples plus complets, consultez [basé sur des tâches de programmation asynchrone](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
 Le <xref:System.Threading.Tasks.Task%601> classe fournit également des constructeurs qui initialisent la tâche mais qui ne le planifiez pas pour l’exécution. Pour des raisons de performances, le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> et `Task.Factory.StartNew` méthodes sont les mécanismes préférés pour la création et la planification des tâches de calculs, mais pour les scénarios où la création de tâches et la planification doivent être séparés, les constructeurs peuvent être utilisés et le la tâche <xref:System.Threading.Tasks.Task.Start%2A> méthode peut ensuite être utilisée pour planifier la tâche pour l’exécution à un moment ultérieur.  
  
 À partir des applications de bureau qui ciblent le [!INCLUDE[net_v46](~/includes/net-v46-md.md)], la culture du thread qui crée et appelle une tâche devient partie intégrante du contexte du thread. Autrement dit, quel que soit la culture actuelle du thread sur lequel la tâche s’exécute, la culture actuelle de la tâche est la culture du thread appelant. Pour les applications qui ciblent des versions du .NET Framework antérieures à la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], la culture de la tâche est la culture du thread sur lequel la tâche s’exécute. Pour plus d’informations, consultez la section « Culture et opérations asynchrones basées sur une tâche » dans le <xref:System.Globalization.CultureInfo> rubrique. Notez que les applications de Store suivent le Runtime Windows dans la définition et l’obtention de la culture par défaut.  
  
Pour les opérations qui ne retournent pas de valeur, vous utilisez la <xref:System.Threading.Tasks.Task> classe. En commençant par C# 7.0, pour une tâche plus légère qui est un type valeur plutôt qu’un type référence, utilisez le <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> structure. 
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres de <see cref="T:System.Threading.Tasks.Task`1" />, à l’exception de <see cref="M:System.Threading.Tasks.Task.Dispose" />, sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise un nouvel objet <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; function" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec la fonction spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur doit uniquement être utilisé dans les scénarios avancés où il est nécessaire que la création et le démarrage de la tâche est séparé.  
  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType> méthodes.  
  
 Si une tâche avec aucune action n’est nécessaire uniquement pour le consommateur d’une API pour mettre quelque chose à attendre, un <xref:System.Threading.Tasks.TaskCompletionSource%601> doit être utilisé.  
  
   
  
## Examples  
 L’exemple suivant compte le nombre approximatif de mots contenus dans les fichiers texte qui représentent la documentation publiée. Chaque tâche est chargée d’ouvrir un fichier, lire son contenu entier de manière asynchrone et calculer le nombre de mots à l’aide d’une expression régulière. Le <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> méthode est appelée pour vous assurer que toutes les tâches terminées avant d’afficher le nombre de mots de chaque ouvrage sur la console.  
  
 Instanciation d’objet est séparée de l’exécution d’objet dans cet exemple afin que l’exemple peut vous assurer que chaque fichier existe. Dans le cas contraire, il affiche le nom du fichier manquant. Sinon, elle appelle le <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> méthode pour lancer chaque tâche.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run3.vb#2)]  
  
 Le modèle d’expression régulière `\p{P}*\s+` correspond à zéro, une ou plusieurs caractères de ponctuation suivis d’un ou plusieurs caractères d’espace blanc. Il suppose que le nombre total de correspondances est égale au nombre approximatif de word.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="state">Objet représentant les données que l'action doit utiliser.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec la fonction et l'état spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> à assigner à cette tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec la fonction spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> méthodes. Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec la fonction spécifiée et les options de création.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="state">Objet représentant les données que la fonction doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> à assigner à la nouvelle tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec l'action, l'état et les options spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="state">Objet représentant les données que la fonction doit utiliser.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec l'action, l'état et les options spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec la fonction spécifiée et les options de création.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> (méthode).  Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Délégué qui représente le code à exécuter dans la tâche. Lorsque cette fonction aura terminé, la propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> de la tâche sera configurée pour retourner la valeur de résultat de la fonction.</param>
        <param name="state">Objet représentant les données que la fonction doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> à assigner à la nouvelle tâche.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> avec l'action, l'état et les options spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task%601> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="function" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1&lt;!TResult&gt; ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="override this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;'Result&gt;" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">True en cas de tentative de marshaling de la continuation vers le contexte d'origine capturé ; sinon, false.</param>
        <summary>Configure un élément awaiter utilisé pour attendre cette <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Objet utilisé pour attendre cette tâche.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une tâche de continuation qui s’exécute lorsqu’une autre tâche se termine.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand la <see cref="T:System.Threading.Tasks.Task`1" /> antécédente se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <summary>Crée une continuation qui s’exécute de façon asynchrone quand la tâche cible se termine.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou quitter tôt suite à son annulation.  
  
   
  
## Examples  
 L’exemple suivant crée une tâche d’antécédent qui utilise le crible d’Ératosthène pour calculer les nombres premiers entre 1 et une valeur entrée par l’utilisateur. Un tableau est utilisé pour contenir des informations sur les nombres premiers. L’index du tableau représente le nombre et la valeur de l’élément indique si ce nombre est composite (sa valeur est `true`) ou de la prime (sa valeur est `false`). Cette tâche est ensuite transmise à une tâche de continuation, qui est chargée d’extraire les nombres premiers du tableau d’entiers et de les afficher.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l’exécution, la tâche achevée et l’objet d’état fourni par l’appelant sont passés comme arguments au délégué.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <summary>Crée une continuation à laquelle sont passées des informations d’état et qui s’exécute quand le <see cref="T:System.Threading.Tasks.Task`1" /> cible s’exécute.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
   
  
## Examples  
 L’exemple suivant crée une tâche qui est transmise à un entier compris entre 2 et 20 et retourne un tableau qui contient les dix premières exposants (à partir de n<sup>1</sup> à n<sup>10</sup>) de ce nombre. Une tâche de continuation est ensuite chargée d’afficher les exposants. Il est passé à la fois l’antécédent et le numéro d’origine dont les exposants génère l’antécédent.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continuewith3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continuewith3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu’argument.</param>
        <param name="cancellationToken">Jeton d’annulation passé à la nouvelle tâche de continuation.</param>
        <summary>Crée une continuation pouvant être annulée qui s’exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
   
  
## Examples  
 L’exemple suivant crée une tâche d’antécédent qui utilise le crible d’Ératosthène pour calculer les nombres premiers entre 1 et une valeur entrée par l’utilisateur. Un tableau est utilisé pour contenir des informations sur les nombres premiers. L’index du tableau représente le nombre et la valeur de l’élément indique si ce nombre est composite (sa valeur est `true`) ou de la prime (sa valeur est `false`). Cette tâche est ensuite transmise à une tâche de continuation, qui est chargée d’extraire les nombres premiers du tableau d’entiers et de les afficher.  
  
 Un jeton d’annulation est passé à l’antécédent et la tâche de continuation. Un <xref:System.Timers.Timer?displayProperty=nameWithType> objet est utilisé pour définir une valeur de délai d’expiration de 100 millisecondes. Si l’événement est déclenché, le <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> méthode est appelée, et le jeton d’annulation est utilisé pour demander l’annulation des tâches.  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue1.vb#1)]  
  
 En règle générale, en fournissant une valeur d’environ 100 000 provoque l’intervalle de délai d’attente expire et le <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> l’événement et la demande d’annulation à définir.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.  
  
ou 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter selon la condition spécifiée dans <paramref name="continuationOptions" />. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s'exécute en fonction de la condition spécifiée dans les <paramref name="continuationOptions" />.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères de continuation spécifiés via le `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 Pour plus d’informations, consultez [Chaînage des tâches à l’aide de tâches de continuation](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d’exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères de continuation spécifiés via le `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter selon la condition spécifiée dans <paramref name="continuationOptions" />. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute en fonction de la condition spécifiée dans les <paramref name="continuationOptions" />.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères spécifiés par le biais du `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée. Pour plus d’informations, consultez [Chaînage des tâches à l’aide de tâches de continuation](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.  
  
ou 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d’exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères spécifiés par le biais du `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult)) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
   
  
## Examples  
 L’exemple suivant crée une chaîne de tâches de continuation. Chaque tâche fournit l’heure actuelle, un <xref:System.DateTime> objet, pour l’argument d’état de la <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29> (méthode). Chaque <xref:System.DateTime> valeur représente l’heure de création de la tâche de continuer. Chaque tâche génère un deuxième <xref:System.DateTime> valeur qui représente l’heure à laquelle la tâche se termine. Une fois toutes les tâches, l’exemple affiche les date et heure à laquelle chaque tâche de continuation commence et se termine.  
  
 [!code-csharp[TPL_ContinuationState#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.  
  
ou 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter selon la condition spécifiée dans <paramref name="continuationOptions" />.  
  
Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s'exécute en fonction de la condition spécifiée dans les <paramref name="continuationOptions" />.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 Le `continuationFunction`est exécuté, doit retourner un <xref:System.Threading.Tasks.Task%601>. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 Le `continuationFunction`est exécuté, doit retourner un <xref:System.Threading.Tasks.Task%601>. État d’achèvement de cette tâche est transférée à la tâche retournée à partir de l’appel de ContinueWith.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter selon la condition spécifiée dans <paramref name="continuationOptions" />.  
  
Une fois exécuté, le délégué passera cette tâche achevée en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute en fonction de la condition spécifiée dans les <paramref name="continuationOptions" />.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 Le `continuationFunction`est exécuté, doit retourner un <xref:System.Threading.Tasks.Task%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task`1" /> a été supprimé.  
  
ou 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute quand la <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 Le `continuationFunction`est exécuté, doit retourner un <xref:System.Threading.Tasks.Task%601>. État d’achèvement de cette tâche est transférée vers la tâche retournée à partir de la <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> appeler.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Chaînage des tâches à l’aide de tâches de continuation</related>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory&lt;TResult&gt; Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory`1&lt;!TResult&gt; Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ Factory { System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit l’accès aux méthodes de fabrique pour la création et la configuration d’instances de <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Objet de fabrique pouvant créer une variété d'objets <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne une instance par défaut de la <xref:System.Threading.Tasks.TaskFactory%601> classe qui est identique à celui créé par un appel sans paramètre <xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType> constructeur. Il a les valeurs de propriété suivantes :  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory%601.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.Scheduler%2A?displayProperty=nameWithType>|`null`, ou <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 L’utilisation la plus courante de cette propriété consiste à créer et démarrer une nouvelle tâche dans un seul appel à la <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode fournit le moyen le plus simple de créer un <xref:System.Threading.Tasks.Task%601> objet avec les valeurs de configuration par défaut.  
  
 L’exemple suivant utilise la méthode statique <xref:System.Threading.Tasks.Task%601.Factory%2A> propriété afin que les trois appels vers le <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> (méthode). La première valeur démarre un `Task<Int32>` objet, qui exécute une expression lambda qui retourne la valeur 1. La deuxième démarre un `Task<Test>` objet, qui exécute une expression lambda qui instancie un nouveau `Test` instance. Le troisième démarre un `Task<String[]>` objet, qui énumère les fichiers dans le répertoire C:\Users\Public\Pictures\Sample Pictures\. (Notez que l’exécution réussie de l’exemple nécessite que le répertoire existe et qu’il contient des fichiers.  
  
 [!code-csharp[TPL#10](~/samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/returnavalue10.cs#10)]
 [!code-vb[TPL#10](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/10_returnavalue.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt; GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter`1&lt;!TResult&gt; GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter&lt;TResult&gt; GetAwaiter();" />
      <MemberSignature Language="F#" Value="override this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter&lt;'Result&gt;" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un élément awaiter utilisé pour attendre cette <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>Une instance d'élément awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est conçue pour l’utilisateur du compilateur plutôt que d’utiliser directement dans le code.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public TResult Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TResult Result" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Result" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Result As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TResult Result { TResult get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : 'Result" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur de résultat de <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>La valeur de résultat de cette <see cref="T:System.Threading.Tasks.Task`1" />, qui est du même type en tant que paramètre de type de la tâche.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’accès à d’accesseur get de la propriété bloque le thread appelant jusqu'à ce que l’opération asynchrone est terminée ; Il équivaut à appeler le <xref:System.Threading.Tasks.Task.Wait%2A> (méthode).  
  
 Une fois que le résultat d’une opération est disponible, il est stocké et est retourné immédiatement sur les appels suivants à la <xref:System.Threading.Tasks.Task%601.Result%2A> propriété. Notez que, si une exception s’est produite pendant l’opération de la tâche, ou si la tâche a été annulée, le <xref:System.Threading.Tasks.Task%601.Result%2A> propriété ne retourne pas de valeur. Au lieu de cela, essayez d’accéder à la propriété valeur lève une <xref:System.AggregateException> exception.  
  
   
  
## Examples  
 L’exemple suivant est un utilitaire de ligne de commande qui calcule le nombre d’octets dans les fichiers dans chaque annuaire dont le nom est passé comme un argument de ligne de commande. Si le répertoire contient des fichiers, il exécute une expression lambda qui instancie un <xref:System.IO.FileStream> objet pour chaque fichier dans le répertoire et récupère la valeur de son <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> propriété. Si un répertoire ne contient aucun fichier, il appelle simplement la <xref:System.Threading.Tasks.Task.FromResult%2A> méthode pour créer une tâche dont <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriété est zéro (0). Lorsque les tâches se terminent, le nombre total d’octets dans les fichiers de tous les un répertoire est disponible à partir de la <xref:System.Threading.Tasks.Task%601.Result%2A> propriété.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AggregateException">La tâche a été annulée. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient un objet <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
ou 
Une exception a été levée pendant l’exécution de la tâche. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient des informations sur l’exception ou les exceptions.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md">Comment : retourner une valeur à partir d'une tâche</related>
      </Docs>
    </Member>
  </Members>
</Type>