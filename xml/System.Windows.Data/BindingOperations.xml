<Type Name="BindingOperations" FullName="System.Windows.Data.BindingOperations">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4601fcaf8f086826132c17425f722a0180d270b0" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52236437" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class BindingOperations" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BindingOperations extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingOperations" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingOperations" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingOperations abstract sealed" />
  <TypeSignature Language="F#" Value="type BindingOperations = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des méthodes statiques pour manipuler des liaisons, notamment des objets <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" /> et <see cref="T:System.Windows.Data.PriorityBinding" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe expose un ensemble de méthodes statiques qui servent d’opérations d’assistance pour les liaisons de données.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessCollection">
      <MemberSignature Language="C#" Value="public static void AccessCollection (System.Collections.IEnumerable collection, Action accessMethod, bool writeAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AccessCollection(class System.Collections.IEnumerable collection, class System.Action accessMethod, bool writeAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AccessCollection (collection As IEnumerable, accessMethod As Action, writeAccess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AccessCollection(System::Collections::IEnumerable ^ collection, Action ^ accessMethod, bool writeAccess);" />
      <MemberSignature Language="F#" Value="static member AccessCollection : System.Collections.IEnumerable * Action * bool -&gt; unit" Usage="System.Windows.Data.BindingOperations.AccessCollection (collection, accessMethod, writeAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="accessMethod" Type="System.Action" />
        <Parameter Name="writeAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="collection">Collection à laquelle accéder.</param>
        <param name="accessMethod">Action à exécuter sur la collection.</param>
        <param name="writeAccess">
          <see langword="true" /> si <paramref name="accessMethod" /> écrira dans la collection ; sinon, <see langword="false" />.</param>
        <summary>Permet d'accéder à une collection à l'aide du mécanisme de synchronisation que l'application a spécifié lorsqu'elle a appelé EnableCollectionSynchronization.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllBindings">
      <MemberSignature Language="C#" Value="public static void ClearAllBindings (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllBindings(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllBindings (target As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllBindings(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ClearAllBindings : System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearAllBindings target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Objet à partir duquel supprimer les liaisons.</param>
        <summary>Supprime toutes les liaisons, notamment les liaisons de type <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" /> et <see cref="T:System.Windows.Data.PriorityBinding" />, à partir du <see cref="T:System.Windows.DependencyObject" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’objet spécifié n’est pas lié aux données, cette méthode n’a aucun effet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Si <paramref name="target" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearBinding">
      <MemberSignature Language="C#" Value="public static void ClearBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearBinding (target As DependencyObject, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member ClearBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet à partir duquel supprimer la liaison.</param>
        <param name="dp">Propriété de dépendance à partir de laquelle la liaison doit être supprimée.</param>
        <summary>Supprime la liaison d’une propriété, le cas échéant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la propriété donnée est lié aux données avec un <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, ou <xref:System.Windows.Data.MultiBinding>, cette méthode supprime l’expression de liaison et des restaurations la valeur de la propriété pour qu’il avait avant toute valeur locale a été définie par la liaison correspondante.  
  
 Si la propriété donnée n’est pas lié aux données, cette méthode n’a aucun effet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas avoir la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionRegisteringEventArgs ^&gt; ^ CollectionRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionRegistering : EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " Usage="member this.CollectionRegistering : System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le système de liaison de données remarque une collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionViewRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionViewRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionViewRegisteringEventArgs ^&gt; ^ CollectionViewRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionViewRegistering : EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " Usage="member this.CollectionViewRegistering : System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le système de liaison de données remarque une vue de collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void DisableCollectionSynchronization (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DisableCollectionSynchronization(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DisableCollectionSynchronization (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DisableCollectionSynchronization(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="static member DisableCollectionSynchronization : System.Collections.IEnumerable -&gt; unit" Usage="System.Windows.Data.BindingOperations.DisableCollectionSynchronization collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">Collection pour laquelle supprimer l'accès synchronisé.</param>
        <summary>Supprime la synchronisation enregistrée pour la collection spécifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectedSource">
      <MemberSignature Language="C#" Value="public static object DisconnectedSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object DisconnectedSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DisconnectedSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ DisconnectedSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectedSource : obj" Usage="System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui remplace le <see cref="P:System.Windows.FrameworkElement.DataContext" /> lorsqu'un conteneur d'éléments est supprimé de l'arborescence d'éléments visuels.</summary>
        <value>Objet qui remplace le <see cref="P:System.Windows.FrameworkElement.DataContext" /> lorsqu'un conteneur d'éléments est supprimé de l'arborescence d'éléments visuels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété si vous avez besoin gérer la <xref:System.Windows.FrameworkElement.DataContext%2A> d’un conteneur d’éléments.  Un conteneur d’élément est l’élément d’interface utilisateur qui affiche un élément dans un <xref:System.Windows.Controls.ItemsControl>.  Quand un <xref:System.Windows.Controls.ItemsControl> données n’est lié à une collection, un conteneur d’éléments est généré pour chaque élément.  Dans certains cas, les conteneurs d’éléments sont supprimés de l’arborescence d’éléments visuels.  Les deux cas classiques où un conteneur d’élément est supprimé sont quand un élément est supprimé de la collection sous-jacente, et lorsque la virtualisation est activée sur le <xref:System.Windows.Controls.ItemsControl>.  Dans ces cas, le <xref:System.Windows.FrameworkElement.DataContext%2A> propriété du conteneur d’élément est définie le <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> propriété, vous devez vérifier si le <xref:System.Windows.FrameworkElement.DataContext%2A> est égal à la <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> avant d’accéder à la <xref:System.Windows.FrameworkElement.DataContext%2A> dans le <xref:System.Windows.FrameworkElement.DataContextChanged> événement pour l’élément conteneurs. Pour plus d’informations sur la virtualisation et les conteneurs d’éléments, consultez la section Notes dans la <xref:System.Windows.Controls.VirtualizingStackPanel> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnableCollectionSynchronization">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Permet à un objet <see cref="T:System.Windows.Data.CollectionView" /> de participer à un accès synchronisé à une collection utilisée sur plusieurs threads.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Une application WPF peut afficher une collection de données à l’aide un <xref:System.Windows.Controls.ItemsControl> ou une de ses sous-classes (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>, etc.). Les canaux de WPF tout son accès à la collection via une sous-classe de <xref:System.Windows.Data.CollectionView>. À la fois le <xref:System.Windows.Controls.ItemsControl> et <xref:System.Windows.Data.CollectionView> ont une affinité au thread sur lequel le <xref:System.Windows.Controls.ItemsControl> a été créé, ce qui signifie que leur utilisation sur un autre thread n’est pas autorisé et lève une exception. En effet, cette restriction s’applique à la collection également.
 
Voulez-vous utiliser le regroupement sur plusieurs threads.   Par exemple, vous souhaitez mettre à jour de la collection (ajouter ou supprimer des éléments) sur un thread « collecte de données », tout en affichant les résultats sur un thread « interface utilisateur », afin que l’interface utilisateur reste réactive lors de la collecte de données qui se passe. Dans ce cas, vous êtes responsable de l’accès synchronisé de (« thread-safe ») à la collection.   Cela s’effectue généralement à l’aide d’un mécanisme de verrouillage simple ou un mécanisme de synchronisation plus élaboré comme sémaphores, événements, etc. de réinitialisation.   Bien que vous devez synchroniser l’accès de votre application à la collection, vous devez également vous assurer que l’accès à partir de WPF (en particulier en <xref:System.Windows.Data.CollectionView>) participe le même mécanisme de synchronisation.  Pour ce faire, appelez la méthode <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A>.
 
Pour utiliser un regroupement sur plusieurs threads, y compris le thread d’interface utilisateur qui détient le <xref:System.Windows.Controls.ItemsControl>, une application responsabilités est les suivantes :

1. Choisir un mécanisme de synchronisation.

1. Synchroniser tous les accès à partir de l’application à la collection à l’aide de ce mécanisme.

1. Appelez <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> pour informer WPF du mécanisme.

   - L’appel doit se produire sur le thread d’interface utilisateur.

   - L’appel doit se produire avant à l’aide de la collection sur un thread différent ou avant d’attacher la collection à le <xref:System.Windows.Controls.ItemsControl>, selon ce qui est plus loin.

   - Appelez le <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> surcharge si vous utilisez un mécanisme de verrouillage simple ; appel le <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> surcharge si vous utilisez un mécanisme plus élaboré.

1. Vérifiez qu’une modification apportée à la collection et la notification de cette modification (via <xref:System.Collections.Specialized.INotifyCollectionChanged>) sont atomique ; aucun accès à partir d’autres threads ne peuvent intervenir.  (Cela est généralement proposé gratuitement. For instance, <xref:System.Collections.ObjectModel.ObservableCollection%601> , garantit à condition que toutes les modifications sont protégées par la synchronisation.)

1. Si vous appelez <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, qu’appel doit également se produire sur le thread d’interface utilisateur.

1. Si vous souhaitez utiliser la même collection sur plusieurs threads d’interface utilisateur, vous devez appeler <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (et <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, si nécessaire) séparément sur chaque thread d’interface utilisateur.

1. Éviter un blocage.  Il s’agit déjà responsabilité de l’application une fois qu’elle choisit d’utiliser la synchronisation, mais il doit également prendre en la participation de WPF de compte dans la synchronisation, comme indiqué dans le paragraphe suivant.

En retour, WPF fournit le comportement suivant :

- Le <xref:System.Windows.Data.CollectionView> accède à la collection à l’aide du mécanisme de synchronisation donnée.

- Le <xref:System.Windows.Data.CollectionView> conserve un « cliché instantané » de la collection pour une utilisation sur le thread d’interface utilisateur.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> événements file quand ils arrivent (sur n’importe quel thread).

- Événements en attente sont appliquées à la copie miroir de façon asynchrone sur le thread d’interface utilisateur lorsqu’il a la possibilité de le faire.

- Le <xref:System.Windows.Data.CollectionView> ne sont pas utiliser directement n’importe quel mécanisme de synchronisation visible par l’application. Il s’agit moyen de WPF de la façon d’éviter un blocage (voir l’élément précédent 7).   

L’effet net est que vous pouvez modifier la collection sur n’importe quel thread, et ces modifications apparaissent dans le <xref:System.Windows.Controls.ItemsControl> lorsque le thread d’interface utilisateur a le temps de « rattraper ».  L’implémentation a été paramétrée pour limiter le taux de modifications de flux dans le thread d’interface utilisateur pour conserver l’arrière-plan des threads à partir de saturer le thread d’interface utilisateur et au détriment de la réponse à une entrée utilisateur normal.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object lockObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object lockObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, lockObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ lockObject);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, lockObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="lockObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="collection">Collection qui a besoin de l’accès synchronisé.</param>
        <param name="lockObject">Objet à verrouiller lors de l’accès à la collection.</param>
        <summary>Permet à un objet <see cref="T:System.Windows.Data.CollectionView" /> de participer à un accès synchronisé à une collection utilisée sur plusieurs threads avec un mécanisme de verrouillage simple.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Une application WPF peut afficher une collection de données à l’aide un <xref:System.Windows.Controls.ItemsControl> ou une de ses sous-classes (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>, etc.). Les canaux de WPF tout son accès à la collection via une sous-classe de <xref:System.Windows.Data.CollectionView>. À la fois le <xref:System.Windows.Controls.ItemsControl> et <xref:System.Windows.Data.CollectionView> ont une affinité au thread sur lequel le <xref:System.Windows.Controls.ItemsControl> a été créé, ce qui signifie que leur utilisation sur un autre thread n’est pas autorisé et lève une exception. En effet, cette restriction s’applique à la collection également.
 
Voulez-vous utiliser le regroupement sur plusieurs threads.   Par exemple, vous souhaitez mettre à jour de la collection (ajouter ou supprimer des éléments) sur un thread « collecte de données », tout en affichant les résultats sur un thread « interface utilisateur », afin que l’interface utilisateur reste réactive lors de la collecte de données qui se passe. Dans ce cas, vous êtes chargé de garantir un accès (« thread-safe ») à la collection et pour garantir que l’accès à partir de WPF synchronisé (en particulier en <xref:System.Windows.Data.CollectionView>) fait partie dans le même mécanisme de synchronisation. En appelant le <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> (méthode), vous pouvez faire à l’aide d’un mécanisme de verrouillage simple. 
 
Pour utiliser un regroupement sur plusieurs threads, y compris le thread d’interface utilisateur qui détient le <xref:System.Windows.Controls.ItemsControl>, vous devez procédez comme suit :

1. Instanciez un objet à verrouiller lors de l’accès à la collection.

1. Synchroniser tous les accès à partir de l’application à la collection par un verrouillage de cet objet.

1. Appelez <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> pour informer WPF que vous utilisez un mécanisme de verrouillage simple.

   - L’appel doit se produire sur le thread d’interface utilisateur.

   - L’appel doit se produire avant à l’aide de la collection sur un thread différent ou avant d’attacher la collection à le <xref:System.Windows.Controls.ItemsControl>, selon ce qui est plus loin.

1. Vérifiez qu’une modification apportée à la collection et la notification de cette modification (via <xref:System.Collections.Specialized.INotifyCollectionChanged>) sont atomique ; aucun accès à partir d’autres threads ne peuvent intervenir.  (Cela est généralement proposé gratuitement. For instance, <xref:System.Collections.ObjectModel.ObservableCollection%601> , garantit à condition que toutes les modifications sont protégées par la synchronisation.)

1. Si vous appelez <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, qu’appel doit également se produire sur le thread d’interface utilisateur.

1. Si vous souhaitez utiliser la même collection sur plusieurs threads d’interface utilisateur, vous devez appeler <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (et <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, si nécessaire) séparément sur chaque thread d’interface utilisateur.

1. Éviter un blocage.  Il s’agit déjà responsabilité de l’application une fois qu’elle choisit d’utiliser la synchronisation, mais il doit également prendre en compte la participation de WPF dans la synchronisation. (Voir plus d’informations, ci-dessous.)

En retour, WPF fournit le comportement suivant :

- Le <xref:System.Windows.Data.CollectionView> accède à la collection en utilisant le mécanisme de verrouillage.

- Le <xref:System.Windows.Data.CollectionView> conserve un « cliché instantané » de la collection pour une utilisation sur le thread d’interface utilisateur.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> événements file quand ils arrivent (sur n’importe quel thread).

- Événements en attente sont appliquées à la copie miroir de façon asynchrone sur le thread d’interface utilisateur lorsqu’il a la possibilité de le faire.

- Le <xref:System.Windows.Data.CollectionView> n’utilisera pas directement n’importe quel mécanisme de synchronisation visible par l’application. Il s’agit moyen de WPF de la façon d’éviter un blocage (voir l’élément précédent 7).   

L’effet net est que vous pouvez modifier la collection sur n’importe quel thread, et ces modifications apparaissent dans le <xref:System.Windows.Controls.ItemsControl> lorsque le thread d’interface utilisateur a le temps de « rattraper ».  L’implémentation a été paramétrée pour limiter le taux de modifications de flux dans le thread d’interface utilisateur pour conserver l’arrière-plan des threads à partir de saturer le thread d’interface utilisateur et au détriment de la réponse à une entrée utilisateur normal.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object context, System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object context, class System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, context As Object, synchronizationCallback As CollectionSynchronizationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ context, System::Windows::Data::CollectionSynchronizationCallback ^ synchronizationCallback);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj * System.Windows.Data.CollectionSynchronizationCallback -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, context, synchronizationCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="context" Type="System.Object" />
        <Parameter Name="synchronizationCallback" Type="System.Windows.Data.CollectionSynchronizationCallback" />
      </Parameters>
      <Docs>
        <param name="collection">Collection qui a besoin de l’accès synchronisé.</param>
        <param name="context">Objet qui est passé au rappel.</param>
        <param name="synchronizationCallback">Rappel qui est appelé chaque fois que l’accès à la collection est nécessaire. Vous pouvez l’utiliser pour garantir que la collection est accessible par un seul thread à la fois.</param>
        <summary>Permet à un objet <see cref="T:System.Windows.Data.CollectionView" /> de participer à un accès synchronisé à une collection utilisée sur plusieurs threads avec un mécanisme de verrouillage autre qu’un verrou simple.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Une application WPF peut afficher une collection de données à l’aide un <xref:System.Windows.Controls.ItemsControl> ou une de ses sous-classes (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>, etc.). Les canaux de WPF tout son accès à la collection via une sous-classe de <xref:System.Windows.Data.CollectionView>. À la fois le <xref:System.Windows.Controls.ItemsControl> et <xref:System.Windows.Data.CollectionView> ont une affinité au thread sur lequel le <xref:System.Windows.Controls.ItemsControl> a été créé, ce qui signifie que leur utilisation sur un autre thread n’est pas autorisé et lève une exception. En effet, cette restriction s’applique à la collection également.
 
Voulez-vous utiliser le regroupement sur plusieurs threads.   Par exemple, vous souhaitez mettre à jour de la collection (ajouter ou supprimer des éléments) sur un thread « collecte de données », tout en affichant les résultats sur un thread « interface utilisateur », afin que l’interface utilisateur reste réactive lors de la collecte de données qui se passe. Dans ce cas, vous êtes chargé de garantir un accès (« thread-safe ») à la collection et pour garantir que l’accès à partir de WPF synchronisé (en particulier en <xref:System.Windows.Data.CollectionView>) fait partie dans le même mécanisme de synchronisation. En appelant le <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> (méthode), vous pouvez faire à l’aide d’un mécanisme de synchronisation comme un sémaphores, d’un événement de réinitialisation, etc.   Pour utiliser un regroupement sur plusieurs threads, y compris le thread d’interface utilisateur qui détient le <xref:System.Windows.Controls.ItemsControl>, vous devez procédez comme suit :

1. Choisir un mécanisme de synchronisation.

1. Synchroniser tous les accès à partir de l’application à la collection à l’aide de ce mécanisme.

1. Appelez le <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> surcharge pour informer WPF que vous utilisez un mécanisme autre que de verrouillage simple.

   - L’appel doit se produire sur le thread d’interface utilisateur.

   - L’appel doit se produire avant à l’aide de la collection sur un thread différent ou avant d’attacher la collection à le <xref:System.Windows.Controls.ItemsControl>, selon ce qui est plus loin.

1. Vérifiez qu’une modification apportée à la collection et la notification de cette modification (via <xref:System.Collections.Specialized.INotifyCollectionChanged>) sont atomique ; aucun accès à partir d’autres threads ne peuvent intervenir.  (Cela est généralement proposé gratuitement. For instance, <xref:System.Collections.ObjectModel.ObservableCollection%601> , garantit à condition que toutes les modifications sont protégées par la synchronisation.)

1. Si vous appelez <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, qu’appel doit également se produire sur le thread d’interface utilisateur.

1. Si vous souhaitez utiliser la même collection sur plusieurs threads d’interface utilisateur, vous devez appeler <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (et <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, si nécessaire) séparément sur chaque thread d’interface utilisateur.

1. Éviter un blocage.  Il s’agit déjà responsabilité de l’application une fois qu’elle choisit d’utiliser la synchronisation, mais il doit également prendre en compte la participation de WPF dans la synchronisation. (Voir plus d’informations, ci-dessous.)

En retour, WPF fournit le comportement suivant :

- Le <xref:System.Windows.Data.CollectionView> accède à la collection en appelant inscrit <xref:System.Windows.Data.CollectionSynchronizationCallback> avec les arguments suivants :

   - `collection`: la collection d’intérêt.
   - `context`: l’objet de contexte enregistré.
   - `accessMethod`: un délégué qui effectue l’accès réel.
   - `writeAccess`: `true` si le délégué modifiera la collection ; `false` dans le cas contraire.

   Votre <xref:System.Windows.Data.CollectionSynchronizationCallback> doit établir la synchronisation sur la collection (à l’aide de la `context` objet et le `writeAccess` valeur, comme il convient), appeler le `accessMethod`, puis relâchez la synchronisation.

- Le <xref:System.Windows.Data.CollectionView> conserve un « cliché instantané » de la collection pour une utilisation sur le thread d’interface utilisateur.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> événements file quand ils arrivent (sur n’importe quel thread).

- Événements en attente sont appliquées à la copie miroir de façon asynchrone sur le thread d’interface utilisateur lorsqu’il a la possibilité de le faire.

- Le <xref:System.Windows.Data.CollectionView> n’utilisera pas directement n’importe quel mécanisme de synchronisation visible par l’application. Il s’agit moyen de WPF de la façon d’éviter un blocage (voir l’élément précédent 7).   

L’effet net est que vous pouvez modifier la collection sur n’importe quel thread, et ces modifications apparaissent dans le <xref:System.Windows.Controls.ItemsControl> lorsque le thread d’interface utilisateur a le temps de « rattraper ».  L’implémentation a été paramétrée pour limiter le taux de modifications de flux dans le thread d’interface utilisateur pour conserver l’arrière-plan des threads à partir de saturer le thread d’interface utilisateur et au détriment de la réponse à une entrée utilisateur normal.

 Le `context` paramètre est un objet arbitraire qui est passé à la `callback`. Vous pouvez l’utiliser pour déterminer le mécanisme de synchronisation utilisé pour contrôler l’accès à `collection`. `Context` peut être `null`.  
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.Binding GetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.Binding GetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBinding (target As DependencyObject, dp As DependencyProperty) As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::Binding ^ GetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.Binding" Usage="System.Windows.Data.BindingOperations.GetBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.Binding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet où <paramref name="dp" /> existe.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer la liaison.</param>
        <summary>Récupère l'objet <see cref="T:System.Windows.Data.Binding" /> défini sur la propriété spécifiée.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.Binding" /> défini sur la propriété donnée ou <see langword="null" /> si aucun objet <see cref="T:System.Windows.Data.Binding" /> n'a été défini.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas être null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingBase GetBindingBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingBase GetBindingBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingBase (target As DependencyObject, dp As DependencyProperty) As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingBase ^ GetBindingBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingBase" Usage="System.Windows.Data.BindingOperations.GetBindingBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet où <paramref name="dp" /> existe.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer l’objet <see cref="T:System.Windows.Data.BindingBase" />.</param>
        <summary>Récupère l'objet <see cref="T:System.Windows.Data.BindingBase" /> défini sur la propriété spécifiée.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.BindingBase" /> défini sur la propriété donnée ou <see langword="null" /> si aucun objet de liaison n'a été défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Data.BindingBase> classe est la classe de base commune pour la <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, et <xref:System.Windows.Data.MultiBinding> classes. Vous pouvez utiliser la <xref:System.Windows.Data.BindingOperations.GetBinding%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A>, et <xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A> méthodes si vous connaissez à l’avance le type de liaison qui est définissent sur la propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas avoir la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpression (target As DependencyObject, dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="System.Windows.Data.BindingOperations.GetBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet cible de liaison où se trouve <paramref name="dp" />.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer l’objet <see cref="T:System.Windows.Data.BindingExpression" />.</param>
        <summary>Retourne l’objet <see cref="T:System.Windows.Data.BindingExpression" /> associé à la propriété de cible de liaison spécifiée sur l’objet spécifié.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.BindingExpression" /> associé à la propriété donnée ou <see langword="null" /> s’il n’en existe aucun. Si un objet <see cref="T:System.Windows.Data.PriorityBindingExpression" /> est défini sur la propriété, <see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Data.BindingExpression> objet gère la connexion entre la source de liaison et la cible de liaison. Vous pouvez obtenir le <xref:System.Windows.Data.BindingExpression> objet en appelant cette méthode statique ou en appelant le <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> méthode sur une limite de données <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement> objet.  
  
   
  
## Examples  
 L’exemple suivant montre l’implémentation d’un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Gestionnaire d’événements qui utilise le <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> méthode pour obtenir le <xref:System.Windows.Data.BindingExpression> , puis appelle le <xref:System.Windows.Data.BindingExpression.DataItem%2A> propriété accéder à l’objet de source de liaison.  
  
 Le <xref:System.Windows.Controls.TextBlock> `SavingsText` est l’objet cible de liaison et <xref:System.Windows.Controls.TextBlock.Text%2A> est la propriété de cible de liaison.  
  
 [!code-csharp[DirectionalBinding#OnRentRaise](~/samples/snippets/csharp/VS_Snippets_Wpf/DirectionalBinding/CSharp/Page1.xaml.cs#onrentraise)]
 [!code-vb[DirectionalBinding#OnRentRaise](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DirectionalBinding/VisualBasic/DirectionalBinding.vb#onrentraise)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas avoir la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpressionBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase GetBindingExpressionBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase GetBindingExpressionBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpressionBase (target As DependencyObject, dp As DependencyProperty) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ GetBindingExpressionBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpressionBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.GetBindingExpressionBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet où <paramref name="dp" /> existe.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer l’objet <see cref="T:System.Windows.Data.BindingExpressionBase" />.</param>
        <summary>Récupère l'objet <see cref="T:System.Windows.Data.BindingExpressionBase" /> défini sur la propriété spécifiée.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.BindingExpressionBase" /> défini sur la propriété donnée ou <see langword="null" /> si aucun objet de liaison n'a été défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Data.BindingExpressionBase> classe est la classe de base commune pour la <xref:System.Windows.Data.BindingExpression>, <xref:System.Windows.Data.PriorityBindingExpression>, et <xref:System.Windows.Data.MultiBindingExpression> classes. Vous pouvez utiliser la <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A>, et <xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A> méthodes si vous connaissez à l’avance le type de liaison qui est défini sur la propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas être null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBinding GetMultiBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBinding GetMultiBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBinding (target As DependencyObject, dp As DependencyProperty) As MultiBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBinding ^ GetMultiBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBinding" Usage="System.Windows.Data.BindingOperations.GetMultiBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet où <paramref name="dp" /> existe.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer la liaison.</param>
        <summary>Récupère l'objet <see cref="T:System.Windows.Data.MultiBinding" /> défini sur la propriété spécifiée.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.MultiBinding" /> défini sur la propriété donnée ou <see langword="null" /> si aucun objet <see cref="T:System.Windows.Data.MultiBinding" /> n'a été défini.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas être null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBindingExpression GetMultiBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBindingExpression GetMultiBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBindingExpression (target As DependencyObject, dp As DependencyProperty) As MultiBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBindingExpression ^ GetMultiBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBindingExpression" Usage="System.Windows.Data.BindingOperations.GetMultiBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet cible de liaison où se trouve <paramref name="dp" />.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer l’objet <see cref="T:System.Windows.Data.MultiBindingExpression" />.</param>
        <summary>Retourne l’objet <see cref="T:System.Windows.Data.MultiBindingExpression" /> associé à la propriété de cible de liaison spécifiée sur l’objet spécifié.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.MultiBindingExpression" /> associé à la propriété donnée ou <see langword="null" /> s’il n’en existe aucun.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objet <xref:System.Windows.Data.MultiBindingExpression> associé à la propriété donnée ou `null` s’il n’en existe aucun.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas avoir la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBinding GetPriorityBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBinding GetPriorityBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBinding (target As DependencyObject, dp As DependencyProperty) As PriorityBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBinding ^ GetPriorityBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBinding" Usage="System.Windows.Data.BindingOperations.GetPriorityBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet où <paramref name="dp" /> existe.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer la liaison.</param>
        <summary>Récupère l'objet <see cref="T:System.Windows.Data.PriorityBinding" /> défini sur la propriété spécifiée.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.PriorityBinding" /> défini sur la propriété donnée ou <see langword="null" /> si aucun objet <see cref="T:System.Windows.Data.PriorityBinding" /> n'a été défini.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas être null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBindingExpression (target As DependencyObject, dp As DependencyProperty) As PriorityBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBindingExpression ^ GetPriorityBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBindingExpression" Usage="System.Windows.Data.BindingOperations.GetPriorityBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet cible de liaison où se trouve <paramref name="dp" />.</param>
        <param name="dp">Propriété de cible de liaison à partir de laquelle récupérer l’objet <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</param>
        <summary>Retourne l’objet <see cref="T:System.Windows.Data.PriorityBindingExpression" /> associé à la propriété de cible de liaison spécifiée sur l’objet spécifié.</summary>
        <returns>Objet <see cref="T:System.Windows.Data.PriorityBindingExpression" /> associé à la propriété donnée ou <see langword="null" /> s’il n’en existe aucun.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Les paramètres <paramref name="target" /> et <paramref name="dp" /> ne peuvent pas avoir la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindingGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindingGroups (root As DependencyObject) As ReadOnlyCollection(Of BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingGroup ^&gt; ^ GetSourceUpdatingBindingGroups(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindingGroups : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="root">Élément <see cref="T:System.Windows.UIElement" /> racine pour lequel obtenir les groupes de liaison.  Cette méthode retourne les objets <see cref="T:System.Windows.Data.BindingGroup" /> associés à cet élément ou ses éléments descendants.</param>
        <summary>Obtient tous les objets <see cref="T:System.Windows.Data.BindingGroup" /> qui ont des valeurs non valides ou des valeurs cibles n'ont pas mis à jour la source.</summary>
        <returns>Collection d'objets <see cref="T:System.Windows.Data.BindingGroup" /> qui sont associés à l'élément spécifié et qui ont des valeurs non valides ou des valeurs cibles qui n'ont pas été mises à jour à la source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `root` est `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A> retourne tous les <xref:System.Windows.Data.BindingGroup> les objets qui ne sont pas valides ou n’ont pas été mis à jour.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindings">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindings (root As DependencyObject) As ReadOnlyCollection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ GetSourceUpdatingBindings(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindings : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindings root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="root">Élément <see cref="T:System.Windows.UIElement" /> racine pour lequel obtenir les groupes de liaison.  Cette méthode retourne les objets <see cref="T:System.Windows.Data.BindingExpressionBase" /> associés à cet élément ou ses éléments descendants.</param>
        <summary>Obtient tous les objets <see cref="T:System.Windows.Data.BindingExpressionBase" /> qui ont des valeurs non valides ou des valeurs cibles n'ont pas mis à jour la source.</summary>
        <returns>Collection d'objets <see cref="T:System.Windows.Data.BindingExpressionBase" /> qui sont associés à l'élément spécifié et qui ont des valeurs non valides ou des valeurs cibles qui n'ont pas été mises à jour à la source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `root` est `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A> retourne tous les <xref:System.Windows.Data.BindingExpressionBase> les objets qui ne sont pas valides ou n’ont pas été mis à jour.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDataBound">
      <MemberSignature Language="C#" Value="public static bool IsDataBound (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDataBound(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDataBound (target As DependencyObject, dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDataBound(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member IsDataBound : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; bool" Usage="System.Windows.Data.BindingOperations.IsDataBound (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objet où <paramref name="dp" /> existe.</param>
        <param name="dp">Propriété de dépendance à vérifier.</param>
        <summary>Retourne une valeur qui indique si la propriété spécifiée est actuellement liée aux données.</summary>
        <returns>
          <see langword="true" /> si la propriété spécifiée est liée aux données ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Si <paramref name="target" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetBinding (target As DependencyObject, dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="static member SetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.SetBinding (target, dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="target">Cible de liaison de la liaison.</param>
        <param name="dp">Propriété cible de la liaison.</param>
        <param name="binding">Objet <see cref="T:System.Windows.Data.BindingBase" /> qui décrit la liaison.</param>
        <summary>Crée et associe une instance de <see cref="T:System.Windows.Data.BindingExpressionBase" /> à la propriété de cible de liaison spécifiée.</summary>
        <returns>Instance de <see cref="T:System.Windows.Data.BindingExpressionBase" /> créée et associée à la propriété spécifiée. La classe <see cref="T:System.Windows.Data.BindingExpressionBase" /> est la classe de base de <see cref="T:System.Windows.Data.BindingExpression" />, <see cref="T:System.Windows.Data.MultiBindingExpression" /> et <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée une nouvelle instance d’un <xref:System.Windows.Data.BindingExpressionBase> et associe l’instance à la propriété de dépendance donnée de l’objet donné. Cette méthode est la façon de joindre une liaison à un élément arbitraire <xref:System.Windows.DependencyObject> qui ne peut pas exposer sa propre méthode SetBinding.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser cette méthode pour définir une liaison. Dans cet exemple, `myNewBindDef` est un <xref:System.Windows.Data.Binding> objet qui décrit la liaison. La cible de liaison est `myDateText`, une instance de la <xref:System.Windows.Controls.TextBlock> classe.  
  
 [!code-csharp[BindConversion#BOSetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/BindConversion/CSharp/Window1.xaml.cs#bosetbinding)]
 [!code-vb[BindConversion#BOSetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindConversion/visualbasic/window1.xaml.vb#bosetbinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="binding" /> ne peut pas avoir la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>