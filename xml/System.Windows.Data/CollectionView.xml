<Type Name="CollectionView" FullName="System.Windows.Data.CollectionView">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e14c6505f1df17c836e0af89fd6a8469c214ecdb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36364721" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CollectionView : System.Windows.Threading.DispatcherObject, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.ICollectionView, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CollectionView extends System.Windows.Threading.DispatcherObject implements class System.Collections.IEnumerable, class System.Collections.Specialized.INotifyCollectionChanged, class System.ComponentModel.ICollectionView, class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.CollectionView" />
  <TypeSignature Language="VB.NET" Value="Public Class CollectionView&#xA;Inherits DispatcherObject&#xA;Implements ICollectionView, IEnumerable, INotifyCollectionChanged, INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="public ref class CollectionView : System::Windows::Threading::DispatcherObject, System::Collections::IEnumerable, System::Collections::Specialized::INotifyCollectionChanged, System::ComponentModel::ICollectionView, System::ComponentModel::INotifyPropertyChanged" />
  <TypeSignature Language="F#" Value="type CollectionView = class&#xA;    inherit DispatcherObject&#xA;    interface ICollectionView&#xA;    interface IEnumerable&#xA;    interface INotifyCollectionChanged&#xA;    interface INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Specialized.INotifyCollectionChanged</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICollectionView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a view for grouping, sorting, filtering, and navigating a data collection.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne devez créer des objets de cette classe dans votre code. Pour créer une vue de collection pour une collection qui implémente uniquement <xref:System.Collections.IEnumerable>, créer un <xref:System.Windows.Data.CollectionViewSource> d’objet, ajoutez votre collection à la <xref:System.Windows.Data.CollectionViewSource.Source%2A> propriété et obtenir la vue de collection à partir de la <xref:System.Windows.Data.CollectionViewSource.View%2A> propriété.  
  
 Vous pouvez considérer une vue de collection comme une couche sur une collection de sources de liaison qui permet de naviguer et pour afficher la collection en fonction de tri, le filtrage et les requêtes de groupe, sans avoir à manipuler la collection source sous-jacente. Si la collection source implémente la <xref:System.Collections.Specialized.INotifyCollectionChanged> de l’interface, les modifications qui déclenchent la <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> événements sont propagées aux vues.  
  
 Car une vue ne modifie pas la collection source sous-jacente, une collection source peut avoir plusieurs vues associées. À l’aide de vues, vous pouvez afficher les mêmes données de différentes façons. Par exemple, vous pouvez utiliser deux vues pour une collection de `Task` objets pour afficher les tâches triées par priorité sur une partie de la page et groupées par zone sur une autre partie de la page.  
  
 Dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] applications, toutes les collections ont une collection par défaut associées à afficher. Au lieu de travailler directement avec la collection, le moteur de liaison accède toujours à la collection via la vue associée. Pour obtenir la vue par défaut, utilisez le <xref:System.Windows.Data.CollectionViewSource.GetDefaultView%2A?displayProperty=nameWithType> (méthode). Une classe interne basé sur <xref:System.Windows.Data.CollectionView> est la vue par défaut pour les collections qui implémentent uniquement <xref:System.Collections.IEnumerable>. <xref:System.Windows.Data.ListCollectionView> est la vue par défaut pour les collections qui implémentent <xref:System.Collections.IList>. <xref:System.Windows.Data.BindingListCollectionView> est la vue par défaut pour les collections qui implémentent <xref:System.ComponentModel.IBindingListView> ou <xref:System.ComponentModel.IBindingList>.  
  
 Vous pouvez également créer une vue de votre collection de [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] à l’aide de la <xref:System.Windows.Data.CollectionViewSource> classe, puis lier votre contrôle à cette vue. Le <xref:System.Windows.Data.CollectionViewSource> classe est la [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] la représentation sous forme de la <xref:System.Windows.Data.CollectionView> classe. Pour obtenir un exemple, consultez [Comment : trier et données de groupe à l’aide d’une vue en XAML](~/docs/framework/wpf/data/how-to-sort-and-group-data-using-a-view-in-xaml.md).  
  
 Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Pour définir une vue dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], utilisez la <xref:System.Windows.Data.CollectionViewSource> classe. <xref:System.Windows.Data.CollectionViewSource> est la [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] la représentation sous forme de la <xref:System.Windows.Data.CollectionView> classe et il expose les membres couramment utilisées de la <xref:System.Windows.Data.CollectionView> classe.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CollectionView (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.#ctor(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CollectionView(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Windows.Data.CollectionView : System.Collections.IEnumerable -&gt; System.Windows.Data.CollectionView" Usage="new System.Windows.Data.CollectionView collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">The underlying collection.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Data.CollectionView" /> class that represents a view of the specified collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’instance de <xref:System.Windows.Data.CollectionView> est lié à la [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] thread du répartiteur de l’appelant de ce constructeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsCrossThreadChanges">
      <MemberSignature Language="C#" Value="protected bool AllowsCrossThreadChanges { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsCrossThreadChanges" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AllowsCrossThreadChanges As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AllowsCrossThreadChanges { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowsCrossThreadChanges : bool" Usage="System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a thread other than the one that created the <see cref="T:System.Windows.Data.CollectionView" /> can change the <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />.</summary>
        <value>
          <see langword="true" /> Si un thread autre que celui qui a créé le <see cref="T:System.Windows.Data.CollectionView" /> peut modifier le <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFilter">
      <MemberSignature Language="C#" Value="public virtual bool CanFilter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanFilter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanFilter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFilter : bool" Usage="System.Windows.Data.CollectionView.CanFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the view supports filtering.</summary>
        <value>
          <see langword="true" /> Si la vue prend en charge le filtrage ; dans le cas contraire, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété retourne `false`, ce qui affecte le <xref:System.Windows.Data.CollectionView.Filter%2A> propriété lève une exception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanGroup">
      <MemberSignature Language="C#" Value="public virtual bool CanGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanGroup" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanGroup As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanGroup { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGroup : bool" Usage="System.Windows.Data.CollectionView.CanGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the view supports grouping.</summary>
        <value>
          <see langword="false" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour tester si la vue prend en charge le tri avant d’ajouter <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A>. Classes dérivées de substituent cette propriété pour indiquer si elles prennent en charge le regroupement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSort">
      <MemberSignature Language="C#" Value="public virtual bool CanSort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSort : bool" Usage="System.Windows.Data.CollectionView.CanSort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the view supports sorting.</summary>
        <value>
          <see langword="false" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour tester si la vue prend en charge le tri avant d’ajouter <xref:System.Windows.Data.CollectionView.SortDescriptions%2A>. Classes dérivées de substituent cette propriété pour indiquer si elles prennent en charge le tri.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChangeLog">
      <MemberSignature Language="C#" Value="protected void ClearChangeLog ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChangeLog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearChangeLog" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChangeLog ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChangeLog();" />
      <MemberSignature Language="F#" Value="member this.ClearChangeLog : unit -&gt; unit" Usage="collectionView.ClearChangeLog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by ClearPendingChanges")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears any pending changes from the change log.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ClearPendingChanges">
      <MemberSignature Language="C#" Value="protected void ClearPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearPendingChanges();" />
      <MemberSignature Language="F#" Value="member this.ClearPendingChanges : unit -&gt; unit" Usage="collectionView.ClearPendingChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears unprocessed changed to the collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event CollectionChanged As NotifyCollectionChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::Collections::Specialized::NotifyCollectionChangedEventHandler ^ CollectionChanged;" />
      <MemberSignature Language="F#" Value="member this.CollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventHandler " Usage="member this.CollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NotifyCollectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the view has changed.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IComparer Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IComparer ^ Comparer { System::Collections::IComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.IComparer" Usage="System.Windows.Data.CollectionView.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an object that you can use to compare items in the view.</summary>
        <value>Un <see cref="T:System.Collections.IComparer" /> de l’objet que vous pouvez utiliser pour comparer des éléments dans la vue.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="collectionView.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The object to check.</param>
        <summary>Returns a value that indicates whether the specified item belongs to the view.</summary>
        <returns>
          <see langword="true" /> if the item belongs to the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne fait pas d’hypothèses concernant indique si l’élément appartient à la collection sous-jacente. Si l’appelant sait que l’élément appartient à la collection sous-jacente, il est plus efficace d’appeler le <xref:System.Windows.Data.CollectionView.PassesFilter%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Data.CollectionView.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of records in the view.</summary>
        <value>Le nombre d’enregistrements dans la vue, ou -1 si le nombre d’enregistrements est inconnu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un filtre est défini, cette valeur de propriété inclut uniquement les éléments qui correspondent au filtre. Si la collection sous-jacente est de type <xref:System.Collections.IEnumerable>, il s’agit d’une opération o (n). Cette valeur est mise en cache jusqu'à ce que la collection est modifiée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lorsque vous dérivez de <see cref="T:System.Windows.Data.CollectionView" />, substituer cette propriété pour fournir une implémentation plus efficace.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Data.CollectionView.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture information to use during sorting.</summary>
        <value>Les informations de culture à utiliser pendant le tri.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public virtual event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ CurrentChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanged : EventHandler " Usage="member this.CurrentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> has changed.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Déclencher cet événement après avoir modifié le <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</para>
        </block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanging">
      <MemberSignature Language="C#" Value="public virtual event System.ComponentModel.CurrentChangingEventHandler CurrentChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CurrentChangingEventHandler CurrentChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanging As CurrentChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::CurrentChangingEventHandler ^ CurrentChanging;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanging : System.ComponentModel.CurrentChangingEventHandler " Usage="member this.CurrentChanging : System.ComponentModel.CurrentChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CurrentChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is changing.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Déclenchez cet événement avant de modifier le <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</para>
        </block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanging" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItem">
      <MemberSignature Language="C#" Value="public virtual object CurrentItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CurrentItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ CurrentItem { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentItem : obj" Usage="System.Windows.Data.CollectionView.CurrentItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current item in the view.</summary>
        <value>Élément actuel de la vue. Par défaut, le premier élément de la collection commence en tant qu’élément actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection.  
  
 Notez que le déplacement du pointeur d’enregistrement actif a des interactions avec un tri ou de filtrage qui est appliquée à la collection. Le tri conserve le pointeur d’enregistrement actif sur le dernier enregistrement sélectionné, mais la vue de collection est restructurée. (Peut-être l’enregistrement sélectionné était au début de la liste avant, mais maintenant l’enregistrement sélectionné peut être quelque part au milieu). Le filtrage conserve l’enregistrement sélectionné si cette sélection reste dans la vue après le filtrage. Sinon, le pointeur d’enregistrement actif est défini pour le premier enregistrement de la vue de collection filtrée.  
  
 L’élément actuel de la collection est lié automatiquement si la cible d’une liaison est une valeur singleton. Si la cible est un <xref:System.Windows.Controls.ItemsControl>, l’élément actuel est synchronisé avec l’élément sélectionné. Par exemple, si une zone de liste est liée à une collection, le <xref:System.Windows.Data.CollectionView.CurrentItem%2A> est synchronisé avec l’élément actuellement sélectionné.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Seules les classes qui passent la gestion des appels à un autre interne à la monnaie <see cref="T:System.Windows.Data.CollectionView" /> objet doit substituer cette propriété ; toutes les autres classes dérivées doivent utiliser le <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> pour mettre à jour les valeurs actuelles stockées dans la classe de base.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CurrentPosition">
      <MemberSignature Language="C#" Value="public virtual int CurrentPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CurrentPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPosition : int" Usage="System.Windows.Data.CollectionView.CurrentPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the ordinal position of the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> within the (optionally sorted and filtered) view.</summary>
        <value>La position ordinale de la <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> dans la vue (éventuellement triée et filtrée).</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Seules les classes qui passent la gestion des appels à un autre interne à la monnaie <see cref="T:System.Windows.Data.CollectionView" /> objet doit substituer cette propriété ; toutes les autres classes dérivées doivent utiliser le <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> pour mettre à jour les valeurs actuelles stockées dans la classe de base.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeferRefresh">
      <MemberSignature Language="C#" Value="public virtual IDisposable DeferRefresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable DeferRefresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DeferRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeferRefresh () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ DeferRefresh();" />
      <MemberSignature Language="F#" Value="abstract member DeferRefresh : unit -&gt; IDisposable&#xA;override this.DeferRefresh : unit -&gt; IDisposable" Usage="collectionView.DeferRefresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enters a defer cycle that you can use to merge changes to the view and delay automatic refresh.</summary>
        <returns>An <see cref="T:System.IDisposable" /> object that you can use to dispose of the calling object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation typique consiste à créer un `using` portée avec cette méthode, puis placez-le plusieurs appels de modification de la vue dans la portée. Cela retarde l’actualisation automatique jusqu'à ce que le cycle différé est terminé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachFromSourceCollection">
      <MemberSignature Language="C#" Value="public virtual void DetachFromSourceCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DetachFromSourceCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DetachFromSourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DetachFromSourceCollection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DetachFromSourceCollection();" />
      <MemberSignature Language="F#" Value="abstract member DetachFromSourceCollection : unit -&gt; unit&#xA;override this.DetachFromSourceCollection : unit -&gt; unit" Usage="collectionView.DetachFromSourceCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the reference to the underlying collection from the <see cref="T:System.Windows.Data.CollectionView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour annuler l’abonnement aux événements sur la collection sous-jacente et autoriser la <xref:System.Windows.Data.CollectionView> pour l’opération garbage collecté.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual Predicate&lt;object&gt; Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Predicate`1&lt;object&gt; Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As Predicate(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Predicate&lt;System::Object ^&gt; ^ Filter { Predicate&lt;System::Object ^&gt; ^ get(); void set(Predicate&lt;System::Object ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : Predicate&lt;obj&gt; with get, set" Usage="System.Windows.Data.CollectionView.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Predicate&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a method used to determine if an item is suitable for inclusion in the view.</summary>
        <value>Délégué qui représente la méthode utilisée pour déterminer si un élément peut être inclus dans l’affichage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations plus simples ne pas prendre en charge le filtrage et lèvent une <xref:System.NotSupportedException>. Utilisez le <xref:System.Windows.Data.CollectionView.CanFilter%2A> propriété pour tester si le filtrage est pris en charge avant de lui assigner cette propriété avec une valeur non null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The current implementation does not support filtering.</exception>
        <altmember cref="E:System.Windows.Data.CollectionViewSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collectionView.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an object that you can use to enumerate the items in the view.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> object that you can use to enumerate the items in the view.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemAt">
      <MemberSignature Language="C#" Value="public virtual object GetItemAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetItemAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetItemAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemAt (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetItemAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetItemAt : int -&gt; obj&#xA;override this.GetItemAt : int -&gt; obj" Usage="collectionView.GetItemAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the item to retrieve.</param>
        <summary>Retrieves the item at the specified zero-based index in the view.</summary>
        <returns>The item at the specified zero-based index in the view.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode évalue l’index avec n’importe quelle <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> ou <xref:System.Windows.Data.CollectionView.Filter%2A> les valeurs de propriété qui sont définies dans la vue.  
  
 Si la collection sous-jacente est de type <xref:System.Collections.IEnumerable>, il s’agit d’une opération o (n).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.</exception>
        <block subset="none" type="overrides">
          <para>Lorsque vous dérivez de <see cref="T:System.Windows.Data.CollectionView" />, substituez cette méthode pour fournir une implémentation plus efficace.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GroupDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt; GroupDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.ComponentModel.GroupDescription&gt; GroupDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.GroupDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GroupDescriptions As ObservableCollection(Of GroupDescription)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ GroupDescriptions { System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupDescriptions : System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;" Usage="System.Windows.Data.CollectionView.GroupDescriptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of <see cref="T:System.ComponentModel.GroupDescription" /> objects that describes how the items in the collection are grouped in the view.</summary>
        <value>
          <see langword="null" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est toujours `null` , car le <xref:System.Windows.Data.CollectionView> classe ne prend pas en charge le regroupement sur sa collection sous-jacente. Les classes dérivées <xref:System.Windows.Data.ListCollectionView> et <xref:System.Windows.Data.BindingListCollectionView> ne prennent pas en charge le regroupement.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.ListCollectionView.GroupDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;object&gt; Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyObservableCollection`1&lt;object&gt; Groups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As ReadOnlyObservableCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ Groups { System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;obj&gt;" Usage="System.Windows.Data.CollectionView.Groups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of the top-level groups that is constructed based on the <see cref="P:System.Windows.Data.CollectionView.GroupDescriptions" /> property.</summary>
        <value>
          <see langword="null" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est toujours `null` , car le <xref:System.Windows.Data.CollectionView> classe ne prend pas en charge le regroupement sur sa collection sous-jacente. Les classes dérivées <xref:System.Windows.Data.ListCollectionView> et <xref:System.Windows.Data.BindingListCollectionView> ne prennent pas en charge le regroupement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (item As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="collectionView.IndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to locate.</param>
        <summary>Returns the index at which the specified item is located.</summary>
        <returns>The index at which the specified item is located, or –1 if the item is unknown.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode retourne un index autre que -1, il doit toujours être true view [index-1] < élément < = vue [index], où les comparaisons sont effectuées à l’aide de la <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> méthode de la vue, le cas échéant.  
  
 Ce comportement particulier de la méthode utilisé par certaines <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> gestionnaires d’événements pour accélérer la réaction d’insertion et de suppression. Si la classe dérivée ne substitue pas cette méthode, un écouteur fait une recherche binaire à l’aide de la <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCurrentAfterLast">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentAfterLast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentAfterLast" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentAfterLast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentAfterLast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentAfterLast : bool" Usage="System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> of the view is beyond the end of the collection.</summary>
        <value>
          <see langword="true" /> Si le <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> de la vue est au-delà de la fin de la collection ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentBeforeFirst">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentBeforeFirst { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentBeforeFirst" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentBeforeFirst As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentBeforeFirst { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentBeforeFirst : bool" Usage="System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> of the view is before the beginning of the collection.</summary>
        <value>
          <see langword="true" /> Si le <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> de la vue est avant le début de la collection ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentInSync">
      <MemberSignature Language="C#" Value="protected bool IsCurrentInSync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentInSync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentInSync" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsCurrentInSync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsCurrentInSync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCurrentInSync : bool" Usage="System.Windows.Data.CollectionView.IsCurrentInSync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is at the <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />.</summary>
        <value>
          <see langword="true" /> Si le <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> se trouve dans la vue et à la <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="protected bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Windows.Data.CollectionView.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the underlying collection provides change notifications.</summary>
        <value>
          <see langword="true" /> Si la collection sous-jacente fournit des notifications de modification ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public virtual bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Windows.Data.CollectionView.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the resulting (filtered) view is empty.</summary>
        <value>
          <see langword="true" /> Si la vue résultante est vide. dans le cas contraire, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInUse">
      <MemberSignature Language="C#" Value="public virtual bool IsInUse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInUse" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsInUse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInUse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInUse : bool" Usage="System.Windows.Data.CollectionView.IsInUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether any object is subscribing to the events of this <see cref="T:System.Windows.Data.CollectionView" />.</summary>
        <value>
          <see langword="true" /> Si n’importe quel objet s’abonne aux événements de ce <see cref="T:System.Windows.Data.CollectionView" />; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRefreshDeferred">
      <MemberSignature Language="C#" Value="protected bool IsRefreshDeferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRefreshDeferred" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsRefreshDeferred" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsRefreshDeferred As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsRefreshDeferred { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRefreshDeferred : bool" Usage="System.Windows.Data.CollectionView.IsRefreshDeferred" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether there is an outstanding <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> in use.</summary>
        <value>
          <see langword="true" /> s’il existe un en suspens <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> en cours d’utilisation ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Les classes dérivées doivent éviter d’appeler <see cref="M:System.Windows.Data.CollectionView.Refresh" /> si <see cref="P:System.Windows.Data.CollectionView.IsRefreshDeferred" /> retourne <see langword="true" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentTo">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentTo (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentTo(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentTo (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentTo(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentTo : obj -&gt; bool&#xA;override this.MoveCurrentTo : obj -&gt; bool" Usage="collectionView.MoveCurrentTo item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to set as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <summary>Sets the specified item to be the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> in the view.</summary>
        <returns>
          <see langword="true" /> if the resulting <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is within the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’élément spécifié est introuvable, la méthode retourne `false` et <xref:System.Windows.Data.CollectionView.CurrentItem%2A> est positionné avant le début de la collection dans la vue.  
  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection. Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Pour plus d’informations sur l’élément actuel d’une vue, consultez <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de cette méthode.  
  
 [!code-csharp[Colors#NewColor](~/samples/snippets/csharp/VS_Snippets_Wpf/Colors/CSharp/Colors.xaml.cs#newcolor)]
 [!code-vb[Colors#NewColor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Colors/visualbasic/colors.xaml.vb#newcolor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToFirst">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToFirst () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToFirst();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToFirst : unit -&gt; bool&#xA;override this.MoveCurrentToFirst : unit -&gt; bool" Usage="collectionView.MoveCurrentToFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the first item in the view as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> if the resulting <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is an item within the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection. Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToLast">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToLast () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToLast();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToLast : unit -&gt; bool&#xA;override this.MoveCurrentToLast : unit -&gt; bool" Usage="collectionView.MoveCurrentToLast " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the last item in the view as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> if the resulting <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is an item within the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection. Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToNext">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToNext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToNext : unit -&gt; bool&#xA;override this.MoveCurrentToNext : unit -&gt; bool" Usage="collectionView.MoveCurrentToNext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the item after the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> in the view as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> if the resulting <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is an item within the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection. Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPosition">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPosition(int position);" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToPosition : int -&gt; bool&#xA;override this.MoveCurrentToPosition : int -&gt; bool" Usage="collectionView.MoveCurrentToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">The index to set the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> to.</param>
        <summary>Sets the item at the specified index to be the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> in the view.</summary>
        <returns>
          <see langword="true" /> if the resulting <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is an item within the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection. Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPrevious">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPrevious();" />
      <MemberSignature Language="F#" Value="abstract member MoveCurrentToPrevious : unit -&gt; bool&#xA;override this.MoveCurrentToPrevious : unit -&gt; bool" Usage="collectionView.MoveCurrentToPrevious " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the item before the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> in the view as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="true" /> if the resulting <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> is an item within the view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vues de collection prend en charge le concept d’un pointeur d’enregistrement actif. Lorsque vous naviguez parmi les objets d’une vue de collection, vous déplacez un pointeur d’enregistrement qui vous permet de récupérer l’objet qui existe à cet emplacement précis de la collection. Pour plus d’informations, consultez « Liaison à des Collections » dans [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="NeedsRefresh">
      <MemberSignature Language="C#" Value="public virtual bool NeedsRefresh { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NeedsRefresh" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NeedsRefresh As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool NeedsRefresh { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NeedsRefresh : bool" Usage="System.Windows.Data.CollectionView.NeedsRefresh" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the view needs to be refreshed.</summary>
        <value>
          <see langword="true" /> Si la vue doit être actualisée ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique si l’état interne de la vue a changé et requiert un <xref:System.Windows.Data.CollectionView.Refresh%2A> appel de méthode. Le scénario typique est si un <xref:System.ComponentModel.SortDescription> ou similaire a été ajouté à la vue lorsque la vue est un cycle d’actualisation différée (voir <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>). Dans ce scénario, aucun appel explicite à <xref:System.Windows.Data.CollectionView.Refresh%2A> est nécessaire ; dès que le cycle d’actualisation différée se termine, la vue appelle automatiquement l’actualisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.Refresh" />
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
      </Docs>
    </Member>
    <Member MemberName="NewItemPlaceholder">
      <MemberSignature Language="C#" Value="public static object NewItemPlaceholder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object NewItemPlaceholder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NewItemPlaceholder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewItemPlaceholder As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ NewItemPlaceholder { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewItemPlaceholder : obj" Usage="System.Windows.Data.CollectionView.NewItemPlaceholder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the object that is in the collection to represent a new item.</summary>
        <value>Objet qui se trouve dans la collection pour représenter un nouvel élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un <xref:System.Windows.Data.CollectionView> qui implémente <xref:System.ComponentModel.IEditableCollectionView> a <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> la valeur <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> ou <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd>, le <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> est ajouté à la collection.  Le <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> apparaît toujours dans la collection ; il ne participe pas de regroupement, de tri ou de filtrage.  
  
 Le <xref:System.Windows.Data.CollectionView.CurrentItem%2A> ne peut pas être le <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>. Les méthodes qui effectuent une navigation relative, telles que la <xref:System.Windows.Data.CollectionView.MoveCurrentToNext%2A>, ignorer la <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>.  <xref:System.Windows.Data.CollectionView.MoveCurrentToFirst%2A> et <xref:System.Windows.Data.CollectionView.MoveCurrentToLast%2A> ignorer la <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> si <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> a la valeur <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> ou <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd>, respectivement. Les méthodes qui effectuent une navigation absolue, telles que <xref:System.Windows.Data.CollectionView.MoveCurrentToPosition%2A>, ne faites rien si le <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> serait le <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OKToChangeCurrent">
      <MemberSignature Language="C#" Value="protected bool OKToChangeCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool OKToChangeCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OKToChangeCurrent" />
      <MemberSignature Language="VB.NET" Value="Protected Function OKToChangeCurrent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool OKToChangeCurrent();" />
      <MemberSignature Language="F#" Value="member this.OKToChangeCurrent : unit -&gt; bool" Usage="collectionView.OKToChangeCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether the view can change which item is the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="false" /> if a listener cancels the change; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAllowsCrossThreadChangesChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAllowsCrossThreadChangesChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAllowsCrossThreadChangesChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnAllowsCrossThreadChangesChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAllowsCrossThreadChangesChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAllowsCrossThreadChangesChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnAllowsCrossThreadChangesChanged : unit -&gt; unit&#xA;override this.OnAllowsCrossThreadChangesChanged : unit -&gt; unit" Usage="collectionView.OnAllowsCrossThreadChangesChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Occurs when the <see cref="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" /> property changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginChangeLogging">
      <MemberSignature Language="C#" Value="protected virtual void OnBeginChangeLogging (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeginChangeLogging(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeginChangeLogging (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeginChangeLogging(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBeginChangeLogging : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnBeginChangeLogging : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.OnBeginChangeLogging args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by OnAllowsCrossThreadChangesChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> object that is added to the change log.</param>
        <summary>Called by the base class to notify the derived class that an <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" /> event has been posted to the message queue.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCollectionChanged">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raises the <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> event.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.OnCollectionChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> object to pass to the event handler.</param>
        <summary>Raises the <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Effectuer un tri, filtrage ou critères de regroupement en considération avant d’appeler cette méthode pour déclencher le <xref:System.Windows.Data.CollectionView.CollectionChanged> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected void OnCollectionChanged (object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCollectionChanged(object sender, class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCollectionChanged (sender As Object, args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCollectionChanged(System::Object ^ sender, System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.OnCollectionChanged : obj * System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.OnCollectionChanged (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">The sender of the event.</param>
        <param name="args">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> object to pass to the event handler.</param>
        <summary>Raises the <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.Windows.Data.CollectionView.ProcessCollectionChanged%2A> s’il s’agit de la bonne [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] distributeur de thread et n’a jamais été mis à jour à partir d’un autre thread ou publie la modification dans le répartiteur à traiter sur le thread approprié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanged : unit -&gt; unit&#xA;override this.OnCurrentChanged : unit -&gt; unit" Usage="collectionView.OnCurrentChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Windows.Data.CollectionView.CurrentChanged" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCurrentChanging">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Raises the <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> event.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected void OnCurrentChanging ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCurrentChanging() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCurrentChanging ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCurrentChanging();" />
      <MemberSignature Language="F#" Value="member this.OnCurrentChanging : unit -&gt; unit" Usage="collectionView.OnCurrentChanging " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises a <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> event that is not cancelable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit <xref:System.Windows.Data.CollectionView.CurrentPosition%2A> -1. Cette méthode est appelée par les modifications de la collection qui affectent le <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanging (System.ComponentModel.CurrentChangingEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanging(class System.ComponentModel.CurrentChangingEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging(System.ComponentModel.CurrentChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanging (args As CurrentChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanging(System::ComponentModel::CurrentChangingEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanging : System.ComponentModel.CurrentChangingEventArgs -&gt; unit&#xA;override this.OnCurrentChanging : System.ComponentModel.CurrentChangingEventArgs -&gt; unit" Usage="collectionView.OnCurrentChanging args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.ComponentModel.CurrentChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Information about the event.</param>
        <summary>Raises the <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> event with the specified arguments.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="collectionView.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Arguments of the event being raised.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event using the specified arguments.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PassesFilter">
      <MemberSignature Language="C#" Value="public virtual bool PassesFilter (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PassesFilter(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.PassesFilter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PassesFilter (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PassesFilter(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member PassesFilter : obj -&gt; bool&#xA;override this.PassesFilter : obj -&gt; bool" Usage="collectionView.PassesFilter item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The item to check.</param>
        <summary>Returns a value that indicates whether the specified item in the underlying collection belongs to the view.</summary>
        <returns>
          <see langword="true" /> if the specified item belongs to the view or if there is not filter set on the collection view; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Windows.Data.CollectionView.Contains%2A> (méthode), cette méthode suppose que l’élément spécifié appartient à la collection sous-jacente. Cette méthode prend les filtres en compte. En règle générale, vous utilisez cette méthode au cours de notifications de modification de collection pour déterminer si l’élément ajouté ou supprimé requiert un traitement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void ProcessCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ProcessCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ProcessCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ProcessCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.ProcessCollectionChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="collectionView.ProcessCollectionChanged args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> object to process.</param>
        <summary>When overridden in a derived class, processes a single change on the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] thread.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Cette méthode doit être substituée dans une classe dérivée pour traiter une modification sur le [ ! Thread de include[TLA2#tla_ui](~/Includes/tla2sharptla-UI-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessPendingChanges">
      <MemberSignature Language="C#" Value="protected void ProcessPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProcessPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProcessPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProcessPendingChanges();" />
      <MemberSignature Language="F#" Value="member this.ProcessPendingChanges : unit -&gt; unit" Usage="collectionView.ProcessPendingChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that all pending changes to the collection have been committed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event PropertyChanged As PropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::ComponentModel::PropertyChangedEventHandler ^ PropertyChanged;" />
      <MemberSignature Language="F#" Value="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " Usage="member this.PropertyChanged : System.ComponentModel.PropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a property value has changed.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="collectionView.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Re-creates the view.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez la <xref:System.Windows.Data.CollectionView.Filter%2A>, <xref:System.Windows.Data.CollectionView.SortDescriptions%2A>, ou <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A> propriété ; une actualisation se produit.  Vous n’avez pas à appeler le <xref:System.Windows.Data.CollectionView.Refresh%2A> méthode immédiatement après avoir défini une de ces propriétés. Pour plus d’informations sur la façon de retarder l’actualisation automatique, consultez <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>.  
  
 Les classes dérivées utilisent la méthode protégée <xref:System.Windows.Data.CollectionView.RefreshOverride%2A> méthode à substituer le comportement de cette méthode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
        <altmember cref="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      </Docs>
    </Member>
    <Member MemberName="RefreshOrDefer">
      <MemberSignature Language="C#" Value="protected void RefreshOrDefer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RefreshOrDefer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOrDefer" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RefreshOrDefer ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RefreshOrDefer();" />
      <MemberSignature Language="F#" Value="member this.RefreshOrDefer : unit -&gt; unit" Usage="collectionView.RefreshOrDefer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Refreshes the view or specifies that the view needs to be refreshed when the defer cycle completes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshOverride">
      <MemberSignature Language="C#" Value="protected virtual void RefreshOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RefreshOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RefreshOverride ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RefreshOverride();" />
      <MemberSignature Language="F#" Value="abstract member RefreshOverride : unit -&gt; unit&#xA;override this.RefreshOverride : unit -&gt; unit" Usage="collectionView.RefreshOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Re-creates the view.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Classes dérivées doivent substituer cette méthode pour modifier le comportement de la <see cref="M:System.Windows.Data.CollectionView.Refresh" /> (méthode).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCurrent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the current item of the <see cref="T:System.Windows.Data.CollectionView" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition);" />
      <MemberSignature Language="F#" Value="member this.SetCurrent : obj * int -&gt; unit" Usage="collectionView.SetCurrent (newItem, newPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">The item to set as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <param name="newPosition">The value to set as the <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> property value.</param>
        <summary>Sets the specified item and index as the values of the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> and <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> properties.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition, int count);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition, int count);" />
      <MemberSignature Language="F#" Value="member this.SetCurrent : obj * int * int -&gt; unit" Usage="collectionView.SetCurrent (newItem, newPosition, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">The item to set as the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <param name="newPosition">The value to set as the <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> property value.</param>
        <param name="count">The number of items in the <see cref="T:System.Windows.Data.CollectionView" />.</param>
        <summary>Sets the specified item and index as the values of the <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> and <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" /> properties. This method can be called from a constructor of a derived class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette surcharge de constructeur d’une classe dérivée.  Ne passez pas les <xref:System.Windows.Data.CollectionView.Count%2A> propriété, qui est une propriété virtuelle, comme `count`. Au lieu de cela, passez le compte d’interne <xref:System.Collections.IList> qui représente la collection.  
  
 <xref:System.Windows.Data.CollectionView.SetCurrent%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.SortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.SortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As SortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::SortDescriptionCollection ^ SortDescriptions { System::ComponentModel::SortDescriptionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDescriptions : System.ComponentModel.SortDescriptionCollection" Usage="System.Windows.Data.CollectionView.SortDescriptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.SortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of <see cref="T:System.ComponentModel.SortDescription" /> structures that describes how the items in the collection are sorted in the view.</summary>
        <value>Vide <see cref="T:System.ComponentModel.SortDescriptionCollection" /> dans tous les cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas ajouter un <xref:System.ComponentModel.SortDescription> à la collection (vide) retournée parce que la classe de base <xref:System.Windows.Data.CollectionView> ne prend pas en charge le tri. Au lieu de cela, utilisez les classes dérivées <xref:System.Windows.Data.ListCollectionView> et <xref:System.Windows.Data.BindingListCollectionView> qui ne prennent pas en charge le tri. Vérifiez également la <xref:System.Windows.Data.CollectionView.CanSort%2A> propriété avant d’ajouter ou de suppression <xref:System.ComponentModel.SortDescription> objets afin d’éviter une exception.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionViewSource.SortDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="SourceCollection">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerable SourceCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable SourceCollection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SourceCollection As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IEnumerable ^ SourceCollection { System::Collections::IEnumerable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceCollection : System.Collections.IEnumerable" Usage="System.Windows.Data.CollectionView.SourceCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the underlying unfiltered collection.</summary>
        <value>Un <see cref="T:System.Collections.IEnumerable" /> objet qui est la collection sous-jacente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see cref="T:System.Collections.IEnumerator" /> object that you can use to enumerate the items in the view.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> object that you can use to enumerate the items in the view.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedOutsideDispatcher">
      <MemberSignature Language="C#" Value="protected bool UpdatedOutsideDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UpdatedOutsideDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.UpdatedOutsideDispatcher" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property UpdatedOutsideDispatcher As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool UpdatedOutsideDispatcher { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdatedOutsideDispatcher : bool" Usage="System.Windows.Data.CollectionView.UpdatedOutsideDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether it has been necessary to update the change log because a <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> notification has been received on a different thread without first entering the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] thread dispatcher.</summary>
        <value>
          <see langword="true" /> s’il a été nécessaire de mettre à jour le journal des modifications, car un <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> notification a été reçue sur un thread différent sans entrer d’abord dans le [ ! Répartiteur de thread Include[TLA#tla_ui](~/Includes/tlasharptla-UI-MD.MD)] ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>