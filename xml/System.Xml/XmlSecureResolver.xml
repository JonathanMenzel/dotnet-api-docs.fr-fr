<Type Name="XmlSecureResolver" FullName="System.Xml.XmlSecureResolver">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ceb22f9106618a3fefd9e4082d3f510f6122c3f" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52245888" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlSecureResolver : System.Xml.XmlResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlSecureResolver extends System.Xml.XmlResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlSecureResolver" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlSecureResolver&#xA;Inherits XmlResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlSecureResolver : System::Xml::XmlResolver" />
  <TypeSignature Language="F#" Value="type XmlSecureResolver = class&#xA;    inherit XmlResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlResolver</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Aide à sécuriser une autre implémentation de <see cref="T:System.Xml.XmlResolver" /> en incluant dans un wrapper l'objet <see cref="T:System.Xml.XmlResolver" /> et en limitant les ressources auxquelles le <see cref="T:System.Xml.XmlResolver" /> sous-jacent a accès.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.Xml.XmlUrlResolver> constitue le programme de résolution par défaut de toutes les classes dans l'espace de noms <xref:System.Xml>. Il est utilisé pour charger des documents XML et à résoudre des ressources externes telles que les entités, DTD ou schémas et d’importer ou d’inclure des directives.  
  
 Vous pouvez remplacer cette valeur par défaut en spécifiant le <xref:System.Xml.XmlResolver> objet à utiliser. Par exemple, si vous souhaitez limiter les ressources qui sous-jacent <xref:System.Xml.XmlResolver> peut accéder, vous pouvez utiliser un <xref:System.Xml.XmlSecureResolver> objet.  
  
 <xref:System.Xml.XmlSecureResolver> Encapsule une implémentation concrète de <xref:System.Xml.XmlResolver> et limite les ressources qui sous-jacent <xref:System.Xml.XmlResolver> a accès à. Par exemple, <xref:System.Xml.XmlSecureResolver> a la possibilité d’interdire la redirection entre domaines, qui se produit à partir d’une référence de ressource URI (Uniform Identifier) incorporée.  
  
 Lorsque vous construisez un <xref:System.Xml.XmlSecureResolver> de l’objet, vous fournissez une valide <xref:System.Xml.XmlResolver> implémentation ainsi qu’une URL, une instance d’un objet de preuve, ou un jeu d’autorisations, qui est utilisée par le <xref:System.Xml.XmlSecureResolver> pour déterminer la sécurité. Soit un <xref:System.Security.PermissionSet?displayProperty=nameWithType> est généré ou celui existant est utilisé et <xref:System.Security.PermissionSet.PermitOnly%2A?displayProperty=nameWithType> est appelé sur lui pour aider à sécuriser sous-jacent <xref:System.Xml.XmlResolver>.  
  
> [!IMPORTANT]
>  Les objets <xref:System.Xml.XmlSecureResolver> peuvent contenir des informations confidentielles telles que des informations d'identification de l'utilisateur. Vous devez être prudent lors de la mise en cache <xref:System.Xml.XmlSecureResolver> objets et ne pas passer le <xref:System.Xml.XmlSecureResolver> objet à un composant non fiable.  
  
> [!IMPORTANT]
>  Il existe des différences dans l’infrastructure de sécurité pour le code en cours d’exécution sur le CLR est intégré à Microsoft SQL Server 2005 et pour le code s’exécutant sur le common language runtime (CLR) du .NET Framework. Cela peut entraîner les cas où le code développé pour le CLR de .NET Framework fonctionne différemment lorsqu’il est utilisé sur le serveur SQL intégré CLR. Une de ces différences affecte le <xref:System.Xml.XmlSecureResolver> classe lorsque vous avez la preuve est basée sur une URL (autrement dit, lorsque vous utilisez le <xref:System.Xml.XmlSecureResolver.CreateEvidenceForUrl%28System.String%29> méthode ou le <xref:System.Xml.XmlSecureResolver.%23ctor%2A> constructeur). La stratégie de résolution CLR intégré de mécanisme de SQL Server n’utilise pas le <xref:System.Security.Policy.Url> ou <xref:System.Security.Policy.Zone> plus d’informations. Au lieu de cela, il accorde des autorisations basées sur le GUID que le serveur ajoute lorsque les assemblys sont chargés. Lorsque vous utilisez le <xref:System.Xml.XmlSecureResolver> dans CLR intégré à SQL Server, fournissez toutes les preuves requises directement en utilisant un <xref:System.Security.PermissionSet>.  
  
## <a name="to-use-a-secure-resolver"></a>Pour utiliser un programme de résolution sécurisée  
  
1.  Créez un objet <xref:System.Xml.XmlSecureResolver> avec un jeu d'autorisations correct.  
  
2.  Créez un objet <xref:System.Xml.XmlReaderSettings> qui utilise l'objet <xref:System.Xml.XmlSecureResolver>.  
  
     [!code-csharp[XmlSecureResolver_Samples#5a](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#5a)]
     [!code-vb[XmlSecureResolver_Samples#5a](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#5a)]  
  
3.  Passer le <xref:System.Xml.XmlReaderSettings> de l’objet à la <xref:System.Xml.XmlReader.Create%2A> méthode lorsque vous créez le <xref:System.Xml.XmlReader> objet.  
  
     [!code-csharp[XmlSecureResolver_Samples#5b](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#5b)]
     [!code-vb[XmlSecureResolver_Samples#5b](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#5b)]  
  
## <a name="to-restrict-access-by-using-a-url"></a>Pour restreindre l’accès à l’aide d’une URL  
 Utilisez le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.String%29> constructeur pour créer un <xref:System.Xml.XmlSecureResolver> objet qui est autorisé à accéder à votre site intranet local uniquement.  
  
 [!code-csharp[XmlSecureResolver_Samples#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#3)]
 [!code-vb[XmlSecureResolver_Samples#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#3)]  
  
## <a name="to-restrict-access-by-using-a-permission-set"></a>Pour restreindre l’accès à l’aide d’un jeu d’autorisations  
  
1.  Créez un objet <xref:System.Net.WebPermission>.  
  
     [!code-csharp[XmlSecureResolver_Samples#4a](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#4a)]
     [!code-vb[XmlSecureResolver_Samples#4a](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#4a)]  
  
2.  Spécifiez les URL que vous souhaitez autoriser l’accès à.  
  
     [!code-csharp[XmlSecureResolver_Samples#4b](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#4b)]
     [!code-vb[XmlSecureResolver_Samples#4b](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#4b)]  
  
3.  Ajoutez les autorisations Web à l'objet <xref:System.Security.PermissionSet>.  
  
     [!code-csharp[XmlSecureResolver_Samples#4c](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#4c)]
     [!code-vb[XmlSecureResolver_Samples#4c](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#4c)]  
  
4.  Utilisez le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.Security.PermissionSet%29> constructeur pour créer un <xref:System.Xml.XmlSecureResolver> objet en utilisant le jeu d’autorisations.  
  
     [!code-csharp[XmlSecureResolver_Samples#4d](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#4d)]
     [!code-vb[XmlSecureResolver_Samples#4d](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#4d)]  
  
     Consultez le <xref:System.Xml.XmlSecureResolver.%23ctor%2A> page de référence pour un autre exemple.  
  
## <a name="to-restrict-access-by-using-evidence"></a>Pour restreindre l’accès à l’aide de preuves  
 Vous pouvez restreindre l’accès à l’aide de la <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> constructeur et en spécifiant <xref:System.Security.Policy.Evidence>. L'objet <xref:System.Security.Policy.Evidence> permet de créer l'objet <xref:System.Security.PermissionSet> appliqué à l'objet <xref:System.Xml.XmlResolver> sous-jacent. L'objet <xref:System.Xml.XmlSecureResolver> appelle la méthode <xref:System.Security.PermissionSet.PermitOnly%2A> de l'objet <xref:System.Security.PermissionSet> créé avant l'ouverture de ressources.  
  
 Voici quelques scénarios courants et le type de preuve à fournir pour chacun :  
  
-   Si vous travaillez dans un environnement totalement fiable, utilisez votre assembly pour créer la preuve :  
  
     [!code-csharp[XmlSecureResolver_Samples#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#1)]
     [!code-vb[XmlSecureResolver_Samples#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#1)]  
  
-   Si vous travaillez dans un environnement de confiance partiel, des codes ou des données provenant d’une source externe, et que vous connaissez l’origine de la source externe et possédez un URI vérifiable, utilisez l’URI pour créer la preuve :  
  
     [!code-csharp[XmlSecureResolver_Samples#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#2)]
     [!code-vb[XmlSecureResolver_Samples#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#2)]  
  
-   Si vous travaillez dans un environnement de confiance partiel et que vous avez code ou des données provenant d’une source externe, mais vous ne connaissez pas l’origine de la source externe, soit :  
  
     Définissez le paramètre `evidence` sur `null`. Ainsi, aucun accès aux ressources n'est autorisé.  
  
     - ou -  
  
     Si votre application nécessite un accès aux ressources, demandez une preuve à l'appelant.  
  
## <a name="to-use-the-secure-resolver-to-load-an-xslt-style-sheet"></a>Pour utiliser le programme de résolution sécurisée pour charger une feuille de style XSLT  
  
1.  Créez un objet <xref:System.Xml.XmlSecureResolver> avec un jeu d'autorisations correct.  
  
2.  Transmettez l'objet <xref:System.Xml.XmlSecureResolver> à la méthode <xref:System.Xml.Xsl.XslCompiledTransform.Load%2A>.  
  
     [!code-csharp[XmlSecureResolver_Samples#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#6)]
     [!code-vb[XmlSecureResolver_Samples#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#6)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Cette classe a une demande d’héritage. Confiance totale est requise pour hériter la <see cref="T:System.Xml.XmlSecureResolver" /> classe.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlSecureResolver" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les trois constructeurs fournissent trois types de restrictions d’accès :  
  
-   Le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.String%29> constructeur restreint l’accès à l’aide d’une URL.  
  
-   Le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.Security.PermissionSet%29> constructeur restreint l’accès à l’aide d’un jeu d’autorisations.  
  
-   Le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.Security.Policy.Evidence%29> constructeur restreint l’accès à l’aide de preuve.  
  
 Consultez les rubriques de référence de constructeur pour obtenir des exemples de ces types de restrictions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSecureResolver (System.Xml.XmlResolver resolver, System.Security.PermissionSet permissionSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlResolver resolver, class System.Security.PermissionSet permissionSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.#ctor(System.Xml.XmlResolver,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSecureResolver(System::Xml::XmlResolver ^ resolver, System::Security::PermissionSet ^ permissionSet);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlSecureResolver : System.Xml.XmlResolver * System.Security.PermissionSet -&gt; System.Xml.XmlSecureResolver" Usage="new System.Xml.XmlSecureResolver (resolver, permissionSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resolver" Type="System.Xml.XmlResolver" />
        <Parameter Name="permissionSet" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="resolver">Programme de résolution XML inclus dans un wrapper par le <see cref="T:System.Xml.XmlSecureResolver" />.</param>
        <param name="permissionSet">Jeu d'autorisations à appliquer au <see cref="T:System.Xml.XmlResolver" /> sous-jacent. Le <see cref="T:System.Xml.XmlSecureResolver" /> appelle la méthode <see cref="M:System.Security.PermissionSet.PermitOnly" /> sur le jeu d'autorisations avant d'appeler la méthode <see cref="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" /> sur le programme de résolution XML sous-jacent.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlSecureResolver" /> avec les <see cref="T:System.Xml.XmlResolver" /> et <see cref="T:System.Security.PermissionSet" /> spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant construit un <xref:System.Xml.XmlSecureResolver> objet à l’aide d’un jeu d’autorisations personnalisé.  
  
 [!code-cpp[XmlSecureResolver.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlSecureResolver.cctor/CPP/secresolver.cpp#1)]
 [!code-csharp[XmlSecureResolver.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver.cctor/CS/secresolver.cs#1)]
 [!code-vb[XmlSecureResolver.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver.cctor/VB/secresolver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlSecureResolver.CreateEvidenceForUrl(System.String)" />
        <altmember cref="T:System.Security.Policy.Evidence" />
        <altmember cref="T:System.Net.WebPermission" />
        <altmember cref="T:System.Security.SecurityManager" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSecureResolver (System.Xml.XmlResolver resolver, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlResolver resolver, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.#ctor(System.Xml.XmlResolver,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSecureResolver(System::Xml::XmlResolver ^ resolver, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlSecureResolver : System.Xml.XmlResolver * System.Security.Policy.Evidence -&gt; System.Xml.XmlSecureResolver" Usage="new System.Xml.XmlSecureResolver (resolver, evidence)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Xml.XmlResolver" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="resolver">Programme de résolution XML inclus dans un wrapper par le <see cref="T:System.Xml.XmlSecureResolver" />.</param>
        <param name="evidence">Preuve utilisée pour créer le <see cref="T:System.Security.PermissionSet" /> qui sera appliqué au <see cref="T:System.Xml.XmlResolver" /> sous-jacent. Le <see cref="T:System.Xml.XmlSecureResolver" /> appelle la méthode <see cref="M:System.Security.PermissionSet.PermitOnly" /> sur le <see cref="T:System.Security.PermissionSet" /> créé avant d'appeler <see cref="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlSecureResolver" /> avec les <see cref="T:System.Xml.XmlResolver" /> et <see cref="T:System.Security.Policy.Evidence" /> spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Voici quelques scénarios possibles et le type de preuve à fournir pour chaque scénario :  
  
-   Si vous travaillez dans un environnement totalement fiable, utilisez votre assembly pour créer la preuve :  
  
     [!code-csharp[XmlSecureResolver_Samples#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#1)]
     [!code-vb[XmlSecureResolver_Samples#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#1)]  
  
-   Si vous travaillez dans un environnement de confiance partiel, des codes ou des données provenant d’une source externe, et que vous connaissez l’origine de la source externe et possédez un URI vérifiable, utilisez l’URI pour créer la preuve :  
  
     [!code-csharp[XmlSecureResolver_Samples#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#2)]
     [!code-vb[XmlSecureResolver_Samples#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#2)]  
  
-   Si vous travaillez dans un environnement de confiance partiel et que vous avez code ou des données provenant d’une source externe, mais vous ne connaissez pas l’origine de la source externe, soit :  
  
     Définissez le paramètre `evidence` sur `null`. Ainsi, aucun accès aux ressources n'est autorisé.  
  
     - ou -  
  
     Si votre application nécessite un accès aux ressources, demandez une preuve à l'appelant.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlSecureResolver (System.Xml.XmlResolver resolver, string securityUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlResolver resolver, string securityUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.#ctor(System.Xml.XmlResolver,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As XmlResolver, securityUrl As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlSecureResolver(System::Xml::XmlResolver ^ resolver, System::String ^ securityUrl);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlSecureResolver : System.Xml.XmlResolver * string -&gt; System.Xml.XmlSecureResolver" Usage="new System.Xml.XmlSecureResolver (resolver, securityUrl)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Xml.XmlResolver" />
        <Parameter Name="securityUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resolver">Programme de résolution XML inclus dans un wrapper par le <see cref="T:System.Xml.XmlSecureResolver" />.</param>
        <param name="securityUrl">URL utilisée pour créer le <see cref="T:System.Security.PermissionSet" /> qui sera appliqué au <see cref="T:System.Xml.XmlResolver" /> sous-jacent. Le <see cref="T:System.Xml.XmlSecureResolver" /> appelle <see cref="M:System.Security.PermissionSet.PermitOnly" /> sur le <see cref="T:System.Security.PermissionSet" /> créé avant d'appeler <see cref="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlSecureResolver" /> avec le <see cref="T:System.Xml.XmlResolver" /> et l'URL spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il existe des différences dans l’infrastructure de sécurité pour le code en cours d’exécution sur le CLR est intégré à Microsoft SQL Server 2005 et pour le code s’exécutant sur le common language runtime (CLR) du .NET Framework. Cela peut entraîner les cas où le code développé pour le CLR de .NET Framework fonctionne différemment lorsqu’il est utilisé sur le serveur SQL intégré CLR. Une de ces différences affecte le <xref:System.Xml.XmlSecureResolver> classe lorsque vous avez la preuve est basée sur une URL (autrement dit, lorsque vous utilisez le <xref:System.Xml.XmlSecureResolver.CreateEvidenceForUrl%2A> méthode ou le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.String%29> constructeur). La stratégie de résolution CLR intégré de mécanisme de SQL Server n’utilise pas le <xref:System.Security.Policy.Url> ou <xref:System.Security.Policy.Zone> plus d’informations. Au lieu de cela, il accorde des autorisations basées sur le GUID que le serveur ajoute lorsque les assemblys sont chargés. Lorsque vous utilisez le <xref:System.Xml.XmlSecureResolver> dans CLR intégré à SQL Server, fournissez toutes les preuves requises directement en utilisant un <xref:System.Security.PermissionSet>.  
  
   
  
## Examples  
 Cet exemple utilise le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.String%29> constructeur pour créer un <xref:System.Xml.XmlSecureResolver> objet qui est autorisé à accéder à votre site intranet local uniquement.  
  
 [!code-csharp[XmlSecureResolver_Samples#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver_Samples/CS/XmlSecureResolver_ex.cs#3)]
 [!code-vb[XmlSecureResolver_Samples#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver_Samples/VB/XmlSecureResolver_ex.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEvidenceForUrl">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.Evidence CreateEvidenceForUrl (string securityUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.Evidence CreateEvidenceForUrl(string securityUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.CreateEvidenceForUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEvidenceForUrl (securityUrl As String) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::Evidence ^ CreateEvidenceForUrl(System::String ^ securityUrl);" />
      <MemberSignature Language="F#" Value="static member CreateEvidenceForUrl : string -&gt; System.Security.Policy.Evidence" Usage="System.Xml.XmlSecureResolver.CreateEvidenceForUrl securityUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="securityUrl">URL utilisée pour créer la preuve.</param>
        <summary>Crée une preuve à l'aide de l'URL fournie.</summary>
        <returns>Preuve générée à partir de l'URL fournie telle que définie par la stratégie par défaut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Il existe des différences dans l’infrastructure de sécurité pour le code en cours d’exécution sur le CLR est intégré à Microsoft SQL Server 2005 et pour le code s’exécutant sur le common language runtime (CLR) du .NET Framework. Cela peut entraîner les cas où le code développé pour le CLR de .NET Framework fonctionne différemment lorsqu’il est utilisé sur le serveur SQL intégré CLR. Une de ces différences affecte le <xref:System.Xml.XmlSecureResolver> classe lorsque vous avez la preuve est basée sur une URL (autrement dit, lorsque vous utilisez le <xref:System.Xml.XmlSecureResolver.CreateEvidenceForUrl%2A> méthode ou le <xref:System.Xml.XmlSecureResolver.%23ctor%28System.Xml.XmlResolver%2CSystem.String%29> constructeur). La stratégie de résolution CLR intégré de mécanisme de SQL Server n’utilise pas le <xref:System.Security.Policy.Url> ou <xref:System.Security.Policy.Zone> plus d’informations. Au lieu de cela, il accorde des autorisations basées sur le GUID que le serveur ajoute lorsque les assemblys sont chargés. Lorsque vous utilisez le <xref:System.Xml.XmlSecureResolver> dans CLR intégré à SQL Server, fournissez toutes les preuves requises directement en utilisant un <xref:System.Security.PermissionSet>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlSecureResolver.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials {  void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials" Usage="System.Xml.XmlSecureResolver.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit les informations d'identification utilisées pour authentifier les demandes web.</summary>
        <value>Informations d'identification à utiliser pour authentifier les demandes web. Le <see cref="T:System.Xml.XmlSecureResolver" /> définit les informations d'identification fournies sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent. Si cette propriété n'est pas définie, la valeur par défaut est <see langword="null" /> ; <see cref="T:System.Xml.XmlSecureResolver" /> n'a donc pas d'informations d'identification d'utilisateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise un <xref:System.Xml.XmlSecureResolver> avec informations d’identification par défaut pour résoudre et ouvrir des ressources réseau requises par le <xref:System.Xml.XmlTextReader>.  
  
 [!code-cpp[XmlSecureResolver.Credentials#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlSecureResolver.Credentials/CPP/secresolver2.cpp#1)]
 [!code-csharp[XmlSecureResolver.Credentials#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSecureResolver.Credentials/CS/secresolver2.cs#1)]
 [!code-vb[XmlSecureResolver.Credentials#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSecureResolver.Credentials/VB/secresolver2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="P:System.Net.CredentialCache.DefaultCredentials" />
      </Docs>
    </Member>
    <Member MemberName="GetEntity">
      <MemberSignature Language="C#" Value="public override object GetEntity (Uri absoluteUri, string role, Type ofObjectToReturn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetEntity(class System.Uri absoluteUri, string role, class System.Type ofObjectToReturn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEntity (absoluteUri As Uri, role As String, ofObjectToReturn As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetEntity(Uri ^ absoluteUri, System::String ^ role, Type ^ ofObjectToReturn);" />
      <MemberSignature Language="F#" Value="override this.GetEntity : Uri * string * Type -&gt; obj" Usage="xmlSecureResolver.GetEntity (absoluteUri, role, ofObjectToReturn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="absoluteUri" Type="System.Uri" />
        <Parameter Name="role" Type="System.String" />
        <Parameter Name="ofObjectToReturn" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="absoluteUri">URI retourné par <see cref="M:System.Xml.XmlSecureResolver.ResolveUri(System.Uri,System.String)" />.</param>
        <param name="role">Pas utilisé pour l'instant.</param>
        <param name="ofObjectToReturn">Type d'objet à retourner. La version actuelle ne retourne que des objets <see cref="T:System.IO.Stream" />.</param>
        <summary>Mappe un URI vers un objet contenant la ressource réelle. Cette méthode définit temporairement le <see cref="T:System.Security.PermissionSet" /> créé dans le constructeur en appelant <see cref="M:System.Security.PermissionSet.PermitOnly" /> avant d'appeler <see langword="GetEntity" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent pour ouvrir la ressource.</summary>
        <returns>Flux retourné en appelant <see langword="GetEntity" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent. Si un type autre que <see cref="T:System.IO.Stream" /> est spécifié, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Votre application peut limiter le déni de service sur le <xref:System.Xml.XmlSecureResolver.GetEntity%2A> méthode en implémentant un <xref:System.Runtime.InteropServices.ComTypes.IStream> qui limite le nombre d’octets lus. Cela permet de se prémunir contre les situations où un code malveillant essaie de passer un flux infini d’octets à la <xref:System.Xml.XmlSecureResolver.GetEntity%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="ofObjectToReturn" /> n'est ni <see langword="null" /> ni un type <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.UriFormatException">L'URI spécifié n'est pas un URI absolu.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="absoluteUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Exception">Une erreur d'exécution se produit (par exemple, une interruption de la connexion au serveur).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntityAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;object&gt; GetEntityAsync (Uri absoluteUri, string role, Type ofObjectToReturn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; GetEntityAsync(class System.Uri absoluteUri, string role, class System.Type ofObjectToReturn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.GetEntityAsync(System.Uri,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEntityAsync (absoluteUri As Uri, role As String, ofObjectToReturn As Type) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ GetEntityAsync(Uri ^ absoluteUri, System::String ^ role, Type ^ ofObjectToReturn);" />
      <MemberSignature Language="F#" Value="override this.GetEntityAsync : Uri * string * Type -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlSecureResolver.GetEntityAsync (absoluteUri, role, ofObjectToReturn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="absoluteUri" Type="System.Uri" />
        <Parameter Name="role" Type="System.String" />
        <Parameter Name="ofObjectToReturn" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="absoluteUri">URI retourné par <see cref="M:System.Xml.XmlSecureResolver.ResolveUri(System.Uri,System.String)" />.</param>
        <param name="role">Pas utilisé pour l'instant.</param>
        <param name="ofObjectToReturn">Type d'objet à retourner. La version actuelle ne retourne que des objets <see cref="T:System.IO.Stream" />.</param>
        <summary>Mappe de façon asynchrone un URI vers un objet contenant la ressource réelle.</summary>
        <returns>Flux retourné en appelant <see langword="GetEntity" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent. Si un type autre que <see cref="T:System.IO.Stream" /> est spécifié, la méthode retourne <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveUri">
      <MemberSignature Language="C#" Value="public override Uri ResolveUri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Uri ResolveUri(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlSecureResolver.ResolveUri(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveUri (baseUri As Uri, relativeUri As String) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Uri ^ ResolveUri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="override this.ResolveUri : Uri * string -&gt; Uri" Usage="xmlSecureResolver.ResolveUri (baseUri, relativeUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI de base utilisé pour résoudre l'URI relatif.</param>
        <param name="relativeUri">URI à résoudre. L'URI peut être absolu ou relatif. S'il est absolu, cette valeur remplace effectivement la valeur de <paramref name="baseUri" />. S'il est relatif, il se combine à <paramref name="baseUri" /> pour produire un URI absolu.</param>
        <summary>Résout l'URI absolu à partir des URI de base et relatifs en appelant <see langword="ResolveUri" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent.</summary>
        <returns>URI absolu ou <see langword="null" /> si l'URI relatif ne peut pas être résolu (retourné en appelant <see langword="ResolveUri" /> sur le <see cref="T:System.Xml.XmlResolver" /> sous-jacent).</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="relativeUri" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>