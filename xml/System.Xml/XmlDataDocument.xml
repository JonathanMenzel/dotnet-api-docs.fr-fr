<Type Name="XmlDataDocument" FullName="System.Xml.XmlDataDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="04468dfdaffe0651a1c8a5d299f43addee6d2261" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48607000" /></Metadata><TypeSignature Language="C#" Value="public class XmlDataDocument : System.Xml.XmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDataDocument extends System.Xml.XmlDocument" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDataDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDataDocument&#xA;Inherits XmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDataDocument : System::Xml::XmlDocument" />
  <TypeSignature Language="F#" Value="type XmlDataDocument = class&#xA;    inherit XmlDocument" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlDocument</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Obsolete("XmlDataDocument class will be removed in a future release.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permet le stockage, la récupération et la manipulation de données structurées par l'entremise d'un <see cref="T:System.Data.DataSet" /> relationnel.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe étend <xref:System.Xml.XmlDocument>. Il vous permet de charger des données relationnelles ou des données XML et de manipuler des données en utilisant le World Wide Web Consortium (W3C) modèle DOM (Document Object). Le modèle DOM présente les données sous forme de hiérarchie d’objets de nœud. Étant donné que `XmlDataDocument` implémente le <xref:System.Xml.XPath.IXPathNavigable> interface, il peut également servir le document source pour la <xref:System.Xml.Xsl.XslTransform> classe.  
  
 `XmlDataDocument` possède une affiliation étroite avec la `DataSet` classe, qui fournit une vue relationnelle des données XML chargées. Toute modification apportée à la `XmlDataDocument` sont répercutées dans le `DataSet` et vice versa.  
  
 Pour charger un `DataSet` avec des données XML, utilisez <xref:System.Data.DataSet.ReadXmlSchema%2A> pour construire un mappage relationnel. Les données XML peuvent ensuite être chargées à l’aide de <xref:System.Xml.XmlDataDocument.Load%2A> ou <xref:System.Xml.XmlDocument.LoadXml%2A>.  
  
 Pour charger des données relationnelles, spécifiez le `DataSet` contenant les données relationnelles en tant que paramètre dans le <xref:System.Xml.XmlDataDocument.%23ctor%2A> constructeur.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlDataDocument" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlDataDocument" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vide <xref:System.Data.DataSet> est créé et associé à la `XmlDataDocument`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument (System.Data.DataSet dataset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataSet dataset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument(System::Data::DataSet ^ dataset);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDataDocument : System.Data.DataSet -&gt; System.Xml.XmlDataDocument" Usage="new System.Xml.XmlDataDocument dataset" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataset" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataset"><see langword="DataSet" /> à charger dans <see langword="XmlDataDocument" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xml.XmlDataDocument" /> avec le <see cref="T:System.Data.DataSet" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `XmlDataDocument` est synchronisée avec la valeur `DataSet`. Toutes les données dans le `DataSet` est immédiatement disponible via le `XmlDataDocument`. Les modifications apportées à la `DataSet` sont propagées dans la `XmlDataDocument`. Les modifications apportées dans le `XmlDataDocument`, à condition qu’ils correspondent à la `DataSet` schéma, sont propagées dans la `DataSet`.  
  
   
  
## Examples  
 L’exemple suivant charge une table de clients dans un `XmlDataDocument`.  
  
 L’exemple utilise la base de données Northwind SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.SqlClient.SqlConnection" />
        <altmember cref="T:System.Data.SqlClient.SqlDataAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="abstract member CloneNode : bool -&gt; System.Xml.XmlNode&#xA;override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDataDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep"><see langword="true" /> pour cloner récursivement la sous-arborescence sous le nœud spécifié ; <see langword="false" /> pour cloner seulement le nœud lui-même.</param>
        <summary>Crée un doublon du nœud en cours.</summary>
        <returns>Nœud cloné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le clonage du `XmlDataDocument` clone également le <xref:System.Data.DataSet> schéma.  
  
 Si `deep` a la valeur `false`, cloné `DataSet` a pas de données ; c'est-à-dire, aucune ligne.  
  
 Si `deep` a la valeur `true`, cloné `DataSet` est définie avec le schéma et ensuite remplie avec les données.  
  
 Consultez <xref:System.Xml.XmlNode.CloneNode%2A> dans la `XmlNode` classe pour voir un tableau décrivant comment cette méthode se comporte avec chacun des différents types de nœuds.  
  
   
  
## Examples  
 L’exemple suivant charge un `DataSet` dans un `XmlDataDocument` , puis crée un clone superficiel du `XmlDataDocument`.  
  
 L’exemple utilise la base de données Northwind SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateElement : string * string * string -&gt; System.Xml.XmlElement&#xA;override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Préfixe du nouvel élément. Dans le cas de String.Empty ou de <see langword="null" />, il n'y a aucun préfixe.</param>
        <param name="localName">Le nom local du nouvel élément.</param>
        <param name="namespaceURI">URI (Uniform Resource Identifier) de l'espace de noms du nouvel élément. Dans le cas de String.Empty ou de <see langword="null" />, il n'y a aucun namespaceURI.</param>
        <summary>Crée un élément avec les <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> et <see cref="P:System.Xml.XmlNode.NamespaceURI" /> spécifiés.</summary>
        <returns>Nouveau <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Note to Inheritors` Si vous surchargez cette fonction, il ne peut pas être utilisé pour l’extensibilité. Au lieu de cela, vous pouvez retourner un élément créé par la classe de base dans ce cas, `XmlDataDocument`. Lisez l'exemple suivant.  
  
```csharp  
class MyXmlDataDocument : XmlDataDocument {  
 public override XmlElement CreateElement(string prefix, string localName, string nsURI) {  
   //Ensure we are returning the base class implementation of element.  
   XmlElement e = base.CreateElement(prefix, localName, nsURI);  
   //Add additional code here.  
   return e;    //Return the element created by XmlDataDocument.  
 }      
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityReference : string -&gt; System.Xml.XmlEntityReference&#xA;override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDataDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la référence d'entité.</param>
        <summary>Crée un élément <see cref="T:System.Xml.XmlEntityReference" /> avec le nom spécifié.</summary>
        <returns><see cref="T:System.Xml.XmlEntityReference" /> portant le nom spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlEntityReference> Impossible de créer des nœuds pour <xref:System.Xml.XmlDataDocument> objets. L'appel de cette méthode lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Appel de cette méthode.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected override System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="abstract member CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator&#xA;override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDataDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">Élément <see cref="T:System.Xml.XmlNode" /> sur lequel vous voulez que le navigateur soit initialement positionné.</param>
        <summary>Crée un objet <see cref="T:System.Xml.XPath.XPathNavigator" /> pour naviguer dans ce document. <see langword="XPathNavigator" /> est placé sur le nœud spécifié dans le paramètre <paramref name="node" />.</summary>
        <returns><see langword="XPathNavigator" /> permettant de naviguer dans le document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `XPathNavigator` fournit un accès aléatoire en lecture seule aux données. Car il est optimisé pour les transformations XSLT, il fournit des avantages de performances lorsqu’il est utilisé comme un mécanisme d’entrée pour le <xref:System.Xml.Xsl.XslTransform.Transform%2A> (méthode).  
  
   
  
## Examples  
 Pour voir une transformation XSLT à l’aide `XmlDataDocument` et un `XPathNavigator`, consultez le <xref:System.Xml.Xsl.XslTransform.Transform%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Xsl.XslTransform" />
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDataDocument.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Xml.XmlDataDocument.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Data.DataSet" /> qui fournit une représentation relationnelle des données dans <see langword="XmlDataDocument" />.</summary>
        <value><see langword="DataSet" /> pouvant être utilisé pour accéder aux données contenues dans le <see langword="XmlDataDocument" /> à l'aide d'un modèle relationnel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `DataSet` vous permet d’accéder aux données dans le `XmlDataDocument` à l’aide d’un modèle relationnel. Cela signifie que vous pouvez gérer les données en tant que tables, des vues, des lignes et des colonnes, relations et ainsi de suite. Modifications apportées dans le `DataSet` sont immédiatement visibles dans le `XmlDataDocument`.  
  
   
  
## Examples  
 L’exemple suivant modifie le prix d’un livre à l’aide de la `DataSet` méthodes.  
  
 [!code-cpp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/VB/source.vb#1)]  
  
 L’exemple utilise les deux fichiers suivants en tant qu’entrée.  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement GetElementById (string elemId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement GetElementById(string elemId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementById (elemId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ GetElementById(System::String ^ elemId);" />
      <MemberSignature Language="F#" Value="abstract member GetElementById : string -&gt; System.Xml.XmlElement&#xA;override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementById elemId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elemId">ID d'attribut avec lequel établir une correspondance.</param>
        <summary>Obtient l'élément <see cref="T:System.Xml.XmlElement" /> avec l'ID spécifié. Cette méthode n'est pas prise en charge par la classe <see cref="T:System.Xml.XmlDataDocument" />. L'appel de cette méthode lève une exception.</summary>
        <returns><see cref="T:System.Xml.XmlElement" /> avec l'ID spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n'est pas prise en charge par la classe <xref:System.Xml.XmlDataDocument>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Appel de cette méthode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromRow">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement GetElementFromRow (System.Data.DataRow r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement GetElementFromRow(class System.Data.DataRow r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementFromRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementFromRow (r As DataRow) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ GetElementFromRow(System::Data::DataRow ^ r);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromRow : System.Data.DataRow -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementFromRow r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="r"><see langword="DataRow" /> dont vous voulez récupérer le <see langword="XmlElement" /> associé.</param>
        <summary>Récupère le <see cref="T:System.Xml.XmlElement" /> associé au <see cref="T:System.Data.DataRow" /> spécifié.</summary>
        <returns><see langword="XmlElement" /> contenant une représentation du <see langword="DataRow" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant charge un `DataSet` dans un `XmlDataDocument` et crée ensuite un `XmlElement` représentant le premier enregistrement de client.  
  
 L’exemple utilise la base de données Northwind SQL Server 2000.  
  
 [!code-cpp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDataDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié à trouver. Il est comparé à la propriété <see cref="P:System.Xml.XmlDocument.Name" /> du nœud correspondant. La valeur spéciale "*" correspond à toutes les étiquettes.</param>
        <summary>Retourne un élément <see cref="T:System.Xml.XmlNodeList" /> contenant la liste de tous les éléments descendants qui correspondent à l'élément <see cref="P:System.Xml.XmlDocument.Name" /> spécifié.</summary>
        <returns>Un élément <see cref="T:System.Xml.XmlNodeList" /> contenant la liste de tous les nœuds correspondants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Il est recommandé d’utiliser le <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> ou <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> méthode au lieu du <xref:System.Xml.XmlDataDocument.GetElementsByTagName%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRowFromElement">
      <MemberSignature Language="C#" Value="public System.Data.DataRow GetRowFromElement (System.Xml.XmlElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow GetRowFromElement(class System.Xml.XmlElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetRowFromElement(System.Xml.XmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRowFromElement (e As XmlElement) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ GetRowFromElement(System::Xml::XmlElement ^ e);" />
      <MemberSignature Language="F#" Value="member this.GetRowFromElement : System.Xml.XmlElement -&gt; System.Data.DataRow" Usage="xmlDataDocument.GetRowFromElement e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Xml.XmlElement" />
      </Parameters>
      <Docs>
        <param name="e"><see langword="XmlElement" /> dont vous voulez récupérer le <see langword="DataRow" /> associé.</param>
        <summary>Récupère le <see cref="T:System.Data.DataRow" /> associé au <see cref="T:System.Xml.XmlElement" /> spécifié.</summary>
        <returns><see langword="DataRow" /> contenant une représentation de <see langword="XmlElement" /> ; <see langword="null" /> s'il n'y a pas de <see langword="DataRow" /> associé à <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant modifie le prix du premier livre.  
  
 [!code-cpp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CPP/getrow.cpp#1)]
 [!code-csharp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CS/getrow.cs#1)]
 [!code-vb[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/VB/getrow.vb#1)]  
  
 L’exemple utilise les fichiers d’entrée suivants :  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge <see langword="XmlDataDocument" /> en utilisant la source de données spécifiée et synchronise <see cref="T:System.Data.DataSet" /> avec les données chargées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour afficher les données XML de manière relationnelle, vous devez tout d’abord spécifier un schéma à utiliser pour le mappage de données. Cela peut être effectué en appelant le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode ou en créant les tables et colonnes dans le `DataSet` manuellement. Cette étape doit être effectuée avant d’appeler `Load`.  
  
 `XmlDataDocument` ne prend pas en charge la création des références d’entité. Si les données incluent des références d’entité, le `Load` méthode résout et développe les références d’entité. Toutefois, si vous utilisez le `Load` surcharge qui accepte un <xref:System.Xml.XmlReader> en tant qu’argument, vous devez spécifier un `XmlReader` qui peut résoudre les entités.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.Stream -&gt; unit&#xA;override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDataDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Flux contenant le document XML à charger.</param>
        <summary>Charge le <see langword="XmlDataDocument" /> à partir du flux spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` ne prend pas en charge la création des références d’entité. Si les données incluent des références d’entité, le `Load` méthode résout et développe les références d’entité.  
  
> [!NOTE]
>  Pour afficher les données XML de manière relationnelle, vous devez tout d’abord spécifier un schéma à utiliser pour le mappage de données. Cela peut être effectué en appelant le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode ou en créant les tables et colonnes dans le `DataSet` manuellement. Cette étape doit être effectuée avant d’appeler `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.TextReader -&gt; unit&#xA;override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDataDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">L'élément <see langword="TextReader" /> utilisé pour introduire les données XML dans le document.</param>
        <summary>Charge le <see langword="XmlDataDocument" /> à partir du <see cref="T:System.IO.TextReader" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` ne prend pas en charge la création des références d’entité. Si les données incluent des références d’entité, le `Load` méthode résout et développe les références d’entité.  
  
> [!NOTE]
>  Pour afficher les données XML de manière relationnelle, vous devez tout d’abord spécifier un schéma à utiliser pour le mappage de données. Cela peut être effectué en appelant le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode ou en créant les tables et colonnes dans le `DataSet` manuellement. Cette étape doit être effectuée avant d’appeler `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; unit&#xA;override this.Load : string -&gt; unit" Usage="xmlDataDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">URL du fichier contenant le document XML à charger.</param>
        <summary>Charge le <see langword="XmlDataDocument" /> à partir de l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` ne prend pas en charge la création des références d’entité. Si les données incluent des références d’entité, le `Load` méthode résout et développe les références d’entité.  
  
> [!NOTE]
>  Pour afficher les données XML de manière relationnelle, vous devez tout d’abord spécifier un schéma à utiliser pour le mappage de données. Cela peut être effectué en appelant le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode ou en créant les tables et colonnes dans le `DataSet` manuellement. Cette étape doit être effectuée avant d’appeler `Load`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Xml.XmlReader -&gt; unit&#xA;override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDataDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="XmlReader" /> contenant le document XML à charger.</param>
        <summary>Charge le <see langword="XmlDataDocument" /> à partir du <see cref="T:System.Xml.XmlReader" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument` ne prend pas en charge la création des références d’entité. Si la source de données contient des références d’entité, vous devez créer un <xref:System.Xml.XmlValidatingReader> avec la <xref:System.Xml.XmlValidatingReader.EntityHandling%2A> propriété EntityHandling.ExpandEntities (il s’agit du comportement par défaut) et passer le `XmlValidatingReader` à la `Load` (méthode). Si vous n’utilisez pas un `XmlValidatingReader`, le `Load` méthode lève une exception.  
  
 Le `Load` méthode conserve toujours l’espace blanc significatif. Le <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propriété détermine si l’espace blanc est conservé. La valeur par défaut est `false`, l’espace blanc n’est pas conservé.  
  
 Si le lecteur est dans l’initiale état, autrement dit, ReadState .initial, `Load` consomme tout le contenu du lecteur et crée le DOM à partir de ce qu’il trouve.  
  
 Si le lecteur est déjà positionné sur un nœud à la profondeur « n », cette méthode charge ce nœud et tous les frères successifs jusqu'à la balise de fin qui ferme la profondeur « n ». Cela a les conséquences suivantes.  
  
 Si le nœud actuel et ses frères suivants ressembler à ce qui suit :  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` lève une exception, car un document ne peut pas avoir deux éléments de niveau racine. Si le nœud actuel et ses frères suivants ressembler à ce qui suit :  
  
```xml  
<!--comment--><?process  
    instruction?><!--comment--></endtag>  
```  
  
 `Load` réussit ; Toutefois, avoir une arborescence DOM incomplet, car il n’existe aucun élément de niveau racine. Vous devez ajouter un élément de niveau racine avant d’enregistrer le document ; Sinon, le <xref:System.Xml.XmlDocument.Save%2A> méthode lève une exception.  
  
 Si le lecteur est positionné sur un nœud sans descendant non valide pour le niveau racine d'un document (par exemple, un espace blanc ou un nœud d'attribut), le lecteur poursuit la lecture jusqu'à se positionner sur un nœud pouvant être utilisé pour la racine. Le chargement du document démarre à ce stade.  
  
   
  
## Examples  
 L’exemple suivant modifie le prix d’un livre à l’aide de la `DataSet` méthodes.  
  
 [!code-cpp[XmlDataDocument.Load#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.Load/CPP/loadrdr.cpp#1)]
 [!code-csharp[XmlDataDocument.Load#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.Load/CS/loadrdr.cs#1)]
 [!code-vb[XmlDataDocument.Load#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.Load/VB/loadrdr.vb#1)]  
  
 L’exemple utilise les deux fichiers d’entrée suivants.  
  
 `2books.xml`  
  
 [!code-xml[XmlDataDocument.Load#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/2books.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[XmlDataDocument.Load#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/test.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le XML en cours de chargement contient des références d'entités et le lecteur ne peut pas résoudre les entités.</exception>
      </Docs>
    </Member>
  </Members>
</Type>