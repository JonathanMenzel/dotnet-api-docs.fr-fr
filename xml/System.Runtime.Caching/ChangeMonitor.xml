<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ChangeMonitor.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ef439688d7b98a238cf8640eb07e63804432a3ba.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ef439688d7b98a238cf8640eb07e63804432a3ba</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</source>
          <target state="translated">Fournit une classe de base pour un type personnalisé dérivé qui surveille les modifications de l'état des données dont dépend un élément de cache.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classe est utilisée comme classe de base pour les classes de surveillance dérivées spécialisées pour les implémentations de cache particulière.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance monitors changes in the state of data which a cache item depends on.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance surveille les modifications de l’état des données dont dépend un élément de cache.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the item can be a file or data entity whose contents are cached.</source>
          <target state="translated">Par exemple, l’élément peut être une entité de données ou de fichier dont le contenu est mis en cache.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the file or data entity is updated, the associated cache entry must be changed also.</source>
          <target state="translated">Si l’entité de données ou le fichier est mis à jour, l’entrée du cache associée doit également être modifiée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</source>
          <target state="translated">Éléments communs qui peuvent être surveillés incluent des entités de données (par exemple, les champs de la base de données, les valeurs, les lignes ou les tables), une autre entrée de cache et les fichiers et les attributs de fichier.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A dependency change is a change in the state of a dependency.</source>
          <target state="translated">Une modification de dépendance est une modification de l’état d’une dépendance.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>In a typical cache implementation, after a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</source>
          <target state="translated">Dans une implémentation de cache typique, après un <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance notifie le cache qu’une dépendance a changé, le cache exécute l’action requise, tels que l’invalidation de l’entrée de cache insérée.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classes can be customized to monitor dependency changes for specific different data stores.</source>
          <target state="translated">Dérivés <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classes peuvent être personnalisées pour surveiller les modifications de dépendance pour les magasins de données différents spécifiques.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, there are cache implementations for a file system, physical memory, or a database.</source>
          <target state="translated">Par exemple, il existe des implémentations de cache pour un système de fichiers, la mémoire physique ou une base de données.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classe examine les modifications qui se produisent à l’extérieur du cache, puis avertit le cache de modifications ont été apportées.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> includes the following classes that derive from <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class:</source>
          <target state="translated">Le <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> comprend les classes suivantes qui dérivent <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classe :</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Each of these classes works with different types of dependencies.</source>
          <target state="translated">Chacune de ces classes fonctionne avec différents types de dépendances.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For example, the derived <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</source>
          <target state="translated">Par exemple, dérivé <ph id="ph1">&lt;xref:System.Runtime.Caching.FileChangeMonitor&gt;</ph> classe surveille les modifications apportées à un cache des données de système de fichiers (fichiers et dossiers) qui dépend de l’élément de cache.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines.</source>
          <target state="translated">Si vous créer une implémentation de cache ou une modification dérivée de type de moniteur, vous devez respecter certaines règles.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The following list summarizes these guidelines.</source>
          <target state="translated">La liste suivante résume ces instructions.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the documentation for individual methods or properties.</source>
          <target state="translated">Pour plus d’informations, consultez la documentation pour les méthodes ou propriétés.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the method returns.</source>
          <target state="translated">Le constructeur d’une classe dérivée doit définir la <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> propriété, commencer la surveillance et appeler <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> méthode avant le retour de la méthode.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called because the <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload will throw an <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> exception if initialization is not completed.</source>
          <target state="translated">Si un constructeur rencontre une erreur lors des constructions et doit supprimer des ressources, le constructeur peut appeler uniquement la <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> surcharge après le <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> méthode est appelée, car le <ph id="ph3">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> surcharge lèvera une <ph id="ph4">&lt;see cref="T:System.InvalidOperationException" /&gt;</ph> exception si l’initialisation n’est pas terminée.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before calling the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">Si les modifications se produisent dans les données en cours d’analyse avant l’initialisation est terminée, le constructeur doit appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode avant d’appeler le <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> type is instantiated, you must insert the monitor into a custom <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation.</source>
          <target state="translated">Après avoir dérivé <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> type est instancié, vous devez insérer l’analyseur dans personnalisé <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implémentation.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Or if you are finished using the change monitor, call the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">Ou si vous avez terminé à l’aide de l’Analyseur de modification, appelez le <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance is inserted into a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation, the <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance require that the change monitor is disposed.</source>
          <target state="translated">Après un <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance est insérée dans un <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> mise en œuvre, le <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance nécessite que le suivi des modifications est supprimé.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Even if the insertion is invalid and causes an exception, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">Même si l’insertion n’est pas valide et provoque une exception, le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implémentation doit appeler la <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After a derived change monitor is inserted into a cache, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation must call <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, by passing a <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object.</source>
          <target state="translated">Une fois que l’Analyseur de modification dérivé est inséré dans un cache, le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implémentation doit appeler <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>, en passant un <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method can be called only one time.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> méthode peut être appelée qu’une seule fois.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called immediately when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">Si une modification de dépendance a déjà eu lieu, le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance sera appelée immédiatement lorsque <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called only one time.</source>
          <target state="translated">Dans le cas contraire, le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance sera appelée qu’une seule fois.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This one time call occurs either when the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called because the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance detected a change, or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called on the <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, whichever occurs first.</source>
          <target state="translated">Cette un fois appel produit lorsque le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode est appelée, car le <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance a détecté une modification, ou lorsque le <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode est appelée sur le <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>, selon ce qui se produit en premier.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance that is provided by an <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implementation should remove the associated cache entry and specify a reason by using the <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> enumeration.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance qui est fournie par un <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> implémentation doit supprimer l’entrée du cache associée et spécifier une raison à l’aide de la <ph id="ph3">&lt;see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance can call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method either before a cache implementation has called <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or after.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance peut appeler le <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode avant qu’une implémentation de cache a appelé <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> méthode ou après.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called before <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called, the base <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> immediately when <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is invoked.</source>
          <target state="translated">Si le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode est appelée avant <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> est appelée, la base de <ph id="ph3">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> implémentation informera le cache qu’il s’est produit et déclenchera le rappel doit être passé à <ph id="ph4">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> immédiatement lorsque <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> est appelé.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Any state data that is passed to the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is saved by the change monitor and subsequently passed to the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method is invoked.</source>
          <target state="translated">Toutes les données d’état sont passées à la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> (méthode) est enregistrée par l’Analyseur de modification et ensuite passée à la <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> (méthode) lors de la <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method.</source>
          <target state="translated">Un analyseur de modification doit implémenter la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>For more information, see the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method documentation.</source>
          <target state="translated">Pour plus d'informations, consultez la documentation sur la méthode <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload must be called to dispose of the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> surcharge de méthode doit être appelée pour supprimer la <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The rules for calling Dispose are as follows:</source>
          <target state="translated">Les règles d’appel de suppression sont les suivantes :</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">Avant qu’un élément est inséré dans le cache, il est responsable de l’appelant de supprimer une <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Once cache item and the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer must make sure that that the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, even if the insert fails.</source>
          <target state="translated">Une fois l’élément du cache et la <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances qui lui sont associées sont passées à un cache, l’implémenteur de cache doit s’assurer que qui le <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode est appelée, même si l’insertion échoue.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>After an item and its associated <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">Après un élément et ses associés <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instances sont passées à un cache, l’appelant ne doit pas supprimer la dépendance car lorsque la <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> est appelée, l’appel est traité comme si la dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>As a result, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is automatically invoked.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode est appelée automatiquement.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">Tenant ces règles, le <ph id="ph1">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode doit être appelée dans une des manières suivantes :</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Users must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">Les utilisateurs doivent appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> si elles décident de ne pas insérer l’instance de l’Analyseur de modification dérivé dans un cache de la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> overload.</source>
          <target state="translated">Si l’implémentation essaie d’insérer l’instance de l’Analyseur de modification dans un cache d’objets mais que l’insertion échoue, l’implémentation de cache est chargée d’appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.</source>
          <target state="translated">Lors de la tentative d’insertion provoque une exception, l’implémentation de cache doit supprimer toutes les dépendances associées.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>If the cache entry is removed, the cache implementation must also dispose of the dependency.</source>
          <target state="translated">Si l’entrée de cache est supprimée, l’implémentation de cache doit également supprimer de la dépendance.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The internal implementation of the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method automatically calls the <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method after it calls a callback that is registered through <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>.</source>
          <target state="translated">L’implémentation interne de la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode appelle automatiquement la <ph id="ph2">&lt;see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode après avoir appelé un rappel qui est inscrit via <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>This automatic call to the dispose method during the event firing only occurs if the initialization of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance was previously completed.</source>
          <target state="translated">Cet appel automatique à la méthode dispose pendant le déclenchement d’un événement se produit uniquement si l’initialisation de la <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance a été effectuée précédemment.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method will automatically dispose of the change monitor.</source>
          <target state="translated">Lorsque le constructeur d’un analyseur de modification dérivé appelle la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> méthode, si l’état de l’Analyseur de modification a déjà changé (autrement dit, l’état qui est surveillé a déjà été modifié lorsque le constructeur était encore actif), puis le <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> méthode sera supprimer automatiquement le suivi des modifications.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> property is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph> after the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called by the derived change-monitor instance, regardless of whether a <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> object has been set by a call to the <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method or not.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /&gt;</ph> est définie sur <ph id="ph2">&lt;see langword="true" /&gt;</ph> après le <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode est appelée par l’instance de l’Analyseur de modification dérivé, indépendamment du fait qu’un <ph id="ph4">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> objet a été défini par un appel à la <ph id="ph5">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> méthode ou non.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>This constructor is called from constructors in derived classes to initialize the base class.</source>
          <target state="translated">Ce constructeur est appelé par les constructeurs de classes dérivées pour initialiser la classe de base.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class has a default constructor.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classe a un constructeur par défaut.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>However, classes that inherit from the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class and define custom change-monitoring behavior must perform initialization in the constructor.</source>
          <target state="translated">Toutefois, les classes qui héritent de la base de <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> de classe et de définir l’analyse de modification personnalisé comportement doit exécuter l’initialisation dans le constructeur.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>For more information, see the Notes for Inheritors section.</source>
          <target state="translated">Pour plus d’informations, consultez les section Remarques à l’attention des héritiers.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>The constructor of a derived class must set the <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> property, begin monitoring, and call the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> class before it returns.</source>
          <target state="translated">Le constructeur d’une classe dérivée doit définir la <ph id="ph1">&lt;see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /&gt;</ph> propriété, commencer la surveillance et appeler la <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> classe avant d’être retournée.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method before it calls the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method.</source>
          <target state="translated">Si une dépendance change avant l’initialisation est terminée (par exemple, si une clé de cache dépendante est introuvable dans le cache), le constructeur doit appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode avant d’appeler le <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.#ctor">
          <source>In this case, constructor can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">Dans ce cas, le constructeur peut appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode uniquement après avoir le <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> méthode est appelée, car le <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode lève une exception si l’initialisation n’est pas terminée.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is used to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance and related resources.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode est utilisée pour libérer le <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance et les ressources associées.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The public <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance so that the instance can be garbage collected.</source>
          <target state="translated">Public <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode est appelée pour coordonner le processus d’élimination avec les événements de cycle de vie des clés de classes dérivées de suivi des modifications (par exemple, l’initialisation) et pour libérer le <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> afin que l’instance peut être le garbage collecté de l’instance.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.Caching.ChangeMonitor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode est implémentée par les classes dérivées de suivi des modifications pour les supprimer de leurs ressources managées et non managées.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Releases all resources that are used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Libère toutes les ressources qui sont utilisées par l'instance actuelle de la classe <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method invokes the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method of derived classes only one time, the first time it is called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode appelle la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode des classes dérivées qu’une seule fois, la première fois qu’elle est appelée.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Subsequent calls to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method have no effect.</source>
          <target state="translated">Les appels suivants à la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> (méthode) n’ont aucun effet.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After the method has been called, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> property is set to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Une fois que la méthode a été appelée, le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A&gt;</ph> est définie sur <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload must be called to dispose of a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> surcharge doit être appelée pour supprimer une <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The following are the rules for calling the dispose method:</source>
          <target state="translated">Voici les règles d’appel de la méthode dispose :</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">Avant qu’un élément est inséré dans le cache, il revient l’appelant pour supprimer un <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Once cache item and the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> is called, even if the insert fails.</source>
          <target state="translated">Une fois l’élément du cache et la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances qui lui sont associées sont passées à un cache, l’implémenteur de cache doit s’assurer que <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> est appelée, même si l’insertion échoue.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>After an item and its associated <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances are passed to a cache, the caller must not dispose the dependency because when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method is called, the call is treated as if the dependency has changed.</source>
          <target state="translated">Après un élément et ses associés <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instances sont passées à un cache, l’appelant ne doit pas supprimer la dépendance car lorsque la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> est appelée, l’appel est traité comme si la dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>As a result, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is automatically invoked.</source>
          <target state="translated">Par conséquent, le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée automatiquement.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Taking these rules into consideration, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method must be called in one of the following ways:</source>
          <target state="translated">Tenant ces règles, le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode doit être appelée dans une des manières suivantes :</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users must call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method overload if they decide not to insert the derived change-monitor instance into a cache.</source>
          <target state="translated">Les utilisateurs doivent appeler le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> si elles décident de ne pas insérer l’instance de l’Analyseur de modification dérivé dans un cache de la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The cache implementation is responsible for calling the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</source>
          <target state="translated">L’implémentation de cache est chargée d’appeler le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> surcharge si l’implémentation essaie d’insérer l’instance de l’Analyseur de modification dans un cache d’objets, mais que l’insertion échoue.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</source>
          <target state="translated">Lors de la tentative d’insertion provoque une exception, l’implémentation de cache doit supprimer toutes les dépendances associées.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>If the cache entry is removed, the cache implementation must also dispose the dependency.</source>
          <target state="translated">Si l’entrée de cache est supprimée, l’implémentation de cache doit également supprimer la dépendance.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>The internal implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically calls the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method after it calls a callback that is registered through the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">L’implémentation interne de la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode appelle automatiquement la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode après avoir appelé un rappel qui est inscrit via le <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>This automatic dispose during the event firing only occurs if the initialization of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance previously completed.</source>
          <target state="translated">Cette suppression automatique pendant le déclenchement d’un événement se produit uniquement si l’initialisation de la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance précédemment s’est terminée.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>When a derived change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method will automatically dispose the change monitor.</source>
          <target state="translated">Lorsque le constructeur d’un analyseur de modification dérivé appelle la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> méthode, si l’état de l’Analyseur de modification a déjà changé (autrement dit, l’état qui est surveillé a déjà été modifié lorsque le constructeur était encore actif) puis <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> méthode sera supprime automatiquement le suivi des modifications.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Users should not call the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Les utilisateurs ne doivent pas appeler les <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>However, you cannot prevent users from calling the method.</source>
          <target state="translated">Toutefois, vous ne pouvez pas empêcher les utilisateurs d’appeler la méthode.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Therefore, if they do, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">Par conséquent, le cas échéant, le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>In that case, the cache entry is notified as if the dependency has changed.</source>
          <target state="translated">Dans ce cas, l’entrée du cache est notifiée comme si la dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>To prevent derived classes from overriding <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method, the method is not an explicit interface implementation.</source>
          <target state="translated">Pour empêcher des classes dérivées de substituer <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode, la méthode n’est pas une implémentation d’interface explicite.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose">
          <source>Initialization is not complete in the derived change-monitor class that called the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method.</source>
          <target state="translated">L'initialisation n'est pas terminée dans la classe d'analyseur de modification dérivée qui a appelé la méthode <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> de base.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release managed and unmanaged resources and any references to a <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour libérer les ressources managées et non managées, ainsi que les références à une instance de <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> ; <ph id="ph3">&lt;see langword="false" /&gt;</ph> pour libérer uniquement les ressources non managées.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed, the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method is called by a <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> thread and any external managed references are likely no longer valid because they have already been garbage collected.</source>
          <target state="translated">Lorsque la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph> est transmise, la méthode <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> est appelée par un thread <ph id="ph3">&lt;see langword="finalizer" /&gt;</ph> et les références managées externes ne sont probablement plus valides, car elles ont déjà été récupérées par le garbage collector.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Releases all managed and unmanaged resources and any references to the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance.</source>
          <target state="translated">Libère toutes les ressources managées et non managées, ainsi que les références à l'instance <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>This overload must be implemented by derived change-monitor classes.</source>
          <target state="translated">Cette surcharge doit être implémentée par des classes de surveillance des modifications dérivées.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>When the value of <ph id="ph1">`disposing`</ph> value is <ph id="ph2">`true`</ph>, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</source>
          <target state="translated">Lorsque la valeur de <ph id="ph1">`disposing`</ph> valeur est <ph id="ph2">`true`</ph>, toutes les ressources managées et non managées sont supprimées et toutes les références à cet objet sont libérées afin que l’instance de surveillance des modifications dérivées peut être nettoyées.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>It is guaranteed that the base <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method will invoke the implemented <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method only one time.</source>
          <target state="translated">Il est garanti que la base de <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode appelle la mise en œuvre <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode qu’une seule fois.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must implement the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload to release all managed and unmanaged resources when the value of <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Un analyseur de modification doit implémenter la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> surcharge pour libérer toutes les ressources managées et lorsque la valeur de <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> est <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method overload that has a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="true" /&gt;</ph> is called only one time, namely, when the instance is disposed for the first time.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> surcharge de méthode qui a un <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> valeur <ph id="ph3">&lt;see langword="true" /&gt;</ph> est appelé le qu’une seule fois, à savoir, lorsque l’instance est supprimée pour la première fois.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A change monitor must not call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> overload directly.</source>
          <target state="translated">Un analyseur de modification ne doit pas appeler les <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> surcharger directement.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>A derived change monitor can call the public parameter-less <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method on the base <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class.</source>
          <target state="translated">Analyseur de modification dérivé peut appeler le public sans paramètre <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode sur la base de <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Alternatively, a change monitor can implement a finalizer method.</source>
          <target state="translated">Vous pouvez également un suivi des modifications peut implémenter une méthode de finaliseur.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>In that case, the finalizer can invoke the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> method and pass it a <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> value of <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Dans ce cas, le finaliseur peut appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /&gt;</ph> méthode et lui passer une <ph id="ph2">&lt;paramref name="disposing" /&gt;</ph> valeur <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>However, this is usually unnecessary.</source>
          <target state="translated">Toutefois, cela est généralement pas nécessaire.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance.</source>
          <target state="translated">Surveiller les modifications de la dépendance est généralement effectuée par un service qui conserve une référence à l’instance de l’Analyseur de modification.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary.</source>
          <target state="translated">La référence empêche l’instance par le garbage collecté et est donc une méthode de finaliseur inutiles.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)">
          <source>To avoid memory leaks, when a dependency changes, the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method disposes the change-monitor instance (unless initialization has not finished).</source>
          <target state="translated">Pour éviter les fuites de mémoire, lorsqu’une dépendance change, la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode supprime l’instance de surveillance des modifications (sauf si l’initialisation n’est pas terminé).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Gets a value that indicates that the state that is monitored by the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class has changed.</source>
          <target state="translated">Obtient une valeur qui indique que l'état surveillé par la classe <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> a changé.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the state that is monitored by the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> instance has changed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'état surveillé par l'instance <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> a changé ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>You can check the value of this property in a derived <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> class to see whether a dependency has changed.</source>
          <target state="translated">Vous pouvez vérifier la valeur de cette propriété dans une dérivée <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> classe pour voir si une dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>The value is set to <ph id="ph1">`true`</ph> when a dependency change occurs (that is, when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called).</source>
          <target state="translated">La valeur est définie sur <ph id="ph1">`true`</ph> lorsque se produit une modification de dépendance (autrement dit, quand le <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>After the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called by the derived class, the value of the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property will be <ph id="ph3">`true`</ph>, regardless of whether a <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> instance has been notified by a call to the <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method.</source>
          <target state="translated">Après le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée par la classe dérivée, la valeur de la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> propriété sera <ph id="ph3">`true`</ph>, indépendamment de si un <ph id="ph4">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> instance a été notifiée par un appel à la <ph id="ph5">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Callers can check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property to see whether a dependency has changed.</source>
          <target state="translated">Les appelants peuvent vérifier le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> propriété pour voir si une dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property.</source>
          <target state="translated">Toutefois, dans un environnement multithread, une approche plus simple et plus facile à gérer est d’insérer des données dans une implémentation de cache sans vérifier le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.HasChanged">
          <source>Cache implementations must check the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</source>
          <target state="translated">Les implémentations de cache doivent vérifier le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> propriété pour vous et ne doit pas effectuer une insertion ou opération ensembliste si une ou plusieurs dépendances associées ont déjà été modifié.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>Called from the constructor of derived classes to indicate that initialization is finished.</source>
          <target state="translated">Appelé par le constructeur des classes dérivées pour indiquer que l'initialisation est terminée.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">Si une dépendance change avant que l’initialisation est terminée dans une classe dérivée, le constructeur de la classe dérivée doit appeler le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>When the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is invoked, the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is automatically set to <ph id="ph3">`true`</ph> by the change monitor.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée, le <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> est automatiquement définie sur <ph id="ph3">`true`</ph> par l’Analyseur de modification.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>As a result, when the change monitor's constructor calls the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> method, the base class will automatically call the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">Par conséquent, lorsque le constructeur de l’Analyseur de modification appelle la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A&gt;</ph> (méthode), la classe de base appelle automatiquement la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>If initialization is complete, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method automatically disposes the derived change-monitor instance.</source>
          <target state="translated">Si l’initialisation est terminée, le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode supprime automatiquement l’instance de l’Analyseur de modification dérivé.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class must call the base <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> method before the constructor returns.</source>
          <target state="translated">Le constructeur d’une classe dérivée doit appeler la base de <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> méthode avant le retour du constructeur.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete">
          <source>The constructor of a derived class can call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method only after <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> is called, because the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method throws an exception if initialization is not completed.</source>
          <target state="translated">Le constructeur d’une classe dérivée peut appeler le <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode uniquement après avoir <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /&gt;</ph> est appelée, car le <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode lève une exception si l’initialisation n’est pas terminée.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>Gets a value that indicates that the derived instance of a <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class is disposed.</source>
          <target state="translated">Obtient une valeur qui indique que l'instance dérivée d'une classe <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> est supprimée.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the instance is disposed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'instance est supprimée ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.IsDisposed">
          <source>The property is set to <ph id="ph1">`true`</ph> after the base <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> method in a derived class to dispose of the instance.</source>
          <target state="translated">La propriété est définie <ph id="ph1">`true`</ph> après la base <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> les appels de méthode le <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A&gt;</ph> méthode dans une classe dérivée pour éliminer l’instance.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A reference to a method that is invoked when a dependency has changed.</source>
          <target state="translated">Référence à une méthode appelée lorsqu'une dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Called by Cache implementers to register a callback and notify an <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> instance through the <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> delegate when a dependency has changed.</source>
          <target state="translated">Appelée par les implémenteurs de cache pour inscrire un rappel et notifier une instance de <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ObjectCache" /&gt;</ph> via le délégué <ph id="ph2">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> lorsqu'une dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Cache implementers use this method to wire themselves up to a change monitor.</source>
          <target state="translated">Les implémenteurs de cache utilisent cette méthode pour se connecter à un analyseur de modification.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If you associate one or more change monitors with the cache item, you pass a <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> instance with a populated change monitors property to the cache item.</source>
          <target state="translated">Si vous associez un ou plusieurs analyseurs de modification à l’élément de cache, vous passez un <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy&gt;</ph> instance avec une propriété de moniteurs de modification remplie à l’élément de cache.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>A cache implementer that supports change monitors is responsible for iterating over the <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> property and register the <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegates with each change monitor that it finds.</source>
          <target state="translated">Un implémenteur de cache qui prend en charge les analyseurs de modification est responsable de l’itération sur le <ph id="ph1">&lt;xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A&gt;</ph> propriété et inscrire le <ph id="ph2">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> changement de délégués avec chaque moniteur qu’il trouve.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</source>
          <target state="translated">Étant donné que le <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> délégué inclut un paramètre d’état facultatif, une implémentation d’analyseur de modification concrète peut passer des informations d’état facultatives.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</source>
          <target state="translated">L’implémenteur de cache détermine si une dépendance explicite sur le type d’état qu’un analyseur de modification personnalisé transmet en tant que partie du rappel peut être extraite.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The base cache extensibility API has no requirement for explicit dependency on the type of state.</source>
          <target state="translated">L’API d’extensibilité de cache de base n’a aucune spécification de dépendance explicite sur le type d’état.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The implementation of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method automatically determines whether the state of the monitor has already changed at the time <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called.</source>
          <target state="translated">L’implémentation de la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> méthode détermine automatiquement si l’état de l’analyse a déjà été modifié au moment <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, then the method automatically calls the <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> event handler, that was registered, through the <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A&gt;</ph> propriété est <ph id="ph2">`true`</ph>, la méthode appelle automatiquement la <ph id="ph3">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> Gestionnaire d’événements, qui a été inscrit, via la <ph id="ph4">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</source>
          <target state="translated">Cela se produit car il est possible de l’heure de qu'une implémentation de cache crée un analyseur de modification, à la fois une implémentation de cache Obtient de l’analyse et celui, l’état surveillé sous-jacent a changé.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If the state has already changed then the object that is passed to the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si l’état a déjà changé, l’objet qui est passé à la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method can be invoked only one time, and will throw an exception on subsequent calls.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> méthode peut être appelée qu’une seule fois et lèvera une exception pour les appels suivants.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The callback method has already been invoked.</source>
          <target state="translated">La méthode de rappel a déjà été appelée.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="onChangedCallback" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> method to be notified of any dependency changes.</source>
          <target state="translated">Vous devez appeler la <ph id="ph1">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> méthode à être averti des modifications de dépendance.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>If a dependency change has already occurred, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called when <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> is called.</source>
          <target state="translated">Si une modification de dépendance a déjà eu lieu, le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance sera appelée lorsque <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /&gt;</ph> est appelée.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>Otherwise, the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance will be called one time, either when the <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> method is called or when the <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> method is called, whichever occurs first.</source>
          <target state="translated">Dans le cas contraire, le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance sera appelée une seule fois, soit lorsque la <ph id="ph2">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /&gt;</ph> méthode est appelée ou lorsque la <ph id="ph3">&lt;see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /&gt;</ph> méthode est appelée, selon ce qui se produit en premier.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.</source>
          <target state="translated">Le <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.OnChangedCallback" /&gt;</ph> instance fournie par l’implémentation de cache doit supprimer l’entrée de cache et si elle est demandée par l’appelant du cache, déclencher la modification nécessaire ou un événement de mise à jour à l’appelant du cache d’origine.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)">
          <source>The object cache implementation must remove the cache entry that is associated with a dependency change.</source>
          <target state="translated">L’implémentation de cache d’objet doit supprimer l’entrée de cache qui est associée à une modification de dépendance.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The data for the change event.</source>
          <target state="translated">Données de l'événement de modification.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>This value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Cette valeur peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Called by derived classes to raise the event when a dependency changes.</source>
          <target state="translated">Appelé par les classes dérivées pour déclencher l'événement lorsqu'une dépendance a été modifiée.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called when dependency changes occur.</source>
          <target state="translated">En règle générale, le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée lorsque des modifications de dépendance.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est également appelée lorsqu’une instance de surveillance des modifications est supprimée mais que la suppression se produit uniquement si le rappel n’a pas déjà été appelé.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is called before the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is called, the state data from the call to the <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> method is saved by the cache implementation.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> méthode est appelée avant la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> méthode est appelée, les données d’état de l’appel à la <ph id="ph3">&lt;xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A&gt;</ph> (méthode) est enregistrée par l’implémentation de cache.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)">
          <source>Also, the callback to the <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> method is invoked immediately when the <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> method is invoked.</source>
          <target state="translated">En outre, le rappel pour le <ph id="ph1">&lt;xref:System.Runtime.Caching.OnChangedCallback&gt;</ph> méthode est appelée immédiatement lorsque la <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A&gt;</ph> méthode est appelée.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>Gets a value that represents the <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph> class instance.</source>
          <target state="translated">Obtient une valeur qui représente l'instance de la classe <ph id="ph1">&lt;see cref="T:System.Runtime.Caching.ChangeMonitor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The identifier for a change-monitor instance.</source>
          <target state="translated">Identificateur d'une instance de surveillance des modifications.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> valeur de propriété se compose généralement dépendance noms combinée des données de chaîne qui identifie de façon unique les données surveillées par une <ph id="ph2">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> property is a string.</source>
          <target state="translated">La valeur de la <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A&gt;</ph> propriété est une chaîne.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>The value of the string is used to assign the unique ID of the <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</source>
          <target state="translated">La valeur de la chaîne est utilisée pour affecter l’ID unique de le <ph id="ph1">&lt;xref:System.Runtime.Caching.ChangeMonitor&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</source>
          <target state="translated">En substituant la propriété, vous pouvez définir une implémentation personnalisée de la valeur de chaîne de la propriété afin d’affecter un ID unique.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.Caching.ChangeMonitor.UniqueId">
          <source>In derived classes, you must set the value of the property in the constructor.</source>
          <target state="translated">Dans les classes dérivées, vous devez définir la valeur de la propriété dans le constructeur.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>