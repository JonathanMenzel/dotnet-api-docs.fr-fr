<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6584944dc100d0b2095a9b1597b9b7066c9b8d33" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52615371" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit une classe de base pour un type personnalisé dérivé qui surveille les modifications de l'état des données dont dépend un élément de cache.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ChangeMonitor> classe est utilisée comme classe de base pour les classes de surveillance dérivées spécialisées pour les implémentations de cache particulière. Un <xref:System.Runtime.Caching.ChangeMonitor> instance surveille les modifications de l’état des données dont dépend un élément de cache. Par exemple, l’élément peut être une entité de fichier ou de données dont le contenu est mis en cache. Si l’entité de données ou de fichier est mis à jour, l’entrée de cache associée doit également être modifiée. Éléments communs qui peuvent être surveillés incluent des entités de données (par exemple, les champs de base de données, des valeurs, des lignes ou des tables), une autre entrée de cache et les fichiers et les attributs de fichier.  
  
 Modification de dépendance est une modification de l’état d’une dépendance. Dans une implémentation de cache typique, après un <xref:System.Runtime.Caching.ChangeMonitor> instance notifie le cache qu’une dépendance a changé, le cache effectue l’action requise, telles que l’invalidation de l’entrée de cache insérée.  
  
 Dérivés <xref:System.Runtime.Caching.ChangeMonitor> classes peuvent être personnalisées pour surveiller les modifications de dépendance pour les magasins de données différents spécifiques. Par exemple, il existe des implémentations de cache pour un système de fichiers, la mémoire physique ou une base de données. Le <xref:System.Runtime.Caching.ChangeMonitor> classe examine les modifications qui se produisent en dehors du cache, puis avertit le cache de modifications ont eu lieu.  
  
 Le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] inclut les classes suivantes dérivent <xref:System.Runtime.Caching.ChangeMonitor> classe :  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Chacune de ces classes fonctionne avec différents types de dépendances. Par exemple, la dérivée <xref:System.Runtime.Caching.FileChangeMonitor> classe surveille les modifications apportées à un cache pour les données de système de fichiers (fichiers et dossiers) qui dépend de l’élément de cache.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Si vous créer une implémentation de cache ou une modification dérivée de type de moniteur, vous devez respecter certaines règles. La liste suivante résume ces instructions. Pour plus d’informations, consultez la documentation pour les méthodes ou propriétés.  
  
-Le constructeur d’une classe dérivée doit définir la <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propriété, commencer la surveillance et appeler <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> méthode avant le retour de la méthode. Si un constructeur rencontre une erreur lors des constructions et doit supprimer des ressources, le constructeur peut appeler uniquement la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> surcharger après le <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> méthode est appelée, car le <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> surcharge lève un <see cref="T:System.InvalidOperationException" /> exception si l’initialisation n’est pas terminée.  
  
-Si les modifications se produisent dans les données qui sont en cours d’analyse avant l’initialisation est terminée, le constructeur doit appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode avant d’appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> (méthode).  
  
-Après une dérivée <see cref="T:System.Runtime.Caching.ChangeMonitor" /> type est instancié, vous devez insérer l’analyseur dans personnalisé <see cref="T:System.Runtime.Caching.ObjectCache" /> implémentation. Ou si vous avez terminé d’utiliser l’Analyseur de modification, appelez le <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> (méthode).  
  
-Après une <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance est insérée dans un <see cref="T:System.Runtime.Caching.ObjectCache" /> implémentation, le <see cref="T:System.Runtime.Caching.ObjectCache" /> instance nécessitent que la surveillance des modifications est supprimée. Même si l’insertion n’est pas valide et provoque une exception, le <see cref="T:System.Runtime.Caching.ObjectCache" /> implémentation doit appeler la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> de surcharge.  
  
-Une fois que l’Analyseur de modification dérivée est inséré dans un cache, le <see cref="T:System.Runtime.Caching.ObjectCache" /> implémentation doit appeler <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, en passant un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objet. Le <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> méthode peut être appelée qu’une seule fois. Si une modification de dépendance a déjà eu lieu, le <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance sera appelée immédiatement lorsque <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> est appelée. Sinon, le <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance sera appelée qu’une seule fois. Cette un fois appel produit lorsque le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode est appelée, car le <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance a détecté une modification, ou lorsque le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode est appelée sur le <see cref="T:System.Runtime.Caching.ChangeMonitor" />, selon la première éventualité.  
  
-Le <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance qui est fournie par un <see cref="T:System.Runtime.Caching.ObjectCache" /> implémentation doit supprimer l’entrée de cache associée et spécifier une raison à l’aide de la <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> énumération.  
  
-A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance peut appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode avant qu’une implémentation de cache a appelé <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> méthode ou après. Si le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode est appelée avant <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> est appelée, la base de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implémentation informe le cache que cela s’est produit et déclenchera le rappel devant être transmis au <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> immédiatement lorsque <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> est appelé. Les données d’état sont passées à la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode est enregistrée par l’Analyseur de modification et ensuite passée à la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> (méthode) lorsque le <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> méthode est appelée.  
  
-Analyseur de modification doit implémenter la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> (méthode). Pour plus d'informations, consultez la documentation sur la méthode <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.  
  
-Le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> surcharge de méthode doit être appelée pour supprimer le <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance. Les règles pour appeler Dispose sont les suivantes : 
-Avant qu’un élément est inséré dans le cache, il est la responsabilité de l’appelant de supprimer une <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.  
  
-Une fois l’élément du cache et la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances qui lui sont associées sont passées à un cache, l’implémenteur de cache doit s’assurer que le <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode est appelée, même si l’insertion échoue.  
  
-Après un élément et ses associés <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances sont passées à un cache, l’appelant ne doit pas supprimer la dépendance car lorsque la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> est appelée, l’appel est traité comme si la dépendance a changé. Par conséquent, le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode est appelée automatiquement.  
  
-Tenant ces règles, le <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode doit être appelée dans une des manières suivantes : 
-Les utilisateurs doivent appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> surcharge de méthode si elles décident de ne pas insérer de l’instance dérivée de suivi des modifications dans un cache.  
  
-Si l’implémentation essaie d’insérer l’instance de l’Analyseur de modification dans un cache d’objets mais que l’insertion échoue, l’implémentation de cache est chargée d’appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> de surcharge. Lorsque la tentative d’insertion provoque une exception, l’implémentation de cache doit supprimer toutes les dépendances associées.  
  
-Si l’entrée de cache est supprimée, l’implémentation de cache doit également supprimer de la dépendance.  
  
-L’implémentation interne de la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode appelle automatiquement la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode après avoir appelé un rappel qui est inscrit via <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Cet appel automatique à la méthode dispose pendant le déclenchement de l’événement se produit uniquement si l’initialisation de la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance a été effectuée précédemment.  
  
</para></block>  
  
 Lorsque le constructeur d’un analyseur de modification dérivée appelle le <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> méthode, si l’état de l’Analyseur de modification a déjà changé (autrement dit, l’état qui est surveillé a déjà été modifié lorsque le constructeur était encore actif), le <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> sera (méthode) supprimer automatiquement le suivi des modifications.  
  
-Le <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> propriété est définie sur <see langword="true" /> après le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode est appelée par l’instance de surveillance des modifications dérivées, indépendamment de si un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objet a été défini par un appel à la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> méthode ou non.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">La mise en cache ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Ce constructeur est appelé par les constructeurs de classes dérivées pour initialiser la classe de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ChangeMonitor> classe a un constructeur par défaut. Toutefois, les classes qui héritent de la base de <xref:System.Runtime.Caching.ChangeMonitor> classe et définissez la surveillance des modifications personnalisée comportement doit exécuter l’initialisation dans le constructeur. Pour plus d’informations, consultez les section Remarques aux héritiers.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le constructeur d’une classe dérivée doit définir la <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propriété, commencer la surveillance et appeler la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> classe avant de retourner. Si une dépendance a été modifiée avant l’initialisation est terminée (par exemple, si une clé de cache dépendante est introuvable dans le cache), le constructeur doit appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode avant d’appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> (méthode). Dans ce cas, le constructeur peut appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode uniquement après la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> méthode est appelée, car le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode lève une exception si l’initialisation n’est pas terminée.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode est utilisée pour libérer le <xref:System.Runtime.Caching.ChangeMonitor> instance et les ressources associées. Public <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode est appelée pour coordonner le processus d’élimination avec les événements de cycle de vie de clé de classes d’analyseur de modification dérivée (par exemple, l’initialisation) et pour libérer le <xref:System.Runtime.Caching.ChangeMonitor> instance afin que l’instance peut être nettoyées. Le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode est implémentée par les classes de surveillance des modifications dérivées pour supprimer leurs ressources managées et non managées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources qui sont utilisées par l’instance actuelle de la classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode appelle le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode des classes dérivées qu’une seule fois, la première fois qu’elle est appelée. Les appels suivants à la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> (méthode) n’ont aucun effet. Une fois que la méthode a été appelée, le <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> propriété est définie sur `true`.  
  
 Le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> surcharge doit être appelée pour supprimer un <xref:System.Runtime.Caching.ChangeMonitor> instance. Les règles sont les suivantes pour appeler la méthode dispose :  
  
-   Avant qu’un élément est inséré dans le cache, il revient l’appelant pour supprimer un <xref:System.Runtime.Caching.ChangeMonitor> instance.  
  
-   Une fois l’élément du cache et la <xref:System.Runtime.Caching.ChangeMonitor> instances qui lui sont associées sont passées à un cache, l’implémenteur de cache doit s’assurer que <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> est appelée, même si l’insertion échoue.  
  
-   Après un élément et ses associés <xref:System.Runtime.Caching.ChangeMonitor> instances sont passées à un cache, l’appelant ne doit pas supprimer la dépendance car lorsque la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> est appelée, l’appel est traité comme si la dépendance a changé. Par conséquent, le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée automatiquement.  
  
-   Ces règles en tenant compte, le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode doit être appelée dans une des manières suivantes :  
  
    -   Les utilisateurs doivent appeler le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> surcharge de méthode si elles décident de ne pas insérer de l’instance dérivée de suivi des modifications dans un cache.  
  
    -   L’implémentation de cache est chargée d’appeler le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> surcharge si l’implémentation essaie d’insérer l’instance de l’Analyseur de modification dans un cache d’objets mais que l’insertion échoue. Lors de la tentative d’insertion provoque une exception, l’implémentation de cache doit supprimer toutes les dépendances associées.  
  
    -   Si l’entrée de cache est supprimée, l’implémentation de cache doit également supprimer la dépendance.  
  
 L’implémentation interne de la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode appelle automatiquement la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode après avoir appelé un rappel qui est inscrit par le biais du <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> (méthode).  
  
> [!NOTE]
>  Cette suppression automatique pendant le déclenchement des événements se produit uniquement si l’initialisation de la <xref:System.Runtime.Caching.ChangeMonitor> instance précédemment s’est terminée.  
  
 Lorsque le constructeur d’un analyseur de modification dérivée appelle le <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> méthode, si l’état de l’Analyseur de modification a déjà changé (autrement dit, l’état qui est surveillé a déjà modifié lorsque le constructeur était toujours actif) puis <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> sera (méthode) supprimer automatiquement le suivi des modifications.  
  
> [!NOTE]
>  Les utilisateurs ne doivent pas appeler le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> (méthode). Toutefois, vous ne pouvez pas empêcher les utilisateurs à partir de l’appel de la méthode. Par conséquent, s’ils le font, la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée. Dans ce cas, l’entrée du cache est notifiée comme si la dépendance a changé.  
  
 Pour empêcher des classes dérivées de substituer <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode, la méthode n’est pas une implémentation d’interface explicite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'initialisation n'est pas terminée dans la classe d'analyseur de modification dérivée qui a appelé la méthode <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> de base.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées, ainsi que les références à une instance de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ; <see langword="false" /> pour libérer uniquement les ressources non managées. Lorsque la valeur <see langword="false" /> est transmise, la méthode <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> est appelée par un thread <see langword="finalizer" /> et les références managées externes ne sont probablement plus valides, car elles ont déjà été récupérées par le garbage collector.</param>
        <summary>Libère toutes les ressources managées et non managées, ainsi que les références à l'instance <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Cette surcharge doit être implémentée par des classes de surveillance des modifications dérivées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque la valeur de `disposing` valeur est `true`, toutes les ressources managées et non managées sont supprimées et toutes les références à cet objet sont libérées afin que l’instance de surveillance des modifications dérivées peut être nettoyées. Il est garanti que la base de <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode appelle l’implémentation <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode qu’une seule fois.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Analyseur de modification doit implémenter la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> surcharge pour libérer toutes les ressources managées et lorsque la valeur de <paramref name="disposing" /> est <see langword="true" />. Le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> surcharge de méthode qui a un <paramref name="disposing" /> valeur <see langword="true" /> parle qu’une seule fois, à savoir, lorsque l’instance est supprimée pour la première fois. Analyseur de modification ne doit pas appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> surcharger directement. Analyseur de modification dérivée peut appeler le public sans paramètre <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode sur la base de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> classe.  
  
Vous pouvez également un analyseur de modification peut implémenter une méthode de finaliseur. Dans ce cas, le finaliseur peut appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> (méthode) et lui passer un <paramref name="disposing" /> valeur <see langword="false" />. Toutefois, il s’agit généralement pas nécessaire. Surveiller les modifications de la dépendance est généralement effectuée par un service qui conserve une référence à l’instance de l’Analyseur de modification. La référence empêche l’instance d’une garbage collecté et est donc une méthode de finaliseur inutiles. Pour éviter les fuites de mémoire, lorsqu’une dépendance change, la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode supprime l’instance de l’Analyseur de modification (à moins que l’initialisation n’est pas terminée).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique que l'état surveillé par la classe <see cref="T:System.Runtime.Caching.ChangeMonitor" /> a changé.</summary>
        <value>
          <see langword="true" /> si l'état surveillé par l'instance <see cref="T:System.Runtime.Caching.ChangeMonitor" /> a changé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez vérifier la valeur de cette propriété dans une dérivée <xref:System.Runtime.Caching.ChangeMonitor> classe pour voir si une dépendance a changé.  
  
 La valeur est définie sur `true` lorsqu’une modification de dépendance se produit (autrement dit, quand le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée). Après le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée par la classe dérivée, la valeur de la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriété sera `true`, quel que soit ou non d’un <xref:System.Runtime.Caching.OnChangedCallback> instance a été notifiée par un appel à la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> (méthode).  
  
> [!NOTE]
>  Les appelants peuvent vérifier le <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriété pour voir si une dépendance a changé. Toutefois, dans un environnement multithread, une approche plus simple et plus facile à gérer est pour insérer des données dans une implémentation de cache sans vérifier le <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriété. Les implémentations de cache doivent vérifier le <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriété pour vous et ne doivent pas effectuer une insertion ou opération ensembliste si une ou plusieurs dépendances associées ont déjà été modifié.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par le constructeur des classes dérivées pour indiquer que l'initialisation est terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une dépendance change avant l’initialisation est terminée dans une classe dérivée, le constructeur de la classe dérivée doit appeler la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> (méthode).  
  
 Lorsque le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée, le <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriété est automatiquement définie sur `true` par l’Analyseur de modification. Par conséquent, lorsque l’Analyseur de modification le constructeur appelle la <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> (méthode), la classe de base appelle automatiquement la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> (méthode). Si l’initialisation est terminée, le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode supprime automatiquement l’instance de surveillance des modifications dérivées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le constructeur d’une classe dérivée doit appeler la base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> méthode avant le retour du constructeur. Le constructeur d’une classe dérivée peut appeler le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode uniquement après avoir <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> est appelée, car le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode lève une exception si l’initialisation n’est pas terminée.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique que l'instance dérivée d'une classe <see cref="T:System.Runtime.Caching.ChangeMonitor" /> est supprimée.</summary>
        <value>
          <see langword="true" /> si l'instance est supprimée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété est définie sur `true` après la base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> les appels de méthode le <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> méthode dans une classe dérivée pour éliminer l’instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Référence à une méthode appelée lorsqu'une dépendance a été modifiée.</param>
        <summary>Appelée par les implémenteurs de cache pour inscrire un rappel et notifier une instance de <see cref="T:System.Runtime.Caching.ObjectCache" /> via le délégué <see cref="T:System.Runtime.Caching.OnChangedCallback" /> lorsqu'une dépendance a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémenteurs de cache utilisent cette méthode pour se connecter à un analyseur de modification. Si vous associez un ou plusieurs analyseurs de modification à l’élément de cache, vous passez un <xref:System.Runtime.Caching.CacheItemPolicy> instance avec une propriété de moniteurs de modification remplie à l’élément de cache. Un implémenteur de cache qui prend en charge des analyseurs de modification est responsable de l’itération sur la <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> propriété et inscrire le <xref:System.Runtime.Caching.OnChangedCallback> délégués avec chaque analyseur de modification qu’il trouve.  
  
 Étant donné que le <xref:System.Runtime.Caching.OnChangedCallback> délégué inclut un paramètre d’état facultatif, une implémentation d’analyseur de modification concrète peut passer des informations d’état facultatives. L’implémenteur de cache détermine si une dépendance explicite sur le type d’état Analyseur de modification personnalisé transmet en tant que partie du rappel peut être extraite.  
  
> [!NOTE]
>  L’API d’extensibilité du cache de base n’a aucune spécification de dépendance explicite sur le type d’état.  
  
 L’implémentation de la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> méthode détermine automatiquement si l’état de l’analyse a déjà changé au moment <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> méthode est appelée. Si le <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propriété est `true`, la méthode appelle automatiquement la <xref:System.Runtime.Caching.OnChangedCallback> Gestionnaire d’événements, qui a été inscrit, via le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> (méthode). Cela se produit, car il est possible qu’à partir du moment qu'une implémentation de cache crée un analyseur de modification, à la fois une implémentation de cache Obtient l’analyse et celui, l’état surveillé sous-jacent a changé. Si l’état a déjà changé, l’objet qui est passé à la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est `null`.  
  
 Le <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> méthode peut être appelée qu’une seule fois et lève une exception lors des appels ultérieurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode de rappel a déjà été appelée.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  Vous devez appeler la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> méthode pour être informé des modifications de dépendance. Si une modification de dépendance a déjà eu lieu, le <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance sera appelée lorsque <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> est appelée. Sinon, le <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance sera appelée une seule fois, soit lorsque le <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> méthode est appelée ou lorsque le <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> méthode est appelée, selon la première éventualité. Le <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance fournie par l’implémentation de cache doit supprimer l’entrée de cache et si cela est demandé par l’appelant du cache, déclencher la modification nécessaire ou l’événement de mise à jour à l’appelant de cache d’origine.  
  
2.  L’implémentation de cache d’objet doit supprimer l’entrée de cache qui est associée à une modification de dépendance.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Données de l'événement de modification. Cette valeur peut être <see langword="null" />.</param>
        <summary>Appelé par les classes dérivées pour déclencher l'événement lorsqu'une dépendance a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée en cas de modification de dépendance. Le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est également appelée lorsqu’une instance de surveillance des modifications est supprimée mais que la suppression se produit uniquement si le rappel n’a pas déjà été appelé.  
  
 Si le <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est appelée avant la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> méthode est appelée, les données d’état de l’appel à la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> méthode est enregistrée par l’implémentation de cache. En outre, le rappel pour le <xref:System.Runtime.Caching.OnChangedCallback> méthode est appelée immédiatement lorsque la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> méthode est appelée.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui représente l'instance de la classe <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>Identificateur d'une instance de surveillance des modifications.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> valeur de propriété se compose généralement dépendance noms combinée des données de chaîne qui identifie de façon unique les données surveillées par un <xref:System.Runtime.Caching.ChangeMonitor> instance. La valeur de la <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> propriété est une chaîne. La valeur de la chaîne est utilisée pour affecter l’ID unique de la <xref:System.Runtime.Caching.ChangeMonitor> instance.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>En substituant la propriété, vous pouvez définir une implémentation personnalisée pour la valeur de chaîne de la propriété pour l’affecter un ID unique.</para>
        </block>
        <block subset="none" type="overrides">
          <para>Dans les classes dérivées, vous devez définir la valeur de la propriété dans le constructeur.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>