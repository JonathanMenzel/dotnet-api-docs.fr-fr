<Type Name="HostFileChangeMonitor" FullName="System.Runtime.Caching.HostFileChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9766bc72336871e34c9cfc627b4f217c5c9854da" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36637452" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HostFileChangeMonitor : System.Runtime.Caching.FileChangeMonitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HostFileChangeMonitor extends System.Runtime.Caching.FileChangeMonitor" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.HostFileChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HostFileChangeMonitor&#xA;Inherits FileChangeMonitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostFileChangeMonitor sealed : System::Runtime::Caching::FileChangeMonitor" />
  <TypeSignature Language="F#" Value="type HostFileChangeMonitor = class&#xA;    inherit FileChangeMonitor" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.FileChangeMonitor</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Monitors directories and file paths and notifies the cache of changes to the monitored items. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.HostFileChangeMonitor> classe est une implémentation concrète de la <xref:System.Runtime.Caching.FileChangeMonitor> type. Cette classe est scellée, par conséquent, il ne peut pas être étendu. Cette classe est utile si vous souhaitez utiliser une implémentation de cache existante et surveiller les fichiers et répertoires pour les modifications.  
  
 Pour chaque fichier spécifié ou le chemin d’accès du répertoire, la <xref:System.Runtime.Caching.HostFileChangeMonitor> classe déclenche une notification de modification si une des modifications suivantes se produisent :  
  
-   Le nom du fichier analysé ou de modifications d’annuaire.  
  
-   Le fichier ou répertoire spécifié n’existait pas au moment de l’analyse a été créée, mais qu’il a été créée ultérieurement. En d’autres termes, un fichier ou répertoire a été créé dans l’étendue des éléments analysés.  
  
-   La taille d’un fichier surveillé est modifiée.  
  
-   Le contenu d’un fichier surveillé modifié, ou le contenu d’un répertoire surveillé modifié.  
  
-   La liste de contrôle d’accès (ACL) du fichier ou répertoire a été modifiée.  
  
-   Le fichier analysé ou le répertoire a été supprimé.  
  
 Si trop de modifications se produisent pour le fichier analysé ou le répertoire en même temps, le <xref:System.Runtime.Caching.HostFileChangeMonitor> instance peut perdre la trace des modifications spécifiques. Dans ce scénario, la <xref:System.Runtime.Caching.HostFileChangeMonitor> classe déclenche une notification de modification. Ce scénario est plus susceptible de se produire lorsque le <xref:System.Runtime.Caching.HostFileChangeMonitor> instance surveille un répertoire et de nombreuses modifications se produisent dans l’étendue de la structure de répertoires dans un laps de temps.  
  
 Étant donné que l’objectif de la <xref:System.Runtime.Caching.HostFileChangeMonitor> classe est uniquement de signaler que quelque chose a changé parmi le jeu de fichiers surveillés et de répertoires, il n’est pas considéré comme important que les informations sur une modification spécifique ne sont pas capturées. L’objectif de la <xref:System.Runtime.Caching.HostFileChangeMonitor> classe consiste à fournir les notifications d’état a été modifié afin qu’une entrée de cache (ou entrées) peuvent être supprimées. Étant donné que la <xref:System.Runtime.Caching.HostFileChangeMonitor> classe n’indique pas exactement ce qui a changé, le suivi des modifications interne de dépassement de capacité n’est pas pertinent.  
  
 Lorsque vous fournissez des chemins d’accès à un <xref:System.Runtime.Caching.HostFileChangeMonitor> chemins d’accès de l’instance, le répertoire et le fichier doivent être des chemins d’accès complets au répertoire ou fichier. Caractères génériques dans les chemins d’accès et les chemins d’accès relatifs ne sont pas autorisés.  
  
 Lorsque la <xref:System.Runtime.Caching.HostFileChangeMonitor> classe est utilisée dans une application ASP.NET, l’identité Windows qui est utilisée pour accéder aux éléments analysés est l’identité de l’application ASP.NET. En d’autres termes, l’identité de l’application sera l’un des éléments suivants :  
  
-   L’identité du processus.  
  
-   L’identité de l’application configurée.  
  
-   Les informations d’identification UNC si l’application est en cours d’exécution à partir d’un partage UNC.  
  
 Lorsque le <xref:System.Runtime.Caching.HostFileChangeMonitor> classe est utilisée dans une application non-ASP.NET, la <xref:System.IO.FileSystemWatcher> classe est utilisée en interne pour surveiller des fichiers. Par conséquent, toute liste de contrôle d’accès (ACL) s’applique à un fichier surveillé ou un répertoire est appliquée à l’identité Windows du thread actuel.  
  
> [!NOTE]
>  Les appelants doivent avoir le niveau approprié d’autorisations de sécurité d’accès au code et doivent disposer des autorisations NTFS pour tous les répertoires et surveillés chemins d’accès.  
  
   
  
## Examples  
 L’exemple suivant crée un élément de cache qui utilise un <xref:System.Runtime.Caching.HostFileChangeMonitor> objet à surveiller l’état de la source de données (qui est un fichier) sur le système de fichiers. L’entrée de cache est définie en utilisant un <xref:System.Runtime.Caching.CacheItemPolicy> objet pour fournir des détails d’éviction et d’expiration pour l’entrée de cache.  
  
 [!code-csharp[CachingASPNetApplications#1](~/samples/snippets/csharp/VS_Snippets_WebNet/cachingaspnetapplications/cs/default.aspx.cs#1)]
 [!code-vb[CachingASPNetApplications#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/cachingaspnetapplications/vb/default.aspx.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostFileChangeMonitor (System.Collections.Generic.IList&lt;string&gt; filePaths);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IList`1&lt;string&gt; filePaths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.HostFileChangeMonitor.#ctor(System.Collections.Generic.IList{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filePaths As IList(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostFileChangeMonitor(System::Collections::Generic::IList&lt;System::String ^&gt; ^ filePaths);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.HostFileChangeMonitor : System.Collections.Generic.IList&lt;string&gt; -&gt; System.Runtime.Caching.HostFileChangeMonitor" Usage="new System.Runtime.Caching.HostFileChangeMonitor filePaths" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filePaths" Type="System.Collections.Generic.IList&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="filePaths">A list that contains one or more directory paths or file paths to monitor.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Runtime.Caching.HostFileChangeMonitor" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les appels à la <xref:System.Runtime.Caching.HostFileChangeMonitor.%23ctor%2A> constructeur doit fournir une valeur non null pour le `filePaths` paramètre. Au minimum, le constructeur valide la collection de chemins d’accès qui est passée dans celle-ci, puis initialise l’analyse pour les chemins d’accès.  
  
> [!NOTE]
>  Le constructeur effectue la validation des chaînes uniquement le nom de chemin d’accès. Il ne canonicaliser les chemins d’accès ni valider que les chemins d’accès existent.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filePaths" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="filePaths" /> contains zero items.  -or-  A path in the <paramref name="filePaths" /> list is <see langword="null" /> or an empty string.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.HostFileChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="hostFileChangeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePaths">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FilePaths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FilePaths" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.HostFileChangeMonitor.FilePaths" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FilePaths As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FilePaths { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePaths : System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="System.Runtime.Caching.HostFileChangeMonitor.FilePaths" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of directories and file paths that was passed to the <see cref="M:System.Runtime.Caching.HostFileChangeMonitor.#ctor(System.Collections.Generic.IList{System.String})" /> constructor.</summary>
        <value>Collection des répertoires et des chemins d’accès de fichier.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastModified">
      <MemberSignature Language="C#" Value="public override DateTimeOffset LastModified { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTimeOffset LastModified" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.HostFileChangeMonitor.LastModified" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LastModified As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property DateTimeOffset LastModified { DateTimeOffset get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModified : DateTimeOffset" Usage="System.Runtime.Caching.HostFileChangeMonitor.LastModified" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a read-only value that indicates the last write time of a monitored file or path.</summary>
        <value>Heure d’un fichier surveillé ou le chemin d’accès de la dernière écriture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une modification de fichier surveille plusieurs fichiers ou chemins d’accès, cette propriété retourne l’heure de la dernière écriture dans le jeu de tous les fichiers et les chemins d’accès.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public override string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.HostFileChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.HostFileChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an identifier for the <see cref="T:System.Runtime.Caching.HostFileChangeMonitor" /> instance that is based on the set of monitored directories and file paths.</summary>
        <value>Identificateur de l’Analyseur de modification.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne qui compose la <xref:System.Runtime.Caching.HostFileChangeMonitor.UniqueId%2A> valeur de propriété est construite à partir des parties suivantes :  
  
-   Un chemin d’accès du fichier ou répertoire.  
  
-   Temps d’écriture le plus récent en heure UTC, mesuré en graduations mais représenté sous forme de chaîne hexadécimale.  
  
-   La taille du fichier, représentée sous forme de chaîne hexadécimale.  
  
 Si un analyseur de modification du fichier de contrôle plusieurs chemins d’accès, les informations retournées par cette propriété sont concaténées en une chaîne unique pour tous les répertoires analysés et les chemins d’accès de fichier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>