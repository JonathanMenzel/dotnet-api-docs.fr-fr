<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c6cf59a4e0d40381714770602c4fb0166959aab6" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55313035" /></Metadata><TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente le type qui implémente un cache en mémoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.Runtime.Caching.MemoryCache> est une implémentation concrète de la classe <xref:System.Runtime.Caching.ObjectCache> abstraite.  
  
> [!NOTE]
>  Le <xref:System.Runtime.Caching.MemoryCache> classe est similaire à celui d’ASP.NET <xref:System.Web.Caching.Cache> classe. Le <xref:System.Runtime.Caching.MemoryCache> classe possède de nombreuses propriétés et méthodes pour l’accès au cache qui sera familier à vous si vous avez utilisé ASP.NET <xref:System.Web.Caching.Cache> classe. Les principales différences entre le <xref:System.Web.Caching.Cache> et <xref:System.Runtime.Caching.MemoryCache> classes sont qui le <xref:System.Runtime.Caching.MemoryCache> classe a été modifiée pour le rendre utilisable par [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] les applications qui ne sont pas des applications ASP.NET. Par exemple, le <xref:System.Runtime.Caching.MemoryCache> classe n’a aucune dépendance le `System.Web` assembly. Une autre différence est que vous pouvez créer plusieurs instances de la <xref:System.Runtime.Caching.MemoryCache> classe pour une utilisation dans la même application et dans le même <xref:System.AppDomain> instance.  
  
 Le <xref:System.Runtime.Caching.MemoryCache> classe n’autorise pas `null` en tant que valeur dans le cache. Toute tentative d’ajouter ou modifier une entrée de cache avec la valeur `null` échouera.  
  
 Le <xref:System.Runtime.Caching.MemoryCache> type n’implémente pas *cache régions*. Par conséquent, lorsque vous appelez <xref:System.Runtime.Caching.MemoryCache> méthodes qui implémentent les méthodes de base qui contiennent un paramètre pour les régions, ne transmettez pas une valeur pour le paramètre. Les méthodes qui utilisent le paramètre de région tous les fournissent une valeur par défaut `null` valeur. Par exemple, le <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> surcharge de méthode a un `regionName` paramètre dont la valeur par défaut est `null`.  
  
   
  
## Examples  
 L’exemple suivant déclare une référence à l’instance de cache mémoire par défaut. L’entrée de cache utilise un <xref:System.Runtime.Caching.CacheItemPolicy> objet pour fournir des détails d’éviction et d’expiration pour l’entrée de cache. Il utilise également un <xref:System.Runtime.Caching.ChangeMonitor> objet à surveiller l’état des données sources (c'est-à-dire un fichier) sur le système de fichiers.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/942236f6-0138-4aaf-af71-a5ea451a1e23">Procédure pas à pas : La mise en cache des données d’Application dans ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/c4b47ee0-4b82-4124-9bce-818088385e34">Mise en cache dans les applications .NET Framework</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nom à utiliser pour rechercher les informations de configuration.  
  
 <c>Remarque</c> : Il n’est pas nécessaire que des informations de configuration existent pour chaque nom.  
  
S'il existe une entrée de configuration correspondante, les informations de configuration sont utilisées pour configurer l'instance de <see cref="T:System.Runtime.Caching.MemoryCache" />. En l'absence d'entrée de configuration correspondante, vous pouvez accéder au nom via la propriété <see cref="P:System.Runtime.Caching.MemoryCache.Name" />, car le nom spécifié est associé à l'instance de <see cref="T:System.Runtime.Caching.MemoryCache" />. Pour plus d'informations sur la configuration du cache mémoire, consultez <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Collection de paires nom/valeur d’informations de configuration à utiliser pour configurer le cache.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Runtime.Caching.MemoryCache> classe est initialisée, il recherche des entrées de configuration qui ont été substituées à l’aide de l’élément facultatif `config` paramètre dans le constructeur. Vous pouvez passer les paramètres suivants dans le `config` paramètre. Toutes les valeurs peuvent être passés en tant qu’entiers.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Lorsque ce constructeur est appelé, les paramètres de configuration sont tout d’abord récupérés à partir des fichiers de configuration d’application. Si aucune entrée de configuration n’existe dans le fichier de configuration d’application, seuls les paramètres fournis dans `config` sont appliquées. Si les entrées de configuration dans la configuration d’application existent, et si les informations sont également transmises dans `config`, les informations contenues dans le `config` remplace les informations qui sont lues à partir du fichier de configuration.  
  
 La valeur du nom qui est assignée à une instance de cache est utilisée de deux manières :  
  
-   Pour vous aider à effectuer le suivi de plusieurs instances de cache existe plusieurs instances.  
  
-   Pour référencer les paramètres dans la configuration de fichier lorsque le <xref:System.Runtime.Caching.MemoryCache> instance est initialisée.  
  
    > [!NOTE]
    >  Il n’existe aucun mécanisme pour appliquer des noms uniques pour les instances de cache. Par conséquent, il est possible d’avoir plusieurs instances de cache portant le même nom.  
  
    > [!CAUTION]
    >  Ne créez pas <xref:System.Runtime.Caching.MemoryCache> instances sauf s’il est requis. Si vous créez des instances de cache dans les applications clientes et Web, le <xref:System.Runtime.Caching.MemoryCache> instances doivent être créées tôt dans le cycle de vie d’application. Vous devez créer uniquement le nombre d’instances de cache qui sera utilisé dans votre application et stocker les références aux instances de cache dans des variables qui sont accessibles dans le monde entier. Par exemple, dans les applications ASP.NET, vous pouvez stocker les références d’état de l’application. Si vous créez uniquement une instance de cache unique dans votre application, utilisez le cache par défaut et obtenir une référence à celui-ci à partir de la <xref:System.Runtime.Caching.MemoryCache.Default%2A> propriété lorsque vous avez besoin accéder au cache.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un nom ou une valeur dans le paramètre <paramref name="config" /> n’a pas pu être analysé(e).</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Une valeur dans la collection <paramref name="config" /> n’est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="name">Nom à utiliser pour rechercher les informations de configuration.</param>
        <param name="config">Collection de paires nom/valeur d’informations de configuration à utiliser pour configurer le cache.</param>
        <param name="ignoreConfigSection">Indique si la section de la configuration doit être ignorée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Objet à ajouter.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <summary>Insère une entrée dans le cache à l'aide d'une instance de <see cref="T:System.Runtime.Caching.CacheItem" /> et ajoute des détails concernant le mode d'expulsion de l'entrée.</summary>
        <returns>true si l'insertion a réussi ou false si une entrée du cache possède déjà la même clé que l'élément.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Les surcharges de méthode <xref:System.Runtime.Caching.ObjectCache.Add%2A> et <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> ne prennent pas en charge la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Par conséquent, pour définir la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> d'une entrée du cache, utilisez les surcharges de méthode <xref:System.Runtime.Caching.MemoryCache.Set%2A> à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Insère une entrée de cache dans le cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> surcharges de méthode sont utilisées pour insérer une entrée dans le cache. Si une entrée de cache avec une clé correspondante n’existe pas, ces méthodes insèrent une nouvelle entrée. Si une entrée de cache avec une clé correspondante existe déjà, ils retournent l’entrée existante.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objet à ajouter.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <summary>Ajoute une entrée dans le cache à l'aide de l'instance de <see cref="T:System.Runtime.Caching.CacheItem" /> spécifiée et des détails concernant le mode de suppression de l'entrée.</summary>
        <returns>S'il existe une entrée de cache ayant la même clé, l'entrée de cache existante ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `item` paramètre fournit la clé et la valeur qui est utilisée par la méthode. Si le cache a une entrée avec la même clé que la clé de la `item` , la méthode retourne l’entrée existante comme un <xref:System.Runtime.Caching.CacheItem> instance. S’il n’existe aucune entrée de cache existante, la méthode crée un nouveau à l’aide de la clé et la valeur fournie par le `item` paramètre et avec les détails d’éviction spécifiés par `policy`.  
  
> [!WARNING]
>  Les surcharges de méthode <xref:System.Runtime.Caching.ObjectCache.Add%2A> et <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> ne prennent pas en charge la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Par conséquent, pour définir la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> d'une entrée du cache, utilisez les surcharges de méthode <xref:System.Runtime.Caching.MemoryCache.Set%2A> à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.Runtime.Caching.CacheItem.Value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Les valeurs d’expiration absolue et décalée de l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> sont des valeurs autres que les valeurs par défaut des champs <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> et <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne peut pas définir de stratégie d’expiration basée sur la combinaison d’une expiration absolue et d’une expiration décalée. Vous ne pouvez définir explicitement qu’un seul paramètre d’expiration quand vous utilisez l’instance de <see cref="T:System.Runtime.Caching.MemoryCache" />. L’autre paramètre d’expiration doit avoir la valeur du champ <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou du champ <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> est inférieure à <see cref="F:System.TimeSpan.Zero" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> a une valeur supérieure à une année.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> n’est pas une valeur de l’énumération <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à ajouter.</param>
        <param name="value">Données pour l'entrée du cache.</param>
        <param name="absoluteExpiration">Date et heure fixes auxquelles l'entrée de cache expirera.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache peut être ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Ajoute une entrée dans le cache à l'aide de la clé spécifiée, d'une valeur et d'une valeur d'expiration absolue.</summary>
        <returns>S'il existe une entrée de cache ayant la même clé, l'entrée de cache existante ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le cache n’a pas une entrée de cache dont la clé correspond la `key` paramètre, une nouvelle entrée de cache est créée et le <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> surcharge de méthode retourne `null`. Si une entrée de cache correspondante existe, l’entrée existante est retournée.  
  
> [!WARNING]
>  Les surcharges de méthode <xref:System.Runtime.Caching.ObjectCache.Add%2A> et <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> ne prennent pas en charge la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Par conséquent, pour définir la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> d'une entrée du cache, utilisez les surcharges de méthode <xref:System.Runtime.Caching.MemoryCache.Set%2A> à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Les valeurs d’expiration absolue et décalée de l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> sont des valeurs autres que les valeurs par défaut des champs <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> et <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne peut pas définir de stratégie d’expiration basée sur la combinaison d’une expiration absolue et d’une expiration décalée. Vous ne pouvez définir explicitement qu’un seul paramètre d’expiration quand vous utilisez l’instance de <see cref="T:System.Runtime.Caching.MemoryCache" />. L’autre paramètre d’expiration doit avoir la valeur <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> est inférieure à <see cref="F:System.TimeSpan.Zero" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> a une valeur supérieure à une année.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> n’est pas une valeur de l’énumération <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à ajouter ou à obtenir.</param>
        <param name="value">Données pour l'entrée du cache.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache peut être ajoutée. Ne passez pas de valeur pour ce paramètre. Par défaut, ce paramètre est <see langword="null" />, étant donné que la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Insère une entrée dans le cache à l'aide de la clé et de la valeur spécifiées, ainsi que des détails spécifiés concernant le mode de suppression.</summary>
        <returns>S'il existe une entrée de cache correspondante, une entrée de cache ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Les surcharges de méthode <xref:System.Runtime.Caching.ObjectCache.Add%2A> et <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> ne prennent pas en charge la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Par conséquent, pour définir la propriété <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> d'une entrée du cache, utilisez les surcharges de méthode <xref:System.Runtime.Caching.MemoryCache.Set%2A> à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Les valeurs d’expiration absolue et décalée de l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> sont des valeurs autres que les valeurs par défaut de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> et de <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne peut pas définir de stratégie d’expiration basée sur la combinaison d’une expiration absolue et d’une expiration décalée. Vous ne pouvez définir explicitement qu’un seul paramètre d’expiration quand vous utilisez la classe <see cref="T:System.Runtime.Caching.MemoryCache" />. L’autre paramètre doit avoir la valeur <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
ou 
Le rappel de suppression et le rappel de mise à jour ont été spécifiés pour <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne prend en charge qu’un seul type de rappel par entrée de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> est inférieure à <see cref="F:System.TimeSpan.Zero" />.  
  
ou 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> a une valeur supérieure à une année.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> n’est pas une valeur de l’énumération <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire, en octets, de l'ordinateur pouvant être utilisée par le cache.</summary>
        <value>Quantité de mémoire en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’instance actuelle du cache dépasse la limite de mémoire définie par le <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propriété, l’implémentation de cache supprime les entrées du cache. Chaque instance de cache dans l’application peut utiliser la quantité de mémoire qui est spécifié par le <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propriété.  
  
 Les paramètres pour le <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propriété peut être spécifiée dans le fichier de configuration d’application. Sinon, il peuvent être passés dans le constructeur lorsque la <xref:System.Runtime.Caching.MemoryCache> classe est initialisée. Pour plus d’informations sur la configuration de cette propriété, consultez [ &lt;namedCaches&gt; , élément (paramètres de Cache)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Pour plus d’informations sur la façon de définir cette valeur lorsque le <xref:System.Runtime.Caching.MemoryCache> classe est en cours d’initialisation, consultez le <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> (méthode).  
  
 <xref:System.Runtime.Caching.MemoryCache> n’applique pas instantanément <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> chaque fois qu’un nouvel élément est ajouté à un <xref:System.Runtime.Caching.MemoryCache> instance. L’heuristique interne qui supprime des éléments supplémentaires à partir de la <xref:System.Runtime.Caching.MemoryCache> fait progressivement et prend en compte les informations du garbage collector (consultez [Garbage Collection](~/docs/standard/garbage-collection/index.md)) et d’autres facteurs tels que la taille de cache actuelle et pression de mémoire système globale. Par conséquent, même si le <xref:System.Runtime.Caching.MemoryCache> tente de conserver la taille du cache dans configuré <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> il est possible de dépasser temporairement la limite en ajoutant des éléments du cache à un taux très élevé.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; , élément (paramètres de Cache)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à rechercher.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Détermine si une entrée de cache existe dans le cache.</summary>
        <returns><see langword="true" /> si le cache contient une entrée de cache dont la clé correspond à <paramref name="key" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Énumération de clés d'entrée de cache uniques pour l'objet <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache peut être ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Crée un objet <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> qui peut déclencher des événements en réponse à des modifications apportées aux entrées du cache spécifiées.</summary>
        <returns>Analyseur de modification qui surveille les entrées du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> méthode crée un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instance. Cet analyseur de modification spécialisé est utilisé pour surveiller les entrées du cache qui sont spécifiées dans le `keys` collection et pour déclencher des événements lorsque les entrées changent.  
  
 Est considéré comme une entrée analysée ont été modifiés pour les raisons suivantes :  
  
-   La clé n’existe pas au moment de l’appel à la <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> (méthode). Dans ce cas, le résultat <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instance est immédiatement définie sur un état modifié. Cela signifie que lorsque le code lie ensuite un rappel de notification de modification, le rappel est déclenché immédiatement.  
  
-   L’entrée de cache associée a été supprimée du cache. Cela peut se produire si l’entrée est supprimée explicitement, si elle arrive à expiration, ou si elle est exclue pour récupérer la mémoire  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un élément dans la collection <paramref name="keys" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à l'instance de <see cref="T:System.Runtime.Caching.MemoryCache" /> par défaut.</summary>
        <value>Instance par défaut du cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours une référence à l’instance de cache par défaut. Pour les scénarios d’application standard, qu’une seule instance de <xref:System.Runtime.Caching.MemoryCache> est requis.  
  
 Étant donné que l’instance de cache par défaut n’est pas créée par le constructeur, vous devez utiliser la configuration pour définir explicitement la mémoire et interrogation des valeurs pour l’instance de cache par défaut. Pour plus d’informations, consultez [ &lt;memoryCache&gt; , élément (paramètres de Cache)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/182a622f-f7cf-472d-9d0b-451d2fd94525">&lt;memoryCache&gt; , élément (paramètres de Cache)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une description des fonctionnalités que fournit le cache.</summary>
        <value>Combinaison d'opérations de bits d'indicateurs qui indiquent les fonctions par défaut de l'implémentation de cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les fonctionnalités d’une implémentation de cache sont une combinaison des valeurs suivantes :  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources qui sont utilisées par l’instance actuelle de la classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque <xref:System.Runtime.Caching.MemoryCache> instance est liée à la <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> événement. Toutefois, lors de l’arrêt du domaine d’application, si un cache en mémoire n’a pas été supprimé explicitement, l’instance de cache appelle automatiquement la <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> (méthode).  
  
 L’instance de cache supprimée est arrêtée en procédant comme suit :  
  
1.  L’état du cache est défini pour indiquer que le cache est supprimé. Toute tentative pour appeler publique mise en cache des méthodes qui modifient l’état du cache, telles que des méthodes pour ajouter, suppriment, ou récupérer des entrées du cache, peut provoquer un comportement inattendu. Par exemple, si vous appelez le <xref:System.Runtime.Caching.MemoryCache.Set%2A> méthode une fois que le cache est supprimé, une erreur d’absence d’opération se produit. Si vous tentez de récupérer des éléments à partir du cache, le <xref:System.Runtime.Caching.MemoryCache.Get%2A> méthode retournera toujours `null`.  
  
2.  Informations sur les compteurs de performances ne sont plus déclenchées à partir de l’instance de cache actuelle.  
  
3.  Toutes les références à des objets mis en cache détenues par l’instance de cache actuelle sont libérées.  
  
4.  N’importe quel <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instances qui sont actuellement surveillés les entrées dans le cache sont avertis.  
  
5.  Les objets de rappel qui fournissent une notification de modifications sur ces moniteurs sont appelés.  
  
6.  N’importe quel <xref:System.Web.Caching.CacheItemRemovedCallback> instances enregistrées auprès des entrées dans le cache sont appelées. La raison de la suppression est passée aux rappels est <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à obtenir.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Retourne une entrée du cache.</summary>
        <returns>Référence à l'entrée du cache identifiée par <paramref name="key" /> si l'entrée existe ; sinon, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à obtenir.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Retourne l'entrée spécifiée du cache sous la forme d'une instance de <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Référence à l'entrée du cache identifiée par <paramref name="key" /> si l'entrée existe ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’entrée de cache spécifiée par `key` existe dans le cache, le <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> retour de la méthode comme un <xref:System.Runtime.Caching.CacheItem> instance. Le <xref:System.Runtime.Caching.CacheItem.Key%2A> et <xref:System.Runtime.Caching.CacheItem.Value%2A> propriétés de la <xref:System.Runtime.Caching.CacheItem> instance sera définie. Toutefois, le <xref:System.Runtime.Caching.CacheItem.RegionName%2A> propriété sera `null`, car les régions ne sont pas implémentées dans la <xref:System.Runtime.Caching.MemoryCache> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Retourne le nombre total d'entrées dans le cache.</summary>
        <returns>Nombre d'entrées du cache.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un énumérateur qui peut être utilisé pour itérer au sein d’une collection d’entrées de cache.</summary>
        <returns>Objet énumérateur qui fournit l'accès aux éléments du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’énumérateur retourné par la <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> méthode peut être utilisée pour effectuer une itération sur les entrées dans le cache.  
  
> [!IMPORTANT]
>  Extraction d’un énumérateur pour un <xref:System.Runtime.Caching.MemoryCache> instance est une opération gourmande en ressources et de blocage. Par conséquent, l’énumérateur ne doit pas être utilisé dans les applications de production.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="regionName">Nom de la région.</param>
        <summary>Obtient la taille de la région nommée.</summary>
        <returns>La taille de la région nommée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Ensemble d'identificateurs uniques pour les entrées de cache à retourner.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Retourne un ensemble d'entrées du cache qui correspondent aux clés spécifiées.</summary>
        <returns>Ensemble d'entrées de cache qui correspondent aux clés spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une entrée de cache qui est représentée par le `keys` n’existe pas, la valeur correspondante pour l’objet retourné dans le dictionnaire est défini sur `null`. Par conséquent, le dictionnaire retourné a toujours le même nombre d’éléments que le nombre d’éléments dans `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une clé dans la collection est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de la valeur de cache à obtenir ou à définir.</param>
        <summary>Obtient ou définit une valeur du cache en utilisant la propriété d'indexeur par défaut pour une instance de la classe <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <value>Valeur dans l'instance de cache de la clé spécifiée, si l'entrée existe ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez cette propriété, la valeur est insérée dans le cache. La stratégie d’expiration pour l’entrée de cache est définie sur <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Si une entrée de cache avec une clé correspondante existe déjà, sa valeur est mise à jour.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.  
  
ou 
La valeur insérée est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom du cache.</summary>
        <value>Nom du cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.MemoryCache.Name%2A> propriété retourne le nom de l’instance actuelle de la <xref:System.Runtime.Caching.MemoryCache> classe. Dans une application qui utilise plusieurs instances de cache, vous pouvez utiliser le <xref:System.Runtime.Caching.MemoryCache.Name%2A> propriété pour aider à distinguer les instances. Pour plus d'informations, voir la méthode <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType>. Le cache en mémoire par défaut retourne le nom par défaut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le pourcentage de mémoire physique que le cache peut utiliser.</summary>
        <value>Pourcentage de mémoire physique que le cache peut utiliser.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propriété retourne le pourcentage de mémoire d’ordinateur physique totale qui peut être utilisé par une instance unique de la <xref:System.Runtime.Caching.MemoryCache> classe. Si l’instance de cache dépasse la limite spécifiée, les entrées du cache sont supprimées.  
  
 Les paramètres pour le <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propriété peut être spécifiée dans le fichier de configuration d’application. Sinon, il peuvent être passés par un appelant lorsque la <xref:System.Runtime.Caching.MemoryCache> classe est initialisée. Pour plus d’informations sur la configuration de cette propriété, consultez [ &lt;namedCaches&gt; , élément (paramètres de Cache)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Pour plus d’informations sur la configuration de la propriété lorsque la <xref:System.Runtime.Caching.MemoryCache> classe est en cours d’initialisation, consultez le <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; , élément (paramètres de Cache)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la durée maximale après laquelle le cache met à jour ses statistiques de mémoire.</summary>
        <value>Durée maximale qui peut s'écouler avant la mise à jour des statistiques de mémoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les paramètres pour le <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> propriété peut être spécifiée dans le fichier de configuration d’application. Ils peuvent être passés également lorsque la <xref:System.Runtime.Caching.MemoryCache> classe est initialisée. Pour plus d’informations sur la configuration de cette propriété, consultez [ &lt;namedCaches&gt; , élément (paramètres de Cache)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Pour plus d’informations sur la configuration de la propriété lorsque la <xref:System.Runtime.Caching.MemoryCache> classe est en cours d’initialisation, consultez le <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; , élément (paramètres de Cache)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime l’élément spécifié du cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à supprimer.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Supprime une entrée du cache.</summary>
        <returns>Si l'entrée est trouvée dans le cache, entrée du cache supprimée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’entrée spécifiée par `key` existe dans le cache, la suppression de l’élément déclenche tous les analyseurs de modification associée. Si l’élément supprimé a été associé à un <xref:System.Web.Caching.CacheItemUpdateCallback> objet ou un <xref:System.Web.Caching.CacheItemRemovedCallback> de l’objet, la raison passée au rappel est <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="regionName" Type="System.String" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à supprimer.</param>
        <param name="reason">La raison pour laquelle l’élément a été supprimé.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache a été ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Supprime une entrée du cache en utilisant la raison.</summary>
        <returns>Si l'entrée est trouvée dans le cache, entrée du cache supprimée ; sinon, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Insère une entrée de cache dans le cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’entrée spécifiée n’existe pas, il est créé. Si l’entrée spécifiée existe, elle est mise à jour.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objet qui représente une entrée de cache à insérer.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <summary>Insère une entrée dans le cache à l'aide d'une instance de <see cref="T:System.Runtime.Caching.CacheItem" /> pour fournir la clé et la valeur de l'entrée de cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme les autres <xref:System.Runtime.Caching.MemoryCache.Set%2A> surcharges de méthode, le <xref:System.Runtime.Caching.MemoryCache.Set%2A> méthode met toujours une valeur de cache dans le cache, qu’une entrée existe déjà avec la même clé. Si l’entrée spécifiée n’existe pas dans le cache, une nouvelle entrée de cache est insérée. Si l’entrée spécifiée existe déjà, sa valeur est mise à jour.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> est <see langword="null" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItem.Key" /> a la valeur <see langword="null" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItem.Value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une combinaison non valide d’arguments pour l’entrée de cache a été passée. Cela se produit si les détails d’expiration suivants sont définis sur l’objet de stratégie pour l’entrée de cache : 
- Si les valeurs d’expiration absolue et décalée de l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> sont autres que les valeurs par défaut des champs <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> et <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne peut pas définir de stratégie d’expiration basée sur une expiration absolue et une expiration décalée. Vous ne pouvez définir explicitement qu’un seul paramètre d’expiration quand vous utilisez la classe <see cref="T:System.Runtime.Caching.MemoryCache" />. L’autre paramètre doit avoir la valeur de la propriété <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Si le rappel de suppression et le rappel de mise à jour sont spécifiés pour l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne prend en charge qu’un seul type de rappel par entrée de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> est inférieure à <see cref="F:System.TimeSpan.Zero" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> a une valeur supérieure à une année.  
  
ou 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> n’est pas une valeur de l’énumération <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à insérer.</param>
        <param name="value">Données pour l'entrée du cache.</param>
        <param name="absoluteExpiration">Date et heure fixes auxquelles l'entrée de cache expirera.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache peut être ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Insère une entrée dans le cache à l'aide d'une clé et d'une valeur, et spécifie les détails d'expiration basés sur l'heure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme les autres <xref:System.Runtime.Caching.MemoryCache.Set%2A> surcharges de méthode, le <xref:System.Runtime.Caching.MemoryCache.Set%2A> méthode met toujours une valeur de cache dans le cache, qu’une entrée existe déjà avec la même clé. Si l’entrée spécifiée n’existe pas, une nouvelle entrée de cache est insérée. Si l’entrée spécifiée existe, elle est mise à jour.  
  
 Le `absoluteExpiration` paramètre indique quand l’entrée doit être supprimée à partir du cache.  
  
 Suppression d’une entrée déclenche tous les analyseurs de modification associée. Si l’élément supprimé a été associé à un <xref:System.Web.Caching.CacheItemUpdateCallback> objet ou <xref:System.Web.Caching.CacheItemRemovedCallback> de l’objet, la raison de la suppression passée aux rappels est contenue dans le <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="Value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Une combinaison non valide d’arguments pour l’entrée de cache a été passée. Cela se produit si les détails d’expiration suivants sont définis sur l’objet de stratégie pour l’entrée de cache : 
-   Si les valeurs d’expiration absolue et décalée de l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> sont autres que les valeurs par défaut de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> et <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Cela est dû au fait que la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne prend pas en charge les entrées d’expiration basées à la fois sur une expiration absolue et une expiration décalée. Vous ne pouvez définir explicitement qu’un seul paramètre d’expiration quand vous utilisez la classe <see cref="T:System.Runtime.Caching.MemoryCache" />. L’autre paramètre doit avoir la valeur <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Si le rappel de suppression et le rappel de mise à jour sont spécifiés sur l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne prend en charge qu’un seul type de rappel par entrée de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> est inférieure à <see cref="F:System.TimeSpan.Zero" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> a une valeur supérieure à une année.  
  
ou 
- La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> n’est pas une valeur de l’énumération <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à insérer.</param>
        <param name="value">Données pour l'entrée du cache.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <param name="regionName">Région nommée du cache à laquelle une entrée de cache peut être ajoutée. Ne passez pas de valeur pour ce paramètre. Ce paramètre est <see langword="null" /> par défaut, car la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> n'implémente pas de régions.</param>
        <summary>Insère une entrée dans le cache à l'aide d'une clé et d'une valeur pour l'éviction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme les autres <xref:System.Runtime.Caching.MemoryCache.Set%2A> surcharges de méthode, le <xref:System.Runtime.Caching.MemoryCache.Set%2A> méthode met toujours une valeur de cache dans le cache, qu’une entrée correspondante existe déjà. Si l’entrée spécifiée n’existe pas dans le cache, une nouvelle entrée de cache est insérée. Si l’entrée spécifiée existe, elle est mise à jour.  
  
 Suppression d’une entrée déclenche tous les analyseurs de modification associée. Si l’élément supprimé a été associé à un <xref:System.Web.Caching.CacheItemUpdateCallback> objet ou <xref:System.Web.Caching.CacheItemRemovedCallback> de l’objet, la raison de la suppression passée aux rappels est contenue dans le <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.  
  
ou 
 <paramref name="value" /> a la valeur <see langword="null" />.  
  
ou 
La référence de rappel passée à la méthode helper dans la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Combinaison non valide d’arguments pour l’entrée de cache. Cela se produit si les détails d’expiration suivants sont définis sur l’objet de stratégie pour l’entrée de cache : 
-   Si les valeurs d’expiration absolue et décalée de l’objet <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> sont autres que les valeurs par défaut de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> et <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Cela est dû au fait que la classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne prend pas en charge les entrées d’expiration basées à la fois sur une expiration absolue et une expiration décalée. Vous ne pouvez définir explicitement qu’un seul paramètre d’expiration quand vous utilisez la classe <see cref="T:System.Runtime.Caching.MemoryCache" />. L’autre paramètre doit avoir la valeur <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> ou <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Si le rappel de suppression et le rappel de mise à jour sont spécifiés sur la classe <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La classe <see cref="T:System.Runtime.Caching.MemoryCache" /> ne prend en charge qu’un seul type de rappel par entrée de cache.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à la propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> est inférieure à <see cref="F:System.TimeSpan.Zero" />.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> a une valeur supérieure à une année.  
  
ou 
La propriété <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> n’est pas une valeur de l’énumération <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> n’est pas un <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prend en charge l’itération au sein d’une collection générique.</summary>
        <returns>Objet énumérateur qui fournit l'accès aux entrées du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement quand un <xref:System.Runtime.Caching.MemoryCache> instance est castée en un <xref:System.Collections.IEnumerable> interface.  
  
 Vous pouvez utiliser cette méthode pour itérer une collection générique d’entrées de cache.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Pourcentage total d'entrées du cache à supprimer.</param>
        <summary>Supprime un pourcentage spécifié d'entrées de cache de l'objet de cache.</summary>
        <returns>Nombre d'entrées supprimées du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.MemoryCache.Trim%2A> propriété supprime tout d’abord les entrées qui ont dépassé ou absolu d’expiration décalée. Tous les rappels inscrits pour les éléments qui sont supprimés recevront une raison de suppression <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Si la suppression d’entrées arrivées à expiration est insuffisante pour atteindre le pourcentage spécifié de découpage, des entrées supplémentaires seront retirées le cache selon un algorithme (LRU dernier) moins récemment utilisé jusqu'à ce que le pourcentage de suppression demandé est atteint. Tous les rappels inscrits pour les éléments qui sont supprimés de cette manière recevront une raison de suppression <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>