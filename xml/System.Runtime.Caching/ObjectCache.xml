<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c5d1a878c469368520395a393dc73698afdad8" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52611445" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente un cache d'objets et fournit les méthodes et propriétés de base pour l'accès au cache d'objets.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache> type est le type de principal pour le cache d’objets en mémoire. Pour développer une implémentation de cache personnalisée, vous dérivez à partir de la <xref:System.Runtime.Caching.ObjectCache> classe.  
  
> [!NOTE]
>  Le <xref:System.Runtime.Caching.ObjectCache> classe est une nouveauté de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Intégrés <xref:System.Runtime.Caching.MemoryCache> classe dérive de la <xref:System.Runtime.Caching.ObjectCache> classe. Le <xref:System.Runtime.Caching.MemoryCache> classe est l’implémentation de cache d’objet concrète uniquement dans le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] qui dérive de la <xref:System.Runtime.Caching.ObjectCache> classe.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Étant donné que le <see cref="T:System.Runtime.Caching.ObjectCache" /> type représente uniquement les fonctions de cache communes, il n’est pas obligatoire pour l’un <see cref="T:System.Runtime.Caching.ObjectCache" /> instance doit être instanciée et obtenue. En outre, il n’est pas nécessaire que les implémentations concrètes de la <see cref="T:System.Runtime.Caching.ObjectCache" /> classe doit être singletons.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> n’est pas un singleton, mais vous devez créer uniquement une peu potentiellement qu’une seule <see cref="T:System.Runtime.Caching.MemoryCache" /> instance et le code qui met en cache des éléments doivent utiliser ces instances.  
  
</para></block>  
  
 Lorsque vous héritez de la <see cref="T:System.Runtime.Caching.ObjectCache" /> (classe), vous devez substituer ses méthodes.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Appelée par des constructeurs de classes dérivées pour initialiser la classe <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache, sans exiger qu'une entrée du cache existante avec une clé correspondante soit retournée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.Add%2A> surcharges de méthode essayant d’insérer une entrée dans le cache, sans remplacer ni supprimer une entrée de cache existante qui a la même clé. L’entrée de cache peut être typé <xref:System.Runtime.Caching.CacheItem> objet ou un objet générique.  
  
 Le <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges de méthode et la <xref:System.Runtime.Caching.ObjectCache.Add%2A> surcharges de méthode ont une différence significative. Lorsque ces méthodes insèrent une entrée de cache, si une entrée correspondante est trouvée dans le cache, le <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges de méthode retournent l’entrée de cache existante, mais la <xref:System.Runtime.Caching.ObjectCache.Add%2A> n’est pas le cas de surcharges de méthode. Ces différentes surcharges de méthode permet aux appelants d’optimiser leur code s’ils ont besoin de l’entrée de cache existante. Dans les caches distribués, en renvoyant une valeur existante à l’aide de la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> méthode peut être plus coûteuse que pour renvoyer une valeur booléenne à l’aide de <xref:System.Runtime.Caching.ObjectCache.Add%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objet à ajouter.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <summary>En cas de substitution dans une classe dérivée, tente d'insérer une entrée dans le cache sous forme d'instance <see cref="T:System.Runtime.Caching.CacheItem" /> et ajoute des détails concernant la méthode d'éviction de l'entrée.</summary>
        <returns>
          <see langword="true" /> si l'insertion a réussi ou <see langword="false" /> si une entrée du cache possède déjà la même clé que <paramref name="item" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.Add%2A> surcharges de méthode sont virtuelles (pas abstraites) sur le <xref:System.Runtime.Caching.ObjectCache> classe, car le <xref:System.Runtime.Caching.ObjectCache.Add%2A> méthode appelle en interne <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Cela réduit le nombre de surcharges de méthode qui a un implémenteur de cache doit fournir. Si une implémentation de cache ne requiert pas de comportement spécial pour le <xref:System.Runtime.Caching.ObjectCache.Add%2A> (méthode), il suffit d’implémenter la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges de méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="value">Objet à insérer.</param>
        <param name="absoluteExpiration">Date et heure fixes auxquelles l'entrée de cache expirera. Ce paramètre est obligatoire lorsque la méthode <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> est appelée.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache peut être ajoutée, si des régions sont implémentées. Dans la mesure où les régions ne sont pas implémentées dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la valeur par défaut est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache sans remplacer d'entrée d'entrée de cache existante.</summary>
        <returns>
          <see langword="true" /> si l'insertion a réussi ou <see langword="false" /> si une entrée du cache possède déjà la même clé que <paramref name="key" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.Add%2A> surcharges de méthode sont virtuelles (pas abstraites) sur le <xref:System.Runtime.Caching.ObjectCache> classe, car le <xref:System.Runtime.Caching.ObjectCache.Add%2A> méthode appelle en interne <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Cela réduit le nombre de surcharges de méthode qui a un implémenteur de cache doit fournir. Si une implémentation de cache ne requiert pas de comportement spécial pour le <xref:System.Runtime.Caching.ObjectCache.Add%2A> (méthode), il suffit d’implémenter la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges de méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="value">Objet à insérer.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache peut être ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache, en spécifiant des informations sur le mode de suppression de l'entrée.</summary>
        <returns>
          <see langword="true" /> en cas d'insertion réussie ou <see langword="false" />, si une entrée du cache possède déjà la même clé que <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.Add%2A> surcharges de méthode sont virtuelles (pas abstraites) sur le <xref:System.Runtime.Caching.ObjectCache> classe, car le <xref:System.Runtime.Caching.ObjectCache.Add%2A> méthode appelle en interne <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Cela réduit le nombre de surcharges de méthode qui a un implémenteur de cache doit fournir. Si une implémentation de cache ne requiert pas de comportement spécial pour le <xref:System.Runtime.Caching.ObjectCache.Add%2A> (méthode), il suffit d’implémenter la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges de méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, tente d'insérer une entrée dans le cache et retourne une entrée du cache existante avec une clé correspondante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges de méthode insérer une entrée dans le cache. Si une entrée de cache avec une clé correspondante existe déjà, ils retournent l’entrée existante. L’entrée de cache peut être un <xref:System.Runtime.Caching.CacheItem> objet ou un objet générique.  
  
 Il existe une différence entre la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges et <xref:System.Runtime.Caching.ObjectCache.Add%2A> surcharges. Lorsque ces méthodes surchargées essaient d’insérer une entrée de cache, si une entrée existante se trouve qu’a une clé qui correspond à un existant inséré l’entrée du cache, le <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> surcharges retournent l’entrée de cache existante. Le <xref:System.Runtime.Caching.ObjectCache.Add%2A> n’est pas le cas de surcharges.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Objet à insérer.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <summary>En cas de substitution dans une classe dérivée, insère l'objet <see cref="T:System.Runtime.Caching.CacheItem" /> spécifié dans le cache, en spécifiant des informations sur le mode de suppression de l'entrée.</summary>
        <returns>S'il existe une entrée de cache ayant la même clé, entrée de cache spécifiée ; sinon, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="value">Objet à insérer.</param>
        <param name="absoluteExpiration">Date et heure fixes auxquelles l'entrée de cache expirera.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache peut être ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache, à l'aide d'une clé, d'un objet pour l'entrée du cache, d'une valeur d'expiration absolue et d'une région facultative dans laquelle ajouter le cache.</summary>
        <returns>S'il existe une entrée du cache ayant la même clé, valeur de l'entrée de cache spécifiée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> surcharge de méthode retourne une valeur d’objet, pas un <xref:System.Runtime.Caching.CacheItem> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="value">Objet à insérer.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache peut être ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache, en spécifiant une clé et une valeur pour l'entrée du cache, ainsi que des informations sur le mode de suppression de l'entrée.</summary>
        <returns>S'il existe une entrée du cache ayant la même clé, valeur de l'entrée de cache spécifiée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> méthode retourne une valeur d’objet, pas un <xref:System.Runtime.Caching.CacheItem> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="regionName">Optionnel. Région nommée du cache dans laquelle le cache peut être trouvé, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, vérifie si l'entrée existe déjà dans le cache.</summary>
        <returns>
          <see langword="true" /> si le cache contient une entrée qui a la même valeur de clé que <paramref name="key" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Identificateurs uniques pour les entrées du cache à surveiller.</param>
        <param name="regionName">Optionnel. Région nommée du cache dans laquelle se trouvent les clés du paramètre <paramref name="keys" />, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un objet <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> qui peut déclencher des événements en réponse aux modifications apportées aux entrées du cache spécifiées.</summary>
        <returns>Analyseur de modification qui surveille les entrées du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand une dérivée <xref:System.Runtime.Caching.ObjectCache> classe substitue à la base de <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> (méthode), l’implémentation de cache doit créer un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objet. Cet analyseur de modification spécialisé notifie les appelants lorsque des modifications sont apportées aux entrées de cache qui sont spécifiées dans le `keys` paramètre. Par exemple, si un élément surveillé dans la `keys` paramètre est mis à jour ou supprimé du cache, l’Analyseur de modification créé par cette méthode déclenche un événement.  
  
 Si une implémentation de cache prend en charge les régions de cache nommé, une valeur de chaîne peut être spécifiée en tant que le `regionName` paramètre. Sinon, le paramètre par défaut est `null`.  
  
> [!NOTE]
>  Pas toutes les implémentations de cache prend en charge des analyseurs de modification d’entrée de cache. Pour déterminer si votre implémentation de cache prend en charge <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objets, consultez la documentation pour l’implémentation de cache spécifique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une description des fonctionnalités que fournit une implémentation de cache.</summary>
        <value>Combinaison d'opérations de bits d'indicateurs qui indiquent les fonctions par défaut d'une implémentation de cache.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à obtenir.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache a été ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient l'entrée du cache spécifiée sous forme d'objet.</summary>
        <returns>Entrée du cache identifiée par <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache à obtenir.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle le cache a été ajouté, si des régions sont implémentées. Dans la mesure où les régions ne sont pas implémentées dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la valeur par défaut est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient l'entrée du cache spécifiée sous la forme d'une instance <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Entrée du cache identifiée par <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode existe parce que certaines implémentations de cache peuvent étendre la <xref:System.Runtime.Caching.CacheItem> classe. Dans ce cas, le <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> surcharge de méthode ne retournera pas nécessairement toutes les informations sur les données mises en cache. Toutefois, le <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> surcharge de méthode permet aux caches personnalisés retourner plus que la valeur de cache.  
  
 Le <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> méthode est comparable à la <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> (méthode), à ceci près que le <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> méthode retourne à l’entrée du cache comme un <xref:System.Runtime.Caching.CacheItem> instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Optionnel. Région nommée du cache pour laquelle le nombre d'entrées de cache doit être calculé, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient le nombre total d'entrées du cache.</summary>
        <returns>Nombre d'entrées du cache. Si <paramref name="regionName" /> n'est pas <see langword="null" />, le nombre indique le nombre d'entrées dans la région de cache spécifiée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un énumérateur qui peut être utilisé pour itérer au sein de la collection d'entrées du cache.</summary>
        <returns>Objet énumérateur qui fournit l’accès aux entrées de cache dans le cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémenteurs de cache peuvent remplacer et étendre cette méthode pour fournir un moyen personnalisé d’itérer une collection d’entrées du cache.  
  
> [!NOTE]
>  Retour d’un énumérateur est généralement une opération plus complexe que le retour de l’entrée de cache dans son intégralité.  
  
 Cette méthode est appelée par les implémentations d’interface explicite qui le <xref:System.Runtime.Caching.ObjectCache> classe a pour le <xref:System.Collections.IEnumerable.GetEnumerator%2A> et <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthodes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un ensemble d'entrées du cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Collection d'identificateurs uniques pour les entrées de cache à obtenir.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle la ou les entrées de cache ont été ajoutées, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient un ensemble d'entrées du cache qui correspondent aux clés spécifiées.</summary>
        <returns>Dictionnaire de paires clé-valeur qui représentent les entrées du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> surcharge de méthode est une optimisation des performances pour les caches distribués qui prennent en charge l’extraction de plusieurs entrées de cache à partir du cache pendant un appel réseau unique.  
  
 Même si un appelant peut passer une ou plusieurs clés à la méthode, il n’existe aucune garantie que toutes les clés représentent des entrées dans le cache. Par conséquent, le dictionnaire retourné peut contenir moins d’éléments que le nombre de clés qui ont été passés à la méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle la ou les entrées de cache ont été ajoutées, si des régions sont implémentées. Dans la mesure où les régions ne sont pas implémentées dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la valeur par défaut est <see langword="null" />.</param>
        <param name="keys">Collection d'identificateurs uniques pour les entrées de cache à obtenir.</param>
        <summary>Obtient un ensemble d'entrées du cache qui correspondent aux clés spécifiées.</summary>
        <returns>Dictionnaire de paires clé-valeur qui représentent les entrées du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> surcharge de méthode est comme la <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> surcharge de méthode, mais vous permet de transmettre la région nommée en utilisant la syntaxe de paramètre optionnel qui est pris en charge par les langages managés tels que c#.  
  
 Cette méthode est une méthode virtuelle, car le <xref:System.Runtime.Caching.ObjectCache> classe fournit une implémentation par défaut qui passe le `params` de tableau à la <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une référence à un environnement d'hébergement managé qui est disponibles pour des implémentations de <see cref="T:System.Runtime.Caching.ObjectCache" /> et qui peut fournir des services spécifiques à l'hôte aux implémentations de <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Référence à un environnement d'hébergement managé ayant connaissance du cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Caching.ObjectCache.Host%2A> propriété est conçue pour une utilisation par [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] environnements hôtes et par les implémentations de cache qui implémentent le comportement dépend du Framework .NET héberger l’environnement.  
  
 Le tableau suivant répertorie l’ensemble des services qui peuvent être disponibles à partir d’un environnement d’hébergement managé et qui sont disponibles pour l’environnement hôte <xref:System.Runtime.Caching.ObjectCache> implémentations via le <xref:System.Runtime.Caching.ObjectCache.Host%2A> propriété :  
  
|Service|Description |  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Permet de fournir des identificateurs de domaine d’application qui peuvent être nécessaires par une implémentation de cache pour les fonctionnalités telles que l’identification des compteurs de performances environnements hôtes.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Permet d’environnements hôtes proposent un système de notification de modification de fichier personnalisé, au lieu d’utiliser celui fourni dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Permet la consommation de mémoire cache cache implémentations rapport à l’environnement hôte. Ainsi, les environnements d’hôte gérer de manière centralisée la consommation de mémoire sur plusieurs implémentations de cache.|  
  
> [!NOTE]
>  Les appelants de cette valeur de propriété nécessitent des autorisations d’accès au code non restreint.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur assignée à la propriété est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été faite pour définir la valeur de propriété plusieurs fois.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">pour la confiance totale pour tous les accesseurs de cette propriété. Cette propriété ne peut pas être utilisée par du code partiellement fiable.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique qu'une entrée du cache n'a aucune expiration absolue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une entrée de cache qui est insérée dans le cache avec la <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> valeur de champ définie comme la valeur d’expiration ne doit jamais expirer basée sur un point absolu dans le temps. Toutefois, une entrée de cache avec ce paramètre peut être supprimée à partir du cache pour d’autres raisons qui sont déterminés par une implémentation de cache particulière, telle que de l’éviction d’événement de la surveillance des modifications due à une sollicitation de la mémoire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique d'une entrée dans le cache.</param>
        <summary>Obtient ou définit l'indexeur par défaut de la classe <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Clé servant d'indexeur dans l'instance de cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de l’accesseur set de cette propriété est comme le <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> (méthode). En interne, une implémentation de cache peut définir l’expiration absolue de la valeur spécifiée pour le <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> (méthode). Toutefois, ce comportement est finalement jusqu'à l’implémentation de cache.  
  
 Le comportement de l’accesseur get revient à appeler le <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> (méthode) et à l’aide de `null` pour le nom de la région.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom d'une instance <see cref="T:System.Runtime.Caching.ObjectCache" /> spécifique.</summary>
        <value>Nom d'une instance de cache spécifique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certaines implémentations de cache peuvent prendre en charge plusieurs instances du cache qui s’exécute dans une application unique. Cette propriété permet aux implémenteurs de cache de retourner un nom qui identifie une instance de cache spécifique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique qu'une entrée du cache n'a pas d'heure d'expiration décalée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’expiration basée sur la durée ou une fenêtre de temps définie est également appelée expiration décalée. En règle générale, une implémentation de cache qui supprime les éléments qui sont basés sur l’expiration décalée supprimera un élément qui n’ont pas été utilisée dans la fenêtre de temps spécifiée.  
  
 Une entrée de cache qui est insérée dans le cache avec la <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> champ la valeur définie comme la valeur d’expiration ne doit jamais être supprimée en raison d’autres que des activités dans une fenêtre temporelle coulissante. Toutefois, un élément de cache peut être supprimé si elle a une expiration absolue, ou si un autre événement d’éviction se produit, telle une modification moniteur ou la mémoire de pression.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache a été ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, supprime l'entrée du cache.</summary>
        <returns>Objet qui représente la valeur de l'entrée de cache supprimée qui était spécifiée par la clé, ou <see langword="null" /> si l'entrée spécifiée est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous substituez cette méthode dans une implémentation de cache personnalisée, s’il existe une entrée de cache dans le cache correspond à `key`, la valeur de l’élément supprimé doit être retournée. Si rien n’a été supprimé du cache, la méthode doit retourner `null`.  
  
> [!NOTE]
>  Certaines implémentations de cache distribué ne peuvent pas en charge la possibilité de retourner la valeur qui a été supprimée du cache. Cela peut être, car l’implémentation de cache ne prend pas en charge le renvoi de la valeur d’un élément de cache supprimée. Il peut également être, car le marshaling de l’objet comme une valeur de retour est trop coûteuse. Dans ce cas, les implémentations de cache peuvent retourner `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut de la <xref:System.Runtime.Caching.ObjectCache.Set%2A> les méthodes de surcharge est une opération insert ou update. Une entrée de cache est que soit insérée comme une nouvelle entrée si l’entrée spécifiée n’existe pas, ou l’entrée de cache est mis à jour avec une nouvelle valeur si elle existe déjà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Élément de cache à ajouter.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <summary>En cas de substitution dans une classe dérivée, insère l'entrée de cache dans le cache sous la forme d'une instance <see cref="T:System.Runtime.Caching.CacheItem" />, en spécifiant des informations sur le mode de suppression de l'entrée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé pour `item` n’existe pas, `item` est inséré comme une nouvelle entrée de cache. Si un élément avec une clé qui correspond à `item` existe, la valeur de `item` est utilisé pour mettre à jour ou remplacer la valeur de l’entrée de cache existante.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="value">Objet à insérer.</param>
        <param name="absoluteExpiration">Date et heure fixes auxquelles l'entrée de cache expirera.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache peut être ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache en spécifiant les détails d'expiration basés sur l'heure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un élément qui correspond à `key` n’existe pas dans le cache, `value` et `key` sont utilisées pour insérer une nouvelle entrée du cache. Si un élément avec une clé qui correspond à `item` existe, l’entrée de cache est mis à jour ou remplacée à l’aide de `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificateur unique de l'entrée de cache.</param>
        <param name="value">Objet à insérer.</param>
        <param name="policy">Objet qui contient les informations d'éviction de l'entrée de cache. Cet objet fournit des options d'éviction autres que la simple expiration absolue.</param>
        <param name="regionName">Optionnel. Région nommée du cache à laquelle l'entrée de cache peut être ajoutée, si des régions sont implémentées. La valeur par défaut du paramètre facultatif est <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, insère une entrée dans le cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode vous permet de fournir plus de détails d’éviction ou d’expiration que celles qui sont disponibles dans la durée d’expiration absolue.  
  
 Si un élément qui correspond à `key` n’existe pas dans le cache, `value` et `key` sont utilisées pour insérer une nouvelle entrée du cache. Si un élément avec une clé qui correspond à `item` existe, l’entrée de cache est mis à jour ou remplacée à l’aide de `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prend en charge une itération sur une collection générique.</summary>
        <returns>Objet énumérateur qui fournit l'accès aux éléments du cache.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsqu’une dérivée <xref:System.Runtime.Caching.ObjectCache> instance est castée en un <xref:System.Collections.IEnumerable> interface.  
  
 Les développeurs peuvent utiliser cette méthode pour itérer une collection générique d’entrées de cache.  
  
 Ceci est la valeur par défaut <xref:System.Collections.IEnumerable.GetEnumerator%2A> implémentation appelle en interne la <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>