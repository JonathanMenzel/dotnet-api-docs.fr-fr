<Type Name="ConcurrentDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Concurrent.ConcurrentDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="44d82d0e0d60f0a0bad84e94daa72d27a4b4b18f" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53226553" /></Metadata><TypeSignature Language="C#" Value="public class ConcurrentDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ConcurrentDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class ConcurrentDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class ConcurrentDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type ConcurrentDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="68e58-101">Type des clés dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-101">The type of the keys in the dictionary.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="68e58-102">Type des valeurs dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-102">The type of the values in the dictionary.</span></span></typeparam>
    <summary><span data-ttu-id="68e58-103">Représente une collection thread-safe de paires clé/valeur accessibles par plusieurs threads simultanément.</span><span class="sxs-lookup"><span data-stu-id="68e58-103">Represents a thread-safe collection of key/value pairs that can be accessed by multiple threads concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-104">Pour les très grandes <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objets, vous pouvez augmenter la taille maximale du tableau à 2 gigaoctets (Go) sur un système 64 bits en définissant l’élément de configuration `true` dans l’environnement d’exécution.</span><span class="sxs-lookup"><span data-stu-id="68e58-104">For very large <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objects, you can increase the maximum array size to 2 gigabytes (GB) on a 64-bit system by setting the  configuration element to `true` in the run-time environment.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="68e58-105"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> implémente le <xref:System.Collections.Generic.IReadOnlyCollection%601> et <xref:System.Collections.Generic.IReadOnlyDictionary%602> interfaces en commençant par le [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; dans les versions précédentes du .NET Framework, le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> n’implémente pas ces interfaces.</span><span class="sxs-lookup"><span data-stu-id="68e58-105"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> and <xref:System.Collections.Generic.IReadOnlyDictionary%602> interfaces starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class did not implement these interfaces.</span></span>  
  
 <span data-ttu-id="68e58-106">Comme le <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> (classe), <xref:System.Collections.Concurrent.ConcurrentDictionary%602> implémente le <xref:System.Collections.Generic.IDictionary%602> interface.</span><span class="sxs-lookup"><span data-stu-id="68e58-106">Like the <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> class, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> implements the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span> <span data-ttu-id="68e58-107">En outre, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> fournit plusieurs méthodes pour l’ajout ou la mise à jour des paires clé/valeur dans le dictionnaire, comme décrit dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="68e58-107">In addition, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> provides several methods for adding or updating key/value pairs in the dictionary, as described in the following table.</span></span>  
  
|<span data-ttu-id="68e58-108">Pour</span><span class="sxs-lookup"><span data-stu-id="68e58-108">To do this</span></span>|<span data-ttu-id="68e58-109">Utilisez cette méthode</span><span class="sxs-lookup"><span data-stu-id="68e58-109">Use this method</span></span>|<span data-ttu-id="68e58-110">Notes d’utilisation</span><span class="sxs-lookup"><span data-stu-id="68e58-110">Usage notes</span></span>|  
|----------------|---------------------|-----------------|  
|<span data-ttu-id="68e58-111">Ajoutez une nouvelle clé dans le dictionnaire, s’il n’existe déjà dans le dictionnaire</span><span class="sxs-lookup"><span data-stu-id="68e58-111">Add a new key to the dictionary, if it doesn't already exist in the dictionary</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A>|<span data-ttu-id="68e58-112">Cette méthode ajoute la paire clé/valeur spécifiée, si la clé n’existe pas actuellement dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-112">This method adds the specified key/value pair, if the key doesn't currently exist in the dictionary.</span></span> <span data-ttu-id="68e58-113">La méthode retourne `true` ou `false` selon que la nouvelle paire a été ajoutée.</span><span class="sxs-lookup"><span data-stu-id="68e58-113">The method returns `true` or `false` depending on whether the new pair was added.</span></span>|  
|<span data-ttu-id="68e58-114">Mettre à jour la valeur pour une clé existante dans le dictionnaire, si cette clé a une valeur spécifique</span><span class="sxs-lookup"><span data-stu-id="68e58-114">Update the value for an existing key in the dictionary, if that key has a specific value</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A>|<span data-ttu-id="68e58-115">Cette méthode vérifie si la clé a une valeur spécifiée, et si elle est le cas, met à jour la clé avec une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="68e58-115">This method checks whether the key has a specified value, and if it does, updates the key with a new value.</span></span> <span data-ttu-id="68e58-116">Elle est similaire à la <xref:System.Threading.Interlocked.CompareExchange%2A> (méthode), à ceci près qu’elle utilisé pour les éléments du dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-116">It's similar to the <xref:System.Threading.Interlocked.CompareExchange%2A> method, except that it's used for dictionary elements.</span></span>|  
|<span data-ttu-id="68e58-117">Store une paire clé/valeur dans le dictionnaire de manière inconditionnelle et remplacer la valeur d’une clé qui existe déjà</span><span class="sxs-lookup"><span data-stu-id="68e58-117">Store a key/value pair in the dictionary unconditionally, and overwrite the value of a key that already exists</span></span>|<span data-ttu-id="68e58-118">Accesseur Set de l’indexeur : `dictionary[key] = newValue`</span><span class="sxs-lookup"><span data-stu-id="68e58-118">The indexer's setter: `dictionary[key] = newValue`</span></span>||  
|<span data-ttu-id="68e58-119">Ajouter une paire clé/valeur au dictionnaire, ou si la clé existe déjà, mettre à jour la valeur de la clé basée sur la valeur de clé existant</span><span class="sxs-lookup"><span data-stu-id="68e58-119">Add a key/value pair to the dictionary, or if the key already exists, update the value for the key based on the key's existing value</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29><br /><br /> <span data-ttu-id="68e58-120">- ou -</span><span class="sxs-lookup"><span data-stu-id="68e58-120">-or-</span></span><br /><br /> <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29>|<span data-ttu-id="68e58-121"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepte la clé et deux délégués.</span><span class="sxs-lookup"><span data-stu-id="68e58-121"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepts the key and two delegates.</span></span> <span data-ttu-id="68e58-122">Il utilise le premier délégué si la clé n’existe pas dans le dictionnaire ; Il accepte la clé et retourne la valeur doit être ajoutée pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-122">It uses the first delegate if the key doesn't exist in the dictionary; it accepts the key and returns the value that should be added for the key.</span></span> <span data-ttu-id="68e58-123">Il utilise le deuxième délégué si la clé n’existe pas ; Il accepte la clé et sa valeur actuelle et retourne la nouvelle valeur doit être définie pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-123">It uses the second delegate if the key does exist; it accepts the key and its current value, and it returns the new value that should be set for the key.</span></span><br /><br /> <span data-ttu-id="68e58-124"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepte la clé, une valeur à ajouter et le délégué de mise à jour.</span><span class="sxs-lookup"><span data-stu-id="68e58-124"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepts the key, a value to add, and the update delegate.</span></span> <span data-ttu-id="68e58-125">Cela est identique à la surcharge précédente, sauf qu’il n’utilise pas un délégué pour ajouter une clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-125">This is the same as the previous overload, except that it doesn't use a delegate to add a key.</span></span>|  
|<span data-ttu-id="68e58-126">Obtenir la valeur d’une clé dans le dictionnaire, en ajoutant la valeur au dictionnaire et retourner si la clé n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="68e58-126">Get the value for a key in the dictionary, adding the value to the dictionary and returning it if the key doesn't exist</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29><br /><br /> <span data-ttu-id="68e58-127">ou</span><span class="sxs-lookup"><span data-stu-id="68e58-127">-or-</span></span><br /><br /> <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29>|<span data-ttu-id="68e58-128">Ces surcharges fournissent l’initialisation tardive pour une paire clé/valeur dans le dictionnaire, en ajoutant la valeur uniquement si elle n’y ne figure pas.</span><span class="sxs-lookup"><span data-stu-id="68e58-128">These overloads provide lazy initialization for a key/value pair in the dictionary, adding the value only if it's not there.</span></span><br /><br /> <span data-ttu-id="68e58-129"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29> prend la valeur doit être ajouté si la clé n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="68e58-129"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29> takes the value to be added if the key doesn't exist.</span></span><br /><br /> <span data-ttu-id="68e58-130"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29> prend un délégué qui génère la valeur si la clé n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="68e58-130"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29> takes a delegate that will generate the value if the key doesn't exist.</span></span>|  
  
 <span data-ttu-id="68e58-131">Toutes ces opérations sont atomiques et sont thread-safe en ce qui concerne toutes les autres opérations sur le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="68e58-131">All these operations are atomic and are thread-safe with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span> <span data-ttu-id="68e58-132">Les seules exceptions sont les méthodes qui acceptent un délégué, autrement dit, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> et <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>.</span><span class="sxs-lookup"><span data-stu-id="68e58-132">The only exceptions are the methods that accept a delegate, that is, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>.</span></span> <span data-ttu-id="68e58-133">Pour les modifications et les opérations d’écriture dans le dictionnaire, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-133">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="68e58-134">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, les délégués pour ces méthodes sont appelées en dehors des verrous pour éviter les problèmes qui peuvent survenir lors de l’exécution de code inconnu sous un verrou.</span><span class="sxs-lookup"><span data-stu-id="68e58-134">(Read operations on the dictionary are performed in a lock-free manner.) However, delegates for these methods are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="68e58-135">Par conséquent, le code exécuté par ces délégués n’est pas soumis à l’atomicité de l’opération.</span><span class="sxs-lookup"><span data-stu-id="68e58-135">Therefore, the code executed by these delegates is not subject to the atomicity of the operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e58-136">L’exemple suivant montre comment construire un <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objet.</span><span class="sxs-lookup"><span data-stu-id="68e58-136">The following example shows how to construct a <xref:System.Collections.Concurrent.ConcurrentDictionary%602> object.</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#1)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="68e58-137">Tous les membres publics et protégés de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-137">All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> are thread-safe and may be used concurrently from multiple threads.</span></span> <span data-ttu-id="68e58-138">Toutefois, les membres sont accessibles via une des interfaces du <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> implémente, y compris les méthodes d’extension n’est pas garanti pour être thread-safe et peuvent doivent être synchronisés par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="68e58-138">However, members accessed through one of the interfaces the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> implements, including extension methods, are not guaranteed to be thread safe and may need to be synchronized by the caller.</span></span></threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-139">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-139">Thread-Safe Collections</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-140">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-140">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e58-141">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-141">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class.</span></span></summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-142">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-142">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-143">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-143">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e58-144">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui est vide, possède le niveau de concurrence par défaut, possède la capacité initiale par défaut et utilise le comparateur par défaut pour le type de clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-144">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-145">Le niveau de concurrence par défaut est égal au nombre de processeurs.</span><span class="sxs-lookup"><span data-stu-id="68e58-145">The default concurrency level is equal to the number of CPUs.</span></span> <span data-ttu-id="68e58-146">Plus le niveau de concurrence est élevée, les opérations d’écriture plus simultanées peuvent avoir lieu sans interférence et de blocage.</span><span class="sxs-lookup"><span data-stu-id="68e58-146">The higher the concurrency level is, the more concurrent write operations can take place without interference and blocking.</span></span> <span data-ttu-id="68e58-147">Valeurs de niveau plus élevés d’accès concurrentiel provoquent également les opérations qui nécessitent tous les verrous (table par exemple, le redimensionnement, `ToArray` et `Count`) pour devenir plus coûteux.</span><span class="sxs-lookup"><span data-stu-id="68e58-147">Higher concurrency level values also cause operations that require all locks (for example, table resizing, `ToArray` and `Count`) to become more expensive.</span></span> <span data-ttu-id="68e58-148">La capacité par défaut (DEFAULT_CAPACITY), qui représente le nombre de compartiments initial, est un compromis entre la taille d’un très petit dictionnaire et le nombre de redimensionnements de lors de la construction d’un dictionnaire de grande taille.</span><span class="sxs-lookup"><span data-stu-id="68e58-148">The default capacity (DEFAULT_CAPACITY), which represents the initial number of buckets, is a trade-off between the size of a very small dictionary and the number of resizes when constructing a large dictionary.</span></span> <span data-ttu-id="68e58-149">En outre, la capacité ne doit pas être divisible par un petit nombre premier.</span><span class="sxs-lookup"><span data-stu-id="68e58-149">Also, the capacity should not be divisible by a small prime number.</span></span> <span data-ttu-id="68e58-150">La capacité par défaut est 31.</span><span class="sxs-lookup"><span data-stu-id="68e58-150">The default capacity is 31.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-151">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-151">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-152">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-152">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="68e58-153"><see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont copiés dans le nouveau <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-153">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="68e58-154">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui contient des éléments copiés depuis le <see cref="T:System.Collections.Generic.IEnumerable`1" /> spécifié, possède le niveau de concurrence par défaut, possède la capacité initiale par défaut et utilise le comparateur par défaut pour le type de clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-154">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IEnumerable`1" />, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-155"><paramref name="collection" /> ou toutes ses clés est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-155"><paramref name="collection" /> or any of its keys is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="68e58-156"><paramref name="collection" /> contient une ou plusieurs clés en double.</span><span class="sxs-lookup"><span data-stu-id="68e58-156"><paramref name="collection" /> contains one or more duplicate keys.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-157">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-157">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-158">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-158">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="68e58-159">Implémentation de comparaison d'égalité à utiliser lors de la comparaison de clés.</span><span class="sxs-lookup"><span data-stu-id="68e58-159">The equality comparison implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="68e58-160">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui est vide, possède le niveau de concurrence et la capacité par défaut, et utilise le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-160">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the default concurrency level and capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-161"><paramref name="comparer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-161"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-162">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-162">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-163">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-163">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="68e58-164"><see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont copiés dans le nouveau <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-164">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="68e58-165">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison de clés.</span><span class="sxs-lookup"><span data-stu-id="68e58-165">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="68e58-166">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui contient des éléments copiés à partir du <see cref="T:System.Collections.IEnumerable" /> spécifié, possède le niveau de concurrence par défaut, possède la capacité initiale par défaut et utilise le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-166">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" /> has the default concurrency level, has the default initial capacity, and uses the specified  <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-167"><paramref name="collection" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-167"><paramref name="collection" /> or <paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-168">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-168">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-169">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-169">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * int -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="68e58-170">Nombre estimé des threads qui mettront à jour le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultanément.</span><span class="sxs-lookup"><span data-stu-id="68e58-170">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="capacity"><span data-ttu-id="68e58-171">Nombre initial d'éléments que <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> peut contenir.</span><span class="sxs-lookup"><span data-stu-id="68e58-171">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> can contain.</span></span></param>
        <summary><span data-ttu-id="68e58-172">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui est vide, possède le niveau de concurrence et la capacité spécifiés, et utilise le comparateur par défaut pour le type de clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-172">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the specified concurrency level and capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="68e58-173"><paramref name="concurrencyLevel" /> est inférieur à 1.</span><span class="sxs-lookup"><span data-stu-id="68e58-173"><paramref name="concurrencyLevel" /> is less than 1.</span></span>  
  
<span data-ttu-id="68e58-174">- ou -</span><span class="sxs-lookup"><span data-stu-id="68e58-174">-or-</span></span> 
 <span data-ttu-id="68e58-175"><paramref name="capacity" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="68e58-175"><paramref name="capacity" /> is less than 0.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-176">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-176">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-177">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-177">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="68e58-178">Nombre estimé des threads qui mettront à jour le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultanément.</span><span class="sxs-lookup"><span data-stu-id="68e58-178">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="collection"><span data-ttu-id="68e58-179"><see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont copiés dans le nouveau <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-179">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="68e58-180">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison de clés.</span><span class="sxs-lookup"><span data-stu-id="68e58-180">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="68e58-181">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui contient des éléments copiés du <see cref="T:System.Collections.IEnumerable" /> spécifié et utilise le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-181">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" />, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-182"><paramref name="collection" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-182"><paramref name="collection" /> or <paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="68e58-183"><paramref name="concurrencyLevel" /> est inférieur à 1.</span><span class="sxs-lookup"><span data-stu-id="68e58-183"><paramref name="concurrencyLevel" /> is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="68e58-184"><paramref name="collection" /> contient une ou plusieurs clés en double.</span><span class="sxs-lookup"><span data-stu-id="68e58-184"><paramref name="collection" /> contains one or more duplicate keys.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-185">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-185">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-186">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-186">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, capacity As Integer, comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, int capacity, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * int * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="68e58-187">Nombre estimé des threads qui mettront à jour le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultanément.</span><span class="sxs-lookup"><span data-stu-id="68e58-187">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="capacity"><span data-ttu-id="68e58-188">Nombre initial d'éléments que <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> peut contenir.</span><span class="sxs-lookup"><span data-stu-id="68e58-188">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> can contain.</span></span></param>
        <param name="comparer"><span data-ttu-id="68e58-189">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison de clés.</span><span class="sxs-lookup"><span data-stu-id="68e58-189">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="68e58-190">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui est vide, possède le niveau de concurrence spécifiés, possède la capacité initiale spécifiée et utilise le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-190">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the specified concurrency level, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-191"><paramref name="comparer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-191"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="68e58-192"><paramref name="concurrencyLevel" /> ou <paramref name="capacity" /> est inférieur à 1.</span><span class="sxs-lookup"><span data-stu-id="68e58-192"><paramref name="concurrencyLevel" /> or <paramref name="capacity" /> is less than 1.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-193">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-193">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-194">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-194">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e58-195">Ajoute une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé n'existe pas déjà, ou met à jour une paire clé/valeur dans le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-195">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e58-196">L’exemple suivant montre comment appeler le <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> méthode :</span><span class="sxs-lookup"><span data-stu-id="68e58-196">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#3)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-197">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-197">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-198">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-198">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate (TKey key, Func&lt;TKey,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate(!TKey key, class System.Func`2&lt;!TKey, !TValue&gt; addValueFactory, class System.Func`3&lt;!TKey, !TValue, !TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate (key As TKey, addValueFactory As Func(Of TKey, TValue), updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue AddOrUpdate(TKey key, Func&lt;TKey, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * Func&lt;'Key, 'Value&gt; * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValueFactory, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-199">Clé à ajouter ou dont la valeur doit être mise à jour.</span><span class="sxs-lookup"><span data-stu-id="68e58-199">The key to be added or whose value should be updated</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="68e58-200">Fonction utilisée pour générer une valeur pour une clé absente</span><span class="sxs-lookup"><span data-stu-id="68e58-200">The function used to generate a value for an absent key</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="68e58-201">Fonction utilisée pour générer une nouvelle valeur pour une clé existante en fonction de la valeur existante de la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-201">The function used to generate a new value for an existing key based on the key's existing value</span></span></param>
        <summary><span data-ttu-id="68e58-202">Utilise les fonctions spécifiées pour ajouter une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé n'existe pas déjà, ou pour mettre à jour une paire clé/valeur dans le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> en utilisant la fonction spécifiée si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-202">Uses the specified functions to add a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or to update a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="68e58-203">Nouvelle valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-203">The new value for the key.</span></span> <span data-ttu-id="68e58-204">Il s’agit soit du résultat de <paramref name="addValueFactory" /> (si la clé était absente), soit du résultat de <paramref name="updateValueFactory" /> (si la clé était présente).</span><span class="sxs-lookup"><span data-stu-id="68e58-204">This will be either be the result of <paramref name="addValueFactory" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-205">Si vous appelez <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultanément sur différents threads, `addValueFactory` peut être appelée plusieurs fois, mais sa paire clé/valeur ne peut pas être ajouté au dictionnaire pour chaque appel.</span><span class="sxs-lookup"><span data-stu-id="68e58-205">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneously on different threads, `addValueFactory` may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</span></span>  

 <span data-ttu-id="68e58-206">Pour les modifications et les opérations d’écriture dans le dictionnaire, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-206">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="68e58-207">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, le `addValueFactory` et `updateValueFactory` délégués sont appelés en dehors des verrous pour éviter les problèmes qui peuvent survenir lors de l’exécution de code inconnu sous un verrou.</span><span class="sxs-lookup"><span data-stu-id="68e58-207">(Read operations on the dictionary are performed in a lock-free manner.) However, the `addValueFactory` and `updateValueFactory` delegates are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="68e58-208">Par conséquent, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> n’est pas atomique en ce qui concerne toutes les autres opérations sur le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="68e58-208">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-209"><paramref name="key" />, <paramref name="addValueFactory" /> ou <paramref name="updateValueFactory" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-209"><paramref name="key" />, <paramref name="addValueFactory" />, or <paramref name="updateValueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-210">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-210">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-211">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-211">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-212">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-212">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate (TKey key, TValue addValue, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate(!TKey key, !TValue addValue, class System.Func`3&lt;!TKey, !TValue, !TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate (key As TKey, addValue As TValue, updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue AddOrUpdate(TKey key, TValue addValue, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValue, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValue" Type="TValue" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-213">Clé à ajouter ou dont la valeur doit être mise à jour.</span><span class="sxs-lookup"><span data-stu-id="68e58-213">The key to be added or whose value should be updated</span></span></param>
        <param name="addValue"><span data-ttu-id="68e58-214">Valeur à ajouter pour une clé absente.</span><span class="sxs-lookup"><span data-stu-id="68e58-214">The value to be added for an absent key</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="68e58-215">Fonction utilisée pour générer une nouvelle valeur pour une clé existante en fonction de la valeur existante de la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-215">The function used to generate a new value for an existing key based on the key's existing value</span></span></param>
        <summary><span data-ttu-id="68e58-216">Ajoute une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé n'existe pas déjà, ou met à jour une paire clé/valeur dans le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> en utilisant la fonction spécifiée si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-216">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="68e58-217">Nouvelle valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-217">The new value for the key.</span></span> <span data-ttu-id="68e58-218">Il s’agit soit du résultat de <paramref name="addValue" /> (si la clé était absente), soit du résultat de <paramref name="updateValueFactory" /> (si la clé était présente).</span><span class="sxs-lookup"><span data-stu-id="68e58-218">This will be either be <paramref name="addValue" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e58-219">L’exemple de code suivant montre comment initialiser un <xref:System.Collections.Concurrent.ConcurrentDictionary%602> et comment utiliser la méthode AddOrUpdate pour ajouter un élément supplémentaire à la collection et mettre à jour les éléments existants.</span><span class="sxs-lookup"><span data-stu-id="68e58-219">The following code example shows how to initialize an <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and how to use the AddOrUpdate method to add an additional item to the collection, and update the existing items.</span></span>  
  
 [!code-csharp[System.Collections.ConcurrentColAddUpdate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrentcoladdupdate/cs/program.cs#1)]
 [!code-vb[System.Collections.ConcurrentColAddUpdate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrentcoladdupdate/vb/module1.vb#1)]  

## Remarks  
 <span data-ttu-id="68e58-220">Pour les modifications et les opérations d’écriture dans le dictionnaire, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-220">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="68e58-221">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, le `updateValueFactory` délégué est appelé en dehors des verrous pour éviter les problèmes qui peuvent survenir lors de l’exécution de code inconnu sous un verrou.</span><span class="sxs-lookup"><span data-stu-id="68e58-221">(Read operations on the dictionary are performed in a lock-free manner.) However, the `updateValueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="68e58-222">Par conséquent, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> n’est pas atomique en ce qui concerne toutes les autres opérations sur le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="68e58-222">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-223"><paramref name="key" /> ou <paramref name="updateValueFactory" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-223"><paramref name="key" /> or <paramref name="updateValueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-224">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-224">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-225">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-225">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-226">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-226">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate&lt;TArg&gt;">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate&lt;TArg&gt; (TKey key, Func&lt;TKey,TArg,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TArg,TValue&gt; updateValueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate&lt;TArg&gt;(!TKey key, class System.Func`3&lt;!TKey, !!TArg, !TValue&gt; addValueFactory, class System.Func`4&lt;!TKey, !TValue, !!TArg, !TValue&gt; updateValueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate(Of TArg) (key As TKey, addValueFactory As Func(Of TKey, TArg, TValue), updateValueFactory As Func(Of TKey, TValue, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg&gt;&#xA; TValue AddOrUpdate(TKey key, Func&lt;TKey, TArg, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TArg, TValue&gt; ^ updateValueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * Func&lt;'Key, 'Value, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValueFactory, updateValueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TArg,TValue&gt;" />
        <Parameter Name="factoryArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="TArg"><span data-ttu-id="68e58-227">Le type d’un argument à passer à <paramref name="addValueFactory" /> et <paramref name="updateValueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-227">The type of an argument to pass into <paramref name="addValueFactory" /> and <paramref name="updateValueFactory" />.</span></span></typeparam>
        <param name="key"><span data-ttu-id="68e58-228">Clé à ajouter ou dont la valeur doit être mise à jour.</span><span class="sxs-lookup"><span data-stu-id="68e58-228">The key to be added or whose value should be updated.</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="68e58-229">Fonction utilisée pour générer une valeur pour une clé absente.</span><span class="sxs-lookup"><span data-stu-id="68e58-229">The function used to generate a value for an absent key.</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="68e58-230">Fonction utilisée pour générer une nouvelle valeur pour une clé existante en fonction de la valeur existante de la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-230">The function used to generate a new value for an existing key based on the key's existing value.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="68e58-231">Argument à passer dans <paramref name="addValueFactory" /> et <paramref name="updateValueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-231">An argument to pass into <paramref name="addValueFactory" /> and <paramref name="updateValueFactory" />.</span></span></param>
        <summary><span data-ttu-id="68e58-232">Utilise l’argument et les fonctions spécifiés pour ajouter une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé n'existe pas déjà, ou pour mettre à jour une paire clé/valeur dans le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> en utilisant la fonction spécifiée si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-232">Uses the specified functions and argument to add a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or to update a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="68e58-233">Nouvelle valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-233">The new value for the key.</span></span> <span data-ttu-id="68e58-234">Il s’agit soit du résultat de <paramref name="addValueFactory" /> (si la clé était absente), soit du résultat de <paramref name="updateValueFactory" /> (si la clé était présente).</span><span class="sxs-lookup"><span data-stu-id="68e58-234">This will be either be the result of <paramref name="addValueFactory" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-235">Si vous appelez <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultanément sur différents threads, `addValueFactory` peut être appelée plusieurs fois, mais sa paire clé/valeur ne peut pas être ajouté au dictionnaire pour chaque appel.</span><span class="sxs-lookup"><span data-stu-id="68e58-235">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneously on different threads, `addValueFactory` may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</span></span>  

 <span data-ttu-id="68e58-236">Pour les modifications et les opérations d’écriture dans le dictionnaire, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-236">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="68e58-237">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, le `addValueFactory` et `updateValueFactory` délégués sont appelés en dehors des verrous pour éviter les problèmes qui peuvent survenir lors de l’exécution de code inconnu sous un verrou.</span><span class="sxs-lookup"><span data-stu-id="68e58-237">(Read operations on the dictionary are performed in a lock-free manner.) However, the `addValueFactory` and `updateValueFactory` delegates are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="68e58-238">Par conséquent, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> n’est pas atomique en ce qui concerne toutes les autres opérations sur le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="68e58-238">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-239"><paramref name="key" />, <paramref name="addValueFactory" /> ou <paramref name="updateValueFactory" /> est une référence Null (Nothing en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="68e58-239"><paramref name="key" />, <paramref name="addValueFactory" />, or <paramref name="updateValueFactory" /> is a null reference (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="concurrentDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e58-240">Supprime toutes les clés et les valeurs de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-240">Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-241">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-241">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-242">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-242">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="concurrentDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-243">Clé à rechercher dans <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-243">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="68e58-244">Détermine si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contient la clé spécifiée.</span><span class="sxs-lookup"><span data-stu-id="68e58-244">Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains the specified key.</span></span></summary>
        <returns><span data-ttu-id="68e58-245"><see langword="true" /> si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-245"><see langword="true" /> if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-246"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-246"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-247">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-247">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-248">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-248">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-249">Obtient le nombre de paires clé/valeur contenues dans <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-249">Gets the number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="68e58-250">Nombre de paires clé/valeur contenues dans <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-250">The number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-251">Cette propriété a la sémantique des instantanés et représente le nombre d’éléments dans le <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> pour le moment où la propriété a été ouverts.</span><span class="sxs-lookup"><span data-stu-id="68e58-251">This property has snapshot semantics and represents the number of items in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> at the moment when the property was accessed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-252">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-252">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-253">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-253">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-254">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-254">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="concurrentDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__35))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__34))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e58-255">Retourne un énumérateur qui itère au sein de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-255">Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-256">Énumérateur pour <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-256">An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-257">L’énumérateur retourné à partir du dictionnaire est sûr à utiliser en même temps que les lectures et écritures dans le dictionnaire, mais il ne représente pas un instantané du moment-à-temps du dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-257">The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</span></span> <span data-ttu-id="68e58-258">Le contenu exposé via l’énumérateur peut contenir des modifications apportées au dictionnaire après <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> a été appelée.</span><span class="sxs-lookup"><span data-stu-id="68e58-258">The contents exposed through the enumerator may contain modifications made to the dictionary after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> was called.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-259">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-259">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-260">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-260">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetOrAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="68e58-261">Ajoute une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé n'existe pas encore.</span><span class="sxs-lookup"><span data-stu-id="68e58-261">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist.</span></span> <span data-ttu-id="68e58-262">Retourne la nouvelle valeur ou la valeur existante si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-262">Returns the new value, or the existing value if the key already exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e58-263">L’exemple suivant montre comment appeler le <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> méthode :</span><span class="sxs-lookup"><span data-stu-id="68e58-263">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#3)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-264">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-264">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-265">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-265">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetOrAdd">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd (TKey key, Func&lt;TKey,TValue&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd(!TKey key, class System.Func`2&lt;!TKey, !TValue&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd (key As TKey, valueFactory As Func(Of TKey, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrAdd(TKey key, Func&lt;TKey, TValue&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * Func&lt;'Key, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-266">Clé de l'élément à ajouter.</span><span class="sxs-lookup"><span data-stu-id="68e58-266">The key of the element to add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="68e58-267">Fonction utilisée pour générer une valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-267">The function used to generate a value for the key.</span></span></param>
        <summary><span data-ttu-id="68e58-268">Ajoute une paire clé/valeur à <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> en utilisant la fonction spécifiée, si la clé n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="68e58-268">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function if the key does not already exist.</span></span> <span data-ttu-id="68e58-269">Retourne la nouvelle valeur ou la valeur existante si la clé existe.</span><span class="sxs-lookup"><span data-stu-id="68e58-269">Returns the new value, or the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="68e58-270">Valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-270">The value for the key.</span></span> <span data-ttu-id="68e58-271">Il s'agit de la valeur existante pour la clé si la clé est déjà dans le dictionnaire, ou de la nouvelle valeur si la clé n'était pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-271">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 <span data-ttu-id="68e58-272">Pour les modifications et les opérations d’écriture dans le dictionnaire, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-272">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="68e58-273">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, le `valueFactory` délégué est appelé en dehors des verrous pour éviter les problèmes qui peuvent survenir lors de l’exécution de code inconnu sous un verrou.</span><span class="sxs-lookup"><span data-stu-id="68e58-273">(Read operations on the dictionary are performed in a lock-free manner.) However, the `valueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="68e58-274">Par conséquent, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> n’est pas atomique en ce qui concerne toutes les autres opérations sur le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="68e58-274">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  

 <span data-ttu-id="68e58-275">Dans la mesure où une clé/valeur peuvent être insérée par un autre thread pendant `valueFactory` est générant une valeur, vous ne pouvez pas font confiance à ce parce que `valueFactory` exécutée, sa valeur produit sera inséré dans le dictionnaire et retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-275">Since a key/value can be inserted by another thread while `valueFactory` is generating a value, you cannot trust that just because `valueFactory` executed, its produced value will be inserted into the dictionary and returned.</span></span> <span data-ttu-id="68e58-276">Si vous appelez <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultanément sur différents threads, `valueFactory` peut être appelée plusieurs fois, mais la paire clé/valeur qu’un seul sera ajoutée au dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-276">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneously on different threads, `valueFactory` may be called multiple times, but only one key/value pair will be added to the dictionary.</span></span> 
 
 <span data-ttu-id="68e58-277">La valeur de retour dépend de la présence de la clé dans le dictionnaire et indique si une clé/valeur est insérée par un autre thread après <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> est appelée, mais avant `valueFactory` génère une valeur :</span><span class="sxs-lookup"><span data-stu-id="68e58-277">The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is called but before `valueFactory` generates a value:</span></span>

 | <span data-ttu-id="68e58-278">Scénario</span><span class="sxs-lookup"><span data-stu-id="68e58-278">Scenario</span></span> | <span data-ttu-id="68e58-279">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="68e58-279">Return value</span></span> |
 | -------- | ------------ |
 | <span data-ttu-id="68e58-280">La clé est déjà dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-280">The key is already in the dictionary.</span></span> | <span data-ttu-id="68e58-281">La valeur existante est retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-281">The existing value is returned.</span></span> |
 | <span data-ttu-id="68e58-282">La clé n’est pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-282">The key is not in the dictionary.</span></span> <span data-ttu-id="68e58-283">`valueFactory` génère une valeur.</span><span class="sxs-lookup"><span data-stu-id="68e58-283">`valueFactory` generates a value.</span></span> <span data-ttu-id="68e58-284">Sur la nouvelle vérification de la clé, aucune clé est trouvée.</span><span class="sxs-lookup"><span data-stu-id="68e58-284">On rechecking for the key, no key is found.</span></span> | <span data-ttu-id="68e58-285">La clé/valeur est insérée dans le dictionnaire, et la valeur est retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-285">The key/value is inserted into the dictionary, and the value is returned.</span></span> |
 | <span data-ttu-id="68e58-286">La clé n’est pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-286">The key is not in the dictionary.</span></span> <span data-ttu-id="68e58-287">`valueFactory` génère une valeur.</span><span class="sxs-lookup"><span data-stu-id="68e58-287">`valueFactory` generates a value.</span></span> <span data-ttu-id="68e58-288">Bien que `valueFactory` est à la génération de la valeur, un thread différent insère une valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-288">While `valueFactory` is generating the value, a different thread inserts a value for the key.</span></span> <span data-ttu-id="68e58-289">Après avoir `valueFactory` s’exécute et lors de la nouvelle vérification de la clé, la clé insérée par l’autre thread est trouvée.</span><span class="sxs-lookup"><span data-stu-id="68e58-289">After `valueFactory` executes and upon rechecking for the key, the key inserted by the other thread is found.</span></span> | <span data-ttu-id="68e58-290">La valeur insérée par l’autre thread est retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-290">The value inserted by the other thread is returned.</span></span> |
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-291"><paramref name="key" /> ou <paramref name="valueFactory" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-291"><paramref name="key" /> or <paramref name="valueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-292">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-292">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-293">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-293">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-294">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-294">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd (key As TKey, value As TValue) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * 'Value -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-295">Clé de l'élément à ajouter.</span><span class="sxs-lookup"><span data-stu-id="68e58-295">The key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="68e58-296">Valeur à ajouter, si la clé n’existe pas encore.</span><span class="sxs-lookup"><span data-stu-id="68e58-296">The value to be added, if the key does not already exist.</span></span></param>
        <summary><span data-ttu-id="68e58-297">Ajoute une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clé n'existe pas encore.</span><span class="sxs-lookup"><span data-stu-id="68e58-297">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist.</span></span> <span data-ttu-id="68e58-298">Retourne la nouvelle valeur ou la valeur existante si la clé existe.</span><span class="sxs-lookup"><span data-stu-id="68e58-298">Returns the new value, or the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="68e58-299">Valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-299">The value for the key.</span></span> <span data-ttu-id="68e58-300">Il s'agit de la valeur existante pour la clé si la clé est déjà dans le dictionnaire, ou de la nouvelle valeur si la clé n'était pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-300">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-301"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-301"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-302">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-302">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-303">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-303">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-304">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-304">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TArg&gt;">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd&lt;TArg&gt; (TKey key, Func&lt;TKey,TArg,TValue&gt; valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd&lt;TArg&gt;(!TKey key, class System.Func`3&lt;!TKey, !!TArg, !TValue&gt; valueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd(Of TArg) (key As TKey, valueFactory As Func(Of TKey, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg&gt;&#xA; TValue GetOrAdd(TKey key, Func&lt;TKey, TArg, TValue&gt; ^ valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, valueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" />
        <Parameter Name="factoryArgument" Type="TArg" />
      </Parameters>
      <Docs>
        <typeparam name="TArg"><span data-ttu-id="68e58-305">Le type d’un argument à passer à <paramref name="valueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-305">The type of an argument to pass into <paramref name="valueFactory" />.</span></span></typeparam>
        <param name="key"><span data-ttu-id="68e58-306">Clé de l'élément à ajouter.</span><span class="sxs-lookup"><span data-stu-id="68e58-306">The key of the element to add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="68e58-307">Fonction utilisée pour générer une valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-307">The function used to generate a value for the key.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="68e58-308">Valeur d’argument à passer dans <paramref name="valueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-308">An argument value to pass into <paramref name="valueFactory" />.</span></span></param>
        <summary><span data-ttu-id="68e58-309">Ajoute une paire clé/valeur au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> en utilisant la fonction spécifiée et un argument si la clé n’existe pas déjà, ou retourne la valeur existante si la clé existe.</span><span class="sxs-lookup"><span data-stu-id="68e58-309">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function and an argument if the key does not already exist, or returns the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="68e58-310">Valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-310">The value for the key.</span></span> <span data-ttu-id="68e58-311">Il s'agit de la valeur existante pour la clé si la clé est déjà dans le dictionnaire, ou de la nouvelle valeur si la clé n'était pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-311">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 <span data-ttu-id="68e58-312">Pour les modifications et les opérations d’écriture dans le dictionnaire, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="68e58-312">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="68e58-313">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, le `valueFactory` délégué est appelé en dehors des verrous pour éviter les problèmes qui peuvent survenir lors de l’exécution de code inconnu sous un verrou.</span><span class="sxs-lookup"><span data-stu-id="68e58-313">(Read operations on the dictionary are performed in a lock-free manner.) However, the `valueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="68e58-314">Par conséquent, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> n’est pas atomique en ce qui concerne toutes les autres opérations sur le <xref:System.Collections.Concurrent.ConcurrentDictionary%602> classe.</span><span class="sxs-lookup"><span data-stu-id="68e58-314">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  

 <span data-ttu-id="68e58-315">Dans la mesure où une clé/valeur peuvent être insérée par un autre thread pendant `valueFactory` est générant une valeur, vous ne pouvez pas font confiance à ce parce que `valueFactory` exécutée, sa valeur produit sera inséré dans le dictionnaire et retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-315">Since a key/value can be inserted by another thread while `valueFactory` is generating a value, you cannot trust that just because `valueFactory` executed, its produced value will be inserted into the dictionary and returned.</span></span> <span data-ttu-id="68e58-316">Si vous appelez <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultanément sur différents threads, `valueFactory` peut être appelée plusieurs fois, mais la paire clé/valeur qu’un seul sera ajoutée au dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-316">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneously on different threads, `valueFactory` may be called multiple times, but only one key/value pair will be added to the dictionary.</span></span> 
 
 <span data-ttu-id="68e58-317">La valeur de retour dépend de la présence de la clé dans le dictionnaire et indique si une clé/valeur est insérée par un autre thread après <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> est appelée, mais avant `valueFactory` génère une valeur :</span><span class="sxs-lookup"><span data-stu-id="68e58-317">The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is called but before `valueFactory` generates a value:</span></span>

 | <span data-ttu-id="68e58-318">Scénario</span><span class="sxs-lookup"><span data-stu-id="68e58-318">Scenario</span></span> | <span data-ttu-id="68e58-319">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="68e58-319">Return value</span></span> |
 | -------- | ------------ |
 | <span data-ttu-id="68e58-320">La clé est déjà dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-320">The key is already in the dictionary.</span></span> | <span data-ttu-id="68e58-321">La valeur existante est retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-321">The existing value is returned.</span></span> |
 | <span data-ttu-id="68e58-322">La clé n’est pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-322">The key is not in the dictionary.</span></span> <span data-ttu-id="68e58-323">`valueFactory` génère une valeur.</span><span class="sxs-lookup"><span data-stu-id="68e58-323">`valueFactory` generates a value.</span></span> <span data-ttu-id="68e58-324">Sur la nouvelle vérification de la clé, aucune clé est trouvée.</span><span class="sxs-lookup"><span data-stu-id="68e58-324">On rechecking for the key, no key is found.</span></span> | <span data-ttu-id="68e58-325">La clé/valeur est insérée dans le dictionnaire, et la valeur est retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-325">The key/value is inserted into the dictionary, and the value is returned.</span></span> |
 | <span data-ttu-id="68e58-326">La clé n’est pas dans le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-326">The key is not in the dictionary.</span></span> <span data-ttu-id="68e58-327">`valueFactory` génère une valeur.</span><span class="sxs-lookup"><span data-stu-id="68e58-327">`valueFactory` generates a value.</span></span> <span data-ttu-id="68e58-328">Bien que `valueFactory` est à la génération de la valeur, un thread différent insère une valeur pour la clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-328">While `valueFactory` is generating the value, a different thread inserts a value for the key.</span></span> <span data-ttu-id="68e58-329">Après avoir `valueFactory` s’exécute et lors de la nouvelle vérification de la clé, la clé insérée par l’autre thread est trouvée.</span><span class="sxs-lookup"><span data-stu-id="68e58-329">After `valueFactory` executes and upon rechecking for the key, the key inserted by the other thread is found.</span></span> | <span data-ttu-id="68e58-330">La valeur insérée par l’autre thread est retournée.</span><span class="sxs-lookup"><span data-stu-id="68e58-330">The value inserted by the other thread is returned.</span></span> |
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-331">Obtient une valeur qui indique si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="68e58-331">Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty.</span></span></summary>
        <value><span data-ttu-id="68e58-332"><see langword="true" /> si le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> est vide ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-332"><see langword="true" /> if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-333">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-333">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-334">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-334">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-335">Clé de la valeur à obtenir ou à définir.</span><span class="sxs-lookup"><span data-stu-id="68e58-335">The key of the value to get or set.</span></span></param>
        <summary><span data-ttu-id="68e58-336">Obtient ou définit la valeur associée à la clé spécifiée.</span><span class="sxs-lookup"><span data-stu-id="68e58-336">Gets or sets the value associated with the specified key.</span></span></summary>
        <value><span data-ttu-id="68e58-337">Valeur de la paire clé/valeur à l'index spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-337">The value of the key/value pair at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-338"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-338"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException"><span data-ttu-id="68e58-339">La propriété est récupérée et <paramref name="key" /> n’existe pas dans la collection.</span><span class="sxs-lookup"><span data-stu-id="68e58-339">The property is retrieved and <paramref name="key" /> does not exist in the collection.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-340">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-340">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-341">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-341">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TKey&gt; ^ Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;'Key&gt;" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-342">Obtient une collection contenant les clés dans <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-342">Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="68e58-343">Collection des clés dans <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-343">A collection of keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-344">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-344">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-345">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-345">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-346">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-346">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-347">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-347">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-348">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-348">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-349">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-349">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-350">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-350">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-351">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-351">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-352">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-352">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-353">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-353">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-354">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-354">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-355">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-355">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;TKey,TValue&gt;.Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As TKey, value As TValue) Implements IDictionary(Of TKey, TValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(TKey key, TValue value) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-356">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-356">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-357">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-357">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;TKey,TValue&gt;.Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As TKey) As Boolean Implements IDictionary(Of TKey, TValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(TKey key) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-358">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-358">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-359">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-359">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-360">Obtient une collection contenant les clés dans <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-360">Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="68e58-361">Collection contenant les clés dans <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-361">A collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-362">Obtient une collection qui contient les valeurs de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-362">Gets a collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="68e58-363">Collection qui contient les valeurs de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-363">A collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="68e58-364">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir du <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-364">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="68e58-365">Ce tableau doit avoir une indexation de base zéro.</span><span class="sxs-lookup"><span data-stu-id="68e58-365">The array must have zero-based indexing.</span></span></param>
        <param name="index"><span data-ttu-id="68e58-366">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</span><span class="sxs-lookup"><span data-stu-id="68e58-366">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="68e58-367">Copie les éléments de <see cref="T:System.Collections.ICollection" /> dans un tableau, en commençant au niveau d'un index de tableau spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-367">Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an array, starting at the specified array index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-368"><paramref name="array" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-368"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="68e58-369"><paramref name="index" /> est inférieur à 0.</span><span class="sxs-lookup"><span data-stu-id="68e58-369"><paramref name="index" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="68e58-370"><paramref name="index" /> est supérieur ou égal à la longueur de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-370"><paramref name="index" /> is equal to or greater than the length of the <paramref name="array" />.</span></span>  
  
<span data-ttu-id="68e58-371">ou</span><span class="sxs-lookup"><span data-stu-id="68e58-371">-or-</span></span> 
<span data-ttu-id="68e58-372">Le nombre d’éléments dans le <see cref="T:System.Collections.ICollection" /> source est supérieur à la quantité d’espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</span><span class="sxs-lookup"><span data-stu-id="68e58-372">The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-373">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-373">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-374">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-374">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-375">Obtient une valeur indiquant si l’accès à <see cref="T:System.Collections.ICollection" /> est synchronisé avec SyncRoot.</span><span class="sxs-lookup"><span data-stu-id="68e58-375">Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized with the SyncRoot.</span></span></summary>
        <value><span data-ttu-id="68e58-376"><see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-376"><see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="68e58-377">Pour <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> cette propriété retourne toujours <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-377">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-378">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-378">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-379">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-379">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-380">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-380">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="68e58-381">Cette propriété n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="68e58-381">This property is not supported.</span></span></summary>
        <value><span data-ttu-id="68e58-382">Retourne systématiquement une valeur Null.</span><span class="sxs-lookup"><span data-stu-id="68e58-382">Always returns null.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="68e58-383">Cette propriété n'est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="68e58-383">This property is not supported.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-384">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-384">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-385">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-385">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-386">Objet à utiliser comme clé.</span><span class="sxs-lookup"><span data-stu-id="68e58-386">The object to use as the key.</span></span></param>
        <param name="value"><span data-ttu-id="68e58-387">Objet à utiliser comme valeur.</span><span class="sxs-lookup"><span data-stu-id="68e58-387">The object to use as the value.</span></span></param>
        <summary><span data-ttu-id="68e58-388">Ajoute la clé et la valeur spécifiées au dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-388">Adds the specified key and value to the dictionary.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-389"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-389"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="68e58-390"><paramref name="key" /> est d’un type qui ne peut pas être assigné au type de clé de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-390"><paramref name="key" /> is of a type that is not assignable to the key type  of the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span>  
  
<span data-ttu-id="68e58-391">ou</span><span class="sxs-lookup"><span data-stu-id="68e58-391">-or-</span></span> 
 <span data-ttu-id="68e58-392"><paramref name="value" /> a un type qui ne peut pas être assigné au type des valeurs dans <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-392"><paramref name="value" /> is of a type that is not assignable to the type of values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span>  
  
<span data-ttu-id="68e58-393">ou</span><span class="sxs-lookup"><span data-stu-id="68e58-393">-or-</span></span> 
<span data-ttu-id="68e58-394">Une valeur ayant la même clé existe déjà dans <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-394">A value with the same key already exists in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-395">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-395">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-396">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-396">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-397">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-397">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-398">Clé à rechercher dans <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-398">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="68e58-399">Obtient si <see cref="T:System.Collections.Generic.IDictionary`2" /> contient un élément avec la clé spécifiée.</span><span class="sxs-lookup"><span data-stu-id="68e58-399">Gets whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key.</span></span></summary>
        <returns><span data-ttu-id="68e58-400"><see langword="true" /> si <see cref="T:System.Collections.Generic.IDictionary`2" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-400"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-401"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-401"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-402">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-402">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-403">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-403">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e58-404">Fournit un <see cref="T:System.Collections.IDictionaryEnumerator" /> pour l'objet <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-404">Provides a <see cref="T:System.Collections.IDictionaryEnumerator" /> for the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-405"><see cref="T:System.Collections.IDictionaryEnumerator" /> pour l'objet <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-405">A <see cref="T:System.Collections.IDictionaryEnumerator" /> for the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-406">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-406">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-407">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-407">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-408">Obtient une valeur indiquant si <see cref="T:System.Collections.Generic.IDictionary`2" /> est de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="68e58-408">Gets a value indicating whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="68e58-409"><see langword="true" /> si <see cref="T:System.Collections.Generic.IDictionary`2" /> est de taille fixe ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-409"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> has a fixed size; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="68e58-410">Pour <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, cette propriété retourne toujours <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-410">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-411">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-411">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-412">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-412">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-413">Obtient une valeur indiquant si <see cref="T:System.Collections.Generic.IDictionary`2" /> est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="68e58-413">Gets a value indicating whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="68e58-414"><see langword="true" /> si <see cref="T:System.Collections.Generic.IDictionary`2" /> est en lecture seule ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-414"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="68e58-415">Pour <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, cette propriété retourne toujours <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-415">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-416">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-416">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-417">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-417">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-418">Clé de la valeur à obtenir ou à définir.</span><span class="sxs-lookup"><span data-stu-id="68e58-418">The key of the value to get or set.</span></span></param>
        <summary><span data-ttu-id="68e58-419">Obtient ou définit la valeur associée à la clé spécifiée.</span><span class="sxs-lookup"><span data-stu-id="68e58-419">Gets or sets the value associated with the specified key.</span></span></summary>
        <value><span data-ttu-id="68e58-420">Valeur associée à la clé spécifiée, ou <see langword="null" /> si <paramref name="key" /> ne figure pas dans le dictionnaire ou si le type de <paramref name="key" /> ne peut pas être assigné au type de clé de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-420">The value associated with the specified key, or  <see langword="null" /> if <paramref name="key" /> is not in the dictionary or <paramref name="key" /> is of a type that is not assignable to the key type of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-421"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-421"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="68e58-422">Une valeur est attribuée et le type de <paramref name="key" /> ne peut pas être attribué au type de clé ou de valeur de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-422">A value is being assigned, and <paramref name="key" /> is of a type that is not assignable to the key type or the value type of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-423">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-423">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-424">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-424">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-425">Obtient un objet <see cref="T:System.Collections.ICollection" /> qui contient les clés de l'objet <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-425">Gets an <see cref="T:System.Collections.ICollection" /> that contains the keys of the  <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="68e58-426">Interface qui contient les clés de <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-426">An interface that contains the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-427">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-427">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-428">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-428">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-429">Clé de l'élément à supprimer.</span><span class="sxs-lookup"><span data-stu-id="68e58-429">The key of the element to remove.</span></span></param>
        <summary><span data-ttu-id="68e58-430">Supprime de <see cref="T:System.Collections.IDictionary" /> l'élément ayant la clé spécifiée.</span><span class="sxs-lookup"><span data-stu-id="68e58-430">Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-431"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-431"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-432">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-432">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-433">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-433">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-434">Obtient un objet <see cref="T:System.Collections.ICollection" /> qui contient les valeurs de l'objet <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-434">Gets an <see cref="T:System.Collections.ICollection" /> that contains the values in the <see cref="T:System.Collections.IDictionary" />.</span></span></summary>
        <value><span data-ttu-id="68e58-435">Interface qui contient les valeurs de <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-435">An interface that contains the values in the <see cref="T:System.Collections.IDictionary" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-436">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-436">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-437">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-437">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e58-438">Retourne un énumérateur qui itère au sein de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-438">Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-439">Énumérateur pour <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-439">An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-440">L’énumérateur retourné à partir du dictionnaire est sûr à utiliser en même temps que les lectures et écritures dans le dictionnaire, mais il ne représente pas un instantané du moment-à-temps du dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="68e58-440">The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</span></span> <span data-ttu-id="68e58-441">Le contenu exposé via l’énumérateur peut contenir des modifications apportées au dictionnaire après <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> a été appelée.</span><span class="sxs-lookup"><span data-stu-id="68e58-441">The contents exposed through the enumerator may contain modifications made to the dictionary after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> was called.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-442">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-442">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-443">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-443">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As KeyValuePair(Of TKey, TValue)()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[]" Usage="concurrentDictionary.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="68e58-444">Copie les paires clé/valeur stockées dans le <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> dans un nouveau tableau.</span><span class="sxs-lookup"><span data-stu-id="68e58-444">Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> to a new array.</span></span></summary>
        <returns><span data-ttu-id="68e58-445">Nouveau tableau qui contient un instantané des paires clé/valeur copiées à partir de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-445">A new array containing a snapshot of key and value pairs copied from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-446">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-446">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-447">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-447">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'Key * 'Value -&gt; bool" Usage="concurrentDictionary.TryAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-448">Clé de l'élément à ajouter.</span><span class="sxs-lookup"><span data-stu-id="68e58-448">The key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="68e58-449">Valeur de l'élément à ajouter.</span><span class="sxs-lookup"><span data-stu-id="68e58-449">The value of the element to add.</span></span> <span data-ttu-id="68e58-450">La valeur peut être <see langword="null" /> pour les types référence.</span><span class="sxs-lookup"><span data-stu-id="68e58-450">The value can be  <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="68e58-451">Tente d'ajouter la clé et la valeur spécifiées à <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-451">Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-452"><see langword="true" /> si la paire clé/valeur a été ajoutée correctement au <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />. <see langword="false" /> si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-452"><see langword="true" /> if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> successfully; <see langword="false" /> if the key already exists.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68e58-453">Cette méthode retourne `false` si la clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-453">This method returns `false` if the key already exists.</span></span> <span data-ttu-id="68e58-454">Utilisez le <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> ou <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> méthode pour mettre à jour la valeur au cas où une clé existe déjà.</span><span class="sxs-lookup"><span data-stu-id="68e58-454">Use the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> or <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> method to update the value in case a key already exists.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68e58-455">L’exemple suivant montre comment appeler le <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType> méthode :</span><span class="sxs-lookup"><span data-stu-id="68e58-455">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-456"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-456"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="68e58-457">Le dictionnaire contient déjà le nombre maximal d'éléments (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="68e58-457">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-458">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-458">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-459">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-459">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="concurrentDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-460">Clé de la valeur à obtenir.</span><span class="sxs-lookup"><span data-stu-id="68e58-460">The key of the value to get.</span></span></param>
        <param name="value"><span data-ttu-id="68e58-461">Lorsque cette méthode est retournée, contient l'objet du <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> qui contient la clé spécifiée ou la valeur par défaut du type, si l'opération a échoué.</span><span class="sxs-lookup"><span data-stu-id="68e58-461">When this method returns, contains the object from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> that has the specified key, or the default value of the type if the operation failed.</span></span></param>
        <summary><span data-ttu-id="68e58-462">Tente d'obtenir la valeur associée à la clé spécifiée à partir de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-462">Attempts to get the value associated with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-463"><see langword="true" /> si la clé a été trouvée dans <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-463"><see langword="true" /> if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-464"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-464"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-465">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-465">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-466">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-466">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryRemove">
      <MemberSignature Language="C#" Value="public bool TryRemove (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryRemove(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryRemove (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryRemove(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryRemove : 'Key *  -&gt; bool" Usage="concurrentDictionary.TryRemove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-467">Clé de l'élément à supprimer et à retourner.</span><span class="sxs-lookup"><span data-stu-id="68e58-467">The key of the element to remove and return.</span></span></param>
        <param name="value"><span data-ttu-id="68e58-468">Lorsque cette méthode retourne une valeur, contient l'objet supprimé du <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, ou la valeur par défaut du type <see langword="TValue" /> si <paramref name="key" /> n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="68e58-468">When this method returns, contains the object removed from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, or the default value of  the <see langword="TValue" /> type if <paramref name="key" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="68e58-469">Tente de supprimer et de retourner la valeur ayant la clé spécifiée du <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-469">Attempts to remove and return the value that has the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-470"><see langword="true" /> si l'objet a été correctement supprimé ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-470"><see langword="true" /> if the object was removed successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e58-471">L’exemple suivant montre comment appeler le <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType> méthode :</span><span class="sxs-lookup"><span data-stu-id="68e58-471">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-472"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-472"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-473">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-473">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-474">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-474">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryUpdate">
      <MemberSignature Language="C#" Value="public bool TryUpdate (TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUpdate(!TKey key, !TValue newValue, !TValue comparisonValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUpdate (key As TKey, newValue As TValue, comparisonValue As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="F#" Value="member this.TryUpdate : 'Key * 'Value * 'Value -&gt; bool" Usage="concurrentDictionary.TryUpdate (key, newValue, comparisonValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="newValue" Type="TValue" />
        <Parameter Name="comparisonValue" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="68e58-475">Clé dont la valeur est comparée à <paramref name="comparisonValue" /> et qui peut être remplacée.</span><span class="sxs-lookup"><span data-stu-id="68e58-475">The key of the value that is compared with <paramref name="comparisonValue" /> and possibly replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="68e58-476">Valeur qui remplace la valeur de l'élément comportant la <paramref name="key" /> spécifiée si la comparaison conclut à une égalité.</span><span class="sxs-lookup"><span data-stu-id="68e58-476">The value that replaces the value of the element that has the specified <paramref name="key" /> if the comparison results in equality.</span></span></param>
        <param name="comparisonValue"><span data-ttu-id="68e58-477">Valeur comparée à la valeur de l’élément comportant le <paramref name="key" /> spécifié.</span><span class="sxs-lookup"><span data-stu-id="68e58-477">The value that is compared with the value of the element that has the specified <paramref name="key" />.</span></span></param>
        <summary><span data-ttu-id="68e58-478">Remplace la valeur associée à <paramref name="key" /> par <paramref name="newValue" /> si la valeur existante de <paramref name="key" /> est égale à <paramref name="comparisonValue" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-478">Updates the value associated with <paramref name="key" /> to <paramref name="newValue" /> if the existing value with <paramref name="key" /> is equal to <paramref name="comparisonValue" />.</span></span></summary>
        <returns><span data-ttu-id="68e58-479"><see langword="true" /> si la valeur avec <paramref name="key" /> était égale à <paramref name="comparisonValue" /> et a été remplacée par <paramref name="newValue" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-479"><see langword="true" /> if the value with <paramref name="key" /> was equal to <paramref name="comparisonValue" /> and was replaced with <paramref name="newValue" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="68e58-480">L’exemple suivant montre comment appeler le <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> méthode :</span><span class="sxs-lookup"><span data-stu-id="68e58-480">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="68e58-481"><paramref name="key" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-481"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-482">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-482">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-483">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-483">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TValue&gt; ^ Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'Value&gt;" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="68e58-484">Obtient une collection qui contient les valeurs de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-484">Gets a collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="68e58-485">Collection qui contient les valeurs de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="68e58-485">A collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="68e58-486">Collections thread-safe</span><span class="sxs-lookup"><span data-stu-id="68e58-486">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="68e58-487">Comment : ajouter et supprimer des éléments d'un ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="68e58-487">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>