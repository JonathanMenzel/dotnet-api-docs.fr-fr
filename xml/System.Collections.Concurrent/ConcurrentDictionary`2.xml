<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ConcurrentDictionary`2.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9575d09f-9d72-4690-889e-b83c405ca456d861bfd0775407d8c4fc1e0c80379639ee948c0c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d861bfd0775407d8c4fc1e0c80379639ee948c0c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">254e16ae65e82f4aa59360cd8572b36b6b5b2f80</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/05/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The type of the keys in the dictionary.</source>
          <target state="translated">Type des clés dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The type of the values in the dictionary.</source>
          <target state="translated">Type des valeurs dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Represents a thread-safe collection of key/value pairs that can be accessed by multiple threads concurrently.</source>
          <target state="translated">Représente une collection thread-safe de paires clé/valeur accessibles par plusieurs threads simultanément.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> objects, you can increase the maximum array size to 2 gigabytes (GB) on a 64-bit system by setting the  configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">Pour les très grandes <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> des objets, vous pouvez augmenter la taille de tableau maximale à 2 gigaoctets (Go) sur un système 64 bits en affectant à l’élément de configuration <ph id="ph2">`true`</ph> dans l’environnement d’exécution.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.IReadOnlyDictionary%602&gt;</ph> interfaces starting with the <ph id="ph4">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>; in previous versions of the .NET Framework, the <ph id="ph5">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> class did not implement these interfaces.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> implémente le <ph id="ph2">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601&gt;</ph> et <ph id="ph3">&lt;xref:System.Collections.Generic.IReadOnlyDictionary%602&gt;</ph> interfaces en commençant par le <ph id="ph4">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>; dans les versions précédentes du .NET Framework, le <ph id="ph5">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> n’implémente pas ces interfaces.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Like the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType&gt;</ph> class, <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> implements the <ph id="ph3">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> interface.</source>
          <target state="translated">Comme le <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType&gt;</ph> (classe), <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> implémente la <ph id="ph3">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>In addition, <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> provides several methods for adding or updating key/value pairs in the dictionary, as described in the following table.</source>
          <target state="translated">En outre, <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> fournit plusieurs méthodes pour l’ajout ou la mise à jour de paires clé/valeur dans le dictionnaire, comme décrit dans le tableau suivant.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>To do this</source>
          <target state="translated">Pour</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Use this method</source>
          <target state="translated">Utilisez cette méthode</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Usage notes</source>
          <target state="translated">Notes d’utilisation</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Add a new key to the dictionary, if it doesn’t already exist in the dictionary</source>
          <target state="translated">Ajoutez une nouvelle clé dans le dictionnaire, s’il n’existe pas dans le dictionnaire</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>This method adds the specified key/value pair, if the key doesn’t currently exist in the dictionary.</source>
          <target state="translated">Cette méthode ajoute la paire clé/valeur spécifiée, si la clé n’existe pas actuellement dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The method returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph> depending on whether the new pair was added.</source>
          <target state="translated">La méthode retourne <ph id="ph1">`true`</ph> ou <ph id="ph2">`false`</ph> selon que la nouvelle paire a été ajoutée.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Update the value for an existing key in the dictionary, if that key has a specific value</source>
          <target state="translated">Mettre à jour la valeur pour une clé existante dans le dictionnaire, si cette clé a une valeur spécifique</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>This method checks whether the key has a specified value, and if it does, updates the key with a new value.</source>
          <target state="translated">Cette méthode vérifie si la clé a une valeur spécifiée, et si elle est le cas, met à jour la clé avec une nouvelle valeur.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>It's similar to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method, except that it's used for dictionary elements.</source>
          <target state="translated">Il est similaire à la <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> (méthode), à ceci près qu’elle l’utilisée pour les éléments du dictionnaire.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Store a key/value pair in the dictionary unconditionally, and overwrite the value of a key that already exists</source>
          <target state="translated">Stocker une paire clé/valeur dans le dictionnaire de manière inconditionnelle et remplacer la valeur d’une clé qui existe déjà</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The indexer’s setter: <ph id="ph1">`dictionary[key] = newValue`</ph></source>
          <target state="translated">Accesseur Set de l’indexeur de : <ph id="ph1">`dictionary[key] = newValue`</ph></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Add a key/value pair to the dictionary, or if the key already exists, update the value for the key based on the key’s existing value</source>
          <target state="translated">Ajouter une paire clé/valeur au dictionnaire, ou si la clé existe déjà, mettre à jour la valeur de la clé en fonction de la valeur de clé existant</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>—or—</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29&gt;</ph> accepts the key and two delegates.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29&gt;</ph> accepte la clé et deux délégués.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>It uses the first delegate if the key doesn’t exist in the dictionary; it accepts the key and returns the value that should be added for the key.</source>
          <target state="translated">Il utilise le premier délégué si la clé n’existe pas dans le dictionnaire ; Il accepte la clé et retourne la valeur doit être ajoutée pour la clé.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>It uses the second delegate if the key does exist; it accepts the key and its current value, and it returns the new value that should be set for the key.</source>
          <target state="translated">Il utilise le deuxième délégué si la clé n’existe pas ; elle accepte la clé et sa valeur actuelle et retourne la nouvelle valeur doit être définie pour la clé.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29&gt;</ph> accepts the key, a value to add, and the update delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29&gt;</ph> accepte le délégué de la mise à jour de la clé et une valeur à ajouter.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>This is the same as the previous overload, except that it doesn't use a delegate to add a key.</source>
          <target state="translated">Il est identique à la surcharge précédente, à ceci près qu’elle n’utilise un délégué pour ajouter une clé.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Get the value for a key in the dictionary, adding the value to the dictionary and returning it if the key doesn’t exist</source>
          <target state="translated">Obtenir la valeur de la clé dans le dictionnaire, l’ajout de la valeur au dictionnaire et à retourner si la clé n’existe pas</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>—or—</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>These overloads provide lazy initialization for a key/value pair in the dictionary, adding the value only if it’s not there.</source>
          <target state="translated">Ces surcharges fournissent l’initialisation tardive pour une paire clé/valeur dans le dictionnaire, en ajoutant la valeur uniquement si elle n’y ne figure pas.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29&gt;</ph> takes the value to be added if the key doesn’t exist.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29&gt;</ph> prend la valeur doit être ajouté si la clé n’existe pas.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29&gt;</ph> takes a delegate that will generate the value if the key doesn’t exist.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29&gt;</ph> prend un délégué qui génère la valeur si la clé n’existe pas.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>All these operations are atomic and are thread-safe with regards to all other operations on the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> class.</source>
          <target state="translated">Toutes ces opérations sont atomiques et sont thread-safe en ce qui concerne toutes les autres opérations sur le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The only exceptions are the methods that accept a delegate, that is, <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph>.</source>
          <target state="translated">Les seules exceptions sont les méthodes qui acceptent un délégué, c'est-à-dire <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>For modifications and write operations to the dictionary, <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> uses fine-grained locking to ensure thread safety.</source>
          <target state="translated">Pour les modifications et les opérations d’écriture dans le dictionnaire, <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> utilise le verrouillage de granularité fine pour garantir la sécurité des threads.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>(Read operations on the dictionary are performed in a lock-free manner.) However, delegates for these methods are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</source>
          <target state="translated">(Les opérations de lecture sur le dictionnaire sont effectuées de manière sans verrou). Toutefois, les délégués pour ces méthodes sont appelées en dehors des verrous pour éviter les problèmes qui peuvent survenir à partir de l’exécution de code inconnu d’un verrou.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Therefore, the code executed by these delegates is not subject to the atomicity of the operation.</source>
          <target state="translated">Par conséquent, le code exécuté par ces délégués n’est pas soumis à la cohérence de l’opération.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The following example shows how to construct a <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> object.</source>
          <target state="translated">L’exemple suivant montre comment construire un <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>All public and protected members of <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> are thread-safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Tous les membres publics et protégés de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> sont thread-safe et peuvent être utilisés simultanément à partir de plusieurs threads.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>However, members accessed through one of the interfaces the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> implements, including extension methods, are not guaranteed to be thread safe and may need to be synchronized by the caller.</source>
          <target state="translated">Toutefois, les membres accessibles via une des interfaces du <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> implémente, y compris les méthodes d’extension n’est pas garanti être thread-safe et peut doivent être synchronisés par l’appelant.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that is empty, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui est vide, possède le niveau de concurrence par défaut, possède la capacité initiale par défaut et utilise le comparateur par défaut pour le type de clé.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>The default concurrency level is the default concurrency multiplier (DEFAULT_CONCURRENCY_MULTIPLIER) times the number of CPUs.</source>
          <target state="translated">Le niveau de concurrence par défaut est le multiplicateur de concurrence par défaut (DEFAULT_CONCURRENCY_MULTIPLIER) par le nombre de processeurs.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>The higher the default concurrency multiplier is, the more concurrent write operations can take place without interference and blocking.</source>
          <target state="translated">Plus le multiplicateur de concurrence par défaut, les opérations d’écriture simultanées plus peuvent avoir lieu sans interférence et de blocage.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>Higher multiplier values also cause operations that require all locks (for example, table resizing, <ph id="ph1">`ToArray`</ph> and <ph id="ph2">`Count`</ph>) to become more expensive.</source>
          <target state="translated">Les valeurs élevées multiplicateur également provoquent les opérations qui nécessitent tous les verrous (table, par exemple, le redimensionnement, <ph id="ph1">`ToArray`</ph> et <ph id="ph2">`Count`</ph>) pour atteindre un coût.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>The default concurrency multiplier is 4.</source>
          <target state="translated">Le multiplicateur de concurrence par défaut est 4.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>The default capacity (DEFAULT_CAPACITY), which represents the initial number of buckets, is a trade-off between the size of a very small dictionary and the number of resizes when constructing a large dictionary.</source>
          <target state="translated">La capacité par défaut (DEFAULT_CAPACITY), qui représente le nombre de compartiments initial, est un compromis entre la taille d’un dictionnaire de très faible et le nombre de redimensionne lors de la construction d’un dictionnaire de grande taille.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>Also, the capacity should not be divisible by a small prime number.</source>
          <target state="translated">En outre, la capacité ne doit pas être divisible par un petit nombre de premiers.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
          <source>The default capacity is 31.</source>
          <target state="translated">La capacité par défaut est 31.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> whose elements are copied to the new <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> dont les éléments sont copiés dans le nouveau <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that contains elements copied from the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui contient des éléments copiés depuis le <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> spécifié, possède le niveau de concurrence par défaut, possède la capacité initiale par défaut et utilise le comparateur par défaut pour le type de clé.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or any of its keys is  <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> ou toutes ses clés est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contains one or more duplicate keys.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contient une ou plusieurs clés en double.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>The equality comparison implementation to use when comparing keys.</source>
          <target state="translated">Implémentation de comparaison d'égalité à utiliser lors de la comparaison de clés.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that is empty, has the default concurrency level and capacity, and uses the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui est vide, possède le niveau de concurrence et la capacité par défaut, et utilise le <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> whose elements are copied to the new <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> dont les éléments sont copiés dans le nouveau <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing keys.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> à utiliser lors de la comparaison de clés.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that contains elements copied from the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEnumerable" /&gt;</ph> has the default concurrency level, has the default initial capacity, and uses the specified  <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui contient des éléments copiés à partir du <ph id="ph2">&lt;see cref="T:System.Collections.IEnumerable" /&gt;</ph> spécifié, possède le niveau de concurrence par défaut, possède la capacité initiale par défaut et utilise le <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
          <source>The estimated number of threads that will update the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> concurrently.</source>
          <target state="translated">Nombre estimé des threads qui mettront à jour le <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> simultanément.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
          <source>The initial number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> can contain.</source>
          <target state="translated">Nombre initial d'éléments que <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that is empty, has the specified concurrency level and capacity, and uses the default comparer for the key type.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui est vide, possède le niveau de concurrence et la capacité spécifiés, et utilise le comparateur par défaut pour le type de clé.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="concurrencyLevel" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="concurrencyLevel" /&gt;</ph> est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The estimated number of threads that will update the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> concurrently.</source>
          <target state="translated">Nombre estimé des threads qui mettront à jour le <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> simultanément.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> whose elements are copied to the new <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> dont les éléments sont copiés dans le nouveau <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing keys.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> à utiliser lors de la comparaison de clés.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that contains elements copied from the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEnumerable" /&gt;</ph>, and uses the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui contient des éléments copiés du <ph id="ph2">&lt;see cref="T:System.Collections.IEnumerable" /&gt;</ph> spécifié et utilise le <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> or <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="comparer" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="concurrencyLevel" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="concurrencyLevel" /&gt;</ph> est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contains one or more duplicate keys.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> contient une ou plusieurs clés en double.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>The estimated number of threads that will update the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> concurrently.</source>
          <target state="translated">Nombre estimé des threads qui mettront à jour le <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> simultanément.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>The initial number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> can contain.</source>
          <target state="translated">Nombre initial d'éléments que <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing keys.</source>
          <target state="translated">Implémentation de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> à utiliser lors de la comparaison de clés.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> class that is empty, has the specified concurrency level, has the specified initial capacity, and uses the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui est vide, possède le niveau de concurrence spécifiés, possède la capacité initiale spécifiée et utilise le <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="concurrencyLevel" /&gt;</ph> or <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="concurrencyLevel" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> est inférieur à 1.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Adds a key/value pair to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key does not already exist, or updates a key/value pair in the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key already exists.</source>
          <target state="translated">Ajoute une paire clé/valeur au <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> si la clé n'existe pas déjà, ou met à jour une paire clé/valeur dans le <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> si la clé existe déjà.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The following example shows how to call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> method:</source>
          <target state="translated">L’exemple suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> méthode :</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>The key to be added or whose value should be updated</source>
          <target state="translated">Clé à ajouter ou dont la valeur doit être mise à jour.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>The function used to generate a value for an absent key</source>
          <target state="translated">Fonction utilisée pour générer une valeur pour une clé absente</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>The function used to generate a new value for an existing key based on the key's existing value</source>
          <target state="translated">Fonction utilisée pour générer une nouvelle valeur pour une clé existante en fonction de la valeur existante de la clé.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>Uses the specified functions to add a key/value pair to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key does not already exist, or to update a key/value pair in the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key already exists.</source>
          <target state="translated">Utilise les fonctions spécifiées pour ajouter une paire clé/valeur au <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> si la clé n'existe pas déjà, ou pour mettre à jour une paire clé/valeur dans le <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> en utilisant la fonction spécifiée si la clé existe déjà.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>The new value for the key.</source>
          <target state="translated">Nouvelle valeur pour la clé.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>This will be either be the result of addValueFactory (if the key was absent) or the result of updateValueFactory (if the key was present).</source>
          <target state="translated">Il s'agit du résultat d'addValueFactory (si la clé était absente) ou du résultat d'updateValueFactory (si la clé était présente).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>If you call <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> simultaneously on different threads, <ph id="ph2">`addValueFactory`</ph> may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</source>
          <target state="translated">Si vous appelez <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> simultanément sur différents threads, <ph id="ph2">`addValueFactory`</ph> peut être appelée plusieurs fois, mais sa paire clé/valeur ne peut pas être ajouté au dictionnaire pour chaque appel.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph>, <ph id="ph2">&lt;paramref name="addValueFactory" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="updateValueFactory" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph>, <ph id="ph2">&lt;paramref name="addValueFactory" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="updateValueFactory" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>The key to be added or whose value should be updated</source>
          <target state="translated">Clé à ajouter ou dont la valeur doit être mise à jour.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>The value to be added for an absent key</source>
          <target state="translated">Valeur à ajouter pour une clé absente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>The function used to generate a new value for an existing key based on the key's existing value</source>
          <target state="translated">Fonction utilisée pour générer une nouvelle valeur pour une clé existante en fonction de la valeur existante de la clé.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>Adds a key/value pair to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key does not already exist, or updates a key/value pair in the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> by using the specified function if the key already exists.</source>
          <target state="translated">Ajoute une paire clé/valeur au <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> si la clé n'existe pas déjà, ou met à jour une paire clé/valeur dans le <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> en utilisant la fonction spécifiée si la clé existe déjà.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>The new value for the key.</source>
          <target state="translated">Nouvelle valeur pour la clé.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>This will be either be addValue (if the key was absent) or the result of updateValueFactory (if the key was present).</source>
          <target state="translated">Il s'agit soit d'addValue (si la clé était absente), soit du résultat d'updateValueFactory (si la clé était présente).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>The following code example shows how to initialize an <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> and how to use the AddOrUpdate method to add an additional item to the collection, and update the existing items.</source>
          <target state="translated">L’exemple de code suivant montre comment initialiser un <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602&gt;</ph> et comment utiliser la méthode AddOrUpdate pour ajouter un élément supplémentaire à la collection et mettre à jour les éléments existants.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> or <ph id="ph2">&lt;paramref name="updateValueFactory" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="updateValueFactory" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
          <source>Removes all keys and values from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Supprime toutes les clés et les valeurs de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Clé à rechercher dans <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> contains the specified key.</source>
          <target state="translated">Détermine si <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> contient la clé spécifiée.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> contient un élément correspondant à la clé spécifiée ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
          <source>Gets the number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Obtient le nombre de paires clé/valeur contenues dans <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
          <source>The number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Nombre de paires clé/valeur contenues dans <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
          <source>This property has snapshot semantics and represents the number of items in the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType&gt;</ph> at the moment when the property was accessed.</source>
          <target state="translated">Cette propriété a la sémantique des instantanés et représente le nombre d’éléments dans le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType&gt;</ph> pour le moment, lorsque la propriété a été effectué.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Retourne un énumérateur qui itère au sein de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
          <source>An enumerator for the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Énumérateur pour <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
          <source>The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</source>
          <target state="translated">L’énumérateur retourné à partir du dictionnaire est plus sûr d’utiliser en même temps que les lectures et écritures dans le dictionnaire, mais il ne représente pas un instantané du moment-à-temps du dictionnaire.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
          <source>The contents exposed through the enumerator may contain modifications made to the dictionary after <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A&gt;</ph> was called.</source>
          <target state="translated">Le contenu exposé via l’énumérateur peut contenir des modifications apportées au dictionnaire après <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A&gt;</ph> a été appelée.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>Adds a key/value pair to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key does not already exist.</source>
          <target state="translated">Ajoute une paire clé/valeur au <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> si la clé n'existe pas encore.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Concurrent.ConcurrentDictionary`2">
          <source>The following example shows how to call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> method:</source>
          <target state="translated">L’exemple suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> méthode :</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The key of the element to add.</source>
          <target state="translated">Clé de l'élément à ajouter.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The function used to generate a value for the key.</source>
          <target state="translated">Fonction utilisée pour générer une valeur pour la clé.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>Adds a key/value pair to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> by using the specified function if the key does not already exist, or returns the existing value if the key exists.</source>
          <target state="translated">Ajoute une paire clé/valeur au <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> en utilisant la fonction spécifiée si la clé n’existe pas déjà, ou retourne la valeur existante si la clé existe.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The value for the key.</source>
          <target state="translated">Valeur pour la clé.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>Since a key/value can be inserted by another thread while <ph id="ph1">`valueFactory`</ph> is generating a value, you cannot trust that just because <ph id="ph2">`valueFactory`</ph> executed, its produced value will be inserted into the dictionary and returned.</source>
          <target state="translated">Dans la mesure où une clé/valeur qui peut être insérée par un autre thread pendant <ph id="ph1">`valueFactory`</ph> est génère une valeur, vous ne peut pas approuver qui fait <ph id="ph2">`valueFactory`</ph> exécutée, sa valeur produit sera inséré dans le dictionnaire et retournée.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>If you call <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> simultaneously on different threads, <ph id="ph2">`valueFactory`</ph> may be called multiple times, but only one key/value pair will be added to the dictionary.</source>
          <target state="translated">Si vous appelez <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> simultanément sur différents threads, <ph id="ph2">`valueFactory`</ph> peut être appelée plusieurs fois, mais la paire clé/valeur qu’un seul sera ajoutée au dictionnaire.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> is called but before <ph id="ph2">`valueFactory`</ph> generates a value:</source>
          <target state="translated">La valeur de retour dépend de la présence de la clé dans le dictionnaire et indique si une clé/valeur est insérée par un autre thread après <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A&gt;</ph> est appelée, mais avant <ph id="ph2">`valueFactory`</ph> génère une valeur :</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>Scenario</source>
          <target state="translated">Scénario</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>Return value</source>
          <target state="translated">Valeur de retour</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The key is already in the dictionary.</source>
          <target state="translated">La clé est déjà dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The existing value is returned.</source>
          <target state="translated">La valeur existante est retournée.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The key is not in the dictionary.</source>
          <target state="translated">La clé n’est pas dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source><ph id="ph1">`valueFactory`</ph> generates a value.</source>
          <target state="translated"><ph id="ph1">`valueFactory`</ph> génère une valeur.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>On rechecking for the key, no key is found.</source>
          <target state="translated">Sur la nouvelle vérification de la clé, aucune clé est trouvée.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The key/value is inserted into the dictionary, and the value is returned.</source>
          <target state="translated">La clé/valeur est insérée dans le dictionnaire, et la valeur est retournée.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The key is not in the dictionary.</source>
          <target state="translated">La clé n’est pas dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source><ph id="ph1">`valueFactory`</ph> generates a value.</source>
          <target state="translated"><ph id="ph1">`valueFactory`</ph> génère une valeur.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>While <ph id="ph1">`valueFactory`</ph> is generating the value, a different thread inserts a value for the key.</source>
          <target state="translated">Alors que <ph id="ph1">`valueFactory`</ph> est à la génération de la valeur, un autre thread insère une valeur pour la clé.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>After <ph id="ph1">`valueFactory`</ph> executes and upon rechecking for the key, the key inserted by the other thread is found.</source>
          <target state="translated">Après avoir <ph id="ph1">`valueFactory`</ph> s’exécute et fonction revérification pour la clé, la clé insérée par l’autre thread est trouvée.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The value inserted by the other thread is returned.</source>
          <target state="translated">La valeur insérée par l’autre thread est retournée.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> or <ph id="ph2">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="valueFactory" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source>The key of the element to add.</source>
          <target state="translated">Clé de l'élément à ajouter.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source>The value to be added, if the key does not already exist.</source>
          <target state="translated">Valeur à ajouter, si la clé n’existe pas encore.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source>Adds a key/value pair to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> if the key does not already exist.</source>
          <target state="translated">Ajoute une paire clé/valeur au <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> si la clé n'existe pas encore.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source>The value for the key.</source>
          <target state="translated">Valeur pour la clé.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source>This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</source>
          <target state="translated">Il s'agit de la valeur existante pour la clé si la clé est déjà dans le dictionnaire, ou de la nouvelle valeur si la clé n'était pas dans le dictionnaire.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> is empty.</source>
          <target state="translated">Obtient une valeur qui indique si <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> est vide.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> is empty; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> est vide ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
          <source>The key of the value to get or set.</source>
          <target state="translated">Clé de la valeur à obtenir ou à définir.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
          <source>Gets or sets the value associated with the specified key.</source>
          <target state="translated">Obtient ou définit la valeur associée à la clé spécifiée.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
          <source>The value of the key/value pair at the specified index.</source>
          <target state="translated">Valeur de la paire clé/valeur à l'index spécifié.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is  <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
          <source>The property is retrieved and <ph id="ph1">&lt;paramref name="key" /&gt;</ph> does not exist in the collection.</source>
          <target state="translated">La propriété est récupérée et <ph id="ph1">&lt;paramref name="key" /&gt;</ph> n'existe pas dans la collection.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
          <source>Gets a collection containing the keys in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated">Obtient une collection contenant les clés dans <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
          <source>A collection of keys in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated">Collection des clés dans <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir du <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">Ce tableau doit avoir une indexation de base zéro.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Index de base zéro dans un <bpt id="p1">&lt;c&gt;</bpt>tableau<ept id="p1">&lt;/c&gt;</ept> auquel commencer la copie.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> to an array, starting at the specified array index.</source>
          <target state="translated">Copie les éléments de <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> dans un tableau, en commençant au niveau d'un index de tableau spécifié.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à 0.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than the length of the <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal à la longueur de <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> source est supérieur à la quantité d’espace disponible entre <ph id="ph2">&lt;paramref name="index" /&gt;</ph> et la fin du <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized with the SyncRoot.</source>
          <target state="translated">Obtient une valeur indiquant si l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> est synchronisé avec SyncRoot.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'accès à <ph id="ph2">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> est synchronisé (thread-safe) ; sinon <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
          <source>For <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> this property always returns <bpt id="p1">**</bpt>false<ept id="p1">**</ept>.</source>
          <target state="translated">Pour <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> cette propriété retourne toujours <bpt id="p1">**</bpt>false<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
          <source>This property is not supported.</source>
          <target state="translated">Cette propriété n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
          <source>Always returns null.</source>
          <target state="translated">Retourne systématiquement une valeur Null.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
          <source>This property is not supported.</source>
          <target state="translated">Cette propriété n'est pas prise en charge.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>The object to use as the key.</source>
          <target state="translated">Objet à utiliser comme clé.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>The object to use as the value.</source>
          <target state="translated">Objet à utiliser comme valeur.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>Adds the specified key and value to the dictionary.</source>
          <target state="translated">Ajoute la clé et la valeur spécifiées au dictionnaire.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is of a type that is not assignable to the key type  of the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est d’un type qui ne peut pas être assigné au type de clé de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not assignable to the type of values in the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> a un type qui ne peut pas être assigné au type des valeurs dans <ph id="ph2">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>A value with the same key already exists in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated">Une valeur ayant la même clé existe déjà dans <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Clé à rechercher dans <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
          <source>Gets whether the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> contains an element with the specified key.</source>
          <target state="translated">Obtient si <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> contient un élément avec la clé spécifiée.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> contient un élément correspondant à la clé spécifiée ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
          <source>Provides a <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Fournit un <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> pour l'objet <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> pour l'objet <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> est de taille fixe ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
          <source>For <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>, this property always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Pour <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>, cette propriété retourne toujours <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph> est en lecture seule ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
          <source>For <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>, this property always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Pour <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>, cette propriété retourne toujours <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
          <source>The key of the value to get or set.</source>
          <target state="translated">Clé de la valeur à obtenir ou à définir.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
          <source>Gets or sets the value associated with the specified key.</source>
          <target state="translated">Obtient ou définit la valeur associée à la clé spécifiée.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
          <source>The value associated with the specified key, or  <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> is not in the dictionary or <ph id="ph3">&lt;paramref name="key" /&gt;</ph> is of a type that is not assignable to the key type of the <ph id="ph4">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Valeur associée à la clé spécifiée, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="key" /&gt;</ph> ne figure pas dans le dictionnaire ou si le type de <ph id="ph3">&lt;paramref name="key" /&gt;</ph> ne peut pas être assigné au type de clé de <ph id="ph4">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is  <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
          <source>A value is being assigned, and <ph id="ph1">&lt;paramref name="key" /&gt;</ph> is of a type that is not assignable to the key type or the value type of the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Une valeur est assignée et <ph id="ph1">&lt;paramref name="key" /&gt;</ph> a un type qui ne peut pas être assigné au type de clé ou au type valeur de <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> that contains the keys of the  <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Obtient un objet <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> qui contient les clés de l'objet <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
          <source>An interface that contains the keys of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Interface qui contient les clés de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
          <source>The key of the element to remove.</source>
          <target state="translated">Clé de l'élément à supprimer.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
          <source>Removes the element with the specified key from the <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>.</source>
          <target state="translated">Supprime de <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> l'élément ayant la clé spécifiée.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> that contains the values in the <ph id="ph2">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>.</source>
          <target state="translated">Obtient un objet <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> qui contient les valeurs de l'objet <ph id="ph2">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
          <source>An interface that contains the values in the <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>.</source>
          <target state="translated">Interface qui contient les valeurs de <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Retourne un énumérateur qui itère au sein de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator for the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Énumérateur pour <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</source>
          <target state="translated">L’énumérateur retourné à partir du dictionnaire est plus sûr d’utiliser en même temps que les lectures et écritures dans le dictionnaire, mais il ne représente pas un instantané du moment-à-temps du dictionnaire.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
          <source>The contents exposed through the enumerator may contain modifications made to the dictionary after <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A&gt;</ph> was called.</source>
          <target state="translated">Le contenu exposé via l’énumérateur peut contenir des modifications apportées au dictionnaire après <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A&gt;</ph> a été appelée.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
          <source>Copies the key and value pairs stored in the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> to a new array.</source>
          <target state="translated">Copie les paires clé/valeur stockées dans le <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> dans un nouveau tableau.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
          <source>A new array containing a snapshot of key and value pairs copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Nouveau tableau qui contient un instantané des paires clé/valeur copiées à partir de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>The key of the element to add.</source>
          <target state="translated">Clé de l'élément à ajouter.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>The value of the element to add.</source>
          <target state="translated">Valeur de l'élément à ajouter.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>The value can be  <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">La valeur peut être <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour les types référence.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>Attempts to add the specified key and value to the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Tente d'ajouter la clé et la valeur spécifiées à <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the key/value pair was added to the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> successfully; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the key already exists.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la paire clé/valeur a été ajoutée correctement au <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>. <ph id="ph3">&lt;see langword="false" /&gt;</ph> si la clé existe déjà.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>This method returns <ph id="ph1">`false`</ph> if the key already exists.</source>
          <target state="translated">Cette méthode retourne <ph id="ph1">`false`</ph> si la clé existe déjà.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>Use the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> method to update the value in case a key already exists.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A&gt;</ph> pour mettre à jour la valeur au cas où une clé existe déjà.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>The following example shows how to call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType&gt;</ph> method:</source>
          <target state="translated">L’exemple suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType&gt;</ph> méthode :</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is  <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
          <source>The dictionary already contains the maximum number of elements (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</source>
          <target state="translated">Le dictionnaire contient déjà le nombre maximal d'éléments (<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
          <source>The key of the value to get.</source>
          <target state="translated">Clé de la valeur à obtenir.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
          <source>When this method returns, contains the object from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> that has the specified key, or the default value of the type if the operation failed.</source>
          <target state="translated">Lorsque cette méthode est retournée, contient l'objet du <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> qui contient la clé spécifiée ou la valeur par défaut du type, si l'opération a échoué.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
          <source>Attempts to get the value associated with the specified key from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Tente d'obtenir la valeur associée à la clé spécifiée à partir de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the key was found in the <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la clé a été trouvée dans <ph id="ph2">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph> ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is  <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
          <source>The key of the element to remove and return.</source>
          <target state="translated">Clé de l'élément à supprimer et à retourner.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
          <source>When this method returns, contains the object removed from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>, or the default value of  the <ph id="ph2">&lt;see langword="TValue" /&gt;</ph> type if <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> does not exist.</source>
          <target state="translated">Quand cette méthode retourne une valeur, contient l’objet supprimé de <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>, ou la valeur par défaut du type <ph id="ph2">&lt;see langword="TValue" /&gt;</ph> si <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> n’existe pas.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
          <source>Attempts to remove and return the value that has the specified key from the <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</source>
          <target state="translated">Tente de supprimer et de retourner la valeur ayant la clé spécifiée du <ph id="ph1">&lt;see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object was removed successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'objet a été correctement supprimé ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
          <source>The following example shows how to call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType&gt;</ph> method:</source>
          <target state="translated">L’exemple suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType&gt;</ph> méthode :</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is  <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source>The key whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparisonValue<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Clé dont la valeur est comparée à <bpt id="p1">&lt;c&gt;</bpt>comparisonValue<ept id="p1">&lt;/c&gt;</ept> et qui peut être remplacée.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source>The value that replaces the value of the element that has the specified <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> if the comparison results in equality.</source>
          <target state="translated">Valeur qui remplace la valeur de l’élément comportant le <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> spécifié si la comparaison conclut à une égalité.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source>The value that is compared to the value of the element that has the specified <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valeur comparée à la valeur de l’élément comportant le <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> spécifié.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source>Compares the existing value for the specified key with a specified value, and if they are equal, updates the key with a third value.</source>
          <target state="translated">Compare la valeur existante pour la clé spécifiée avec une valeur spécifiée, et si elles sont égales, met à jour la clé avec une troisième valeur.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value with <ph id="ph2">&lt;paramref name="key" /&gt;</ph> was equal to <ph id="ph3">&lt;paramref name="comparisonValue" /&gt;</ph> and was replaced with <ph id="ph4">&lt;paramref name="newValue" /&gt;</ph>; otherwise, <ph id="ph5">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la valeur avec <ph id="ph2">&lt;paramref name="key" /&gt;</ph> était égale à <ph id="ph3">&lt;paramref name="comparisonValue" /&gt;</ph> et a été remplacée par <ph id="ph4">&lt;paramref name="newValue" /&gt;</ph> ; sinon, <ph id="ph5">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source>The following example shows how to call the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A&gt;</ph> method:</source>
          <target state="translated">L’exemple suivant montre comment appeler le <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A&gt;</ph> méthode :</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
          <source>Gets a collection that contains the values in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated">Obtient une collection qui contient les valeurs de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
          <source>A collection that contains the values in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</source>
          <target state="translated">Collection qui contient les valeurs de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.Dictionary`2" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>