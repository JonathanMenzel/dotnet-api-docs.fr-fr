<Type Name="PeerName" FullName="System.Net.PeerToPeer.PeerName">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b3a042a306350711555199f3457d07237a871d13" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52381562" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PeerName : IEquatable&lt;System.Net.PeerToPeer.PeerName&gt;, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable PeerName extends System.Object implements class System.IEquatable`1&lt;class System.Net.PeerToPeer.PeerName&gt;, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.PeerToPeer.PeerName" />
  <TypeSignature Language="VB.NET" Value="Public Class PeerName&#xA;Implements IEquatable(Of PeerName), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class PeerName : IEquatable&lt;System::Net::PeerToPeer::PeerName ^&gt;, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type PeerName = class&#xA;    interface ISerializable&#xA;    interface IEquatable&lt;PeerName&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Net.PeerToPeer.PeerName&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Spécifie les valeurs qui définissent un objet <see cref="T:System.Net.PeerToPeer.PeerName" /> pair à pair. Un nom d'homologue est en général une chaîne utilisée pour identifier une ressource homologue.</summary>
    <remarks>To be added.</remarks>
    <altmember cref="N:System.Net.PeerToPeer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PeerName (string remotePeerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string remotePeerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (remotePeerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PeerName(System::String ^ remotePeerName);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PeerName : string -&gt; System.Net.PeerToPeer.PeerName" Usage="new System.Net.PeerToPeer.PeerName remotePeerName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="remotePeerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="remotePeerName">Contenant le nom d’homologue à encoder en tant qu’instance <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Initialise un nouvel objet de type <see cref="T:System.Net.PeerToPeer.PeerName" /> avec la valeur <see cref="T:System.String" /> fournie comme nom d’homologue complet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.String" /> fourni n’est pas un <see cref="T:System.Net.PeerToPeer.PeerName" /> valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remotePeerName" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PeerName (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PeerName(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PeerName : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.PeerToPeer.PeerName" Usage="new System.Net.PeerToPeer.PeerName (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Référence à l’objet qui contient les données nécessaires pour désérialiser cette instance.</param>
        <param name="context">Le contexte qui fournit les moyens de désérialiser les données. On l’appelle aussi source des données sérialisées.</param>
        <summary>Remplit un objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec les données nécessaires pour sérialiser le <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est requis pour la désérialisation de ce type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Au moins un paramètre a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PeerName (string classifier, System.Net.PeerToPeer.PeerNameType peerNameType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string classifier, valuetype System.Net.PeerToPeer.PeerNameType peerNameType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.String,System.Net.PeerToPeer.PeerNameType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PeerName(System::String ^ classifier, System::Net::PeerToPeer::PeerNameType peerNameType);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PeerName : string * System.Net.PeerToPeer.PeerNameType -&gt; System.Net.PeerToPeer.PeerName" Usage="new System.Net.PeerToPeer.PeerName (classifier, peerNameType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classifier" Type="System.String" />
        <Parameter Name="peerNameType" Type="System.Net.PeerToPeer.PeerNameType" />
      </Parameters>
      <Docs>
        <param name="classifier">
          <see cref="T:System.String" /> contenant le nom d’homologue à encoder en tant que <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <param name="peerNameType">Valeur d'énumération <see cref="T:System.Net.PeerToPeer.PeerNameType" /> qui spécifie le type nom d’homologue à créer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur retourne un objet de type <xref:System.Net.PeerToPeer.PeerName> qui contient le nom qualifié complet de l’homologue. Il spécifie également si le nom d’homologue est sécurisé ou non sécurisé.  
  
 Cette instance utilise l’identité d’homologue par défaut pour l’utilisateur actuel et spécifié <xref:System.Net.PeerToPeer.PeerName.Classifier%2A>, en plus du type de nom d’homologue à créer avec le classifieur spécifié et le type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> inclut un ou plusieurs caractères non autorisés.</exception>
        <exception cref="T:System.ArgumentNullException">Au moins un paramètre a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">- L’identité par défaut utilisée comme base de <see cref="T:System.Net.PeerToPeer.PeerName" /> pas pu être récupérée.  
  
- Impossible de créer <see cref="T:System.Net.PeerToPeer.PeerName" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Net.PeerToPeer.PeerName.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une chaîne qui spécifie le <see cref="P:System.Net.PeerToPeer.PeerName.Authority" /> utilisée par cet objet <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <value>Chaîne qui contient la partie authentification du <see cref="T:System.Net.PeerToPeer.PeerName" /> spécifié. Pour les noms d'homologue sécurisés, cette propriété contient la clé publique sous la forme d'une chaîne hexadécimale de quarante caractères. Pour les noms d'homologue non sécurisés, cette propriété a la valeur zéro (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seul le propriétaire, ou hôte homologue, peut inscrire un nom d’homologue sécurisé. Un nom d’homologue est considéré comme sécurisé s’il est sauvegardé par un certificat auto-signé.  
  
 Noms de pairs respectent la casse et le format d’un nom d’homologue est : *autorité.classifieur*. Par exemple, « 0.NomHomologue » est un nom de pair bien formé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>À l’aide d’un nom d’homologue sécurisé ne garantit pas la sécurité globale de l’application de mise en réseau. La sécurité d’une application dépend de son implémentation.</para>
        </block>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Classifier" />
        <altmember cref="T:System.Net.PeerToPeer.PeerNameType" />
      </Docs>
    </Member>
    <Member MemberName="Classifier">
      <MemberSignature Language="C#" Value="public string Classifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Classifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.Classifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Classifier As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Classifier { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Classifier : string" Usage="System.Net.PeerToPeer.PeerName.Classifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une chaîne qui contient le classifieur pour un <see cref="T:System.Net.PeerToPeer.PeerName" /> pair à pair.</summary>
        <value>Chaîne qui contient la partie classifieur utilisée pour identifier un nom d'homologue pour <see cref="T:System.Net.PeerToPeer.PeerNameRegistration" /> ou résolution au sein d'un <see cref="T:System.Net.PeerToPeer.Cloud" /> PNRP.  
  
Sauf spécification explicite, la valeur par défaut pour toutes les propriétés est <see langword="null" /> pour les types référence et zéro (0) pour les propriétés de type <see langword="int" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le format d’un nom d’homologue est : *autorité.classifieur*. Le nom d’homologue *classifieur* composant peut être défini sur n’importe quelle chaîne qui contient les 149 caractères Unicode, y compris le `null` marque de fin (« \0 »). Chaînes de nom d’homologue respectent la casse.  
  
 Pour les noms d’homologue sécurisés, le classifieur et le point (point) après l’autorité sont facultatifs. Pour les noms d’homologue non sécurisés, le classifieur n’est pas facultatif.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Authority" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.IsSecured" />
        <altmember cref="T:System.Net.PeerToPeer.PeerNameType" />
      </Docs>
    </Member>
    <Member MemberName="CreateFromPeerHostName">
      <MemberSignature Language="C#" Value="public static System.Net.PeerToPeer.PeerName CreateFromPeerHostName (string peerHostName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.PeerToPeer.PeerName CreateFromPeerHostName(string peerHostName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromPeerHostName (peerHostName As String) As PeerName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::PeerToPeer::PeerName ^ CreateFromPeerHostName(System::String ^ peerHostName);" />
      <MemberSignature Language="F#" Value="static member CreateFromPeerHostName : string -&gt; System.Net.PeerToPeer.PeerName" Usage="System.Net.PeerToPeer.PeerName.CreateFromPeerHostName peerHostName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.PeerToPeer.PeerName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peerHostName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peerHostName">Chaîne qui contient le nom d'hôte qualifié DNS.</param>
        <summary>Crée une nouvelle instance de l'objet <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> spécifié avec le nom d'hôte homologue spécifié.</summary>
        <returns>Objet <see cref="T:System.Net.PeerToPeer.PeerName" /> qui représente le nom d'hôte homologue spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’hôte de peer-to-peer est le « nœud de valeur initiale » responsable du lancement de la session de mise en réseau peer-to-peer, l’invitation homologues à participer aux applications pour lesquelles ce type de connectivité réseau est plus approprié pour les communications, telles que les groupes de conversation ou de jeu sessions.  
  
 Cette méthode peut être utilisée pour créer un <xref:System.Net.PeerToPeer.PeerName> objet basé sur le <xref:System.Net.PeerToPeer.PeerName.PeerHostName%2A> propriété. Ce nom d’homologue n’est pas associé à l’identité du nœud appelant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.String" /> fourni n'est pas une chaîne de nom d'hôte homologue valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">Un <see cref="T:System.Net.PeerToPeer.PeerName" /> n'a pas pu être créé à partir du <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" />fourni</exception>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelativePeerName">
      <MemberSignature Language="C#" Value="public static System.Net.PeerToPeer.PeerName CreateRelativePeerName (System.Net.PeerToPeer.PeerName peerName, string classifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.PeerToPeer.PeerName CreateRelativePeerName(class System.Net.PeerToPeer.PeerName peerName, string classifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::PeerToPeer::PeerName ^ CreateRelativePeerName(System::Net::PeerToPeer::PeerName ^ peerName, System::String ^ classifier);" />
      <MemberSignature Language="F#" Value="static member CreateRelativePeerName : System.Net.PeerToPeer.PeerName * string -&gt; System.Net.PeerToPeer.PeerName" Usage="System.Net.PeerToPeer.PeerName.CreateRelativePeerName (peerName, classifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.PeerToPeer.PeerName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peerName" Type="System.Net.PeerToPeer.PeerName" />
        <Parameter Name="classifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peerName">Objet <see cref="T:System.Net.PeerToPeer.PeerName" /> sur lequel définir la nouvelle valeur de chaîne du classifieur.</param>
        <param name="classifier">
          <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> à définir sur la valeur <see cref="T:System.Net.PeerToPeer.PeerName" /> retournée.</param>
        <summary>Crée un nouveau <see cref="T:System.Net.PeerToPeer.PeerName" /> en remplaçant le champ <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> défini sur l'objet <see cref="T:System.Net.PeerToPeer.PeerName" /> fourni par la valeur de chaîne du classifieur spécifié.</summary>
        <returns>Le nouvel objet <see cref="T:System.Net.PeerToPeer.PeerName" /> qui contient le classifieur mis à jour.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.PeerToPeer.PeerName.Classifier%2A> est ajouté à l’objet de <xref:System.Net.PeerToPeer.PeerName.Authority%2A> partie de la <xref:System.Net.PeerToPeer.PeerName>. Cette chaîne n’est pas plus de 149 caractères, y compris le `null` marque de fin. Spécifiez `null` pour retourner le nom d’homologue de l’identité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.String" /> fourni n'est pas un classifieur du nom de l'homologue valide.</exception>
        <exception cref="T:System.ArgumentNullException">Au moins un paramètre a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">Un <see cref="T:System.Net.PeerToPeer.PeerName" /> n'a pas pu être créé à partir du <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" />fourni</exception>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le contenu de cet objet <see cref="T:System.Net.PeerToPeer.PeerName" /> est équivalent au contenu d'un autre objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de Equals est définie par IEquatable\<T >.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Authority" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Classifier" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Net.PeerToPeer.PeerName other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Net.PeerToPeer.PeerName other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.Equals(System.Net.PeerToPeer.PeerName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As PeerName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Net::PeerToPeer::PeerName ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Net.PeerToPeer.PeerName -&gt; bool" Usage="peerName.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Net.PeerToPeer.PeerName" />
      </Parameters>
      <Docs>
        <param name="other">Nom d'homologue à comparer avec ce <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Effectue une comparaison sensible à la casse du <see cref="T:System.Net.PeerToPeer.PeerName" /> actuel et du nom d'homologue spécifié.</summary>
        <returns>Retourne la valeur <see langword="True" /> si le <see cref="T:System.Net.PeerToPeer.PeerName" /> spécifié identifie la même ressource que l'objet nom de l'homologue actuel ; sinon, cette méthode retourne la valeur <see langword="False" />.  
  
Cette méthode retourne également <see langword="False" /> si <paramref name="other" /> a la valeur <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux noms d’homologue sont considérés comme égaux s’ils contiennent des caractères identiques dans leurs <xref:System.Net.PeerToPeer.PeerName.Authority%2A> et <xref:System.Net.PeerToPeer.PeerName.Classifier%2A> composants.  
  
 Aucune normalisation n’est exécutée sur les chaînes avant la comparaison.  Toute la normalisation doit être effectuée pendant ou avant la construction d’objets de nom d’homologue.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="peerName.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> à comparer avec l'objet <see cref="T:System.Net.PeerToPeer.PeerName" /> actuel.</param>
        <summary>Détermine si le contenu de ce <see cref="T:System.Net.PeerToPeer.PeerName" /> est égal au contenu d'un autre objet.</summary>
        <returns>
          <see langword="True" /> si le <see cref="T:System.Net.PeerToPeer.PeerName" /> et l'objet de comparaison contiennent les mêmes informations ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode hérite de la signature par défaut et le comportement de <xref:System.Object>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="peerName.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Substitue la méthode <see cref="M:System.Object.GetHashCode" />.</summary>
        <returns>Code de hachage pour le <see cref="T:System.Object" /> en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux objets sont considérés comme égaux si cette méthode retourne le même code de hachage pour les deux d'entre eux.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="peerName.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Contient les données sérialisées associées à l’objet <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <param name="context">Contient la destination du flux sérialisé associé à l’objet <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un type dérivé doit appeler la méthode <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> de type de base.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="IsSecured">
      <MemberSignature Language="C#" Value="public bool IsSecured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecured" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.IsSecured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecured : bool" Usage="System.Net.PeerToPeer.PeerName.IsSecured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur booléenne qui spécifie s'il s'agit d'un nom d'homologue sécurisé.</summary>
        <value>Si la valeur est <see langword="true" />, ce nom d'homologue est sécurisé avec une paire de clé privée/ clé publique. Son nom contient le hachage SHA (Secure Hash Algorithm, algorithme de hachage sécurisé) de la clé publique du certificat utilisateur de cet ordinateur homologue. Sinon, si la valeur est <see langword="false" />, le nom d'homologue n'est associé à aucune identité.  
  
Sauf spécification explicite, la valeur par défaut pour toutes les propriétés est <see langword="null" /> pour les types référence et zéro (0) pour les propriétés de type <see langword="int" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nom d’homologue est considéré comme sécurisé s’il est sauvegardé par un certificat auto-signé.  
  
 Seul le propriétaire peut inscrire un nom d’homologue sécurisé avec PNRP.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>À l’aide d’un nom d’homologue sécurisé ne garantit pas la sécurité globale de l’application de mise en réseau. La sécurité d’une application dépend de son implémentation.</para>
        </block>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
        <altmember cref="N:System.Security.Permissions" />
      </Docs>
    </Member>
    <Member MemberName="PeerHostName">
      <MemberSignature Language="C#" Value="public string PeerHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PeerHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.PeerHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeerHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PeerHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PeerHostName : string" Usage="System.Net.PeerToPeer.PeerName.PeerHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l'hôte de réseau pair à pair. Il s'agit d'une version encodée par DNS du <see cref="T:System.Net.PeerToPeer.PeerName" /> qui équivalent à un <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> du fait qu'ils sont tous deux identificateurs.  La différence entre les deux est la représentation visuelle.</summary>
        <value>Valeur <see cref="T:System.String" /> qui est le nom de l'hôte de réseau pair à pair. Sauf spécification explicite, la valeur par défaut de toutes les propriétés est <see langword="null" /> pour les types référence.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’hôte de peer-to-peer est le « nœud de valeur initiale » responsable du lancement de la session de mise en réseau peer-to-peer, l’invitation homologues à participer aux applications pour lesquelles ce type de connectivité réseau est plus approprié pour les communications, telles que les groupes de conversation ou de jeu sessions.  
  
 Le <xref:System.Net.PeerToPeer.PeerName.PeerHostName%2A> propriété spécifie le nom d’un homologue qui a créé la session de mise en réseau peer-to-peer, et qui est considérée comme l’hôte de la session.  L’hôte d’une session de mise en réseau pair à pair peut rassembler des homologues dans plusieurs <xref:System.Net.PeerToPeer.Cloud>. En outre, un homologue peut être hébergé simultanément par plusieurs hôtes d’homologue.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Contient les données sérialisées associées à l’objet <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <param name="context">Contient la destination du flux sérialisé associé à l’objet <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Implémente l'interface <see cref="T:System.Runtime.Serialization.ISerializable" /> et retourne les données nécessaires pour sérialiser l'instance <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="peerName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne représentant l'objet <see cref="T:System.Net.PeerToPeer.PeerName" /> en cours.</summary>
        <returns>Chaîne qui représente le <see cref="T:System.Net.PeerToPeer.PeerName" /> actuel, spécifiée au format suivant : *Autorité.Classifieur*. Par exemple, "0.MonHomologueInternet".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode hérite de la signature par défaut et le comportement de <xref:System.Object>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
  </Members>
</Type>