<Type Name="PnrpPermission" FullName="System.Net.PeerToPeer.PnrpPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fa800ff1deb4f0174a3bd9adba3f0d6d9db0f90d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460113" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PnrpPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PnrpPermission extends System.Security.CodeAccessPermission implements class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.Net.PeerToPeer.PnrpPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PnrpPermission&#xA;Inherits CodeAccessPermission&#xA;Implements IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class PnrpPermission sealed : System::Security::CodeAccessPermission, System::Security::Permissions::IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Spécifie les valeurs utilisées dans les autorisations d'objet <see cref="N:System.Net.PeerToPeer" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les autorisations par défaut permettent à tous les locaux et les applications de la zone Intranet d’accéder aux services PNRP. Si les autorisations par défaut ne sont pas modifiées, toutes les applications de lien local et de site local ont accès aux services d’égal à égal, mais les applications (internet) globales n’ont aucun accès.  
  
 Les instances de ce type ont deux États d’autorisation : ils ont soit aucun accès aux ressources protégées par l’autorisation, ou un accès complet illimité à ces ressources.  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
    <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
    <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
    <altmember cref="N:System.Security.Permissions" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PnrpPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PnrpPermission(System::Security::Permissions::PermissionState state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Une des valeurs dans l’énumération <see cref="T:System.Security.Permissions.PermissionState" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> avec l’état d’autorisation initial fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les instances de ce type ont deux États d’autorisation : ils ont soit aucun accès aux ressources protégées par l’autorisation, ou un accès complet illimité à ces ressources.  
  
 Si `state` est illimité, l’instance PnrpPermission passe toutes les demandes. Si `state` contient toute autre valeur, l’instance PnrpPermission échoue toutes les demandes.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsUnrestricted" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne une copie identique de l'objet <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> en cours.</summary>
        <returns>Objet avec une interface IPermission, dont l'instance contient une copie de l'instance actuelle de <see cref="T:System.Net.PeerToPeer.PnrpPermission" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie d’une autorisation représente le même accès aux ressources que l’autorisation d’origine.  
  
 Les instances de ce type ont deux États d’autorisation : ils ont soit aucun accès aux ressources protégées par l’autorisation, ou un accès complet illimité à ces ressources.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">-   Le paramètre n’est pas un élément <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> valide.  
  
-   Le numéro de version du paramètre n’est pas pris en charge.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre est une référence <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXml (e As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="e">Encodage XML à utiliser pour reconstruire l’autorisation.</param>
        <summary>Reconstruit un objet de sécurité avec un état spécifié à partir d’un encodage XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Représente le modèle d’objet XML pour l’encodage des objets de sécurité. Cette classe ne peut pas être héritée.  
  
 Cette classe est destinée à être une implémentation légère d’un modèle d’objet XML simple à utiliser dans le système de sécurité et non en tant que modèle objet XML global.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">-   Le paramètre n’est pas un élément <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> valide.  
  
-   Le numéro de version du paramètre n’est pas pris en charge.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre est une référence <see langword="null" /> (<see langword="Nothing" /> en Visual Basic).</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="T:System.Security.SecurityElement" />
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorisation sur <see cref="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" /> avec l'autorisation en cours. Elle doit être du même type que l’autorisation actuelle.</param>
        <summary>Crée et retourne une autorisation qui est l'intersection entre le <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> en cours et l'autorisation  spécifiée.</summary>
        <returns>Nouvelle autorisation qui représente l'intersection entre le <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> en cours et l'autorisation  spécifiée. Cette nouvelle autorisation est une référence <see langword="null" /> (<see langword="Nothing" /> en Visual Basic), si l'intersection est vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’intersection de deux autorisations est une autorisation qui décrit l’ensemble des opérations qu’elles décrivent en commun. Seule une demande qui passe les deux autorisations d’origine passera l’intersection.  
  
 Les instructions suivantes doivent être `true` pour toutes les implémentations de la méthode Intersect. X et Y représentent <xref:System.Security.IPermission> références d’objet qui ne sont pas un `null` référence (Nothing en Visual Basic).  
  
-   X.Intersect(X) retourne une valeur égale à X.  
  
-   X.Intersect (y) retourne la même valeur qu’y.Intersect (x).  
  
-   X.Intersect (une `null` référence (`Nothing` en Visual Basic)) retourne un `null` référence (`Nothing` en Visual Basic).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre cible n'est pas une référence <see langword="null" /> (<see langword="Nothing" /> en Visual Basic) et n'est pas une instance de la même classe que l'autorisation en cours.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsSubsetOf(System.Security.IPermission)" />
        <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorisation qui doit être testée pour la relation de sous-ensemble. Cette autorisation doit être du même type que l’autorisation actuelle.</param>
        <summary>Détermine si le <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> actuel est un sous-ensemble de l'autorisation spécifiée.</summary>
        <returns>
          <see langword="True" /> si l'autorisation <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> en cours est un sous-ensemble de l'autorisation spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En cours <xref:System.Net.PeerToPeer.PnrpPermission> est un sous-ensemble de l’autorisation spécifiée si l’autorisation actuelle spécifie un ensemble d’opérations qui est entièrement contenu par l’autorisation spécifiée. Par exemple, une autorisation qui représente l’accès à «*C:\example.txt*« est un sous-ensemble d’une autorisation qui représente l’accès à »*C:\\*». Si cette méthode retourne `true`, l’autorisation en cours ne représente pas plus d’accès à la ressource protégée que l’autorisation spécifiée.  
  
 Les instructions suivantes doivent être `true` pour toutes les implémentations de la méthode IsSubsetOf. X, Y et Z représentent <xref:System.Security.IPermission> les objets qui ne sont pas un `null` référence (`Nothing` en Visual Basic).  
  
-   X.IsSubsetOf (x) retourne `true`.  
  
-   X.IsSubsetOf (y) retourne la même valeur qu’y.IsSubsetOf (x) si et seulement si X et Y représentent le même jeu d’autorisations.  
  
-   Si x.IsSubsetOf (y) et Y.IsSubsetOf renvoient tous deux `true`, x.IsSubsetOf (z) retourne `true`.  
  
-  
  
 Si X représente un objet IPermission vide avec un état d’autorisation *aucun* et Y représente un objet IPermission qui est une `null` référence (`Nothing` en Visual Basic), x.IsSubsetOf (y) retourne `true`. Si Z est également une autorisation vide, l’opération de définition composée x.Union (z). IsSubsetOf (y) retourne également `true` , car le <xref:System.Net.PeerToPeer.PnrpPermission.Union%2A> de deux autorisations vides est une autorisation vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre cible n'est pas une référence <see langword="null" /> (<see langword="Nothing" /> en Visual Basic) et n'est pas une instance de la même classe que l'autorisation en cours.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui spécifie si le <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> actuel est illimité.</summary>
        <returns>
          <see langword="True" /> si l'autorisation en cours est illimitée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une autorisation sans restriction représente l’accès à toutes les ressources protégées par l’autorisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un encodage XML du <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> et de son état actuel.</summary>
        <returns>Objet <see cref="T:System.Security.SecurityElement" /> contenant l'encodage XML de l'autorisation, y compris des informations d'état.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Autorisation à combiner avec l’autorisation actuelle. Elle doit être du même type que l’autorisation actuelle.</param>
        <summary>Crée une autorisation qui est l'union entre le <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> actuel et l'autorisation spécifiée.</summary>
        <returns>Nouvelle autorisation qui représente le <see cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" /> du <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> en cours et l'autorisation spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat d’un appel à <xref:System.Net.PeerToPeer.PnrpPermission.Union%2A> est une autorisation qui représente toutes les opérations représentées par l’analyseur lexical actuel <xref:System.Net.PeerToPeer.PnrpPermission> et l’autorisation spécifiée. Toute demande qui transmet une autorisation passe leur union.  
  
 Les instructions suivantes doivent être `true` pour toutes les implémentations de la méthode Union. X et Y représentent <xref:System.Security.IPermission> les objets qui ne sont pas un `null` référence (`Nothing` en Visual Basic).  
  
-   X.Union (x) retourne un objet qui a la même valeur que X.  
  
-   X.Union (y) retourne un objet qui a la même valeur que l’objet retourné par y.Union (x).  
  
-   X.Union (une `null` référence (`Nothing` en Visual Basic)) retourne un objet qui a la même valeur que X.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Le paramètre <paramref name="target" /> n'est pas valide.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsSubsetOf(System.Security.IPermission)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsUnrestricted" />
      </Docs>
    </Member>
  </Members>
</Type>