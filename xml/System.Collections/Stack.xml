<Type Name="Stack" FullName="System.Collections.Stack">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e52fd777b1e5cc88d2a91ddd6b9534b882b7d478" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48772360" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Stack : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Stack" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack&#xA;Implements ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stack : ICloneable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack = class&#xA;    interface ICollection&#xA;    interface ICloneable&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="6e792-101">Représente une simple collection non générique d’objets de type dernier entré, premier sorti (LIFO).</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-101">Represents a simple last-in-first-out (LIFO) non-generic collection of objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-102">Pour la version générique de cette collection, consultez <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6e792-102">For the generic version of this collection, see <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6e792-103">La capacité d’un <xref:System.Collections.Stack> est le nombre d’éléments du <xref:System.Collections.Stack> peut contenir.</span><span class="sxs-lookup"><span data-stu-id="6e792-103">The capacity of a <xref:System.Collections.Stack> is the number of elements the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="6e792-104">Comme les éléments sont ajoutés à un <xref:System.Collections.Stack>, la capacité est automatiquement augmentée par réallocation.</span><span class="sxs-lookup"><span data-stu-id="6e792-104">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required through reallocation.</span></span>  
  
 <span data-ttu-id="6e792-105">Si <xref:System.Collections.Stack.Count%2A> est inférieure à la capacité de la pile, <xref:System.Collections.Stack.Push%2A> est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-105">If <xref:System.Collections.Stack.Count%2A> is less than the capacity of the stack, <xref:System.Collections.Stack.Push%2A> is an O(1) operation.</span></span> <span data-ttu-id="6e792-106">Si la capacité doit être augmentée pour intégrer le nouvel élément <xref:System.Collections.Stack.Push%2A> devient un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-106">If the capacity needs to be increased to accommodate the new element, <xref:System.Collections.Stack.Push%2A> becomes an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span> <span data-ttu-id="6e792-107"><xref:System.Collections.Stack.Pop%2A> est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-107"><xref:System.Collections.Stack.Pop%2A> is an O(1) operation.</span></span>  
  
 <span data-ttu-id="6e792-108"><xref:System.Collections.Stack> accepte `null` comme une valeur valide et autorise les éléments en double.</span><span class="sxs-lookup"><span data-stu-id="6e792-108"><xref:System.Collections.Stack> accepts `null` as a valid value and allows duplicate elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-109">L’exemple suivant montre comment créer et ajouter des valeurs pour un <xref:System.Collections.Stack> et comment afficher ses valeurs.</span><span class="sxs-lookup"><span data-stu-id="6e792-109">The following example shows how to create and add values to a <xref:System.Collections.Stack> and how to display its values.</span></span>  
  
 [!code-cpp[Classic Stack Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack Example/CS/source.cs#1)]
 [!code-vb[Classic Stack Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="6e792-110">Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-110">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="6e792-111">Il n'est pas garanti que les membres d'instance soient thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-111">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="6e792-112">Pour garantir la sécurité des threads de la <see cref="T:System.Collections.Stack" />, toutes les opérations doivent être effectuées via le wrapper retourné par la <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" /> (méthode).</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-112">To guarantee the thread safety of the <see cref="T:System.Collections.Stack" />, all operations must be done through the wrapper returned by the <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" /> method.</span>
      </span>
      <span data-ttu-id="6e792-113">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-113">Enumerating through a collection is intrinsically not a thread-safe procedure.</span>
      </span>
      <span data-ttu-id="6e792-114">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-114">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span>
      </span>
      <span data-ttu-id="6e792-115">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6e792-115">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Collections.Generic.Stack`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="6e792-116">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-116">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-117">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Stack" /> qui est vide et possède la capacité initiale par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-117">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that is empty and has the default initial capacity.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-118">La capacité d’un <xref:System.Collections.Stack> est le nombre d’éléments qui le <xref:System.Collections.Stack> peut contenir.</span><span class="sxs-lookup"><span data-stu-id="6e792-118">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="6e792-119">Comme les éléments sont ajoutés à un <xref:System.Collections.Stack>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.</span><span class="sxs-lookup"><span data-stu-id="6e792-119">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="6e792-120">Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-120">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="6e792-121">Ce constructeur est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-121">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.ICollection col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (col As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::ICollection ^ col);" />
      <MemberSignature Language="F#" Value="new System.Collections.Stack : System.Collections.ICollection -&gt; System.Collections.Stack" Usage="new System.Collections.Stack col" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="col" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="col">
          <span data-ttu-id="6e792-122">
            <see cref="T:System.Collections.ICollection" /> à partir duquel les éléments sont copiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-122">The <see cref="T:System.Collections.ICollection" /> to copy elements from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6e792-123">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Stack" /> qui contient des éléments copiés à partir de la collection spécifiée et qui possède la capacité initiale correspondant au nombre d'éléments copiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-123">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that contains elements copied from the specified collection and has the same initial capacity as the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-124">La capacité d’un <xref:System.Collections.Stack> est le nombre d’éléments qui le <xref:System.Collections.Stack> peut contenir.</span><span class="sxs-lookup"><span data-stu-id="6e792-124">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="6e792-125">Comme les éléments sont ajoutés à un <xref:System.Collections.Stack>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.</span><span class="sxs-lookup"><span data-stu-id="6e792-125">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="6e792-126">Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-126">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="6e792-127">Les éléments sont copiés dans le <xref:System.Collections.Stack> dans le même ordre qu’ils sont lus par le <xref:System.Collections.IEnumerator> de la <xref:System.Collections.ICollection>.</span><span class="sxs-lookup"><span data-stu-id="6e792-127">The elements are copied onto the <xref:System.Collections.Stack> in the same order they are read by the <xref:System.Collections.IEnumerator> of the <xref:System.Collections.ICollection>.</span></span>  
  
 <span data-ttu-id="6e792-128">Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `col`.</span><span class="sxs-lookup"><span data-stu-id="6e792-128">This constructor is an O(`n`) operation, where `n` is the number of elements in `col`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6e792-129">
            <paramref name="col" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-129">
              <paramref name="col" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Stack : int -&gt; System.Collections.Stack" Usage="new System.Collections.Stack initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">
          <span data-ttu-id="6e792-130">Nombre initial d'éléments que <see cref="T:System.Collections.Stack" /> peut contenir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-130">The initial number of elements that the <see cref="T:System.Collections.Stack" /> can contain.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6e792-131">Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Stack" /> qui est vide et possède une capacité égale à la plus grande valeur parmi la capacité initiale spécifiée et la capacité initiale par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-131">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that is empty and has the specified initial capacity or the default initial capacity, whichever is greater.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-132">La capacité d’un <xref:System.Collections.Stack> est le nombre d’éléments qui le <xref:System.Collections.Stack> peut contenir.</span><span class="sxs-lookup"><span data-stu-id="6e792-132">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="6e792-133">Comme les éléments sont ajoutés à un <xref:System.Collections.Stack>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.</span><span class="sxs-lookup"><span data-stu-id="6e792-133">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="6e792-134">Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-134">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="6e792-135">Ce constructeur est un O (`n`) opération, où `n` est `initialCapacity`.</span><span class="sxs-lookup"><span data-stu-id="6e792-135">This constructor is an O(`n`) operation, where `n` is `initialCapacity`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="6e792-136">
            <paramref name="initialCapacity" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-136">
              <paramref name="initialCapacity" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-137">Supprime tous les objets du <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-137">Removes all objects from the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-138"><xref:System.Collections.Stack.Count%2A> est défini sur zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées.</span><span class="sxs-lookup"><span data-stu-id="6e792-138"><xref:System.Collections.Stack.Count%2A> is set to zero, and references to other objects from elements of the collection are also released.</span></span>  
  
 <span data-ttu-id="6e792-139">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-139">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-140">L’exemple suivant montre comment effacer les valeurs de la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-140">The following example shows how to clear the values of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="stack.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-141">Crée une copie superficielle de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-141">Creates a shallow copy of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-142">Copie superficielle de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-142">A shallow copy of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-143">Une copie superficielle d’une collection copie uniquement les éléments de la collection, si elles sont des types référence ou types valeur, mais il ne copie pas les objets qui la fait référence à.</span><span class="sxs-lookup"><span data-stu-id="6e792-143">A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="6e792-144">Les références dans la nouvelle collection pointent vers les mêmes objets que les références dans la collection d’origine pointent vers.</span><span class="sxs-lookup"><span data-stu-id="6e792-144">The references in the new collection point to the same objects that the references in the original collection point to.</span></span>  
  
 <span data-ttu-id="6e792-145">En revanche, une copie complète d’une collection copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.</span><span class="sxs-lookup"><span data-stu-id="6e792-145">In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="6e792-146">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-146">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="stack.Contains obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="6e792-147">Objet à rechercher dans <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-147">The object to locate in the <see cref="T:System.Collections.Stack" />.</span>
          </span>
          <span data-ttu-id="6e792-148">La valeur peut être <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-148">The value can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6e792-149">Détermine si le <see cref="T:System.Collections.Stack" /> contient un élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-149">Determines whether an element is in the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-150">
            <see langword="true" /> si <paramref name="obj" /> existe dans <see cref="T:System.Collections.Stack" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-150">
              <see langword="true" />, if <paramref name="obj" /> is found in the <see cref="T:System.Collections.Stack" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-151">Cette méthode détermine l’égalité en appelant le <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="6e792-151">This method determines equality by calling the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6e792-152">Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-152">This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
 <span data-ttu-id="6e792-153">À compter de .NET Framework 2.0, cette méthode teste l’égalité en passant le `obj` l’argument de la <xref:System.Object.Equals%2A> méthode des objets individuels dans la collection.</span><span class="sxs-lookup"><span data-stu-id="6e792-153">Starting with the .NET Framework 2.0, this method tests for equality by passing the `obj` argument to the <xref:System.Object.Equals%2A> method of individual objects in the collection.</span></span> <span data-ttu-id="6e792-154">Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide en passant les éléments individuels dans la collection à la <xref:System.Object.Equals%2A> méthode de la `obj` argument.</span><span class="sxs-lookup"><span data-stu-id="6e792-154">In the earlier versions of the .NET Framework, this determination was made by using passing the individual items in the collection to the <xref:System.Object.Equals%2A> method of the `obj` argument.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">
          <span data-ttu-id="6e792-155">Exécution d'opérations de chaînes indépendantes de la culture</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-155">Performing Culture-Insensitive String Operations</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="stack.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="6e792-156">
            <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-156">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Stack" />.</span>
          </span>
          <span data-ttu-id="6e792-157">
            <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-157">The <see cref="T:System.Array" /> must have zero-based indexing.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="6e792-158">Index de base zéro dans un <c>tableau</c> auquel commencer la copie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-158">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6e792-159">Copie <see cref="T:System.Collections.Stack" /> dans un <see cref="T:System.Array" /> unidimensionnel existant commençant à l'index de tableau spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-159">Copies the <see cref="T:System.Collections.Stack" /> to an existing one-dimensional <see cref="T:System.Array" />, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-160">Les éléments sont copiés dans le tableau par ordre dernier-in-first-out (LIFO), similaire à celui des éléments retournés par une succession d’appels à <xref:System.Collections.Stack.Pop%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-160">The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to <xref:System.Collections.Stack.Pop%2A>.</span></span>  
  
 <span data-ttu-id="6e792-161">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-161">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-162">L’exemple suivant montre comment copier un <xref:System.Collections.Stack> dans un tableau unidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="6e792-162">The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.</span></span>  
  
 [!code-cpp[Classic Stack.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6e792-163">
            <paramref name="array" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-163">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="6e792-164">
            <paramref name="index" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-164">
              <paramref name="index" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6e792-165">
            <paramref name="array" /> est multidimensionnel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-165">
              <paramref name="array" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="6e792-166">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-166">-or-</span>
          </span>
          <span data-ttu-id="6e792-167">Le nombre d’éléments dans le <see cref="T:System.Collections.Stack" /> source est supérieur à la quantité d’espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-167">The number of elements in the source <see cref="T:System.Collections.Stack" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="6e792-168">Le type du <see cref="T:System.Collections.Stack" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-168">The type of the source <see cref="T:System.Collections.Stack" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Stack.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Stack.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6e792-169">Obtient le nombre d'éléments contenus dans le <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-169">Gets the number of elements contained in the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6e792-170">Nombre d'éléments contenus dans <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-170">The number of elements contained in the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-171">La capacité est le nombre d’éléments qui le <xref:System.Collections.Stack> peut stocker.</span><span class="sxs-lookup"><span data-stu-id="6e792-171">The capacity is the number of elements that the <xref:System.Collections.Stack> can store.</span></span> <span data-ttu-id="6e792-172"><xref:System.Collections.Stack.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-172"><xref:System.Collections.Stack.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="6e792-173">La capacité est toujours supérieure ou égale à <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-173">The capacity is always greater than or equal to <xref:System.Collections.Stack.Count%2A>.</span></span> <span data-ttu-id="6e792-174">Si <xref:System.Collections.Stack.Count%2A> dépasse la capacité lors de l’ajout d’éléments, la capacité est automatiquement augmentée en réallouant le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.</span><span class="sxs-lookup"><span data-stu-id="6e792-174">If <xref:System.Collections.Stack.Count%2A> exceeds the capacity while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</span></span>  
  
 <span data-ttu-id="6e792-175">La récupération de la valeur de cette propriété est une opération O(1).</span><span class="sxs-lookup"><span data-stu-id="6e792-175">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-176">Retourne <see cref="T:System.Collections.IEnumerator" /> pour l'objet <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-176">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-177">
            <see cref="T:System.Collections.IEnumerator" /> pour <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-177">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-178">(Visual Basic, c#)</span><span class="sxs-lookup"><span data-stu-id="6e792-178">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="6e792-179">L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.</span><span class="sxs-lookup"><span data-stu-id="6e792-179">The `foreach` statement of the C# language (`for each` in Visual Basic) hides the complexity of the enumerators.</span></span>  <span data-ttu-id="6e792-180">Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.</span><span class="sxs-lookup"><span data-stu-id="6e792-180">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="6e792-181">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="6e792-181">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="6e792-182">Au départ, l’énumérateur est positionné avant le premier élément de la collection.</span><span class="sxs-lookup"><span data-stu-id="6e792-182">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="6e792-183"><xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.</span><span class="sxs-lookup"><span data-stu-id="6e792-183"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="6e792-184">À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini.</span><span class="sxs-lookup"><span data-stu-id="6e792-184">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="6e792-185">Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-185">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="6e792-186"><xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé.</span><span class="sxs-lookup"><span data-stu-id="6e792-186"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="6e792-187"><xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-187"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="6e792-188">Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="6e792-188">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="6e792-189">Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`.</span><span class="sxs-lookup"><span data-stu-id="6e792-189">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="6e792-190">Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="6e792-190">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="6e792-191">Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-191">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="6e792-192">Un énumérateur est valide tant que la collection demeure inchangée.</span><span class="sxs-lookup"><span data-stu-id="6e792-192">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="6e792-193">Si des modifications sont apportées à la collection, telles que l'ajout, la modification ou la suppression d'éléments, l'énumérateur est définitivement invalidé et son comportement n'est pas défini.</span><span class="sxs-lookup"><span data-stu-id="6e792-193">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="6e792-194">Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6e792-194">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="6e792-195">Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.</span><span class="sxs-lookup"><span data-stu-id="6e792-195">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="6e792-196">Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</span><span class="sxs-lookup"><span data-stu-id="6e792-196">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="6e792-197">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-197">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Stack.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6e792-198">Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.Stack" /> est synchronisé (thread-safe).</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-198">Gets a value indicating whether access to the <see cref="T:System.Collections.Stack" /> is synchronized (thread safe).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6e792-199">
            <see langword="true" /> si l'accès à <see cref="T:System.Collections.Stack" /> est synchronisé (thread-safe) ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-199">
              <see langword="true" />, if access to the <see cref="T:System.Collections.Stack" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="6e792-200">La valeur par défaut est <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-200">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-201">Pour garantir la sécurité des threads de la <xref:System.Collections.Stack>, toutes les opérations doivent être effectuées via le wrapper retourné par la <xref:System.Collections.Stack.Synchronized%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="6e792-201">To guarantee the thread safety of the <xref:System.Collections.Stack>, all operations must be done through the wrapper returned by the <xref:System.Collections.Stack.Synchronized%2A> method.</span></span>  
  
 <span data-ttu-id="6e792-202">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6e792-202">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="6e792-203">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</span><span class="sxs-lookup"><span data-stu-id="6e792-203">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="6e792-204">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</span><span class="sxs-lookup"><span data-stu-id="6e792-204">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="6e792-205">L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Stack.SyncRoot%2A> pendant toute l’énumération.</span><span class="sxs-lookup"><span data-stu-id="6e792-205">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="6e792-206">La récupération de la valeur de cette propriété est une opération O(1).</span><span class="sxs-lookup"><span data-stu-id="6e792-206">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-207">L’exemple suivant montre comment synchroniser un <xref:System.Collections.Stack>, déterminer si un <xref:System.Collections.Stack> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-207">The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual object Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Peek();" />
      <MemberSignature Language="F#" Value="abstract member Peek : unit -&gt; obj&#xA;override this.Peek : unit -&gt; obj" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-208">Retourne l'objet situé en haut de <see cref="T:System.Collections.Stack" /> sans le supprimer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-208">Returns the object at the top of the <see cref="T:System.Collections.Stack" /> without removing it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-209">
            <see cref="T:System.Object" /> situé en haut de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-209">The <see cref="T:System.Object" /> at the top of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-210">Cette méthode est analogue à la méthode <xref:System.Collections.Stack.Pop%2A>, mais <xref:System.Collections.Stack.Peek%2A> ne modifie pas la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-210">This method is similar to the <xref:System.Collections.Stack.Pop%2A> method, but <xref:System.Collections.Stack.Peek%2A> does not modify the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="6e792-211">`null` peut être placé le <xref:System.Collections.Stack> comme espace réservé, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="6e792-211">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="6e792-212">Pour faire la distinction entre une valeur null et la fin de la pile, vérifiez la <xref:System.Collections.Stack.Count%2A> propriété ou catch le <xref:System.InvalidOperationException>, qui est levé lorsque le <xref:System.Collections.Stack> est vide.</span><span class="sxs-lookup"><span data-stu-id="6e792-212">To distinguish between a null value and the end of the stack, check the <xref:System.Collections.Stack.Count%2A> property or catch the <xref:System.InvalidOperationException>, which is thrown when the <xref:System.Collections.Stack> is empty.</span></span>  
  
 <span data-ttu-id="6e792-213">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-213">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-214">L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Stack>, supprimer des éléments dans le <xref:System.Collections.Stack>, ou d’afficher l’élément en haut de la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-214">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6e792-215">La <see cref="T:System.Collections.Stack" /> est vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-215">The <see cref="T:System.Collections.Stack" /> is empty.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Stack.Pop" />
        <altmember cref="M:System.Collections.Stack.Push(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public virtual object Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Pop () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; obj&#xA;override this.Pop : unit -&gt; obj" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-216">Supprime et retourne l'objet en haut de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-216">Removes and returns the object at the top of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-217">
            <see cref="T:System.Object" /> supprimé du haut de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-217">The <see cref="T:System.Object" /> removed from the top of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-218">Cette méthode est analogue à la méthode <xref:System.Collections.Stack.Peek%2A>, mais <xref:System.Collections.Stack.Peek%2A> ne modifie pas la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-218">This method is similar to the <xref:System.Collections.Stack.Peek%2A> method, but <xref:System.Collections.Stack.Peek%2A> does not modify the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="6e792-219">`null` peut être placé le <xref:System.Collections.Stack> comme espace réservé, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="6e792-219">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="6e792-220">Pour faire la distinction entre une valeur null et la fin de la pile, vérifiez la <xref:System.Collections.Stack.Count%2A> propriété ou catch le <xref:System.InvalidOperationException>, qui est levé lorsque le <xref:System.Collections.Stack> est vide.</span><span class="sxs-lookup"><span data-stu-id="6e792-220">To distinguish between a null value and the end of the stack, check the <xref:System.Collections.Stack.Count%2A> property or catch the <xref:System.InvalidOperationException>, which is thrown when the <xref:System.Collections.Stack> is empty.</span></span>  
  
 <span data-ttu-id="6e792-221">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-221">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-222">L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Stack>, supprimer des éléments dans le <xref:System.Collections.Stack>, ou d’afficher l’élément en haut de la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-222">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="6e792-223">La <see cref="T:System.Collections.Stack" /> est vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-223">The <see cref="T:System.Collections.Stack" /> is empty.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Stack.Peek" />
        <altmember cref="M:System.Collections.Stack.Push(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public virtual void Push (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Push(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Push(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Push (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Push(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Push : obj -&gt; unit&#xA;override this.Push : obj -&gt; unit" Usage="stack.Push obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="6e792-224">
            <see cref="T:System.Object" /> sur lequel un push doit être exécuté dans <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-224">The <see cref="T:System.Object" /> to push onto the <see cref="T:System.Collections.Stack" />.</span>
          </span>
          <span data-ttu-id="6e792-225">La valeur peut être <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-225">The value can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6e792-226">Insère un objet en haut de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-226">Inserts an object at the top of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-227">Si <xref:System.Collections.Stack.Count%2A> est déjà égale à la capacité, la capacité de la <xref:System.Collections.Stack> est augmentée en réallouant automatiquement le tableau interne, et les éléments existants sont copiés vers le nouveau tableau avant le nouvel élément est ajouté.</span><span class="sxs-lookup"><span data-stu-id="6e792-227">If <xref:System.Collections.Stack.Count%2A> already equals the capacity, the capacity of the <xref:System.Collections.Stack> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</span></span>  
  
 <span data-ttu-id="6e792-228">`null` peut être placé le <xref:System.Collections.Stack> comme espace réservé, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="6e792-228">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="6e792-229">Il occupe une position de la pile et est traité comme n’importe quel objet.</span><span class="sxs-lookup"><span data-stu-id="6e792-229">It occupies a slot in the stack and is treated like any object.</span></span>  
  
 <span data-ttu-id="6e792-230">Si <xref:System.Collections.Stack.Count%2A> est inférieure à la capacité de la pile, <xref:System.Collections.Stack.Push%2A> est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-230">If <xref:System.Collections.Stack.Count%2A> is less than the capacity of the stack, <xref:System.Collections.Stack.Push%2A> is an O(1) operation.</span></span> <span data-ttu-id="6e792-231">Si la capacité doit être augmentée pour intégrer le nouvel élément <xref:System.Collections.Stack.Push%2A> devient un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-231">If the capacity needs to be increased to accommodate the new element, <xref:System.Collections.Stack.Push%2A> becomes an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-232">L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Stack>, supprimer des éléments dans le <xref:System.Collections.Stack>, ou d’afficher l’élément en haut de la <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-232">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Stack.Peek" />
        <altmember cref="M:System.Collections.Stack.Pop" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Stack Synchronized (System.Collections.Stack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Stack Synchronized(class System.Collections.Stack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Stack ^ Synchronized(System::Collections::Stack ^ stack);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Stack -&gt; System.Collections.Stack" Usage="System.Collections.Stack.Synchronized stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Stack</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Collections.Stack" />
      </Parameters>
      <Docs>
        <param name="stack">
          <span data-ttu-id="6e792-233">
            <see cref="T:System.Collections.Stack" /> à synchroniser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-233">The <see cref="T:System.Collections.Stack" /> to synchronize.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6e792-234">Retourne un wrapper synchronisé (thread-safe) pour <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-234">Returns a synchronized (thread safe) wrapper for the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-235">Wrapper synchronisé (thread-safe) autour de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-235">A synchronized wrapper around the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-236">Pour garantir la sécurité des threads de le <xref:System.Collections.Stack>, toutes les opérations doivent être effectuées via ce wrapper.</span><span class="sxs-lookup"><span data-stu-id="6e792-236">To guarantee the thread safety of the <xref:System.Collections.Stack>, all operations must be done through this wrapper.</span></span>  
  
 <span data-ttu-id="6e792-237">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6e792-237">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="6e792-238">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</span><span class="sxs-lookup"><span data-stu-id="6e792-238">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="6e792-239">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</span><span class="sxs-lookup"><span data-stu-id="6e792-239">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="6e792-240">L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Stack.SyncRoot%2A> pendant toute l’énumération.</span><span class="sxs-lookup"><span data-stu-id="6e792-240">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="6e792-241">Cette méthode est une opération o (1).</span><span class="sxs-lookup"><span data-stu-id="6e792-241">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-242">L’exemple suivant montre comment synchroniser un <xref:System.Collections.Stack>, déterminer si un <xref:System.Collections.Stack> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-242">The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6e792-243">
            <paramref name="stack" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-243">
              <paramref name="stack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Stack.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="6e792-244">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-244">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="6e792-245">
            <see cref="T:System.Object" /> pouvant être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-245">An <see cref="T:System.Object" /> that can be used to synchronize access to the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-246">Pour créer une version synchronisée de la <xref:System.Collections.Stack>, utilisez le <xref:System.Collections.Stack.Synchronized%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="6e792-246">To create a synchronized version of the <xref:System.Collections.Stack>, use the <xref:System.Collections.Stack.Synchronized%2A> method.</span></span> <span data-ttu-id="6e792-247">Toutefois, les classes dérivées peuvent fournir leur propre version synchronisée de la <xref:System.Collections.Stack> à l’aide de la <xref:System.Collections.Stack.SyncRoot%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="6e792-247">However, derived classes can provide their own synchronized version of the <xref:System.Collections.Stack> using the <xref:System.Collections.Stack.SyncRoot%2A> property.</span></span> <span data-ttu-id="6e792-248">Le code de synchronisation doit effectuer les opérations sur le <xref:System.Collections.Stack.SyncRoot%2A> de la <xref:System.Collections.Stack>, et non directement sur le <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="6e792-248">The synchronizing code must perform operations on the <xref:System.Collections.Stack.SyncRoot%2A> of the <xref:System.Collections.Stack>, not directly on the <xref:System.Collections.Stack>.</span></span> <span data-ttu-id="6e792-249">Cela garantit un bon fonctionnement des collections dérivées d’autres objets.</span><span class="sxs-lookup"><span data-stu-id="6e792-249">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="6e792-250">Plus précisément, il maintient une synchronisation correcte avec les autres threads qui pourraient modifier simultanément les <xref:System.Collections.Stack> objet.</span><span class="sxs-lookup"><span data-stu-id="6e792-250">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <xref:System.Collections.Stack> object.</span></span>  
  
 <span data-ttu-id="6e792-251">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</span><span class="sxs-lookup"><span data-stu-id="6e792-251">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="6e792-252">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</span><span class="sxs-lookup"><span data-stu-id="6e792-252">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="6e792-253">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</span><span class="sxs-lookup"><span data-stu-id="6e792-253">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="6e792-254">L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Stack.SyncRoot%2A> pendant toute l’énumération.</span><span class="sxs-lookup"><span data-stu-id="6e792-254">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="6e792-255">La récupération de la valeur de cette propriété est une opération O(1).</span><span class="sxs-lookup"><span data-stu-id="6e792-255">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6e792-256">Copie <see cref="T:System.Collections.Stack" /> vers un nouveau tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-256">Copies the <see cref="T:System.Collections.Stack" /> to a new array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6e792-257">Nouveau tableau contenant les copies des éléments de <see cref="T:System.Collections.Stack" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6e792-257">A new array containing copies of the elements of the <see cref="T:System.Collections.Stack" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e792-258">Les éléments sont copiés dans le tableau par ordre dernier-in-first-out (LIFO), similaire à celui des éléments retournés par une succession d’appels à <xref:System.Collections.Stack.Pop%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-258">The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to <xref:System.Collections.Stack.Pop%2A>.</span></span>  
  
 <span data-ttu-id="6e792-259">Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e792-259">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6e792-260">L’exemple suivant montre comment copier un <xref:System.Collections.Stack> dans un tableau unidimensionnel.</span><span class="sxs-lookup"><span data-stu-id="6e792-260">The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.</span></span>  
  
 [!code-cpp[Classic Stack.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.Stack.Pop" />
      </Docs>
    </Member>
  </Members>
</Type>