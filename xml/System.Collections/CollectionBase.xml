<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CollectionBase.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac509de5a8fc0b91651ca42d10dde326c186122e14a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">09de5a8fc0b91651ca42d10dde326c186122e14a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.CollectionBase">
          <source>Provides the <ph id="ph1">&lt;see langword="abstract" /&gt;</ph> base class for a strongly typed collection.</source>
          <target state="translated">Fournit la classe de base <ph id="ph1">&lt;see langword="abstract" /&gt;</ph> pour une collection fortement typée.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>A <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> instance is always modifiable.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> instance est toujours modifiable.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>See <ph id="ph1">&lt;xref:System.Collections.ReadOnlyCollectionBase&gt;</ph> for a read-only version of this class.</source>
          <target state="translated">Consultez <ph id="ph1">&lt;xref:System.Collections.ReadOnlyCollectionBase&gt;</ph> pour une version en lecture seule de cette classe.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> can hold.</source>
          <target state="translated">La capacité d’un <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> est le nombre d’éléments du <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Lorsque des éléments sont ajoutés à un <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>, la capacité est augmentée automatiquement par réallocation.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>The capacity can be decreased by setting the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">La capacité peut être diminuée en définissant le <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> propriété explicitement.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Statique public (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) de ce type sont thread-safe.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Il n'est pas garanti que les membres d'instance soient thread-safe.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for a <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>, but derived classes can create their own synchronized versions of the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> using the <ph id="ph3">&lt;see cref="P:System.Collections.ICollection.SyncRoot" /&gt;</ph> property.</source>
          <target state="translated">Cette implémentation ne fournit pas synchronisé wrapper (thread-safe) pour un <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>, mais les classes dérivées peuvent créer leurs propres versions synchronisées de la <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> à l’aide de la <ph id="ph3">&lt;see cref="P:System.Collections.ICollection.SyncRoot" /&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>This base class is provided to make it easier for implementers to create a strongly typed custom collection.</source>
          <target state="translated">Cette classe de base est fournie pour le rendre plus facile pour les implémenteurs afin de créer une collection personnalisée fortement typée.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.CollectionBase">
          <source>Implementers are encouraged to extend this base class instead of creating their own.</source>
          <target state="translated">Il est préférable d’étendre cette classe de base au lieu de créer leurs propres.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Collections.CollectionBase">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> class with the default initial capacity.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> avec la capacité initiale par défaut.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> can hold.</source>
          <target state="translated">La capacité d’un <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> est le nombre d’éléments qui le <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Lorsque des éléments sont ajoutés à un <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>, la capacité est automatiquement augmentée si nécessaire, en réallouant le tableau interne.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</source>
          <target state="translated">Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite d’avoir à effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Ce constructeur est une opération o (1).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.#ctor(System.Int32)">
          <source>The number of elements that the new list can initially store.</source>
          <target state="translated">Nombre d'éléments que la nouvelle liste peut initialement stocker.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> class with the specified capacity.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> avec la capacité spécifiée.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor(System.Int32)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> can hold.</source>
          <target state="translated">La capacité d’un <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> est le nombre d’éléments qui le <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor(System.Int32)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Lorsque des éléments sont ajoutés à un <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>, la capacité est automatiquement augmentée si nécessaire, en réallouant le tableau interne.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</source>
          <target state="translated">Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite d’avoir à effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.Capacity">
          <source>Gets or sets the number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> can contain.</source>
          <target state="translated">Obtient ou définit le nombre d'éléments que <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source>The number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> can contain.</source>
          <target state="translated">Nombre initial d'éléments que <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> peut contenir.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> can store.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> est le nombre d’éléments qui le <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> peut stocker.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> est le nombre d’éléments réellement contenus dans le <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> est toujours supérieur ou égal à <ph id="ph2">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source>If <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> dépasse <ph id="ph2">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> lors de l’ajout d’éléments, la capacité est automatiquement augmentée en réallouant le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source>The capacity can be decreased by setting the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">La capacité peut être diminuée en définissant le <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> propriété explicitement.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity.</source>
          <target state="translated">Lorsque la valeur de <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Capacity%2A&gt;</ph> est défini explicitement, le tableau interne est aussi réalloué pour prendre en compte la capacité spécifiée.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Capacity">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the new capacity.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est la nouvelle capacité.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.Capacity">
          <source><ph id="ph1">&lt;see cref="P:System.Collections.CollectionBase.Capacity" /&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</source>
          <target state="translated">La valeur affectée à <ph id="ph1">&lt;see cref="P:System.Collections.CollectionBase.Capacity" /&gt;</ph> est inférieure à <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.Capacity">
          <source>There is not enough memory available on the system.</source>
          <target state="translated">Il n’y a pas assez de mémoire disponible sur le système.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.Clear">
          <source>Removes all objects from the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Supprime tous les objets de l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.Clear">
          <source>This method cannot be overridden.</source>
          <target state="translated">Cette méthode ne peut pas être substituée.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> is set to zero.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> est égale à zéro.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.Clear">
          <source>To perform custom actions before or after the collection is cleared, override the protected <ph id="ph1">&lt;xref:System.Collections.CollectionBase.OnClear%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.CollectionBase.OnClearComplete%2A&gt;</ph> method.</source>
          <target state="translated">Pour effectuer des actions personnalisées avant ou après l’effacement de la collection, substituez la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.OnClear%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.CollectionBase.OnClearComplete%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Obtient le nombre d'éléments contenus dans l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.Count">
          <source>This property cannot be overridden.</source>
          <target state="translated">Cette propriété ne peut pas être remplacée.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Count">
          <source>The number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Nombre d'éléments contenus dans l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.Count">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Retourne un énumérateur qui itère au sein de l'instance <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> pour l'instance du <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">(Visual Basic, c#)</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">L'instruction <ph id="ph1">`foreach`</ph> du langage C# (<ph id="ph2">`for each`</ph> en Visual Basic) se charge de la complexité des énumérateurs.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Il est donc recommandé d'utiliser <ph id="ph1">`foreach`</ph> plutôt que de manipuler l'énumérateur directement.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Au départ, l’énumérateur est positionné avant le premier élément de la collection.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> replace également l'énumérateur à cette position.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>At this position, calling <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">À cette position, l’appel <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> lève une exception.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Par conséquent, vous devez appeler <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retourne le même objet tant que <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> n'est pas appelé.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> affecte l'élément suivant à <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retourne <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Lorsque l’énumérateur est à cette position, les appels suivants à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> également retourner <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, calling <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">Si le dernier appel à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retourné <ph id="ph2">`false`</ph>, l’appel <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> lève une exception.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Pour attribuer une nouvelle fois <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> au premier élément de la collection, vous pouvez appeler <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> suivi de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un énumérateur est valide tant que la collection demeure inchangée.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> lève une <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>If the collection is modified between <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">Si la collection est modifiée entre <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retourne l’élément auquel il est attribué, même si l’énumérateur est déjà invalidé.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumérateur ne dispose pas d’un accès exclusif à la collection. Par conséquent, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>While the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.GetEnumerator%2A&gt;</ph> method is not visible to COM clients by default, inheriting the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> class can expose it and can cause undesirable behavior in COM clients.</source>
          <target state="translated">Alors que le <ph id="ph1">&lt;xref:System.Collections.CollectionBase.GetEnumerator%2A&gt;</ph> méthode n’est pas visible pour les clients COM par défaut, qui héritent la <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe peut l’exposer et provoquer un comportement indésirable dans les clients COM.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.GetEnumerator">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.InnerList">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> containing the list of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Obtient <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> contenant la liste des éléments dans l'instance de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.InnerList">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> representing the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance itself.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph> représentant l'instance de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> elle-même.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.InnerList">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.InnerList">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.List">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> containing the list of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Obtient <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> contenant la liste des éléments dans l'instance de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.List">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> representing the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance itself.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> représentant l'instance de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> elle-même.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.List">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.List">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.List">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnClear">
          <source>Performs additional custom processes when clearing the contents of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires lors de l'effacement du contenu de l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action before the collection is cleared.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action avant que la collection est effacée.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>If the process fails, the collection reverts back to its previous state.</source>
          <target state="translated">Si le processus échoue, la collection revient à son état précédent.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>This method allows implementers to define processes that must be performed before deleting all the elements from the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être effectuées avant de supprimer tous les éléments sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnClear" /&gt;</ph> is invoked before the standard Clear behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnClearComplete" /&gt;</ph> is invoked after the standard Clear behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnClear" /&gt;</ph> est appelé avant le comportement Clear standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnClearComplete" /&gt;</ph> est appelé après le comportement Clear standard.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClear">
          <source>For example, implementers can exempt certain elements from deletion by a global Clear.</source>
          <target state="translated">Par exemple, les implémenteurs peuvent exempter certains éléments de la suppression par un Clear global.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source>Performs additional custom processes after clearing the contents of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires après l'effacement du contenu de l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action after the collection is cleared.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action après l’effacement de la collection.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source>This method allows implementers to define processes that must be performed after deleting all the elements from the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être exécutés après la suppression de tous les éléments sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnClearComplete">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnClear" /&gt;</ph> is invoked before the standard Clear behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnClearComplete" /&gt;</ph> is invoked after the standard Clear behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnClear" /&gt;</ph> est appelé avant le comportement Clear standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnClearComplete" /&gt;</ph> est appelé après le comportement Clear standard.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>The zero-based index at which to insert <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Index de base zéro au niveau duquel insérer <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>The new value of the element at <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Nouvelle valeur de l’élément à la position <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>Performs additional custom processes before inserting a new element into the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute les processus personnalisés supplémentaires avant l'insertion d'un nouvel élément dans l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is inserted.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action avant l’insertion de l’élément spécifié.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>If the process fails, the collection reverts back to its previous state.</source>
          <target state="translated">Si le processus échoue, la collection revient à son état précédent.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>This method allows implementers to define processes that must be performed before inserting the element into the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus doivent être effectuées avant l’insertion de l’élément sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph> is invoked before the standard Insert behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph> is invoked after the standard Insert behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph> est appelé avant le comportement Insert standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph> est appelé après le comportement d’insertion standard.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source>For example, implementers can restrict which types of objects can be inserted into the <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Par exemple, les implémenteurs peuvent restreindre les types d’objets peuvent être insérées dans la <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> is called prior to this method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> est appelé avant cette méthode.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The zero-based index at which to insert <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Index de base zéro au niveau duquel insérer <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The new value of the element at <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Nouvelle valeur de l’élément à la position <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>Performs additional custom processes after inserting a new element into the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute les processus personnalisés supplémentaires après l'insertion d'un nouvel élément dans l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is inserted.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action après l’insertion de l’élément spécifié.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The collection reverts back to its previous state if one of the following occurs:</source>
          <target state="translated">La collection retrouve son état précédent si une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The process fails.</source>
          <target state="translated">Le processus échoue.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>This method is overridden to throw an exception.</source>
          <target state="translated">Cette méthode est substituée pour lever une exception.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>This method allows implementers to define processes that must be performed after inserting the element into the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être exécutés après l’insertion de l’élément sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph> is invoked before the standard Insert behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph> is invoked after the standard Insert behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph> est appelé avant le comportement Insert standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph> est appelé après le comportement d’insertion standard.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> can be found.</source>
          <target state="translated">Index de base zéro au niveau duquel se trouve <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>The value of the element to remove from <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valeur de l’élément à supprimer d’<bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>Performs additional custom processes when removing an element from the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires lors de la suppression d'un élément de l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is removed.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action avant la suppression de l’élément spécifié.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>If the process fails, the collection reverts back to its previous state.</source>
          <target state="translated">Si le processus échoue, la collection revient à son état précédent.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>This method allows implementers to define processes that must be performed before removing the element from the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être effectuées avant de supprimer l’élément sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph> is invoked before the standard Remove behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph> is invoked after the standard Remove behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph> est appelé avant le comportement Remove standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph> est appelé après le comportement Remove standard.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source>For example, implementers can prevent removal of elements by always throwing an exception in <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Par exemple, les implémenteurs peuvent interdire la suppression d’éléments en levant systématiquement une exception dans <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> is called prior to this method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> est appelé avant cette méthode.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> can be found.</source>
          <target state="translated">Index de base zéro au niveau duquel se trouve <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The value of the element to remove from <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valeur de l’élément à supprimer d’<bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>Performs additional custom processes after removing an element from the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires après la suppression d'un élément de l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is removed.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action après la suppression de l’élément spécifié.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The collection reverts back to its previous state if one of the following occurs:</source>
          <target state="translated">La collection retrouve son état précédent si une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The process fails.</source>
          <target state="translated">Le processus échoue.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>This method is overridden to throw an exception.</source>
          <target state="translated">Cette méthode est substituée pour lever une exception.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>This method allows implementers to define processes that must be performed after removing the element from the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être effectuées après la suppression de l’élément sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph> is invoked before the standard Remove behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph> is invoked after the standard Remove behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph> est appelé avant le comportement Remove standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph> est appelé après le comportement Remove standard.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept> can be found.</source>
          <target state="translated">Index de base zéro au niveau duquel se trouve <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The value to replace with <bpt id="p1">&lt;c&gt;</bpt>newValue<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valeur à remplacer par <bpt id="p1">&lt;c&gt;</bpt>newValue<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The new value of the element at <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Nouvelle valeur de l’élément à la position <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>Performs additional custom processes before setting a value in the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires avant la définition d'une valeur dans l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action before the specified element is set.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action avant que l’élément spécifié est défini.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>If the process fails, the collection reverts back to its previous state.</source>
          <target state="translated">Si le processus échoue, la collection revient à son état précédent.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>This method allows implementers to define processes that must be performed before setting the specified element in the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être effectuées avant de définir l’élément spécifié dans l’objet sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph> is invoked before the standard Set behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /&gt;</ph> is invoked after the standard Set behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph> est appelé avant le comportement Set standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /&gt;</ph> est appelé après le comportement Set standard.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source>For example, implementers can restrict which values can be overwritten by performing a check inside <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Par exemple, les implémenteurs peuvent restreindre les valeurs peuvent être substituées en effectuant une vérification à l’intérieur de <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> is called prior to this method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> est appelé avant cette méthode.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept> can be found.</source>
          <target state="translated">Index de base zéro au niveau duquel se trouve <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The value to replace with <bpt id="p1">&lt;c&gt;</bpt>newValue<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valeur à remplacer par <bpt id="p1">&lt;c&gt;</bpt>newValue<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The new value of the element at <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Nouvelle valeur de l’élément à la position <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>Performs additional custom processes after setting a value in the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires après la définition d'une valeur dans l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The default implementation of this method is intended to be overridden by a derived class to perform some action after the specified element is set.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est destinée à être substituée par une classe dérivée pour effectuer une action après que l’élément spécifié est défini.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The collection reverts back to its previous state if one of the following occurs:</source>
          <target state="translated">La collection retrouve son état précédent si une des actions suivantes se produit :</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The process fails.</source>
          <target state="translated">Le processus échoue.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>This method is overridden to throw an exception.</source>
          <target state="translated">Cette méthode est substituée pour lever une exception.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>This method allows implementers to define processes that must be performed after setting the specified element in the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être exécutés après la définition de l’élément spécifié dans l’objet sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph> is invoked before the standard Set behavior, whereas <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /&gt;</ph> is invoked after the standard Set behavior.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph> est appelé avant le comportement Set standard, tandis que <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /&gt;</ph> est appelé après le comportement Set standard.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>The object to validate.</source>
          <target state="translated">Objet à valider.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>Performs additional custom processes when validating a value.</source>
          <target state="translated">Exécute des processus personnalisés supplémentaires lors de la validation d'une valeur.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>The default implementation of this method determines whether <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, and, if so, throws <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">L’implémentation par défaut de cette méthode détermine si <ph id="ph1">`value`</ph> est <ph id="ph2">`null`</ph>et, si tel est le cas, lève <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>It is intended to be overridden by a derived class to perform additional action when the specified element is validated.</source>
          <target state="translated">Elle est destinée à être substituée par une classe dérivée pour effectuer une action supplémentaire lorsque l’élément spécifié est validé.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>The On* methods are invoked only on the instance returned by the <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> property, but not on the instance returned by the <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> property.</source>
          <target state="translated">Les méthodes On * sont uniquement appelées sur l’instance retournée par la <ph id="ph1">&lt;xref:System.Collections.CollectionBase.List%2A&gt;</ph> propriété, mais pas sur l’instance retournée par la <ph id="ph2">&lt;xref:System.Collections.CollectionBase.InnerList%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>The default implementation of this method is an O(1) operation.</source>
          <target state="translated">L’implémentation par défaut de cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>This method allows implementers to define processes that must be performed when executing the standard behavior of the underlying <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">Cette méthode permet aux implémenteurs de définir des processus qui doivent être effectuées lors de l’exécution le comportement standard de sous-jacent <ph id="ph1">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>By defining this method, implementers can add functionality to inherited methods without having to override all other methods.</source>
          <target state="translated">En définissant cette méthode, les implémenteurs peuvent ajouter des fonctionnalités aux méthodes héritées sans avoir à remplacer toutes les autres méthodes.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> can be used to impose restrictions on the type of objects that are accepted into the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> peut être utilisé pour imposer des restrictions sur le type des objets qui sont acceptés dans la collection.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source>The default implementation prevents <ph id="ph1">&lt;see langword="null" /&gt;</ph> from being added to or removed from the underlying <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</source>
          <target state="translated">L’implémentation par défaut empêche <ph id="ph1">&lt;see langword="null" /&gt;</ph> d’être ajouté ou supprimé sous-jacent <ph id="ph2">&lt;see cref="T:System.Collections.ArrayList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.OnValidate(System.Object)">
          <source><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> is called prior to <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>, and <ph id="ph4">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph> est appelé avant <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>, et <ph id="ph4">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>The zero-based index of the element to remove.</source>
          <target state="translated">Index de base zéro de l'élément à supprimer.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>Removes the element at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> instance.</source>
          <target state="translated">Supprime l'élément à l'index spécifié de l'instance de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>This method is not overridable.</source>
          <target state="translated">Cette méthode n'est pas substituable.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Dans des collections d’éléments contigus, telles que les listes, les éléments qui suivent l’élément supprimé remontent pour occuper l’espace libéré.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la collection est indexée, les index des éléments déplacés sont également mis à jour.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.RemoveAt(System.Int32)">
          <source>This method calls <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Cette méthode appelle <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>, et <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui constitue la destination des éléments copiés à partir de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> doit avoir une indexation de base zéro.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Index de base zéro dans un <bpt id="p1">&lt;c&gt;</bpt>tableau<ept id="p1">&lt;/c&gt;</ept> auquel commencer la copie.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copie l'ensemble de l'objet <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> vers un objet <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel compatible, en commençant à l'index spécifié du tableau cible.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">Le tableau spécifié doit être d’un type compatible.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Cette méthode utilise <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> pour copier les éléments.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> source est supérieur à la quantité d’espace disponible entre <ph id="ph2">&lt;paramref name="index" /&gt;</ph> et la fin du <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le type du <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> source ne peut pas être converti automatiquement en type du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Obtient une valeur indiquant si l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est synchronisé (thread-safe).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'accès à <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est synchronisé (thread-safe) ; sinon <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>A <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> instance is not synchronized.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> instance n’est pas synchronisée.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>Derived classes can provide a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Les classes dérivées peuvent fournir une version synchronisée de la <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">L’exemple de code suivant montre comment verrouiller la collection à l’aide de la <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> pendant l’énumération entière :</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated">Objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>Derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Classes dérivées peuvent produire leur propre version synchronisée de la <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</source>
          <target state="translated">Le code de synchronisation doit effectuer les opérations sur le <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> de la <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph>, et non directement sur le <ph id="ph3">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Cela garantit un bon fonctionnement des collections dérivées d’autres objets.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> object.</source>
          <target state="translated">Plus particulièrement, il maintient la synchronisation est assurée avec les autres threads qui pourraient modifier simultanément le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">L’exemple de code suivant montre comment verrouiller la collection à l’aide de la <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> pendant l’énumération entière :</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#ICollection#SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to be added to the end of the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> à ajouter à la fin de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>Adds an object to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated">Ajoute un objet à la fin de la <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> index at which the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> has been added.</source>
          <target state="translated">Index <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> auquel <ph id="ph2">&lt;paramref name="value" /&gt;</ph> a été ajouté.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> already equals the capacity, the capacity of the list is doubled by automatically reallocating the internal array and copying the existing elements to the new array before the new element is added.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> est déjà égale à la capacité, la capacité de la liste est doublée en réallouant le tableau interne et copie les éléments existants dans le nouveau tableau avant le nouvel élément est ajouté automatiquement.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> is less than the capacity, this method is an O(1) operation.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> est inférieur à la capacité, cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Si la capacité doit être augmentée pour intégrer le nouvel élément, cette méthode devient un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Add(System.Object)">
          <source>This method calls <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Cette méthode appelle <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph>, et <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> à rechercher dans <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> contains a specific element.</source>
          <target state="translated">Détermine si <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> contient un élément spécifique.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> contains the specified <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> contient le <ph id="ph3">&lt;paramref name="value" /&gt;</ph> spécifié ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cette méthode détermine l’égalité en appelant <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether <ph id="ph4">`item`</ph> exists.</source>
          <target state="translated">À compter de .NET Framework 2.0, cette méthode utilise les objets de la collection <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes sur <ph id="ph3">`item`</ph> pour déterminer si <ph id="ph4">`item`</ph> existe.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">`item`</ph> paramètre sur les objets dans la collection.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Contains(System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> à rechercher dans <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>Searches for the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and returns the zero-based index of the first occurrence within the entire <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated">Recherche le <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> spécifié et retourne l'index de base zéro de la première occurrence dans l'ensemble du <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Index de base zéro de la première occurrence de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> dans l'ensemble du <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>, s'il existe ; sinon, -1.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cette méthode détermine l’égalité en appelant <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether <ph id="ph4">`item`</ph> exists.</source>
          <target state="translated">À compter de .NET Framework 2.0, cette méthode utilise les objets de la collection <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes sur <ph id="ph3">`item`</ph> pour déterminer si <ph id="ph4">`item`</ph> existe.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> méthodes de la <ph id="ph3">`item`</ph> paramètre sur les objets dans la collection.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#IndexOf(System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Index de base zéro auquel la <bpt id="p1">&lt;c&gt;</bpt>valeur<ept id="p1">&lt;/c&gt;</ept> doit être insérée.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to insert.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> à insérer.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an element into the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> at the specified index.</source>
          <target state="translated">Insère un élément dans la classe <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> au niveau de l'index spécifié.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> already equals the capacity, the capacity of the list is doubled by automatically reallocating the internal array before the new element is inserted.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph> est déjà égale à la capacité, la capacité de la liste est doublée en réallouant automatiquement le tableau interne avant que le nouvel élément est inséré.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> is added to the end of <ph id="ph4">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`index`</ph> est égal à <ph id="ph2">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>, <ph id="ph3">`value`</ph> est ajouté à la fin de <ph id="ph4">&lt;xref:System.Collections.CollectionBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element.</source>
          <target state="translated">Dans des collections d'éléments contigus, telles que les listes, les éléments situés après le point d'insertion descendent afin de prendre en compte le nouvel élément.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la collection est indexée, les index des éléments déplacés sont également mis à jour.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur à <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This method calls <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Cette méthode appelle <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnInsert(System.Int32,System.Object)" /&gt;</ph>, et <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnInsertComplete(System.Int32,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est de taille fixe ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">Une collection de taille fixe ne permet pas l’ajout ou la suppression d’éléments après sa création, mais permet la modification des éléments existants.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Une collection de taille fixe est simplement une collection avec un wrapper qui empêche l’ajout et suppression d’éléments. Par conséquent, si des modifications sont apportées à la collection sous-jacente, y compris l’ajout ou la suppression d’éléments, la collection de taille fixe reflète ces modifications.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est en lecture seule ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>The zero-based index of the element to get or set.</source>
          <target state="translated">Index de base zéro de l'élément à obtenir ou à définir.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Obtient ou définit l'élément au niveau de l'index spécifié.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Élément au niveau de l'index spécifié.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
          <target state="translated">Cette propriété permet d'accéder à un élément spécifique de la collection à l'aide de la syntaxe suivante : <ph id="ph1">`myCollection[index]`</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est également une opération o (1).</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Collections.CollectionBase.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.CollectionBase.System#Collections#IList#Item(System.Int32)">
          <source>When this property is set, the methods <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /&gt;</ph> are called.</source>
          <target state="translated">Lorsque cette propriété est définie, les méthodes <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnSet(System.Int32,System.Object,System.Object)" /&gt;</ph>, et <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnSetComplete(System.Int32,System.Object,System.Object)" /&gt;</ph> sont appelées.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to remove from the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> à supprimer de <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</source>
          <target state="translated">Supprime la première occurrence d'un objet spécifique de <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> does not contain the specified object, the <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> remains unchanged.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> ne contient pas l’objet spécifié, le <ph id="ph2">&lt;xref:System.Collections.CollectionBase&gt;</ph> demeure inchangée.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">Aucune exception n'est levée.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.CollectionBase.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>This method determines equality by calling <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Cette méthode détermine l’égalité en appelant <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot.</source>
          <target state="translated">Dans des collections d’éléments contigus, telles que les listes, les éléments qui suivent l’élément supprimé remontent pour occuper l’espace libéré.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>If the collection is indexed, the indexes of the elements that are moved are also updated.</source>
          <target state="translated">Si la collection est indexée, les index des éléments déplacés sont également mis à jour.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>This behavior does not apply to collections where elements are conceptually grouped into buckets, such as a hash table.</source>
          <target state="translated">Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>The following code example implements the <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> class and uses that implementation to create a collection of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objects.</source>
          <target state="translated">Le code suivant exemple implémente le <ph id="ph1">&lt;xref:System.Collections.CollectionBase&gt;</ph> classe et utilise cette implémentation pour créer une collection de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter was not found in the <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> object.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="value" /&gt;</ph> est introuvable dans l'objet <ph id="ph2">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.CollectionBase" /&gt;</ph> est de taille fixe.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.CollectionBase.System#Collections#IList#Remove(System.Object)">
          <source>This method calls <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Cette méthode appelle <ph id="ph1">&lt;see cref="M:System.Collections.CollectionBase.OnValidate(System.Object)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Collections.CollectionBase.OnRemove(System.Int32,System.Object)" /&gt;</ph>, et <ph id="ph3">&lt;see cref="M:System.Collections.CollectionBase.OnRemoveComplete(System.Int32,System.Object)" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>