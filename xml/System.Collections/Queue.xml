<Type Name="Queue" FullName="System.Collections.Queue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="55d6be00e6a078b279a0a5ba7de350d9d7004b69" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52591932" /></Metadata><TypeSignature Language="C#" Value="public class Queue : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Queue" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue&#xA;Implements ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class Queue : ICloneable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Queue = class&#xA;    interface ICollection&#xA;    interface ICloneable&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une collection d’objets premier entré, premier sorti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

Cette classe implémente une file d’attente sous forme de tableau circulaire. Objets stockés dans un <xref:System.Collections.Queue> sont insérés à une extrémité et supprimés à l’autre.  

> [!IMPORTANT]
>  Nous ne vous recommandons d’utiliser la `Queue` classe pour tout nouveau développement. Au lieu de cela, nous vous recommandons d’utiliser le modèle générique <xref:System.Collections.Generic.Queue%601> classe. Pour plus d’informations, consultez [les collections Non génériques ne doit pas être utilisées](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) sur GitHub.

 Les piles et les files d’attente sont utiles lorsque vous avez besoin de stockage temporaire des informations ; Autrement dit, lorsque vous souhaitez ignorer un élément après avoir récupéré sa valeur. Utilisez <xref:System.Collections.Queue> si vous avez besoin accéder aux informations dans le même ordre que celui qu’elles sont stockées dans la collection. Utilisez <xref:System.Collections.Stack> si vous avez besoin accéder aux informations dans l’ordre inverse. Utilisez <xref:System.Collections.Concurrent.ConcurrentQueue%601> ou <xref:System.Collections.Concurrent.ConcurrentStack%601> si vous avez besoin pour accéder à la collection à partir de plusieurs threads simultanément.  
  
 Trois opérations principales peuvent être effectuées sur un <xref:System.Collections.Queue> et ses éléments :  
  
-   <xref:System.Collections.Queue.Enqueue%2A> Ajoute un élément à la fin de la <xref:System.Collections.Queue>.  
  
-   <xref:System.Collections.Queue.Dequeue%2A> Supprime l’élément le plus ancien à partir du début de la <xref:System.Collections.Queue>.  
  
-   <xref:System.Collections.Queue.Peek%2A> Retourne l’élément le plus ancien qui se trouve au début de la <xref:System.Collections.Queue> mais ne supprime ne pas de la <xref:System.Collections.Queue>.  
  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments du <xref:System.Collections.Queue> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Queue>, la capacité est automatiquement augmentée par réallocation.  La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 Le facteur de croissance est le nombre par lequel la capacité actuelle est multipliée lorsqu’une capacité supérieure est requise.  Le facteur de croissance est déterminé lorsque le <xref:System.Collections.Queue> est construit. Le facteur de croissance par défaut est 2.0. La capacité de la <xref:System.Collections.Queue> augmentera toujours d’au moins un minimum de quatre, quel que soit le facteur de croissance. Par exemple, un <xref:System.Collections.Queue> avec un facteur de croissance de 1.0 augmentera toujours de capacité par quatre lorsqu’une capacité supérieure est requise.  
  
 <xref:System.Collections.Queue> accepte `null` comme une valeur valide et autorise les éléments en double.  
  
 Pour la version générique de cette collection, consultez <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>  
  
   
  
## Examples  
 L’exemple suivant montre comment créer et ajouter des valeurs pour un <xref:System.Collections.Queue> et comment imprimer ses valeurs.  
  
 [!code-cpp[Classic Queue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  
  
Pour garantir la sécurité des threads de la <see cref="T:System.Collections.Queue" />, toutes les opérations doivent être effectuées via le wrapper retourné par la <see cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" /> (méthode).  
  
L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</threadsafe>
    <altmember cref="T:System.Collections.Generic.Queue`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Queue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Queue" /> qui est vide, possède la capacité initiale par défaut et utilise le facteur de croissance par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments du <xref:System.Collections.Queue> peut contenir.  Comme les éléments sont ajoutés à un <xref:System.Collections.Queue>, la capacité est automatiquement augmentée par réallocation.  La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 Le facteur de croissance est le nombre par lequel la capacité actuelle est multipliée lorsqu’une capacité supérieure est requise.  Le facteur de croissance est déterminé lorsque le <xref:System.Collections.Queue> est construit.  
  
 Ce constructeur est une opération o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.ICollection col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (col As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(System::Collections::ICollection ^ col);" />
      <MemberSignature Language="F#" Value="new System.Collections.Queue : System.Collections.ICollection -&gt; System.Collections.Queue" Usage="new System.Collections.Queue col" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="col" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="col"><see cref="T:System.Collections.ICollection" /> à partir duquel les éléments sont copiés.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Queue" /> qui contient des éléments copiés à partir de la collection spécifiée, possède la capacité initiale correspondant au nombre d'éléments copiés et utilise le facteur de croissance par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments du <xref:System.Collections.Queue> peut contenir.  Comme les éléments sont ajoutés à un <xref:System.Collections.Queue>, la capacité est automatiquement augmentée par réallocation.  La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 Le facteur de croissance est le nombre par lequel la capacité actuelle est multipliée lorsqu’une capacité supérieure est requise.  Le facteur de croissance est déterminé lorsque le <xref:System.Collections.Queue> est construit.  
  
 Les éléments sont copiés dans le <xref:System.Collections.Queue> dans le même ordre qu’ils sont lus par le <xref:System.Collections.IEnumerator> de la <xref:System.Collections.ICollection>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `col`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="col" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Queue : int -&gt; System.Collections.Queue" Usage="new System.Collections.Queue capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre initial d'éléments que <see cref="T:System.Collections.Queue" /> peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Queue" /> qui est vide, possède la capacité initiale spécifiée et utilise le facteur de croissance par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments du <xref:System.Collections.Queue> peut contenir.  Comme les éléments sont ajoutés à un <xref:System.Collections.Queue>, la capacité est automatiquement augmentée par réallocation.  La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 Le facteur de croissance est le nombre par lequel la capacité actuelle est multipliée lorsqu’une capacité supérieure est requise.  Le facteur de croissance est déterminé lorsque le <xref:System.Collections.Queue> est construit.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Queue>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity, float growFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 growFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, growFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity, float growFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Queue : int * single -&gt; System.Collections.Queue" Usage="new System.Collections.Queue (capacity, growFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="growFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre initial d'éléments que <see cref="T:System.Collections.Queue" /> peut contenir.</param>
        <param name="growFactor">Facteur d'augmentation de la capacité de <see cref="T:System.Collections.Queue" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Queue" /> qui est vide, possède la capacité initiale spécifiée et utilise le facteur de croissance spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments du <xref:System.Collections.Queue> peut contenir.  Comme les éléments sont ajoutés à un <xref:System.Collections.Queue>, la capacité est automatiquement augmentée par réallocation.  La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 Le facteur de croissance est le nombre par lequel la capacité actuelle est multipliée lorsqu’une capacité supérieure est requise.  Le facteur de croissance est déterminé lorsque le <xref:System.Collections.Queue> est construit. La capacité de la <xref:System.Collections.Queue> augmentera toujours par une valeur minimale, quel que soit le facteur de croissance ; un facteur de croissance de 1.0 n’empêchera pas le <xref:System.Collections.Queue> à partir de l’augmentation de taille.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Queue>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="growFactor" /> est inférieur à 1.0 ou supérieur à 10.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="queue.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les objets du <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Queue.Count%2A> est défini sur zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées.  
  
 La capacité reste inchangée. Pour rétablir la capacité de la <xref:System.Collections.Queue>, appelez <xref:System.Collections.Queue.TrimToSize%2A>. Suppression vide <xref:System.Collections.Queue> définit la capacité de la <xref:System.Collections.Queue> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment effacer les valeurs de la <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Queue.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="queue.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle de <see cref="T:System.Collections.Queue" />.</summary>
        <returns>Copie superficielle de <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie superficielle d’une collection copie uniquement les éléments de la collection, si elles sont des types référence ou types valeur, mais il ne copie pas les objets qui la fait référence à. Les références dans la nouvelle collection pointent vers les mêmes objets que les références dans la collection d’origine pointent vers.  
  
 En revanche, une copie complète d’une collection copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="queue.Contains obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Object" /> à rechercher dans <see cref="T:System.Collections.Queue" />. La valeur peut être <see langword="null" />.</param>
        <summary>Détermine si le <see cref="T:System.Collections.Queue" /> contient un élément.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> existe dans <see cref="T:System.Collections.Queue" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité en appelant <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `obj` pour déterminer si `item` existe. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `obj` paramètre sur les objets dans la collection.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Exécution d'opérations de chaînes indépendantes de la culture</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="queue.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Queue" />. Le <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="index">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie les éléments <see cref="T:System.Collections.Queue" /> dans un <see cref="T:System.Array" /> unidimensionnel existant, en commençant au niveau de l'index de tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.Queue>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment copier un <xref:System.Collections.Queue> dans un tableau unidimensionnel.  
  
 [!code-cpp[Classic Queue.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> est multidimensionnel.  
  
- ou - 
Le nombre d’éléments dans le <see cref="T:System.Collections.Queue" /> source est supérieur à la quantité d’espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Le type du <see cref="T:System.Collections.Queue" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Queue.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans le <see cref="T:System.Collections.Queue" />.</summary>
        <value>Nombre d'éléments contenus dans <see cref="T:System.Collections.Queue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments qui le <xref:System.Collections.Queue> peut stocker. <xref:System.Collections.Queue.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Queue>.  
  
 La capacité d’un <xref:System.Collections.Queue> est toujours supérieure ou égale à <xref:System.Collections.Queue.Count%2A>. Si <xref:System.Collections.Queue.Count%2A> dépasse la capacité lors de l’ajout d’éléments, la capacité est automatiquement augmentée en réallouant le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments. La nouvelle capacité est déterminée en multipliant la capacité actuelle par le facteur de croissance, qui est déterminée lorsque le <xref:System.Collections.Queue> est construit. La capacité de la <xref:System.Collections.Queue> augmentera toujours par une valeur minimale, quel que soit le facteur de croissance ; un facteur de croissance de 1.0 n’empêchera pas le <xref:System.Collections.Queue> à partir de l’augmentation de taille.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public virtual object Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Dequeue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Dequeue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Dequeue();" />
      <MemberSignature Language="F#" Value="abstract member Dequeue : unit -&gt; obj&#xA;override this.Dequeue : unit -&gt; obj" Usage="queue.Dequeue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime et renvoie l'objet au début de la <see cref="T:System.Collections.Queue" />.</summary>
        <returns>Objet supprimé du début de la <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est analogue à la méthode <xref:System.Collections.Queue.Peek%2A>, mais <xref:System.Collections.Queue.Peek%2A> ne modifie pas la <xref:System.Collections.Queue>.  
  
 `null` peut être ajouté à la <xref:System.Collections.Queue> en tant que valeur. Faire la distinction entre une valeur null et la fin de la <xref:System.Collections.Queue>, vérifiez le <xref:System.Collections.Queue.Count%2A> propriété ou catch le <xref:System.InvalidOperationException>, qui est levée si le <xref:System.Collections.Queue> est vide.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Queue>, supprimer des éléments dans le <xref:System.Collections.Queue>, ou d’afficher l’élément au début de la <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Collections.Queue" /> est vide.</exception>
        <altmember cref="M:System.Collections.Queue.Enqueue(System.Object)" />
        <altmember cref="M:System.Collections.Queue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public virtual void Enqueue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Enqueue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Enqueue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Enqueue (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Enqueue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Enqueue : obj -&gt; unit&#xA;override this.Enqueue : obj -&gt; unit" Usage="queue.Enqueue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à ajouter à <see cref="T:System.Collections.Queue" />. La valeur peut être <see langword="null" />.</param>
        <summary>Ajoute un objet à la fin de la <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Queue> est le nombre d’éléments du <xref:System.Collections.Queue> peut contenir.  Comme les éléments sont ajoutés à un <xref:System.Collections.Queue>, la capacité est automatiquement augmentée par réallocation.  La capacité peut être diminuée en appelant <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 Le facteur de croissance est le nombre par lequel la capacité actuelle est multipliée lorsqu’une capacité supérieure est requise.  Le facteur de croissance est déterminé lorsque le <xref:System.Collections.Queue> est construit. La capacité de la <xref:System.Collections.Queue> augmentera toujours par une valeur minimale, quel que soit le facteur de croissance ; un facteur de croissance de 1.0 n’empêchera pas le <xref:System.Collections.Queue> à partir de l’augmentation de taille.  
  
 Si <xref:System.Collections.Queue.Count%2A> est inférieure à la capacité du tableau interne, cette méthode est une opération o (1). Si le tableau interne doit être réalloué pour intégrer un nouvel élément, cette méthode devient un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Queue>, supprimer des éléments dans le <xref:System.Collections.Queue>, ou d’afficher l’élément au début de la <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Queue.Dequeue" />
        <altmember cref="M:System.Collections.Queue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="queue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de <see cref="T:System.Collections.Queue" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> pour <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l'ajout, la modification ou la suppression d'éléments, l'énumérateur est définitivement invalidé et son comportement n'est pas défini.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Queue.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.Queue" /> est synchronisé (thread-safe).</summary>
        <value><see langword="true" /> si l'accès à <see cref="T:System.Collections.Queue" /> est synchronisé (thread-safe) ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour garantir la sécurité des threads de la <xref:System.Collections.Queue>, toutes les opérations doivent être effectuées via le wrapper retourné par la <xref:System.Collections.Queue.Synchronized%2A> (méthode).  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Queue.SyncRoot%2A> pendant toute l’énumération. La récupération de la valeur de cette propriété est une opération O(1).  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 L’exemple suivant montre comment synchroniser un <xref:System.Collections.Queue>, déterminer si un <xref:System.Collections.Queue> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Queue.SyncRoot" />
        <altmember cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual object Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Peek();" />
      <MemberSignature Language="F#" Value="abstract member Peek : unit -&gt; obj&#xA;override this.Peek : unit -&gt; obj" Usage="queue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie l'objet situé au début de la <see cref="T:System.Collections.Queue" /> sans le supprimer.</summary>
        <returns>Objet situé au début de la <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est analogue à la méthode <xref:System.Collections.Queue.Dequeue%2A>, mais <xref:System.Collections.Queue.Peek%2A> ne modifie pas la <xref:System.Collections.Queue>.  
  
 `null` peut être ajouté à la <xref:System.Collections.Queue> en tant que valeur. Faire la distinction entre une valeur null et la fin de la <xref:System.Collections.Queue>, vérifiez le <xref:System.Collections.Queue.Count%2A> propriété ou catch le <xref:System.InvalidOperationException>, qui est levée si le <xref:System.Collections.Queue> est vide.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Queue>, supprimer des éléments dans le <xref:System.Collections.Queue>, ou d’afficher l’élément au début de la <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Collections.Queue" /> est vide.</exception>
        <altmember cref="M:System.Collections.Queue.Enqueue(System.Object)" />
        <altmember cref="M:System.Collections.Queue.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Queue Synchronized (System.Collections.Queue queue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Queue Synchronized(class System.Collections.Queue queue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Queue ^ Synchronized(System::Collections::Queue ^ queue);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Queue -&gt; System.Collections.Queue" Usage="System.Collections.Queue.Synchronized queue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Queue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queue" Type="System.Collections.Queue" />
      </Parameters>
      <Docs>
        <param name="queue"><see cref="T:System.Collections.Queue" /> à synchroniser.</param>
        <summary>Retourne un nouvel objet <see cref="T:System.Collections.Queue" /> thread-safe encapsulant la file d'attente d'origine.</summary>
        <returns>Wrapper <see cref="T:System.Collections.Queue" /> synchronisé (thread-safe).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le wrapper retourné par cette méthode verrouille la file d’attente avant une opération est effectuée afin qu’elle soit effectuée de manière thread-safe.  
  
 Pour garantir la sécurité des threads de le <xref:System.Collections.Queue>, toutes les opérations doivent être effectuées via ce wrapper uniquement.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Queue.SyncRoot%2A> pendant toute l’énumération. Cette méthode est une opération o (1).  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 L’exemple suivant montre comment synchroniser un <xref:System.Collections.Queue>, déterminer si un <xref:System.Collections.Queue> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="queue" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Queue.IsSynchronized" />
        <altmember cref="P:System.Collections.Queue.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Queue.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.Queue" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.Queue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer une version synchronisée de la <xref:System.Collections.Queue>, utilisez le <xref:System.Collections.Queue.Synchronized%2A> (méthode). Toutefois, les classes dérivées peuvent fournir leur propre version synchronisée de la <xref:System.Collections.Queue> à l’aide de la <xref:System.Collections.Queue.SyncRoot%2A> propriété. Le code de synchronisation doit effectuer les opérations sur le <xref:System.Collections.Queue.SyncRoot%2A> de la <xref:System.Collections.Queue>, et non directement sur le <xref:System.Collections.Queue>. Cela garantit un bon fonctionnement des collections dérivées d’autres objets. Plus précisément, il maintient une synchronisation correcte avec les autres threads qui pourraient modifier simultanément les <xref:System.Collections.Queue> objet.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Queue.SyncRoot%2A> pendant toute l’énumération. La récupération de la valeur de cette propriété est une opération O(1).  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Queue.IsSynchronized" />
        <altmember cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="queue.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie les éléments <see cref="T:System.Collections.Queue" /> vers un nouveau tableau.</summary>
        <returns>Nouveau tableau contenant les éléments copiés à partir de <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Queue> n’est pas modifié. L’ordre des éléments dans le nouveau tableau est le même que l’ordre des éléments à partir du début de la <xref:System.Collections.Queue> à sa fin.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment copier un <xref:System.Collections.Queue> dans un tableau unidimensionnel.  
  
 [!code-cpp[Classic Queue.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="queue.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit la capacité au nombre réel d'éléments dans <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour réduire la surcharge mémoire d’une file d’attente si aucun nouvel élément ne doit être ajouté à la file d’attente.  
  
 Pour réinitialiser un <xref:System.Collections.Queue> à son état initial, appelez le <xref:System.Collections.Queue.Clear%2A> méthode avant d’appeler <xref:System.Collections.Queue.TrimToSize%2A>. Suppression vide <xref:System.Collections.Queue> définit la capacité de la <xref:System.Collections.Queue> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Queue.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Queue" /> est en lecture seule.</exception>
        <altmember cref="M:System.Collections.Queue.Clear" />
        <altmember cref="P:System.Collections.Queue.Count" />
      </Docs>
    </Member>
  </Members>
</Type>