<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BitArray.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5056363895a01ed4f3d85a3d6c19a8aa8cb07f553.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">056363895a01ed4f3d85a3d6c19a8aa8cb07f553</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.BitArray">
          <source>Manages a compact array of bit values, which are represented as Booleans, where <ph id="ph1">&lt;see langword="true" /&gt;</ph> indicates that the bit is on (1) and <ph id="ph2">&lt;see langword="false" /&gt;</ph> indicates the bit is off (0).</source>
          <target state="translated">Gère un tableau compact de valeurs de bit représentées par des Boolean, où <ph id="ph1">&lt;see langword="true" /&gt;</ph> indique que le bit est activé (1) et <ph id="ph2">&lt;see langword="false" /&gt;</ph> indique que le bit est désactivé (0).</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>The <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> class is a collection class in which the capacity is always the same as the count.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> est une classe de collection dans laquelle la capacité est toujours identique au décompte.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Elements are added to a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> by increasing the <ph id="ph2">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> property; elements are deleted by decreasing the <ph id="ph3">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> property.</source>
          <target state="translated">Les éléments sont ajoutés à un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> en augmentant la <ph id="ph2">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> propriété ; éléments sont supprimés en diminuant la <ph id="ph3">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>The size of a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> is controlled by the client; indexing past the end of the <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph> throws an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.The <ph id="ph4">&lt;xref:System.Collections.BitArray&gt;</ph> class provides methods that are not found in other collections, including those that allow multiple elements to be modified at once using a filter, such as <ph id="ph5">&lt;xref:System.Collections.BitArray.And%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Collections.BitArray.Or%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Collections.BitArray.Xor%2A&gt;</ph> , <ph id="ph8">&lt;xref:System.Collections.BitArray.Not%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Collections.BitArray.SetAll%2A&gt;</ph>.</source>
          <target state="translated">La taille d’un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> est contrôlée par le client ; indexation au-delà de la fin de la <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph> lève une <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>. Le <ph id="ph4">&lt;xref:System.Collections.BitArray&gt;</ph> classe fournit des méthodes qui ne figurent pas dans d’autres collections, notamment celles qui autorisent plusieurs éléments peuvent être modifiés à la fois en utilisant un filtre, tel que <ph id="ph5">&lt;xref:System.Collections.BitArray.And%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Collections.BitArray.Or%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Collections.BitArray.Xor%2A&gt;</ph> , <ph id="ph8">&lt;xref:System.Collections.BitArray.Not%2A&gt;</ph>et <ph id="ph9">&lt;xref:System.Collections.BitArray.SetAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> class is a structure that provides the same functionality as <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph>, but with faster performance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> classe est une structure qui fournit les mêmes fonctionnalités que <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph>, mais avec de meilleures performances.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source><ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> is faster because it is a value type and therefore allocated on the stack, whereas <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph> is a reference type and, therefore, allocated on the heap.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> est plus rapide, car il s’agit d’un type valeur et par conséquent allouées sur la pile, alors que <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph> est un type référence et, par conséquent, alloués sur le tas.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source><ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32?displayProperty=nameWithType&gt;</ph> can store exactly 32 bits, whereas <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph> can store a variable number of bits.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32?displayProperty=nameWithType&gt;</ph> peut stocker 32 bits exactement, alors que <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph> peut stocker un nombre variable de bits.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source><ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> stores both bit flags and small integers, thereby making it ideal for data that is not exposed to the user.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> stocke les bits indicateurs et des petits entiers, ce qui le rend idéal pour les données qui ne sont pas exposées à l’utilisateur.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>However, if the number of required bit flags is unknown, is variable, or is greater than 32, use <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> instead.</source>
          <target state="translated">Toutefois, si le nombre de bits indicateurs requis est inconnu, variable ou supérieur à 32, utilisez <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> is in the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespace; <ph id="ph3">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> is in the <ph id="ph4">&lt;xref:System.Collections.Specialized&gt;</ph> namespace.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> est dans le <ph id="ph2">&lt;xref:System.Collections&gt;</ph> espace de noms ; <ph id="ph3">&lt;xref:System.Collections.Specialized.BitVector32&gt;</ph> est dans le <ph id="ph4">&lt;xref:System.Collections.Specialized&gt;</ph> espace de noms.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Elements in this collection can be accessed using an integer index.</source>
          <target state="translated">Éléments de cette collection est accessible à l’aide d’un index d’entiers.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Indexes in this collection are zero-based.</source>
          <target state="translated">Index de cette collection sont de base zéro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>The following code example shows how to create and initialize a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> and how to print out its values.</source>
          <target state="translated">L’exemple de code suivant montre comment créer et initialiser un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> et comment afficher ses valeurs.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Statique public (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) de ce type sont thread-safe.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Il n'est pas garanti que les membres d'instance soient thread-safe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for a <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Cette implémentation ne fournit pas synchronisé wrapper (thread-safe) pour un <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.BitArray">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="T:System.Collections.BitArray">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class whose capacity and initial values can be specified.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> dont la capacité et les valeurs initiales peuvent être spécifiées.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Boolean[])">
          <source>An array of Booleans to copy.</source>
          <target state="translated">Tableau de valeurs booléennes à copier.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Boolean[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class that contains bit values copied from the specified array of Booleans.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> qui contient des valeurs de bit copiées à partir du tableau de valeurs booléennes spécifié.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Boolean[])">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`values`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments dans <ph id="ph3">`values`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Boolean[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source>An array of bytes containing the values to copy, where each byte represents eight consecutive bits.</source>
          <target state="translated">Tableau d’octets contenant les valeurs à copier, dans lequel chaque octet représente huit bits consécutifs.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class that contains bit values copied from the specified array of bytes.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> qui contient des valeurs de bit copiées à partir du tableau d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source>The first byte in the array represents bits 0 through 7, the second byte represents bits 8 through 15, and so on.</source>
          <target state="translated">Le premier octet dans le tableau représente les bits 0 à 7, le deuxième octet représente les bits 8 à 15 et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source>The Least Significant Bit of each byte represents the lowest index value: " <ph id="ph1">`bytes`</ph> [0] &amp; 1" represents bit 0, " <ph id="ph2">`bytes`</ph> [0] &amp; 2" represents bit 1, " <ph id="ph3">`bytes`</ph> [0] &amp; 4" represents bit 2, and so on.</source>
          <target state="translated">Le Bit de poids faible de chaque octet représente la plus petite valeur d’index : « <ph id="ph1">`bytes`</ph> [0] &amp; 1 » représente le bit 0, « <ph id="ph2">`bytes`</ph> [0] &amp; 2" représente le bit 1, « <ph id="ph3">`bytes`</ph> [0] &amp; 4" représente le bit 2 et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`bytes`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments dans <ph id="ph3">`bytes`</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Byte[])">
          <source>The length of <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est supérieure à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Collections.BitArray)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> à copier.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Collections.BitArray)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class that contains bit values copied from the specified <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> qui contient des valeurs de bit copiées à partir du <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Collections.BitArray)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`bits`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments dans <ph id="ph3">`bits`</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="bits" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bits" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32)">
          <source>The number of bit values in the new <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Nombre de valeurs de bit dans le nouveau <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class that can hold the specified number of bit values, which are initially set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> qui peut contenir le nombre spécifié de valeurs de bit, dont la valeur initiale est <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source>An array of integers containing the values to copy, where each integer represents 32 consecutive bits.</source>
          <target state="translated">Tableau d’entiers contenant les valeurs à copier, où chaque entier représente 32 bits consécutifs.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class that contains bit values copied from the specified array of 32-bit integers.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> qui contient des valeurs de bits copiées à partir du tableau spécifié d’entiers 32 bits.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source>The number in the first <ph id="ph1">`values`</ph> array element represents bits 0 through 31, the second number in the array represents bits 32 through 63, and so on.</source>
          <target state="translated">Le numéro de la première <ph id="ph1">`values`</ph> élément du tableau représente les bits 0 à 31, le deuxième nombre dans le tableau représente les bits 32 à 63 et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source>The Least Significant Bit of each integer represents the lowest index value: " <ph id="ph1">`values`</ph> [0] &amp; 1" represents bit 0, " <ph id="ph2">`values`</ph> [0] &amp; 2" represents bit 1, " <ph id="ph3">`values`</ph> [0] &amp; 4" represents bit 2, and so on.</source>
          <target state="translated">Le Bit de poids faible de chaque entier représente la plus petite valeur d’index : « <ph id="ph1">`values`</ph> [0] &amp; 1 » représente le bit 0, « <ph id="ph2">`values`</ph> [0] &amp; 2" représente le bit 1, « <ph id="ph3">`values`</ph> [0] &amp; 4" représente le bit 2 et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`values`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est le nombre d’éléments dans <ph id="ph3">`values`</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="values" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32[])">
          <source>The length of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph></source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="values" /&gt;</ph> est supérieure à <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32,System.Boolean)">
          <source>The number of bit values in the new <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Nombre de valeurs de bit dans le nouveau <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32,System.Boolean)">
          <source>The Boolean value to assign to each bit.</source>
          <target state="translated">Valeur booléenne à affecter à chaque bit.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> class that can hold the specified number of bit values, which are initially set to the specified value.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> qui peut contenir le nombre spécifié de valeurs de bit auxquelles la valeur spécifiée est affectée initialement.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.#ctor(System.Int32,System.Boolean)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ce constructeur est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.#ctor(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>The array with which to perform the bitwise AND operation.</source>
          <target state="translated">Tableau utilisé pour exécuter l’opération AND au niveau du bit.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>Performs the bitwise AND operation between the elements of the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object and the corresponding elements in the specified array.</source>
          <target state="translated">Exécute l’opération AND au niveau du bit entre les éléments de l’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actuel et les éléments correspondants dans le tableau spécifié.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object will be modified to store the result of the bitwise AND operation.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actuel est modifié pour stocker le résultat de l’opération AND au niveau du bit.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>An array containing the result of the bitwise AND operation, which is a reference to the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object.</source>
          <target state="translated">Tableau qui contient le résultat de l’opération AND au niveau du bit, qui est une référence à l’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>The bitwise AND operation returns <ph id="ph1">`true`</ph> if both operands are <ph id="ph2">`true`</ph>, and returns <ph id="ph3">`false`</ph> if one or both operands are <ph id="ph4">`false`</ph>.</source>
          <target state="translated">L’opération AND au niveau du bit retourne <ph id="ph1">`true`</ph> si les deux opérandes sont <ph id="ph2">`true`</ph>et retourne <ph id="ph3">`false`</ph> si un ou deux opérandes sont <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source>The following code example shows how to perform the bitwise AND operation between two <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objects.</source>
          <target state="translated">L’exemple de code suivant montre comment effectuer l’opération AND au niveau du bit entre deux <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.And(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> and the current <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> do not have the same number of elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> et le <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actuel n’ont pas le même nombre d’éléments.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Crée une copie superficielle de <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Copie superficielle de <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Une copie superficielle d’une collection copie uniquement les éléments de la collection, si elles sont des types référence ou types valeur, mais elle ne copie pas les objets que les références.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">Les références dans la nouvelle collection désignent les mêmes objets que les références dans la collection d’origine à.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En revanche, une copie complète d’une collection copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel qui constitue la destination des éléments copiés à partir de <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> doit avoir une indexation de base zéro.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Index de base zéro dans un <bpt id="p1">&lt;c&gt;</bpt>tableau<ept id="p1">&lt;/c&gt;</ept> auquel commencer la copie.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> to a compatible one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at the specified index of the target array.</source>
          <target state="translated">Copie l'ensemble de l'objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> vers un objet <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> unidimensionnel compatible, en commençant à l'index spécifié du tableau cible.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The specified array must be of a compatible type.</source>
          <target state="translated">Le tableau spécifié doit être d’un type compatible.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>Only <ph id="ph1">`bool`</ph>, <ph id="ph2">`int`</ph>, and <ph id="ph3">`byte`</ph> types of arrays are supported.</source>
          <target state="translated">Uniquement <ph id="ph1">`bool`</ph>, <ph id="ph2">`int`</ph>, et <ph id="ph3">`byte`</ph> types de tableaux sont pris en charge.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Cette méthode utilise <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> pour copier les éléments.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment copier un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> dans une dimension <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> est multidimensionnel.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le nombre d’éléments dans le <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> source est supérieur à la quantité d’espace disponible entre <ph id="ph2">&lt;paramref name="index" /&gt;</ph> et la fin du <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Le type du <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> source ne peut pas être converti automatiquement en type du <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destination.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Obtient le nombre d'éléments contenus dans le <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Count">
          <source>The number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Nombre d'éléments contenus dans <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> return the same value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> retournent la même valeur.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> can be set to a specific value, but <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> peut être défini sur une valeur spécifique, mais <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source>The zero-based index of the value to get.</source>
          <target state="translated">Index de base zéro de la valeur à obtenir.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source>Gets the value of the bit at a specific position in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Obtient la valeur du bit à une position spécifique dans le <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source>The value of the bit at position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</source>
          <target state="translated">Valeur du bit à la position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source>The following code example shows how to set and get specific elements in a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir des éléments spécifiques un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Get(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than or equal to the number of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal au nombre d'éléments dans le <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Retourne un énumérateur qui itère au sein de <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the entire <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> pour l'intégralité de <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">L'instruction <ph id="ph1">`foreach`</ph> du langage C# (<ph id="ph2">`for each`</ph> en Visual Basic) se charge de la complexité des énumérateurs.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Il est donc recommandé d'utiliser <ph id="ph1">`foreach`</ph> plutôt que de manipuler l'énumérateur directement.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Au départ, l’énumérateur est positionné avant le premier élément de la collection.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> replace également l'énumérateur à cette position.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">À cette position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> n'est pas défini.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Par conséquent, vous devez appeler <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> retourne le même objet tant que <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> n'est pas appelé.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> affecte l'élément suivant à <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> dépasse la fin de la collection, l’énumérateur est placée après le dernier élément dans la collection et <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retourne <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Lorsque l’énumérateur est à cette position, les appels suivants à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> également retourner <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si le dernier appel à <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retourné <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> n’est pas défini.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Pour attribuer une nouvelle fois <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> au premier élément de la collection, vous pouvez appeler <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> suivi de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un énumérateur est valide tant que la collection demeure inchangée.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si des modifications sont apportées à la collection, telles que l'ajout, la modification ou la suppression d'éléments, l'énumérateur est définitivement invalidé et son comportement n'est pas défini.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsReadOnly">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Cette propriété a toujours la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsReadOnly">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.BitArray.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> implémente le <ph id="ph2">&lt;xref:System.Collections.BitArray.IsReadOnly%2A&gt;</ph> propriété car il est requis par le <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsReadOnly">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Obtient une valeur indiquant si l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> est synchronisé (thread-safe).</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Cette propriété a toujours la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.BitArray.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> implémente le <ph id="ph2">&lt;xref:System.Collections.BitArray.IsSynchronized%2A&gt;</ph> propriété car il est requis par le <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">L’exemple de code suivant montre comment verrouiller la collection à l’aide de la <ph id="ph1">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> pendant toute l’énumération.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.IsSynchronized">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>The zero-based index of the value to get or set.</source>
          <target state="translated">Index de base zéro de la valeur à obtenir ou définir.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>Gets or sets the value of the bit at a specific position in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit la valeur du bit à une position spécifique dans le <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>The value of the bit at position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</source>
          <target state="translated">Valeur du bit à la position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
          <target state="translated">Cette propriété permet d'accéder à un élément spécifique de la collection à l'aide de la syntaxe suivante : <ph id="ph1">`myCollection[index]`</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.BitArray.Item%2A&gt;</ph> property.</source>
          <target state="translated">Le langage c# utilise le mot clé pour définir les indexeurs au lieu d’implémenter la <ph id="ph1">&lt;xref:System.Collections.BitArray.Item%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.BitArray.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implémente <ph id="ph1">&lt;xref:System.Collections.BitArray.Item%2A&gt;</ph> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est également une opération o (1).</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.BitArray.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal à <ph id="ph2">&lt;see cref="P:System.Collections.BitArray.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Length">
          <source>Gets or sets the number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit le nombre d'éléments dans <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source>The number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Nombre d'éléments dans <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> return the same value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> retournent la même valeur.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> can be set to a specific value, but <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> peut être défini sur une valeur spécifique, mais <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph> est en lecture seule.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source>If <ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>, the <ph id="ph3">&lt;xref:System.Collections.BitArray&gt;</ph> is truncated and the elements after the index <ph id="ph4">`value`</ph> -1 are deleted.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> est défini sur une valeur qui est inférieure à <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>, le <ph id="ph3">&lt;xref:System.Collections.BitArray&gt;</ph> est tronqué et les éléments situés après l’index <ph id="ph4">`value`</ph> -1 sont supprimés.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source>If <ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> is set to a value that is greater than <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>, the new elements are set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.BitArray.Length%2A&gt;</ph> est défini sur une valeur qui est supérieure à <ph id="ph2">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>, les nouveaux éléments sont la valeur <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.Length">
          <source>Setting this property is an O(<ph id="ph1">`n`</ph>) operation.</source>
          <target state="translated">Définition de cette propriété est un O (<ph id="ph1">`n`</ph>) opération.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.Length">
          <source>The property is set to a value that is less than zero.</source>
          <target state="translated">La valeur affectée à la propriété est inférieure à 0.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Not">
          <source>Inverts all the bit values in the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>, so that elements set to <ph id="ph2">&lt;see langword="true" /&gt;</ph> are changed to <ph id="ph3">&lt;see langword="false" /&gt;</ph>, and elements set to <ph id="ph4">&lt;see langword="false" /&gt;</ph> are changed to <ph id="ph5">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Inverse toutes les valeurs de bits dans le <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> en cours, de sorte que les éléments ayant la valeur <ph id="ph2">&lt;see langword="true" /&gt;</ph> prennent la valeur <ph id="ph3">&lt;see langword="false" /&gt;</ph> et que les éléments ayant la valeur <ph id="ph4">&lt;see langword="false" /&gt;</ph> prennent la valeur <ph id="ph5">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Not">
          <source>The current instance with inverted bit values.</source>
          <target state="translated">L'instance actuelle comportant des valeurs de bit inversées.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Not">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Not">
          <source>The following code example shows how to apply NOT to a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment s’appliquent pas à un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>The array with which to perform the bitwise OR operation.</source>
          <target state="translated">Tableau utilisé pour exécuter l’opération OR au niveau du bit.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>Performs the bitwise OR operation between the elements of the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object and the corresponding elements in the specified array.</source>
          <target state="translated">Exécute l’opération OR au niveau du bit entre les éléments de l’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actif et les éléments correspondants dans le tableau spécifié.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object will be modified to store the result of the bitwise OR operation.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actif est modifié pour stocker le résultat de l’opération OR au niveau du bit.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>An array containing the result of the bitwise OR operation, which is a reference to the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object.</source>
          <target state="translated">Tableau qui contient le résultat de l’opération OR au niveau du bit, qui est une référence à l’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actif.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>The bitwise OR operation returns <ph id="ph1">`true`</ph> if one or both operands are <ph id="ph2">`true`</ph>, and returns <ph id="ph3">`false`</ph> if both operands are <ph id="ph4">`false`</ph>.</source>
          <target state="translated">L’opération OR au niveau du bit retourne <ph id="ph1">`true`</ph> si un ou deux opérandes sont <ph id="ph2">`true`</ph>et retourne <ph id="ph3">`false`</ph> si les deux opérandes sont <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source>The following code example shows how to perform the OR operation between two <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objects.</source>
          <target state="translated">L’exemple de code suivant montre comment effectuer l’opération OR entre deux <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Or(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> and the current <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> do not have the same number of elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> et le <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actuel n’ont pas le même nombre d’éléments.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source>The zero-based index of the bit to set.</source>
          <target state="translated">Index de base zéro du bit à définir.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source>The Boolean value to assign to the bit.</source>
          <target state="translated">Valeur booléenne à assigner au bit.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source>Sets the bit at a specific position in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> to the specified value.</source>
          <target state="translated">Affecte au bit la valeur spécifiée à une position spécifique dans <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Cette méthode est une opération o (1).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source>The following code example shows how to set and get specific elements in a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir des éléments spécifiques un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Set(System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than or equal to the number of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> est supérieur ou égal au nombre d'éléments dans le <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.SetAll(System.Boolean)">
          <source>The Boolean value to assign to all bits.</source>
          <target state="translated">Valeur booléenne à affecter à tous les bits.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.SetAll(System.Boolean)">
          <source>Sets all bits in the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> to the specified value.</source>
          <target state="translated">Affecte la valeur spécifiée à tous les bits du <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.SetAll(System.Boolean)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.SetAll(System.Boolean)">
          <source>The following code example shows how to set and get specific elements in a <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment définir et obtenir des éléments spécifiques un <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="P:System.Collections.BitArray.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Obtient un objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</source>
          <target state="translated">Objet qui peut être utilisé pour synchroniser l'accès à <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>Derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Classes dérivées peuvent produire leur propre version synchronisée de la <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.BitArray&gt;</ph>.</source>
          <target state="translated">Le code de synchronisation doit effectuer les opérations sur le <ph id="ph1">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> de la <ph id="ph2">&lt;xref:System.Collections.BitArray&gt;</ph>, et non directement sur le <ph id="ph3">&lt;xref:System.Collections.BitArray&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Cela garantit un bon fonctionnement des collections dérivées d’autres objets.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> object.</source>
          <target state="translated">Plus particulièrement, il maintient la synchronisation est assurée avec les autres threads qui pourraient modifier simultanément le <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> during the entire enumeration.</source>
          <target state="translated">L’exemple de code suivant montre comment verrouiller la collection à l’aide de la <ph id="ph1">&lt;xref:System.Collections.BitArray.SyncRoot%2A&gt;</ph> pendant toute l’énumération.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.BitArray.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La récupération de la valeur de cette propriété est une opération O(1).</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>The array with which to perform the bitwise exclusive OR operation.</source>
          <target state="translated">Tableau utilisé pour exécuter l’opération OR exclusive au niveau du bit.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>Performs the bitwise exclusive OR operation between the elements of the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object against the corresponding elements in the specified array.</source>
          <target state="translated">Exécute l’opération OR exclusive au niveau du bit entre les éléments de l’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actif par rapport aux éléments correspondants dans le tableau spécifié.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object will be modified to store the result of the bitwise exclusive OR operation.</source>
          <target state="translated">L’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actif est modifié pour stocker le résultat de l’opération OR exclusive au niveau du bit.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>An array containing the result of the bitwise exclusive OR operation, which is a reference to the current <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> object.</source>
          <target state="translated">Tableau qui contient le résultat de l’opération OR exclusive au niveau du bit, qui est une référence à l’objet <ph id="ph1">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actif.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>The bitwise exclusive OR operation returns <ph id="ph1">`true`</ph> if exactly one operand is <ph id="ph2">`true`</ph>, and returns <ph id="ph3">`false`</ph> if both operands have the same Boolean value.</source>
          <target state="translated">L’opération OR exclusive au niveau du bit retourne <ph id="ph1">`true`</ph> si un seul opérande est <ph id="ph2">`true`</ph>et retourne <ph id="ph3">`false`</ph> si les deux opérandes ont la même valeur Boolean.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode est un O (<ph id="ph1">`n`</ph>) opération, où <ph id="ph2">`n`</ph> est <ph id="ph3">&lt;xref:System.Collections.BitArray.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source>The following code example shows how to perform the XOR operation between two <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objects.</source>
          <target state="translated">L’exemple de code suivant montre comment effectuer l’opération XOR entre deux <ph id="ph1">&lt;xref:System.Collections.BitArray&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.BitArray.Xor(System.Collections.BitArray)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> and the current <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> do not have the same number of elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> et le <ph id="ph2">&lt;see cref="T:System.Collections.BitArray" /&gt;</ph> actuel n’ont pas le même nombre d’éléments.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>