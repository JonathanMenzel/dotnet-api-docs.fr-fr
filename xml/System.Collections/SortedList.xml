<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8480f7240e183ff7f80273ad720bb2d3da77e384" /><Meta Name="ms.sourcegitcommit" Value="954560a1b131dce1872e29ce5c01cd9f2c927f11" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/11/2019" /><Meta Name="ms.locfileid" Value="54234980" /></Metadata><TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une collection de paires clé/valeur triées par les clés et accessible par clé et par index.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

Un <xref:System.Collections.SortedList> est accessible par sa clé, comme un élément dans un élément <xref:System.Collections.IDictionary> implémentation, ou par son index, comme un élément de <xref:System.Collections.IList> implémentation.  

> [!IMPORTANT]
> Nous ne vous recommandons d’utiliser la `SortedList` classe pour tout nouveau développement. Au lieu de cela, nous vous recommandons d’utiliser le modèle générique <xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType> classe. Pour plus d’informations, consultez [les collections Non génériques ne doit pas être utilisées](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) sur GitHub.

 Un <xref:System.Collections.SortedList> objet conserve en interne les deux tableaux pour stocker les éléments de la liste ; autrement dit, un tableau pour les clés et un autre tableau de valeurs associées. Chaque élément est une paire clé/valeur qui est accessible en tant qu’un <xref:System.Collections.DictionaryEntry> objet. Une clé ne peut pas être `null`, mais une valeur peut être.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments du <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est automatiquement augmentée par réallocation. La capacité peut être diminuée en appelant <xref:System.Collections.SortedList.TrimToSize%2A> ou en définissant le <xref:System.Collections.SortedList.Capacity%2A> propriété explicitement.  
  
 **.NET framework :** Pour très volumineux <xref:System.Collections.SortedList> objets, vous pouvez augmenter la capacité maximale à 2 milliards des éléments sur un système 64 bits en définissant le `enabled` attribut de la [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) élément de configuration `true` dans le environnement d’exécution.  
  
 Les éléments d’un <xref:System.Collections.SortedList> objet sont triées par les clés soit selon un spécifique <xref:System.Collections.IComparer> implémentation spécifié lorsque le <xref:System.Collections.SortedList> est créé ou conformément au <xref:System.IComparable> implémentation fournie par les clés elles-mêmes. Dans les deux cas, un <xref:System.Collections.SortedList> n’autorise pas les clés en double.  
  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList> objet.  
  
 Opérations sur un <xref:System.Collections.SortedList> objet ont tendance à être plus lentes que les opérations sur un <xref:System.Collections.Hashtable> objet en raison du tri. Toutefois, le <xref:System.Collections.SortedList> offre davantage de souplesse en autorisant l’accès aux valeurs via les clés associées ou les index.  
  
 Éléments de cette collection est accessible à l’aide d’un index d’entiers.  Index de cette collection sont de base zéro.  
  
 Le `foreach` instruction du langage c# (`for each` en Visual Basic) retourne un objet du type des éléments dans la collection. Étant donné que chaque élément de la <xref:System.Collections.SortedList> objet est une paire clé/valeur, le type d’élément n’est pas le type de la clé ou le type de la valeur. Au lieu de cela, le type d’élément est <xref:System.Collections.DictionaryEntry>. Par exemple :  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 La `foreach` instruction est un wrapper autour de l’énumérateur, qui permet la lecture à partir n’écrit ne pas à la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser un <xref:System.Collections.SortedList> objet et comment imprimer ses clés et valeurs.  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  
  
Un <see cref="T:System.Collections.SortedList" /> objet peut prendre en charge simultanément, plusieurs lecteurs, que la collection n’est pas modifiée. Pour garantir la sécurité des threads de la <see cref="T:System.Collections.SortedList" />, toutes les opérations doivent être effectuées via le wrapper retourné par la <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> (méthode).  
  
L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" /> qui est vide, possède la capacité initiale par défaut et est triée suivant l'interface <see cref="T:System.IComparable" /> implémentée par chaque clé ajoutée à l'objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés dans le <xref:System.Collections.SortedList> objet. Les éléments sont triés en fonction de la <xref:System.IComparable> implémentation de chaque clé ajoutée à la <xref:System.Collections.SortedList>.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments qui le <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.SortedList> objet.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée des collections à l’aide de différents <xref:System.Collections.SortedList> constructeurs et illustre les différences de comportement entre les collections.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser lors de la comparaison de clés.  
  
ou 
 <see langword="null" /> pour utiliser l'implémentation de <see cref="T:System.IComparable" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" /> qui est vide, possède la capacité initiale par défaut et est triée suivant l'interface <see cref="T:System.Collections.IComparer" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont triés selon le <xref:System.Collections.IComparer> implémentation. Si le `comparer` paramètre est `null`, le <xref:System.IComparable> implémentation de chaque clé est utilisée ; par conséquent, chaque clé doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés dans le <xref:System.Collections.SortedList> objet.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments qui le <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.SortedList> objet.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée des collections à l’aide de différents <xref:System.Collections.SortedList> constructeurs et illustre les différences de comportement entre les collections.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Implémentation de <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" /> qui contient des éléments copiés à partir du dictionnaire spécifié, possède la capacité initiale correspondant au nombre d'éléments copiés et est triée suivant l'interface <see cref="T:System.IComparable" /> implémentée par chaque clé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés dans le <xref:System.Collections.SortedList> objet. Les éléments sont triés en fonction de la <xref:System.IComparable> implémentation de chaque clé ajoutée à la <xref:System.Collections.SortedList>.  
  
 Un <xref:System.Collections.Hashtable> objet est un exemple d’un <xref:System.Collections.IDictionary> implémentation qui peut être passée à ce constructeur. La nouvelle <xref:System.Collections.SortedList> objet contient une copie des clés et valeurs stockées dans le <xref:System.Collections.Hashtable>.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments qui le <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.SortedList> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `d`.  
  
   
  
## Examples  
 L’exemple de code suivant crée des collections à l’aide de différents <xref:System.Collections.SortedList> constructeurs et illustre les différences de comportement entre les collections.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Un ou plusieurs éléments de <paramref name="d" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">Nombre initial d'éléments que l'objet <see cref="T:System.Collections.SortedList" /> peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" /> qui est vide, possède la capacité initiale spécifiée et est triée suivant l'interface <see cref="T:System.IComparable" /> implémentée par chaque clé ajoutée à l'objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés dans le <xref:System.Collections.SortedList> objet. Les éléments sont triés en fonction de la <xref:System.IComparable> implémentation de chaque clé ajoutée à la <xref:System.Collections.SortedList>.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments qui le <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.SortedList> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `initialCapacity`.  
  
   
  
## Examples  
 L’exemple de code suivant crée des collections à l’aide de différents <xref:System.Collections.SortedList> constructeurs et illustre les différences de comportement entre les collections.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCapacity" /> est inférieur à zéro.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour créer un objet <see cref="T:System.Collections.SortedList" /> avec le <paramref name="initialCapacity" /> spécifié.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser lors de la comparaison de clés.  
  
ou 
 <see langword="null" /> pour utiliser l'implémentation de <see cref="T:System.IComparable" /> de chaque clé.</param>
        <param name="capacity">Nombre initial d'éléments que l'objet <see cref="T:System.Collections.SortedList" /> peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" /> qui est vide, possède la capacité initiale spécifiée et est triée suivant l'interface <see cref="T:System.Collections.IComparer" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont triés selon le <xref:System.Collections.IComparer> implémentation. Si le `comparer` paramètre est `null`, le <xref:System.IComparable> implémentation de chaque clé est utilisée ; par conséquent, chaque clé doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés dans le <xref:System.Collections.SortedList> objet.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments qui le <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.SortedList> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
   
  
## Examples  
 L’exemple de code suivant crée des collections à l’aide de différents <xref:System.Collections.SortedList> constructeurs et illustre les différences de comportement entre les collections.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour créer un objet <see cref="T:System.Collections.SortedList" /> avec le <paramref name="capacity" /> spécifié.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Implémentation de <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.SortedList" />.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser lors de la comparaison de clés.  
  
ou 
 <see langword="null" /> pour utiliser l'implémentation de <see cref="T:System.IComparable" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.SortedList" /> qui contient des éléments copiés à partir du dictionnaire spécifié, possède la capacité initiale correspondant au nombre d'éléments copiés et est triée suivant l'interface <see cref="T:System.Collections.IComparer" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont triés selon le <xref:System.Collections.IComparer> implémentation. Si le `comparer` paramètre est `null`, le <xref:System.IComparable> implémentation de chaque clé est utilisée ; par conséquent, chaque clé doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés dans le <xref:System.Collections.SortedList> objet.  
  
 Un <xref:System.Collections.Hashtable> objet est un exemple d’un <xref:System.Collections.IDictionary> implémentation qui peut être passée à ce constructeur. La nouvelle <xref:System.Collections.SortedList> objet contient une copie des clés et valeurs stockées dans le <xref:System.Collections.Hashtable>.  
  
 La capacité d’un <xref:System.Collections.SortedList> objet est le nombre d’éléments qui le <xref:System.Collections.SortedList> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.SortedList>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.SortedList> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `d`.  
  
   
  
## Examples  
 L’exemple de code suivant crée des collections à l’aide de différents <xref:System.Collections.SortedList> constructeurs et illustre les différences de comportement entre les collections.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="comparer" /> a la valeur <see langword="null" />, et un ou plusieurs éléments de <paramref name="d" /> n’implémentent pas l’interface <see cref="T:System.IComparable" /></exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à ajouter.</param>
        <param name="value">Valeur de l'élément à ajouter. La valeur peut être <see langword="null" />.</param>
        <summary>Ajoute un élément avec la clé et la valeur spécifiées dans un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’insertion est déterminé en fonction du comparateur sélectionné, explicitement ou par défaut, lorsque le <xref:System.Collections.SortedList> objet a été créé.  
  
 Si <xref:System.Collections.SortedList.Count%2A> est déjà égale à <xref:System.Collections.SortedList.Capacity%2A>, la capacité de la <xref:System.Collections.SortedList> objet est augmenté en réallouant automatiquement le tableau interne, et les éléments existants sont copiés vers le nouveau tableau avant le nouvel élément est ajouté.  
  
 Vous pouvez également utiliser le <xref:System.Collections.SortedList.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:System.Collections.SortedList> objet (par exemple, `myCollection["myNonexistentKey"] = myValue`). Toutefois, si la clé spécifiée existe déjà dans le <xref:System.Collections.SortedList>, ce qui affecte le <xref:System.Collections.SortedList.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.SortedList.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Les éléments d’un <xref:System.Collections.SortedList> objet sont triées par les clés soit selon un spécifique <xref:System.Collections.IComparer> implémentation spécifié lorsque le <xref:System.Collections.SortedList> est créé ou conformément au <xref:System.IComparable> implémentation fournie par les clés elles-mêmes.  
  
 Une clé ne peut pas être `null`, mais une valeur peut être.  
  
 Cette méthode est un O (`n`) opération pour les données non triées, où `n` est <xref:System.Collections.SortedList.Count%2A>. C’est un O (log `n`) opération si le nouvel élément est ajouté à la fin de la liste. Si l’insertion conduit à un redimensionnement, l’opération est O (`n`).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment ajouter des éléments à un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un élément possédant le <paramref name="key" /> spécifié existe déjà dans l'objet <see cref="T:System.Collections.SortedList" />.  
  
ou 
<see cref="T:System.Collections.SortedList" /> est défini pour utiliser l'interface <see cref="T:System.IComparable" /> et <paramref name="key" /> n'implémente pas l'interface <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.SortedList" /> est de taille fixe.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour ajouter l'élément à <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le comparateur lève une exception.</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la capacité d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Nombre d'éléments que l'objet <see cref="T:System.Collections.SortedList" /> peut contenir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A> est le nombre d’éléments qui le <xref:System.Collections.SortedList> objet peut stocker. <xref:System.Collections.SortedList.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> est toujours supérieur ou égal à <xref:System.Collections.SortedList.Count%2A>. Si <xref:System.Collections.SortedList.Count%2A> dépasse <xref:System.Collections.SortedList.Capacity%2A> lors de l’ajout d’éléments, la capacité est automatiquement augmentée en réallouant le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.SortedList.TrimToSize%2A> ou en définissant le <xref:System.Collections.SortedList.Capacity%2A> propriété explicitement. Lorsque la valeur de <xref:System.Collections.SortedList.Capacity%2A> n’est défini explicitement, le tableau interne est également réalloué pour prendre en charge de la capacité spécifiée.  
  
 Récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est un O (`n`) opération, où `n` est la nouvelle capacité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur assignée est inférieure ou égale au nombre actuel d'éléments dans l'objet <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’y a pas assez de mémoire disponible sur le système.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A> est défini à zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées.  
  
 <xref:System.Collections.SortedList.Capacity%2A> reste inchangé. Pour rétablir la capacité de la <xref:System.Collections.SortedList> de l’objet, appelez <xref:System.Collections.SortedList.TrimToSize%2A> ou définir le <xref:System.Collections.SortedList.Capacity%2A> propriété directement. Suppression vide <xref:System.Collections.SortedList> définit la capacité de la <xref:System.Collections.SortedList> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment supprimer les parties inutilisées d’une <xref:System.Collections.SortedList> objet et comment effacer les valeurs de la <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:System.Collections.SortedList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.SortedList" /> est de taille fixe.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Copie superficielle de l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie superficielle d’une collection copie uniquement les éléments de la collection, si elles sont des types référence ou les types valeur, mais il ne copie pas les objets que les références. Les références dans la nouvelle collection pointent vers les mêmes objets que les références dans la collection d’origine pointent vers.  
  
 En revanche, une copie complète d’une collection copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans l'objet <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Détermine si un objet <see cref="T:System.Collections.SortedList" /> contient une clé spécifique.</summary>
        <returns><see langword="true" /> si l'objet <see cref="T:System.Collections.SortedList" /> contient un élément avec le <paramref name="key" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments d’un <xref:System.Collections.SortedList> objet sont triées par les clés soit selon un spécifique <xref:System.Collections.IComparer> implémentation spécifié lorsque le <xref:System.Collections.SortedList> est créé ou conformément au <xref:System.IComparable> implémentation fournie par les clés elles-mêmes.  
  
 L'objet <xref:System.Collections.SortedList.Contains%2A> implémente l'objet <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Elle se comporte exactement comme <xref:System.Collections.SortedList.ContainsKey%2A>.  
  
 Cette méthode utilise un algorithme de recherche binaire ; Par conséquent, cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer si un <xref:System.Collections.SortedList> objet contient un élément spécifique.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le comparateur lève une exception.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans l'objet <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Détermine si un objet <see cref="T:System.Collections.SortedList" /> contient une clé spécifique.</summary>
        <returns><see langword="true" /> si l'objet <see cref="T:System.Collections.SortedList" /> contient un élément avec le <paramref name="key" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments d’un <xref:System.Collections.SortedList> objet sont triées par les clés soit selon un spécifique <xref:System.Collections.IComparer> implémentation spécifié lorsque le <xref:System.Collections.SortedList> est créé ou conformément au <xref:System.IComparable> implémentation fournie par les clés elles-mêmes.  
  
 Cette méthode se comporte exactement comme le <xref:System.Collections.SortedList.Contains%2A> (méthode).  
  
 Cette méthode utilise un algorithme de recherche binaire ; Par conséquent, cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer si un <xref:System.Collections.SortedList> objet contient un élément spécifique.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le comparateur lève une exception.</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à trouver dans l'objet <see cref="T:System.Collections.SortedList" />. La valeur peut être <see langword="null" />.</param>
        <summary>Détermine si un objet <see cref="T:System.Collections.SortedList" /> contient une valeur spécifique.</summary>
        <returns><see langword="true" /> si l'objet <see cref="T:System.Collections.SortedList" /> contient un élément avec le <paramref name="value" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs des éléments de la <xref:System.Collections.SortedList> objet sont comparées à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A> (méthode).  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, la durée d’exécution moyenne est proportionnelle à <xref:System.Collections.SortedList.Count%2A>. Autrement dit, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer si un <xref:System.Collections.SortedList> objet contient un élément spécifique.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Objet <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des objets <see cref="T:System.Collections.DictionaryEntry" /> copiés à partir de <see cref="T:System.Collections.SortedList" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie des éléments <see cref="T:System.Collections.SortedList" /> dans un objet <see cref="T:System.Array" /> unidimensionnel, en commençant à l'index spécifié dans le tableau.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les paires clé/valeur sont copiés vers le <xref:System.Array> objet dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.SortedList> objet.  
  
 Pour copier uniquement les clés dans le <xref:System.Collections.SortedList>, utilisez `SortedList.Keys.CopyTo`.  
  
 Pour copier uniquement les valeurs dans le <xref:System.Collections.SortedList>, utilisez `SortedList.Values.CopyTo`.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment copier les valeurs dans un <xref:System.Collections.SortedList> objet dans une dimension <xref:System.Array> objet.  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> est multidimensionnel.  
  
ou 
Le nombre d'éléments de l'objet <see cref="T:System.Collections.SortedList" /> source est supérieur à la quantité d'espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.InvalidCastException">Le type du <see cref="T:System.Collections.SortedList" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Nombre d'éléments contenus dans l'objet <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément est une paire clé/valeur qui est accessible en tant qu’un <xref:System.Collections.DictionaryEntry> objet.  
  
 <xref:System.Collections.SortedList.Capacity%2A> est le nombre d’éléments qui le <xref:System.Collections.SortedList> objet peut stocker. <xref:System.Collections.SortedList.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.SortedList>.  
  
 <xref:System.Collections.SortedList.Capacity%2A> est toujours supérieur ou égal à <xref:System.Collections.SortedList.Count%2A>. Si <xref:System.Collections.SortedList.Count%2A> dépasse <xref:System.Collections.SortedList.Capacity%2A> lors de l’ajout d’éléments, la capacité est automatiquement augmentée en réallouant le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de la valeur à obtenir.</param>
        <summary>Obtient la valeur à l'index spécifié d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Valeur à l'index spécifié de l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList> objet.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir une ou toutes les clés ou valeurs dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> sort de la plage d'index valides pour l'objet <see cref="T:System.Collections.SortedList" />.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Collections.IDictionaryEnumerator" /> qui itère a sein d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Objet <see cref="T:System.Collections.IDictionaryEnumerator" /> de l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l'ajout, la modification ou la suppression d'éléments, l'énumérateur est définitivement invalidé et son comportement n'est pas défini.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de la clé à obtenir.</param>
        <summary>Obtient la clé à l'index spécifié d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Clé à l'index spécifié de l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList> objet.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir une ou toutes les clés ou valeurs dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> sort de la plage d'index valides pour l'objet <see cref="T:System.Collections.SortedList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les clés d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Objet <see cref="T:System.Collections.IList" /> contenant les clés de l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Collections.IList> objet est une vue en lecture seule des clés de la <xref:System.Collections.SortedList> objet. Les modifications apportées à sous-jacent <xref:System.Collections.SortedList> sont immédiatement répercutées dans le <xref:System.Collections.IList>.  
  
 Les éléments de retourné <xref:System.Collections.IList> sont triés dans le même ordre que les clés de la <xref:System.Collections.SortedList>.  
  
 Cette méthode est similaire à la <xref:System.Collections.SortedList.Keys%2A> propriété, mais retourne un <xref:System.Collections.IList> au lieu de l’objet une <xref:System.Collections.ICollection> objet.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir une ou toutes les clés ou valeurs dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les valeurs d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Objet <see cref="T:System.Collections.IList" /> contenant les valeurs de l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Collections.IList> objet est une vue en lecture seule des valeurs de la <xref:System.Collections.SortedList> objet. Les modifications apportées à sous-jacent <xref:System.Collections.SortedList> sont immédiatement répercutées dans le <xref:System.Collections.IList>.  
  
 Les éléments de retourné <xref:System.Collections.IList> sont triés dans le même ordre que les valeurs de la <xref:System.Collections.SortedList>.  
  
 Cette méthode est similaire à la <xref:System.Collections.SortedList.Values%2A> propriété, mais retourne un <xref:System.Collections.IList> au lieu de l’objet une <xref:System.Collections.ICollection> objet.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir une ou toutes les clés ou valeurs dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans l'objet <see cref="T:System.Collections.SortedList" />.</param>
        <summary>Retourne l'index de base zéro de la clé spécifiée dans un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Index de base zéro du paramètre <paramref name="key" />, si <paramref name="key" /> se trouve dans l'objet <see cref="T:System.Collections.SortedList" /> ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments d’un <xref:System.Collections.SortedList> objet sont triées par les clés soit selon un spécifique <xref:System.Collections.IComparer> implémentation spécifié lorsque le <xref:System.Collections.SortedList> est créé ou conformément au <xref:System.IComparable> implémentation fournie par les clés elles-mêmes.  
  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList>.  
  
 Cette méthode utilise un algorithme de recherche binaire ; Par conséquent, cette méthode est un O (log `n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer l’index d’une clé ou une valeur dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le comparateur lève une exception.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à trouver dans l'objet <see cref="T:System.Collections.SortedList" />. La valeur peut être <see langword="null" />.</param>
        <summary>Retourne l'index de base zéro de la première occurrence de la valeur spécifiée dans un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Index de base zéro de la première occurrence du paramètre <paramref name="value" />, si <paramref name="value" /> se trouve dans l'objet <see cref="T:System.Collections.SortedList" /> ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList> objet.  
  
 Les valeurs des éléments de la <xref:System.Collections.SortedList> sont comparées à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A> (méthode).  
  
 Cette méthode utilise une recherche linéaire ; Par conséquent, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer l’index d’une clé ou une valeur dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si un objet <see cref="T:System.Collections.SortedList" /> est de taille fixe.</summary>
        <value><see langword="true" /> si l'objet <see cref="T:System.Collections.SortedList" /> est de taille fixe ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection avec une taille fixe n’autorise pas l’ajout ou la suppression d’éléments une fois que la collection est créée, mais n’autorise pas la modification des éléments existants.  
  
 Une collection avec une taille fixe est simplement une collection avec un wrapper qui empêche l’ajout et suppression d’éléments. Par conséquent, si des modifications sont apportées à la collection sous-jacente, y compris l’ajout ou la suppression d’éléments, la collection de taille fixe reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si un objet <see cref="T:System.Collections.SortedList" /> est en lecture seule.</summary>
        <value><see langword="true" /> si l'objet <see cref="T:System.Collections.SortedList" /> est en lecture seule ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.  
  
 Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à un objet <see cref="T:System.Collections.SortedList" /> est synchronisé (thread-safe).</summary>
        <value><see langword="true" /> si l'accès à l'objet <see cref="T:System.Collections.SortedList" /> est synchronisé (thread-safe) ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour garantir la cohérence de thread d’un <xref:System.Collections.SortedList> de l’objet, toutes les opérations doivent être effectuées via le wrapper retourné par la <xref:System.Collections.SortedList.Synchronized%2A> (méthode).  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller une collection en utilisant le <xref:System.Collections.SortedList.SyncRoot%2A> propriété pendant toute l’énumération.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 L’exemple de code suivant montre comment synchroniser un <xref:System.Collections.SortedList> d’objet, de déterminer si un <xref:System.Collections.SortedList> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé dont la valeur doit être obtenue ou définie.</param>
        <summary>Obtient ou définit la valeur associée à une clé spécifique dans un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Valeur associée au paramètre <paramref name="key" /> dans l'objet <see cref="T:System.Collections.SortedList" />, si <paramref name="key" /> existe ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Collections.SortedList.Item%2A> propriété accéder à un élément spécifique dans une collection en spécifiant la syntaxe suivante : `myCollection[key]`.  
  
 Vous pouvez également utiliser cette propriété pour ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:System.Collections.SortedList> objet (par exemple, `myCollection["myNonexistentKey"] = myValue)`. Toutefois, si la clé spécifiée existe déjà dans le <xref:System.Collections.SortedList>, ce qui affecte le <xref:System.Collections.SortedList.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.SortedList.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Une clé ne peut pas être `null`, mais une valeur peut être. Faire la distinction entre `null` qui est retourné parce que la clé spécifiée est introuvable et `null` qui est retournée parce que la valeur de la clé spécifiée est `null`, utiliser le <xref:System.Collections.SortedList.Contains%2A> méthode ou le <xref:System.Collections.SortedList.ContainsKey%2A> méthode pour déterminer si la clé existe dans la liste.  
  
 Les éléments d’un <xref:System.Collections.SortedList> sont triées par les clés soit selon un spécifique <xref:System.Collections.IComparer> implémentation spécifié lorsque le <xref:System.Collections.SortedList> est créé ou conformément au <xref:System.IComparable> implémentation fournie par les clés elles-mêmes.  
  
 Le C# langue utilise le [ `this` ](~/docs/csharp/language-reference/keywords/this.md) mot clé pour définir les indexeurs au lieu d’implémenter la <xref:System.Collections.SortedList.Keys%2A> propriété. Visual Basic implémente <xref:System.Collections.SortedList.Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 Récupération de la valeur de cette propriété est un O (log `n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>. Définition de la propriété est un O (log `n`) opération si la clé est déjà dans le <xref:System.Collections.SortedList>. Si la clé n’est pas dans la liste, la propriété est un O (`n`) opération pour les données non triées, ou O (log `n`) si le nouvel élément est ajouté à la fin de la liste. Si l’insertion conduit à un redimensionnement, l’opération est O (`n`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La propriété est définie et l'objet <see cref="T:System.Collections.SortedList" /> est en lecture seule.  
  
ou 
La propriété est définie, <paramref name="key" /> n’existe pas dans la collection et <see cref="T:System.Collections.SortedList" /> a une taille fixe.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour ajouter l'élément à <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le comparateur lève une exception.</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les clés d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Objet <see cref="T:System.Collections.ICollection" /> contenant les clés de l'objet <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.ICollection> objet est une vue en lecture seule des clés de la <xref:System.Collections.SortedList> objet. Les modifications apportées à sous-jacent <xref:System.Collections.SortedList> sont immédiatement répercutées dans le <xref:System.Collections.ICollection>.  
  
 Les éléments de la <xref:System.Collections.ICollection> sont triés dans le même ordre que les clés de la <xref:System.Collections.SortedList>.  
  
 Cette propriété est similaire à la <xref:System.Collections.SortedList.GetKeyList%2A> (méthode), mais retourne un <xref:System.Collections.ICollection> au lieu de l’objet une <xref:System.Collections.IList> objet.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à supprimer.</param>
        <summary>Supprime d'un objet <see cref="T:System.Collections.SortedList" /> l'élément ayant la clé spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l'objet <xref:System.Collections.SortedList> ne contient pas d'élément avec la clé spécifiée, <xref:System.Collections.SortedList> reste inchangé. Aucune exception n'est levée.  
  
 Dans des collections d’éléments contigus, telles que les listes, les éléments qui suivent l’élément supprimé remontent pour occuper l’espace libéré. Si la collection est indexée, les index des éléments déplacés sont également mis à jour. Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment supprimer des éléments dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:System.Collections.SortedList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.SortedList" /> est de taille fixe.</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à supprimer.</param>
        <summary>Supprime l'élément à l'index spécifié d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList> objet.  
  
 Dans des collections d’éléments contigus, telles que les listes, les éléments qui suivent l’élément supprimé remontent pour occuper l’espace libéré. Si la collection est indexée, les index des éléments déplacés sont également mis à jour. Ce comportement ne s’applique pas aux collections dont les éléments sont regroupés de manière conceptuelle en compartiments, comme par exemple les tables de hachage.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment supprimer des éléments dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> sort de la plage d'index valides pour l'objet <see cref="T:System.Collections.SortedList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.SortedList" /> est de taille fixe.</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro au niveau duquel enregistrer <paramref name="value" />.</param>
        <param name="value"><see cref="T:System.Object" /> à enregistrer dans l'objet <see cref="T:System.Collections.SortedList" />. La valeur peut être <see langword="null" />.</param>
        <summary>Remplace la valeur à l'index spécifié dans un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La séquence d’index est basée sur l’ordre de tri. Lorsqu’un élément est ajouté, il est inséré dans <xref:System.Collections.SortedList> dans le tri correct ordre et l’indexation s’ajuste en conséquence. Lorsqu’un élément est supprimé, l’indexation s’adapte également en conséquence. Par conséquent, l’index d’une paire clé/valeur spécifique peut changer que les éléments sont ajoutés ou supprimés à partir de la <xref:System.Collections.SortedList> objet.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment remplacer la valeur d’un élément existant dans un <xref:System.Collections.SortedList> objet.  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> sort de la plage d'index valides pour l'objet <see cref="T:System.Collections.SortedList" />.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">Objet <see cref="T:System.Collections.SortedList" /> à synchroniser.</param>
        <summary>Retourne un wrapper synchronisé (thread-safe) pour un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <returns>Wrapper synchronisé (thread-safe) pour l'objet <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour garantir la cohérence de thread d’un <xref:System.Collections.SortedList> de l’objet, toutes les opérations doivent être effectuées via ce wrapper uniquement.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant le <xref:System.Collections.SortedList.SyncRoot%2A> propriété pendant toute l’énumération.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Cette méthode est une opération o (1).  
  
 L’exemple de code suivant montre comment synchroniser un <xref:System.Collections.SortedList> d’objet, de déterminer si un <xref:System.Collections.SortedList> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.SortedList>.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> est <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Objet pouvant être utilisé pour synchroniser l’accès à l’objet <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer une version synchronisée de la <xref:System.Collections.SortedList> de l’objet, utilisez le <xref:System.Collections.SortedList.Synchronized%2A> (méthode). Toutefois, les classes dérivées peuvent fournir leur propre version synchronisée de la <xref:System.Collections.SortedList> à l’aide de la <xref:System.Collections.SortedList.SyncRoot%2A> propriété. Le code de synchronisation doit effectuer les opérations sur le <xref:System.Collections.SortedList.SyncRoot%2A> de la <xref:System.Collections.SortedList>, et non directement sur le <xref:System.Collections.SortedList>. Cela garantit un bon fonctionnement des collections dérivées d’autres objets. Plus précisément, il maintient une synchronisation correcte avec les autres threads qui pourraient modifier simultanément les <xref:System.Collections.SortedList> objet.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant le <xref:System.Collections.SortedList.SyncRoot%2A> propriété pendant toute l’énumération.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Collections.IEnumerator" /> qui itère au sein de <see cref="T:System.Collections.SortedList" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> pour <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position. À cette position, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l’énumérateur jusqu’au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>. Si la collection est modifiée entre <xref:System.Collections.IEnumerator.MoveNext%2A> et <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> retourne l’élément auquel il est attribué, même si l’énumérateur est déjà invalidé.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Affecte à la capacité le nombre réel d'éléments d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour réduire une surcharge de mémoire d’une collection si aucun nouvel élément ne doit être ajouté à la collection.  
  
 Pour réinitialiser un <xref:System.Collections.SortedList> objet à son état initial, l’appel de la <xref:System.Collections.SortedList.Clear%2A> méthode avant d’appeler <xref:System.Collections.SortedList.TrimToSize%2A>. Suppression vide <xref:System.Collections.SortedList> définit la capacité de la <xref:System.Collections.SortedList> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.SortedList.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment supprimer les parties inutilisées d’une <xref:System.Collections.SortedList> objet et comment effacer ses valeurs.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:System.Collections.SortedList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.SortedList" /> est de taille fixe.</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les valeurs d'un objet <see cref="T:System.Collections.SortedList" />.</summary>
        <value>Objet <see cref="T:System.Collections.ICollection" /> contenant les valeurs de l'objet <see cref="T:System.Collections.SortedList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.ICollection> objet est une vue en lecture seule des valeurs de la <xref:System.Collections.SortedList> objet. Les modifications apportées à sous-jacent <xref:System.Collections.SortedList> sont immédiatement répercutées dans le <xref:System.Collections.ICollection>.  
  
 Les éléments de la <xref:System.Collections.ICollection> sont triés dans le même ordre que les valeurs de la <xref:System.Collections.SortedList>.  
  
 Cette propriété est similaire à la <xref:System.Collections.SortedList.GetValueList%2A> (méthode), mais retourne un <xref:System.Collections.ICollection> au lieu de l’objet une <xref:System.Collections.IList> objet.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
  </Members>
</Type>