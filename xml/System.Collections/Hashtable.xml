<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="53ed2202033670d8b876ac3bf0ddfbe3e0765e81" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57922808" /></Metadata><TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Hashtable = class&#xA;    interface IDictionary&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une collection de paires clé/valeur qui sont organisées en fonction du code de hachage de la clé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

Chaque élément est une paire clé/valeur stockée dans un <xref:System.Collections.DictionaryEntry> objet. Une clé ne peut pas être `null`, mais une valeur peut être.  

> [!IMPORTANT]
>  Nous ne vous recommandons d’utiliser la `Hashtable` classe pour tout nouveau développement. Au lieu de cela, nous vous recommandons d’utiliser le modèle générique <xref:System.Collections.Generic.Dictionary%602> classe. Pour plus d’informations, consultez [les collections Non génériques ne doit pas être utilisées](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) sur GitHub.
  
 Les objets utilisés en tant que clés par un <xref:System.Collections.Hashtable> requises pour substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> (méthode) (ou le <xref:System.Collections.IHashCodeProvider> interface) et le <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode) (ou le <xref:System.Collections.IComparer> interface). L’implémentation des méthodes et interfaces doit gérer respecte la casse de la même façon ; Sinon, le <xref:System.Collections.Hashtable> peut ne pas fonctionner correctement. Par exemple, lorsque vous créez un <xref:System.Collections.Hashtable>, vous devez utiliser le <xref:System.Collections.CaseInsensitiveHashCodeProvider> classe (ou toute non-respect de la casse <xref:System.Collections.IHashCodeProvider> implémentation) avec le <xref:System.Collections.CaseInsensitiveComparer> classe (ou toute non-respect de la casse <xref:System.Collections.IComparer> implémentation).  
  
 En outre, ces méthodes doivent donner les mêmes résultats lorsqu’elle est appelée avec les mêmes paramètres, tandis que la clé existe dans le <xref:System.Collections.Hashtable>. Une alternative consiste à utiliser un <xref:System.Collections.Hashtable> constructeur avec un <xref:System.Collections.IEqualityComparer> paramètre. Si l’égalité des clés ont été simplement l’égalité des références, l’implémentation héritée de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> suffirait.  
  
 Les objets de clé doivent être immuables tant qu’ils sont utilisés comme clés dans le <xref:System.Collections.Hashtable>.  
  
 Lorsqu’un élément est ajouté à la <xref:System.Collections.Hashtable>, l’élément est placé dans un compartiment en fonction du code de hachage de la clé. Les recherches suivantes de la clé d’utilisent le code de hachage de la clé à rechercher dans le compartiment particulier qu’une seule, ce qui réduit considérablement le nombre de comparaisons de clés requises pour rechercher un élément.  
  
 Le facteur de charge d’un <xref:System.Collections.Hashtable> détermine le taux maximal d’éléments par compartiment. Plus petits facteurs de charge à l’origine les temps moyens de recherche au détriment de la consommation de mémoire accrue. Le facteur de charge par défaut de 1.0 fournit généralement le meilleur compromis entre vitesse et la taille. Un facteur de charge différents peut également être spécifié lorsque le <xref:System.Collections.Hashtable> est créé.  
  
 Comme les éléments sont ajoutés à un <xref:System.Collections.Hashtable>, le facteur de charge réel de la <xref:System.Collections.Hashtable> augmente. Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments dans la <xref:System.Collections.Hashtable> est automatiquement augmentée au plus petit nombre premier est supérieur à deux fois le nombre actuel de <xref:System.Collections.Hashtable> compartiments.  
  
 Chaque objet de clé dans le <xref:System.Collections.Hashtable> doit fournir sa propre fonction de hachage, qui est accessible en appelant <xref:System.Collections.Hashtable.GetHash%2A>. Toutefois, tout objet implémentant <xref:System.Collections.IHashCodeProvider> peut être passé à un <xref:System.Collections.Hashtable> constructeur, et que la fonction de hachage est utilisée pour tous les objets dans la table.  
  
 La capacité d’un <xref:System.Collections.Hashtable> est le nombre d’éléments du <xref:System.Collections.Hashtable> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Hashtable>, la capacité est automatiquement augmentée par réallocation.  
  
 **.NET framework :** Pour très volumineux <xref:System.Collections.Hashtable> objets, vous pouvez augmenter la capacité maximale à 2 milliards des éléments sur un système 64 bits en définissant le `enabled` attribut de la [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) élément de configuration `true` dans le environnement d’exécution.  
  
 Le `foreach` instruction du langage c# (`For Each` en Visual Basic) retourne un objet du type des éléments dans la collection. Étant donné que chaque élément de la <xref:System.Collections.Hashtable> est une paire clé/valeur, le type d’élément n’est pas le type de la clé ou le type de la valeur. Au lieu de cela, le type d’élément est <xref:System.Collections.DictionaryEntry>. Par exemple :  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 La `foreach` instruction est un wrapper autour de l’énumérateur, qui permet la lecture à partir n’écrit ne pas à la collection.  
  
 Étant donné que la sérialisation et la désérialisation d’un énumérateur pour un <xref:System.Collections.Hashtable> peut provoquer les réorganisation des éléments, il n’est pas possible de continuer l’énumération sans appeler le <xref:System.Collections.IEnumerator.Reset%2A> (méthode).  
  
> [!NOTE]
>  Étant donné que les clés peuvent être héritées et leur comportement modifié, leur unicité absolue ne peut pas être garantie par des comparaisons à l’aide de la <xref:System.Type.Equals%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer, initialiser et effectuer diverses fonctions à un <xref:System.Collections.Hashtable> et comment imprimer ses clés et valeurs.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Collections.Hashtable" /> est thread-safe pour une utilisation par plusieurs threads de lecture et d’un seul thread d’écriture. Il est thread-safe pour une utilisation multithread lorsque seul un des threads effectuer des opérations d’écriture (mise à jour), ce qui permet des lectures sans verrouillage condition que les enregistreurs sont sérialisés à le <see cref="T:System.Collections.Hashtable" />. Pour prendre en charge plusieurs writers toutes les opérations sur le <see cref="T:System.Collections.Hashtable" /> doit être effectuée via le wrapper retourné par la <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> méthode, ne pourvu qu’aucun thread de lecture la <see cref="T:System.Collections.Hashtable" /> objet.  
  
L’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale, du facteur de charge, du fournisseur de codes de hachage et du comparateur par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacité d’une table de hachage est utilisée pour calculer le nombre optimal de compartiments de table de hachage en fonction du facteur de charge. Capacité est automatiquement augmentée en fonction des besoins.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Objet <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" /> en copiant les éléments du dictionnaire spécifié vers le nouvel objet <see cref="T:System.Collections.Hashtable" />. Le nouvel objet <see cref="T:System.Collections.Hashtable" /> a une capacité initiale égale au nombre d'éléments copiés et utilise le facteur de charge, le fournisseur de codes de hachage et le comparateur par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité initiale est définie sur le nombre d’éléments dans le dictionnaire source. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Les éléments de la nouvelle <xref:System.Collections.Hashtable> sont triés dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.IDictionary> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `d` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable equalityComparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">Objet <see cref="T:System.Collections.IEqualityComparer" /> qui définit le fournisseur de code de hachage et le comparateur à utiliser avec l'objet <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut et le comparateur par défaut. Le fournisseur de code de hachage par défaut est l'implémentation de <see cref="M:System.Object.GetHashCode" /> de chaque clé et le comparateur par défaut est l'implémentation de <see cref="M:System.Object.Equals(System.Object)" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale et du facteur de charge par défaut, et de l'objet <see cref="T:System.Collections.IEqualityComparer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacité d’une table de hachage est utilisée pour calculer le nombre optimal de compartiments de table de hachage en fonction du facteur de charge. Capacité est automatiquement augmentée en fonction des besoins.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le <xref:System.Collections.IEqualityComparer> objet inclut le fournisseur de code de hachage et le comparateur. Si un <xref:System.Collections.IEqualityComparer> est utilisé dans le <xref:System.Collections.Hashtable> constructeur, les objets utilisés en tant que clés dans le <xref:System.Collections.Hashtable> objet n’est pas nécessaire de substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthodes.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Collections.IEqualityComparer> permet des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre approximatif d'éléments que l'objet <see cref="T:System.Collections.Hashtable" /> peut contenir initialement.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale spécifiée et du facteur de charge, du fournisseur de codes de hachage et du comparateur par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécification de la capacité initiale vous évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Hashtable> objet. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Objet <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="equalityComparer">Objet <see cref="T:System.Collections.IEqualityComparer" /> qui définit le fournisseur de code de hachage et le comparateur à utiliser avec <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut et le comparateur par défaut. Le fournisseur de code de hachage par défaut est l'implémentation de <see cref="M:System.Object.GetHashCode" /> de chaque clé et le comparateur par défaut est l'implémentation de <see cref="M:System.Object.Equals(System.Object)" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" /> en copiant les éléments du dictionnaire spécifié vers un nouvel objet <see cref="T:System.Collections.Hashtable" />. Le nouvel objet <see cref="T:System.Collections.Hashtable" /> a une capacité initiale égale au nombre d'éléments copiés et utilise le facteur de charge par défaut et l'objet <see cref="T:System.Collections.IEqualityComparer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité initiale est définie sur le nombre d’éléments dans le dictionnaire source. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le <xref:System.Collections.IEqualityComparer> objet inclut le fournisseur de code de hachage et le comparateur. Si un <xref:System.Collections.IEqualityComparer> est utilisé dans le <xref:System.Collections.Hashtable> constructeur, les objets utilisés en tant que clés dans le <xref:System.Collections.Hashtable> objet n’est pas nécessaire de substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthodes.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Collections.IEqualityComparer> permet des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Les éléments de la nouvelle <xref:System.Collections.Hashtable> sont triés dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.IDictionary> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `d` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">Objet <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Nombre dans la plage comprise entre 0,1 et 1,0 qui est multiplié par la valeur par défaut qui fournit les meilleures performances. Le résultat est le ratio maximal d'éléments par compartiment.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" /> en copiant les éléments du dictionnaire spécifié vers le nouvel objet <see cref="T:System.Collections.Hashtable" />. Le nouvel objet <see cref="T:System.Collections.Hashtable" /> a une capacité initiale égale au nombre d'éléments copiés et utilise le facteur de charge spécifié et le fournisseur de codes de hachage et le comparateur par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité initiale est définie sur le nombre d’éléments dans le dictionnaire source. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue. Un facteur de charge de 1,0 est le meilleur compromis entre vitesse et la taille.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Les éléments de la nouvelle <xref:System.Collections.Hashtable> sont triés dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.IDictionary> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `d` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="loadFactor" /> est inférieur à 0,1.  
  
ou 
 <paramref name="loadFactor" /> est supérieur à 1,0.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hcp">Objet <see cref="T:System.Collections.IHashCodeProvider" /> qui fournit les codes de hachage pour toutes les clés dans l'objet <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Objet <see cref="T:System.Collections.IComparer" /> à utiliser pour déterminer si deux clés sont égales.  
  
ou 
 <see langword="null" /> pour utiliser le comparateur par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale et du facteur de charge par défaut, et du fournisseur de codes de hachage et du comparateur spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacité d’une table de hachage est utilisée pour calculer le nombre optimal de compartiments de table de hachage en fonction du facteur de charge. Capacité est automatiquement augmentée en fonction des besoins.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le fournisseur de code de hachage personnalisé et le comparateur personnalisé permettent des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre approximatif d'éléments que l'objet <see cref="T:System.Collections.Hashtable" /> peut contenir initialement.</param>
        <param name="equalityComparer">Objet <see cref="T:System.Collections.IEqualityComparer" /> qui définit le fournisseur de code de hachage et le comparateur à utiliser avec <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut et le comparateur par défaut. Le fournisseur de code de hachage par défaut est l'implémentation de <see cref="M:System.Object.GetHashCode" /> de chaque clé et le comparateur par défaut est l'implémentation de <see cref="M:System.Object.Equals(System.Object)" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de l'objet <see cref="T:System.Collections.IEqualityComparer" /> et de la capacité initiale spécifiés et du facteur de charge par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécification de la capacité initiale vous évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Hashtable> objet. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le <xref:System.Collections.IEqualityComparer> objet inclut le fournisseur de code de hachage et le comparateur. Si un <xref:System.Collections.IEqualityComparer> est utilisé dans le <xref:System.Collections.Hashtable> constructeur, les objets utilisés en tant que clés dans le <xref:System.Collections.Hashtable> n’est pas nécessaire de substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthodes.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Collections.IEqualityComparer> permet des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le `capacity` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre approximatif d'éléments que l'objet <see cref="T:System.Collections.Hashtable" /> peut contenir initialement.</param>
        <param name="loadFactor">Nombre dans la plage comprise entre 0,1 et 1,0 qui est multiplié par la valeur par défaut qui fournit les meilleures performances. Le résultat est le ratio maximal d'éléments par compartiment.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale et du facteur de charge spécifiés, et du fournisseur de codes de hachage et du comparateur par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécification de la capacité initiale vous évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Hashtable> objet. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue. Un facteur de charge de 1,0 est le meilleur compromis entre vitesse et la taille.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le `capacity` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="loadFactor" /> est inférieur à 0,1.  
  
ou 
 <paramref name="loadFactor" /> est supérieur à 1,0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="capacity" /> provoque un dépassement de capacité.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenant les informations nécessaires pour sérialiser <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenant la source et la destination du flux sérialisé associé à <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> qui est sérialisable à l’aide des objets<see cref="T:System.Runtime.Serialization.SerializationInfo" /> et <see cref="T:System.Runtime.Serialization.StreamingContext" /> spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacité d’une table de hachage est utilisée pour calculer le nombre optimal de compartiments de table de hachage en fonction du facteur de charge. Capacité est automatiquement augmentée en fonction des besoins.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
 Étant donné que la sérialisation et la désérialisation d’un énumérateur pour un <xref:System.Collections.Hashtable> peut provoquer les réorganisation des éléments, il n’est pas possible de continuer l’énumération sans appeler le <xref:System.Collections.IEnumerator.Reset%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Objet <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="hcp">Objet <see cref="T:System.Collections.IHashCodeProvider" /> qui fournit les codes de hachage pour toutes les clés dans <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Objet <see cref="T:System.Collections.IComparer" /> à utiliser pour déterminer si deux clés sont égales.  
  
ou 
 <see langword="null" /> pour utiliser le comparateur par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" /> en copiant les éléments du dictionnaire spécifié vers le nouvel objet <see cref="T:System.Collections.Hashtable" />. Le nouvel objet <see cref="T:System.Collections.Hashtable" /> a une capacité initiale égale au nombre d'éléments copiés et utilise le facteur de charge par défaut et le fournisseur de codes de hachage et le comparateur spécifiés. Cette API est obsolète. Pour obtenir une alternative, consultez <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité initiale est définie sur le nombre d’éléments dans le dictionnaire source. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le fournisseur de code de hachage personnalisé et le comparateur personnalisé permettent des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Les éléments de la nouvelle <xref:System.Collections.Hashtable> sont triés dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.IDictionary> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `d` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Objet <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Nombre dans la plage comprise entre 0,1 et 1,0 qui est multiplié par la valeur par défaut qui fournit les meilleures performances. Le résultat est le ratio maximal d'éléments par compartiment.</param>
        <param name="equalityComparer">Objet <see cref="T:System.Collections.IEqualityComparer" /> qui définit le fournisseur de code de hachage et le comparateur à utiliser avec <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut et le comparateur par défaut. Le fournisseur de code de hachage par défaut est l'implémentation de <see cref="M:System.Object.GetHashCode" /> de chaque clé et le comparateur par défaut est l'implémentation de <see cref="M:System.Object.Equals(System.Object)" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" /> en copiant les éléments du dictionnaire spécifié vers le nouvel objet <see cref="T:System.Collections.Hashtable" />. Le nouvel objet <see cref="T:System.Collections.Hashtable" /> a une capacité initiale égale au nombre d'éléments copiés et utilise le facteur de charge et l'objet <see cref="T:System.Collections.IEqualityComparer" /> spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité initiale est définie sur le nombre d’éléments dans le dictionnaire source. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue. Un facteur de charge de 1,0 est le meilleur compromis entre vitesse et la taille.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le <xref:System.Collections.IEqualityComparer> objet inclut le fournisseur de code de hachage et le comparateur. Si un <xref:System.Collections.IEqualityComparer> est utilisé dans le <xref:System.Collections.Hashtable> constructeur, les objets utilisés en tant que clés dans le <xref:System.Collections.Hashtable> objet n’est pas nécessaire de substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthodes.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Collections.IEqualityComparer> permet des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Les éléments de la nouvelle <xref:System.Collections.Hashtable> sont triés dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.IDictionary> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `d` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="loadFactor" /> est inférieur à 0,1.  
  
ou 
 <paramref name="loadFactor" /> est supérieur à 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre approximatif d'éléments que l'objet <see cref="T:System.Collections.Hashtable" /> peut contenir initialement.</param>
        <param name="hcp">Objet <see cref="T:System.Collections.IHashCodeProvider" /> qui fournit les codes de hachage pour toutes les clés dans <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Objet <see cref="T:System.Collections.IComparer" /> à utiliser pour déterminer si deux clés sont égales.  
  
ou 
 <see langword="null" /> pour utiliser le comparateur par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale, du fournisseur de codes de hachage, du comparateur et du facteur de charge par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécification de la capacité initiale vous évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Hashtable> objet. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le fournisseur de code de hachage personnalisé et le comparateur personnalisé permettent des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le `capacity` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre approximatif d'éléments que l'objet <see cref="T:System.Collections.Hashtable" /> peut contenir initialement.</param>
        <param name="loadFactor">Nombre dans la plage comprise entre 0,1 et 1,0 qui est multiplié par la valeur par défaut qui fournit les meilleures performances. Le résultat est le ratio maximal d'éléments par compartiment.</param>
        <param name="equalityComparer">Objet <see cref="T:System.Collections.IEqualityComparer" /> qui définit le fournisseur de code de hachage et le comparateur à utiliser avec <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut et le comparateur par défaut. Le fournisseur de code de hachage par défaut est l'implémentation de <see cref="M:System.Object.GetHashCode" /> de chaque clé et le comparateur par défaut est l'implémentation de <see cref="M:System.Object.Equals(System.Object)" /> de chaque clé.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale, du facteur de charge et de l'objet <see cref="T:System.Collections.IEqualityComparer" /> spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécification de la capacité initiale vous évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Hashtable> objet. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue. Un facteur de charge de 1,0 est le meilleur compromis entre vitesse et la taille.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le <xref:System.Collections.IEqualityComparer> objet inclut le fournisseur de code de hachage et le comparateur. Si un <xref:System.Collections.IEqualityComparer> est utilisé dans le <xref:System.Collections.Hashtable> constructeur, les objets utilisés en tant que clés dans le <xref:System.Collections.Hashtable> n’est pas nécessaire de substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthodes.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Collections.IEqualityComparer> permet des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le `capacity` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="loadFactor" /> est inférieur à 0,1.  
  
ou 
 <paramref name="loadFactor" /> est supérieur à 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Objet <see cref="T:System.Collections.IDictionary" /> à copier vers un nouvel objet <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="loadFactor">Nombre dans la plage comprise entre 0,1 et 1,0 qui est multiplié par la valeur par défaut qui fournit les meilleures performances. Le résultat est le ratio maximal d'éléments par compartiment.</param>
        <param name="hcp">Objet <see cref="T:System.Collections.IHashCodeProvider" /> qui fournit les codes de hachage pour toutes les clés dans <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Objet <see cref="T:System.Collections.IComparer" /> à utiliser pour déterminer si deux clés sont égales.  
  
ou 
 <see langword="null" /> pour utiliser le comparateur par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Hashtable" /> en copiant les éléments du dictionnaire spécifié vers le nouvel objet <see cref="T:System.Collections.Hashtable" />. Le nouvel objet <see cref="T:System.Collections.Hashtable" /> a une capacité initiale égale au nombre d'éléments copiés et utilise le facteur de charge, le fournisseur de codes de hachage et le comparateur spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité initiale est définie sur le nombre d’éléments dans le dictionnaire source. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue. Un facteur de charge de 1,0 est le meilleur compromis entre vitesse et la taille.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable> objet. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le fournisseur de code de hachage personnalisé et le comparateur personnalisé permettent des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Les éléments de la nouvelle <xref:System.Collections.Hashtable> sont triés dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.IDictionary> objet.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans le `d` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="loadFactor" /> est inférieur à 0,1.  
  
ou 
 <paramref name="loadFactor" /> est supérieur à 1,0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre approximatif d'éléments que l'objet <see cref="T:System.Collections.Hashtable" /> peut contenir initialement.</param>
        <param name="loadFactor">Nombre dans la plage comprise entre 0,1 et 1,0 qui est multiplié par la valeur par défaut qui fournit les meilleures performances. Le résultat est le ratio maximal d'éléments par compartiment.</param>
        <param name="hcp">Objet <see cref="T:System.Collections.IHashCodeProvider" /> qui fournit les codes de hachage pour toutes les clés dans <see cref="T:System.Collections.Hashtable" />.  
  
ou 
 <see langword="null" /> pour utiliser le fournisseur de code de hachage par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.GetHashCode" />.</param>
        <param name="comparer">Objet <see cref="T:System.Collections.IComparer" /> à utiliser pour déterminer si deux clés sont égales.  
  
ou 
 <see langword="null" /> pour utiliser le comparateur par défaut, qui est l'implémentation de chaque clé de <see cref="M:System.Object.Equals(System.Object)" />.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Collections.Hashtable" /> à l'aide de la capacité initiale, du facteur de charge, du fournisseur de codes de hachage et du comparateur spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécification de la capacité initiale vous évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Hashtable> objet. La capacité est automatiquement augmentée en fonction des besoins selon le facteur de charge.  
  
 Le facteur de charge est le ratio maximal d’éléments par compartiment. Un facteur de charge plus petit signifie une recherche plus rapide au détriment de la consommation de mémoire accrue. Un facteur de charge de 1,0 est le meilleur compromis entre vitesse et la taille.  
  
 Lorsque le facteur de charge réel atteint le facteur de charge spécifié, le nombre de compartiments est automatiquement augmenté au plus petit nombre premier qui est supérieure à deux fois le nombre actuel de compartiments.  
  
 Le fournisseur de code de hachage fournit les codes de hachage des clés dans le <xref:System.Collections.Hashtable>. Le fournisseur de code de hachage par défaut est l’implémentation de clé de <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Le comparateur détermine si deux clés sont égales. Chaque clé dans un <xref:System.Collections.Hashtable> doit être unique. Le comparateur par défaut est l’implémentation de clé de <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Le fournisseur de code de hachage personnalisé et le comparateur personnalisé permettent des scénarios tels qu’effectuant des recherches avec des chaînes de non-respect de la casse.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le `capacity` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant crée des tables de hachage à l’aide de différents <xref:System.Collections.Hashtable> constructeurs et montre les différences de comportement entre les tables de hachage, même si chacune d’elles contient les mêmes éléments.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> est inférieur à zéro.  
  
ou 
 <paramref name="loadFactor" /> est inférieur à 0,1.  
  
ou 
 <paramref name="loadFactor" /> est supérieur à 1,0.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="hashtable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à ajouter.</param>
        <param name="value">Valeur de l'élément à ajouter. La valeur peut être <see langword="null" />.</param>
        <summary>Ajoute un élément avec la clé et la valeur spécifiées dans <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une clé ne peut pas être `null`, mais une valeur peut être.  
  
 Un objet qui ne présente aucune corrélation entre son état et sa valeur de code de hachage ne doit généralement pas utilisé comme clé. Par exemple, les objets de chaîne sont meilleures que les objets de StringBuilder pour une utilisation en tant que clés.  
  
 Vous pouvez également utiliser le <xref:System.Collections.Hashtable.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:System.Collections.Hashtable>; par exemple, `myCollection["myNonexistentKey"] = myValue`. Toutefois, si la clé spécifiée existe déjà dans le <xref:System.Collections.Hashtable>, ce qui affecte le <xref:System.Collections.Hashtable.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.Hashtable.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Si <xref:System.Collections.Hashtable.Count%2A> est inférieure à la capacité de la <xref:System.Collections.Hashtable>, cette méthode est une opération o (1). Si la capacité doit être augmentée pour intégrer un nouvel élément, cette méthode devient un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter des éléments à la <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un élément possédant la même clé existe déjà dans <see cref="T:System.Collections.Hashtable" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Hashtable" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.Hashtable" /> est de taille fixe.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashtable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A> est défini sur zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées. La capacité reste inchangée.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment effacer les valeurs de la <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Hashtable" /> est en lecture seule.</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="hashtable.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle de <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Copie superficielle de <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie superficielle d’une collection copie uniquement les éléments de la collection, si elles sont des types référence ou types valeur, mais il ne copie pas les objets qui la fait référence à. Les références dans la nouvelle collection pointent vers les mêmes objets que les références dans la collection d’origine pointent vers.  
  
 En revanche, une copie complète d’une collection copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Le <xref:System.Collections.Hashtable> clone a le même nombre, la capacité, le même <xref:System.Collections.IHashCodeProvider> implémentation et les mêmes <xref:System.Collections.IComparer> implémentation que l’original <xref:System.Collections.Hashtable>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.comparer : System.Collections.IComparer with get, set" Usage="System.Collections.Hashtable.comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Collections.IComparer" /> à utiliser pour <see cref="T:System.Collections.Hashtable" />.</summary>
        <value><see cref="T:System.Collections.IComparer" /> à utiliser pour <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété a une valeur, mais la table de hachage a été créée à l'aide d'un <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="hashtable.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.Hashtable" /> contient une clé spécifique.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Collections.Hashtable" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'objet <xref:System.Collections.Hashtable.Contains%2A> implémente l'objet <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Elle se comporte exactement comme <xref:System.Collections.Hashtable.ContainsKey%2A>.  
  
 Cette méthode est une opération o (1).  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple suivant montre comment déterminer si le <xref:System.Collections.Hashtable> contient un élément spécifique.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="hashtable.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.Hashtable" /> contient une clé spécifique.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Collections.Hashtable" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se comporte exactement comme <xref:System.Collections.Hashtable.Contains%2A>.  
  
 Cette méthode est une opération o (1).  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple suivant montre comment déterminer si le <xref:System.Collections.Hashtable> contient un élément spécifique.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="hashtable.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à trouver dans <see cref="T:System.Collections.Hashtable" />. La valeur peut être <see langword="null" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.Hashtable" /> contient une valeur spécifique.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Collections.Hashtable" /> contient un élément avec le <paramref name="value" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs des éléments de la <xref:System.Collections.Hashtable> sont comparées à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode).  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
 À compter de .NET Framework 2.0, cette méthode utilise des objets de la collection <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes sur `item` pour déterminer l’existence d’un élément. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple suivant montre comment déterminer si le <xref:System.Collections.Hashtable> contient un élément spécifique.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="hashtable.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel qui constitue la destination des objets <see cref="T:System.Collections.DictionaryEntry" /> copiés à partir de <see cref="T:System.Collections.Hashtable" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie les éléments <see cref="T:System.Collections.Hashtable" /> dans une instance de <see cref="T:System.Array" /> unidimensionnelle à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.Hashtable>.  
  
 Pour copier uniquement les clés dans le <xref:System.Collections.Hashtable>, utilisez `Hashtable.Keys.CopyTo`.  
  
 Pour copier uniquement les valeurs dans le <xref:System.Collections.Hashtable>, utilisez `Hashtable.Values.CopyTo`.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment copier la liste des clés ou la liste des valeurs dans un <xref:System.Collections.Hashtable> dans une dimension <xref:System.Array>.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> est multidimensionnel.  
  
ou 
Le nombre d’éléments dans le <see cref="T:System.Collections.Hashtable" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.InvalidCastException">Le type du <see cref="T:System.Collections.Hashtable" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Hashtable.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de paires clé/valeur contenues dans <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Nombre de paires clé/valeur contenues dans <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Collections.IEqualityComparer" Usage="System.Collections.Hashtable.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Collections.IEqualityComparer" /> à utiliser pour <see cref="T:System.Collections.Hashtable" />.</summary>
        <value><see cref="T:System.Collections.IEqualityComparer" /> à utiliser pour <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.IEqualityComparer> inclut le fournisseur de code de hachage et le comparateur. Si un <xref:System.Collections.IEqualityComparer> est utilisé dans le <xref:System.Collections.Hashtable> constructeur, les objets utilisés en tant que clés dans le <xref:System.Collections.Hashtable> n’est pas nécessaire de substituer le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> et <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthodes.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété a une valeur, mais la table de hachage a été créée à l'aide d'un <see cref="T:System.Collections.IHashCodeProvider" /> et d'un <see cref="T:System.Collections.IComparer" />.</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="hashtable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Collections.IDictionaryEnumerator" /> qui itère au sein de <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>
  <see cref="T:System.Collections.IDictionaryEnumerator" /> pour <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l'énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, la modification ou la suppression d’éléments, l’énumérateur est définitivement invalidé et son comportement n’est pas défini.  
  
 L'énumérateur ne dispose pas d'un accès exclusif à la collection. Par conséquent, l'énumération d'une collection n'est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l'énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Cette méthode est une opération o (1).  
  
 Étant donné que la sérialisation et la désérialisation d’un énumérateur pour un <xref:System.Collections.Hashtable> peut provoquer les réorganisation des éléments, il n’est pas possible de continuer l’énumération sans appeler le <xref:System.Collections.IEnumerator.Reset%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant compare l’utilisation de <xref:System.Collections.Hashtable.GetEnumerator%2A> et `foreach` pour énumérer le contenu d’un <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member GetHash : obj -&gt; int&#xA;override this.GetHash : obj -&gt; int" Usage="hashtable.GetHash key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Object" /> pour lequel un code de hachage doit être retourné.</param>
        <summary>Retourne le code de hachage pour la clé spécifiée.</summary>
        <returns>Code de hachage pour <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la table de hachage a été créée avec un spécifique <xref:System.Collections.IHashCodeProvider> implémentation, cette méthode utilise ce fournisseur de code de hachage ; sinon, il utilise le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> implémentation de `key`.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashtable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenant les informations nécessaires pour sérialiser <see cref="T:System.Collections.Hashtable" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenant la source et la destination du flux sérialisé associé à <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Implémente l'interface <see cref="T:System.Runtime.Serialization.ISerializable" /> et retourne les données requises pour sérialiser <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La collection a été modifiée.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.hcp : System.Collections.IHashCodeProvider with get, set" Usage="System.Collections.Hashtable.hcp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet qui peut dispenser des codes de hachage.</summary>
        <value>Objet qui peut dispenser des codes de hachage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété a une valeur, mais la table de hachage a été créée à l'aide d'un <see cref="T:System.Collections.IEqualityComparer" />.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.Hashtable.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.Hashtable" /> est de taille fixe.</summary>
        <value><see langword="true" /> si <see cref="T:System.Collections.Hashtable" /> est de taille fixe ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection de taille fixe ne permet pas l’ajout ou la suppression d’éléments après sa création, mais permet la modification des éléments existants.  
  
 Une collection avec une taille fixe est simplement une collection avec un wrapper qui empêche l’ajout et suppression d’éléments. Par conséquent, si des modifications sont apportées à la collection sous-jacente, y compris l’ajout ou la suppression d’éléments, la collection de taille fixe reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.Hashtable.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.Hashtable" /> est en lecture seule.</summary>
        <value><see langword="true" /> si <see cref="T:System.Collections.Hashtable" /> est en lecture seule ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.  
  
 Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Hashtable.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.Hashtable" /> est synchronisé (thread-safe).</summary>
        <value><see langword="true" /> si l'accès à <see cref="T:System.Collections.Hashtable" /> est synchronisé (thread-safe) ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Collections.Hashtable> peut prendre en charge un writer et plusieurs lecteurs simultanément. Pour prendre en charge plusieurs writers, toutes les opérations doivent être effectuées via le wrapper retourné par la <xref:System.Collections.Hashtable.Synchronized%2A> (méthode).  
  
 L’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Hashtable.SyncRoot%2A> pendant toute l’énumération :  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant montre comment synchroniser un <xref:System.Collections.Hashtable>, déterminer si un <xref:System.Collections.Hashtable> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.Hashtable.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé dont la valeur doit être obtenue ou définie.</param>
        <summary>Obtient ou définit la valeur associée à la clé spécifiée.</summary>
        <value>Valeur associée à la clé spécifiée. Si la clé spécifiée est introuvable, la tentative d'obtention retourne <see langword="null" /> et la tentative de définition crée un nouvel élément avec la clé spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’accéder à un élément spécifique de la collection à l’aide de la syntaxe suivante : `myCollection[key]`.  
  
 Vous pouvez également utiliser le <xref:System.Collections.Hashtable.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le <xref:System.Collections.Hashtable>; par exemple, `myCollection["myNonexistentKey"] = myValue`. Toutefois, si la clé spécifiée existe déjà dans le <xref:System.Collections.Hashtable>, ce qui affecte le <xref:System.Collections.Hashtable.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.Hashtable.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Une clé ne peut pas être `null`, mais une valeur peut être. Faire la distinction entre `null` qui est retourné parce que la clé spécifiée est introuvable et `null` qui est retournée parce que la valeur de la clé spécifiée est `null`, utiliser le <xref:System.Collections.Hashtable.Contains%2A> méthode ou le <xref:System.Collections.Hashtable.ContainsKey%2A> méthode pour déterminer si la clé existe dans la liste.  
  
 Récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est également une opération o (1).  
  
 Le C# langue utilise le [ `this` ](~/docs/csharp/language-reference/keywords/this.md) mot clé pour définir les indexeurs au lieu d’implémenter la <xref:System.Collections.IList.Item%2A> propriété. Visual Basic implémente <xref:System.Collections.Hashtable.Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La propriété est définie et <see cref="T:System.Collections.Hashtable" /> est en lecture seule.  
  
ou 
La propriété est définie, <paramref name="key" /> n’existe pas dans la collection et <see cref="T:System.Collections.Hashtable" /> a une taille fixe.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member KeyEquals : obj * obj -&gt; bool&#xA;override this.KeyEquals : obj * obj -&gt; bool" Usage="hashtable.KeyEquals (item, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> à comparer à <paramref name="key" />.</param>
        <param name="key">Clé de <see cref="T:System.Collections.Hashtable" /> à comparer à <paramref name="item" />.</param>
        <summary>Compare un <see cref="T:System.Object" /> spécifique avec une clé spécifique dans <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns><see langword="true" /> si <paramref name="item" /> et <paramref name="key" /> sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la table de hachage a été créée avec un spécifique <xref:System.Collections.IComparer> implémentation, cette méthode utilise ce comparateur ; c'est-à-dire, <xref:System.Collections.IComparer.Compare%2A> (`item`, `key`). Sinon, il utilise `item.Equals(key)`.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.Hashtable.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient <see cref="T:System.Collections.ICollection" /> contenant les clés de <see cref="T:System.Collections.Hashtable" />.</summary>
        <value><see cref="T:System.Collections.ICollection" /> contenant les clés de <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des clés dans le <xref:System.Collections.ICollection> n’est pas spécifié, mais c’est le même ordre que les valeurs associées dans le <xref:System.Collections.ICollection> retourné par le <xref:System.Collections.Hashtable.Values%2A> (méthode).  
  
 Retourné <xref:System.Collections.ICollection> n’est pas une copie statique ; au lieu de cela, le <xref:System.Collections.ICollection> fait référence aux clés dans la version d’origine <xref:System.Collections.Hashtable>. Par conséquent, remplace le <xref:System.Collections.Hashtable> continuent d’être répercutées dans le <xref:System.Collections.ICollection>.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashtable.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sender">Source de l'événement de désérialisation.</param>
        <summary>Implémente l’interface <see cref="T:System.Runtime.Serialization.ISerializable" /> et déclenche l’événement de désérialisation une fois la désérialisation terminée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Hashtable.Count%2A>.  
  
 Étant donné que la sérialisation et la désérialisation d’un énumérateur pour un <xref:System.Collections.Hashtable> peut provoquer les réorganisation des éléments, il n’est pas possible de continuer l’énumération sans appeler le <xref:System.Collections.IEnumerator.Reset%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">L'objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associé au <see cref="T:System.Collections.Hashtable" /> en cours n'est pas valide.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="hashtable.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à supprimer.</param>
        <summary>Supprime l'élément avec la clé spécifiée d'<see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Collections.Hashtable> ne contient pas d’élément avec la clé spécifiée, le <xref:System.Collections.Hashtable> reste inchangé. Aucune exception n'est levée.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre comment supprimer des éléments dans le <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Hashtable" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.Hashtable" /> est de taille fixe.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Hashtable -&gt; System.Collections.Hashtable" Usage="System.Collections.Hashtable.Synchronized table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Collections.Hashtable" /> à synchroniser.</param>
        <summary>Retourne un wrapper synchronisé (thread-safe) pour <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Wrapper synchronisé (thread-safe) pour <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Hashtable.Synchronized%2A> méthode est thread-safe pour plusieurs lecteurs et writers. En outre, le wrapper synchronisé garantit qu’il y a qu’un seul writer écrit à la fois.  
  
 L'énumération d'une collection n'est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Hashtable.SyncRoot%2A> pendant toute l’énumération :  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre comment synchroniser un <xref:System.Collections.Hashtable>, déterminer si un <xref:System.Collections.Hashtable> est synchronisé et utiliser une liste synchronisé <xref:System.Collections.Hashtable>.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" /> est <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Hashtable.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.Hashtable" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer une version synchronisée de la <xref:System.Collections.Hashtable>, utilisez le <xref:System.Collections.Hashtable.Synchronized%2A> (méthode). Toutefois, les classes dérivées peuvent fournir leur propre version synchronisée de la <xref:System.Collections.Hashtable> à l’aide de la <xref:System.Collections.Hashtable.SyncRoot%2A> propriété. Le code de synchronisation doit effectuer les opérations sur le <xref:System.Collections.Hashtable.SyncRoot%2A> de la <xref:System.Collections.Hashtable>, et non directement sur le <xref:System.Collections.Hashtable> . Cela garantit un bon fonctionnement des collections dérivées d’autres objets. Plus précisément, il maintient une synchronisation correcte avec les autres threads qui pourraient modifier simultanément les <xref:System.Collections.Hashtable> objet.  
  
 L’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 L’exemple de code suivant montre comment verrouiller la collection en utilisant la <xref:System.Collections.Hashtable.SyncRoot%2A> pendant toute l’énumération :  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 L'instruction `foreach` du langage C# (`for each` en Visual Basic) se charge de la complexité des énumérateurs.  Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l'énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position. À cette position, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou suppression d’éléments, l’énumérateur peut être invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>. Si la collection est modifiée entre <xref:System.Collections.IEnumerator.MoveNext%2A> et <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> retourne l’élément auquel il est attribué, même si l’énumérateur est déjà invalidé.  
  
 L'énumérateur ne dispose pas d'un accès exclusif à la collection. Par conséquent, l'énumération d'une collection n'est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.Hashtable.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient <see cref="T:System.Collections.ICollection" /> contenant les valeurs de <see cref="T:System.Collections.Hashtable" />.</summary>
        <value><see cref="T:System.Collections.ICollection" /> contenant les valeurs de <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des valeurs dans le <xref:System.Collections.ICollection> n’est pas spécifié, mais c’est le même ordre que les clés associées dans le <xref:System.Collections.ICollection> retourné par le <xref:System.Collections.Hashtable.Keys%2A> (méthode).  
  
 Retourné <xref:System.Collections.ICollection> n’est pas une copie statique ; au lieu de cela, le <xref:System.Collections.ICollection> fait référence aux valeurs d’origine <xref:System.Collections.Hashtable>. Par conséquent, remplace le <xref:System.Collections.Hashtable> continuent d’être répercutées dans le <xref:System.Collections.ICollection>.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>