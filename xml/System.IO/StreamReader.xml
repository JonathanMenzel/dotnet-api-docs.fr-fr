<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33c61e2d978c9240a8d9e26953e50ff51770cb80" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="40212302" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9083a-101">Implémente <see cref="T:System.IO.TextReader" /> qui lit les caractères à partir d'un flux d'octets dans un encodage particulier.</span>
      <span class="sxs-lookup">
        <span data-stu-id="9083a-101">Implements a <see cref="T:System.IO.TextReader" /> that reads characters from a byte stream in a particular encoding.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-102"><xref:System.IO.StreamReader> est conçu pour l’entrée de caractères dans un encodage particulier, tandis que la <xref:System.IO.Stream> classe est conçue pour les octets d’entrée et sortie.</span><span class="sxs-lookup"><span data-stu-id="9083a-102"><xref:System.IO.StreamReader> is designed for character input in a particular encoding, whereas the <xref:System.IO.Stream> class is designed for byte input and output.</span></span> <span data-ttu-id="9083a-103">Utilisez <xref:System.IO.StreamReader> pour lire les lignes d’informations à partir d’un fichier texte standard.</span><span class="sxs-lookup"><span data-stu-id="9083a-103">Use <xref:System.IO.StreamReader> for reading lines of information from a standard text file.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9083a-104">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="9083a-104">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="9083a-105">Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="9083a-105">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="9083a-106">Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="9083a-106">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="9083a-107">Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9083a-107">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="9083a-108">Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="9083a-108">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="9083a-109"><xref:System.IO.StreamReader> par défaut de l’encodage UTF-8, sauf indication contraire, au lieu de la valeur par défaut : la page de codes ANSI pour le système actuel.</span><span class="sxs-lookup"><span data-stu-id="9083a-109"><xref:System.IO.StreamReader> defaults to UTF-8 encoding unless specified otherwise, instead of defaulting to the ANSI code page for the current system.</span></span> <span data-ttu-id="9083a-110">UTF-8 gère correctement les caractères Unicode et fournit des résultats cohérents sur les versions localisées du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="9083a-110">UTF-8 handles Unicode characters correctly and provides consistent results on localized versions of the operating system.</span></span> <span data-ttu-id="9083a-111">Si vous obtenez l’encodage de caractères actuel à l’aide de la <xref:System.IO.StreamReader.CurrentEncoding%2A> propriété, la valeur n’est pas fiable jusqu’après la première <xref:System.IO.StreamReader.Read%2A> méthode, car la détection automatique de codage n’est effectué qu’au premier appel à un <xref:System.IO.StreamReader.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-111">If you get the current character encoding using the <xref:System.IO.StreamReader.CurrentEncoding%2A> property, the value is not reliable until after the first <xref:System.IO.StreamReader.Read%2A> method, since encoding auto detection is not done until the first call to a <xref:System.IO.StreamReader.Read%2A> method.</span></span>  
  
 <span data-ttu-id="9083a-112">Par défaut, un <xref:System.IO.StreamReader> n’est pas thread-safe.</span><span class="sxs-lookup"><span data-stu-id="9083a-112">By default, a <xref:System.IO.StreamReader> is not thread safe.</span></span> <span data-ttu-id="9083a-113">Consultez <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> pour un wrapper thread-safe.</span><span class="sxs-lookup"><span data-stu-id="9083a-113">See <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> for a thread-safe wrapper.</span></span>  
  
 <span data-ttu-id="9083a-114">Le <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> et <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharges de méthode lire et écrire le nombre de caractères spécifié par le `count` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-114">The <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method overloads read and write the number of characters specified by the `count` parameter.</span></span> <span data-ttu-id="9083a-115">Ils doivent être distingués des <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> et <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, qui lisent et écrivent le nombre d’octets spécifié par le `count` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-115">These are to be distinguished from <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> and <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, which read and write the number of bytes specified by the `count` parameter.</span></span> <span data-ttu-id="9083a-116">Utilisez le <xref:System.IO.BufferedStream> méthodes uniquement pour lire et écrire des éléments de tableau d’un nombre entier d’octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-116">Use the <xref:System.IO.BufferedStream> methods only for reading and writing an integral number of byte array elements.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9083a-117">Lors de la lecture à partir d’un <xref:System.IO.Stream>, il est plus efficace d’utiliser une mémoire tampon qui est la même taille que la mémoire tampon interne du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-117">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
 <span data-ttu-id="9083a-118">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-118">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-119">L’exemple suivant utilise une instance de <xref:System.IO.StreamReader> pour lire le texte d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="9083a-119">The following example uses an instance of <xref:System.IO.StreamReader> to read text from a file.</span></span> <span data-ttu-id="9083a-120">Le constructeur utilisé dans cet exemple n’est pas pris en charge pour une utilisation dans [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] applications.</span><span class="sxs-lookup"><span data-stu-id="9083a-120">The constructor used in this example is not supported for use in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] Apps.</span></span>  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 <span data-ttu-id="9083a-121">L’exemple suivant instancie un <xref:System.IO.StreamReader> objet et appelle son <xref:System.IO.StreamReader.ReadAsync%2A> méthode pour lire un fichier de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="9083a-121">The following example instantiates a <xref:System.IO.StreamReader> object and calls its <xref:System.IO.StreamReader.ReadAsync%2A> method to read a file asynchronously.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9083a-122">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-122">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="9083a-123">Flux à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-123">The stream to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-124">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-124">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-125">Ce constructeur initialise l’encodage à <xref:System.Text.UTF8Encoding>, le <xref:System.IO.StreamReader.BaseStream%2A> à l’aide de la propriété du `stream` paramètre et la taille de la mémoire tampon interne à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-125">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="9083a-126">Le <xref:System.IO.StreamReader> object appelle <xref:System.IO.Stream.Dispose> sur fourni <xref:System.IO.Stream> objet lorsque <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="9083a-126">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-127">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-127">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-128">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-128">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-129">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-129">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-130">
            <paramref name="stream" /> ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-130">
              <paramref name="stream" /> does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-131">
            <paramref name="stream" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-131">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9083a-132">Chemin d’accès complet au fichier à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-132">The complete file path to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-133">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le nom de fichier spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-133">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-134">Le chemin d’accès complet du fichier spécifié par le `path` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-134">The complete file path is specified by the `path` parameter.</span></span> <span data-ttu-id="9083a-135">Ce constructeur initialise l’encodage à <xref:System.Text.UTF8Encoding> et la taille de mémoire tampon à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-135">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding> and the buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="9083a-136">Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().</span><span class="sxs-lookup"><span data-stu-id="9083a-136">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="9083a-137">Le `path` paramètre n’est pas requis pour être un fichier stocké sur le disque ; il peut être n’importe quelle partie d’un système qui prend en charge l’accès à l’aide de flux de données.</span><span class="sxs-lookup"><span data-stu-id="9083a-137">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-138">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-138">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-139">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-140">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-140">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-141">Le <paramref name="path" /> est une chaîne vide ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-141">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-142">
            <paramref name="path" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-142">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9083a-143">Impossible de trouver le fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-143">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="9083a-144">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-144">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-145">
            <paramref name="path" /> comprend une syntaxe incorrecte ou non valide pour le nom de fichier, le nom de répertoire ou le nom de volume.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-145">
              <paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="9083a-146">Flux à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-146">The stream to be read.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-147">Indique s'il faut rechercher les marques d'ordre des octets au début du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-147">Indicates whether to look for byte order marks at the beginning of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-148">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié, avec l'option de détection de la marque d'ordre d'octet spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-148">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified byte order mark detection option.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-149">Ce constructeur initialise l’encodage à <xref:System.Text.UTF8Encoding>, le <xref:System.IO.StreamReader.BaseStream%2A> à l’aide de la propriété du `stream` paramètre et la taille de la mémoire tampon interne à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-149">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="9083a-150">Le `detectEncodingFromByteOrderMarks` paramètre détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-150">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-151">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-151">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-152">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-152">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-153">Le <xref:System.IO.StreamReader> object appelle <xref:System.IO.Stream.Dispose> sur fourni <xref:System.IO.Stream> objet lorsque <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="9083a-153">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
 <span data-ttu-id="9083a-154">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-154">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-155">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-155">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-156">
            <paramref name="stream" /> ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-156">
              <paramref name="stream" /> does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-157">
            <paramref name="stream" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-157">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="9083a-158">Flux à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-158">The stream to be read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-159">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-159">The character encoding to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-160">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié, avec l'encodage de caractères spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-160">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-161">L’encodage de caractères est défini par le `encoding` paramètre et la taille du tampon est définie sur 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-161">The character encoding is set by the `encoding` parameter, and the buffer size is set to 1024 bytes.</span></span> <span data-ttu-id="9083a-162">Le <xref:System.IO.StreamReader> objet tente de détecter l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-162">The <xref:System.IO.StreamReader> object attempts to  detect the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-163">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-163">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-164">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-164">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-165">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-165">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-166">Le <xref:System.IO.StreamReader> object appelle <xref:System.IO.Stream.Dispose> sur fourni <xref:System.IO.Stream> objet lorsque <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="9083a-166">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-167">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-167">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-168">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-168">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-169">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-169">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-170">
            <paramref name="stream" /> ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-170">
              <paramref name="stream" /> does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-171">
            <paramref name="stream" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-171">
              <paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9083a-172">Chemin d’accès complet au fichier à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-172">The complete file path to be read.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-173">Indique s'il faut rechercher les marques d'ordre des octets au début du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-173">Indicates whether to look for byte order marks at the beginning of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-174">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le nom de fichier spécifié, avec l'option de détection de la marque d'ordre d'octet spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-174">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified byte order mark detection option.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-175">Ce constructeur initialise l’encodage à <xref:System.Text.UTF8Encoding>, le <xref:System.IO.StreamReader.BaseStream%2A> à l’aide de la propriété du `stream` paramètre et la taille de la mémoire tampon interne à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-175">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="9083a-176">Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().</span><span class="sxs-lookup"><span data-stu-id="9083a-176">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="9083a-177">Le `path` paramètre n’est pas requis pour être un fichier stocké sur le disque ; il peut être n’importe quelle partie d’un système qui prend en charge l’accès à l’aide de flux de données.</span><span class="sxs-lookup"><span data-stu-id="9083a-177">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
 <span data-ttu-id="9083a-178">Le `detectEncodingFromByteOrderMarks` paramètre détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-178">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-179">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-179">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-180">Sinon, le <xref:System.Text.UTF8Encoding> est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-180">Otherwise, the <xref:System.Text.UTF8Encoding> is used.</span></span> <span data-ttu-id="9083a-181">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-181">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-182">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-182">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-183">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-183">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-184">Le <paramref name="path" /> est une chaîne vide ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-184">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-185">
            <paramref name="path" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-185">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9083a-186">Impossible de trouver le fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-186">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="9083a-187">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-187">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-188">
            <paramref name="path" /> comprend une syntaxe incorrecte ou non valide pour le nom de fichier, le nom de répertoire ou le nom de volume.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-188">
              <paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9083a-189">Chemin d’accès complet au fichier à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-189">The complete file path to be read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-190">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-190">The character encoding to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-191">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le nom de fichier spécifié, avec l'encodage de caractères spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-191">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-192">Ce constructeur initialise l’encodage tel que spécifié par le `encoding` paramètre et la taille de la mémoire tampon interne à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-192">This constructor initializes the encoding as specified by the `encoding` parameter, and the internal buffer size to 1024 bytes.</span></span> <span data-ttu-id="9083a-193">Le <xref:System.IO.StreamReader> objet tente de détecter l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-193">The <xref:System.IO.StreamReader> object attempts to  detect the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-194">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-194">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-195">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-195">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-196">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-196">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-197">Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().</span><span class="sxs-lookup"><span data-stu-id="9083a-197">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="9083a-198">Le `path` paramètre n’est pas requis pour être un fichier stocké sur le disque ; il peut être n’importe quelle partie d’un système qui prend en charge l’accès à l’aide de flux de données.</span><span class="sxs-lookup"><span data-stu-id="9083a-198">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-199">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-199">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-200">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-200">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-201">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-201">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-202">Le <paramref name="path" /> est une chaîne vide ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-202">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-203">
            <paramref name="path" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-203">
              <paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9083a-204">Impossible de trouver le fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-204">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="9083a-205">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-205">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9083a-206">
            <paramref name="path" /> comprend une syntaxe incorrecte ou non valide pour le nom de fichier, le nom de répertoire ou le nom de volume.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-206">
              <paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="9083a-207">Flux à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-207">The stream to be read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-208">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-208">The character encoding to use.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-209">Indique s'il faut rechercher les marques d'ordre des octets au début du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-209">Indicates whether to look for byte order marks at the beginning of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-210">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié, avec l'encodage de caractères et l'option de détection de la marque d'ordre d'octet spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-210">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding and byte order mark detection option.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-211">Ce constructeur initialise l’encodage tel que spécifié par le `encoding` paramètre, le <xref:System.IO.StreamReader.BaseStream%2A> à l’aide de la propriété du `stream` paramètre et la taille de la mémoire tampon interne à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-211">This constructor initializes the encoding as specified by the `encoding` parameter, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="9083a-212">Le `detectEncodingFromByteOrderMarks` paramètre détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-212">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-213">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-213">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-214">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-214">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-215">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-215">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-216">Le <xref:System.IO.StreamReader> object appelle <xref:System.IO.Stream.Dispose> sur fourni <xref:System.IO.Stream> objet lorsque <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="9083a-216">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-217">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-217">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-218">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-218">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-219">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-219">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-220">
            <paramref name="stream" /> ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-220">
              <paramref name="stream" /> does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-221">
            <paramref name="stream" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-221">
              <paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9083a-222">Chemin d’accès complet au fichier à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-222">The complete file path to be read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-223">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-223">The character encoding to use.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-224">Indique s'il faut rechercher les marques d'ordre des octets au début du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-224">Indicates whether to look for byte order marks at the beginning of the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-225">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le nom de fichier spécifié, avec l'encodage de caractères et l'option de détection de la marque d'ordre d'octet spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-225">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding and byte order mark detection option.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-226">Ce constructeur initialise l’encodage tel que spécifié par le `encoding` paramètre et la taille de la mémoire tampon interne à 1 024 octets.</span><span class="sxs-lookup"><span data-stu-id="9083a-226">This constructor initializes the encoding as specified by the `encoding` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="9083a-227">Le `detectEncodingFromByteOrderMarks` paramètre détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-227">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-228">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-228">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-229">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-229">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-230">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-230">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-231">Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().</span><span class="sxs-lookup"><span data-stu-id="9083a-231">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="9083a-232">Le `path` paramètre n’est pas requis pour être un fichier stocké sur le disque ; il peut être n’importe quelle partie d’un système qui prend en charge l’accès à l’aide de flux de données.</span><span class="sxs-lookup"><span data-stu-id="9083a-232">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-233">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-233">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-234">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-234">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-235">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-235">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-236">Le <paramref name="path" /> est une chaîne vide ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-236">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-237">
            <paramref name="path" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-237">
              <paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9083a-238">Impossible de trouver le fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-238">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="9083a-239">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-239">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9083a-240">
            <paramref name="path" /> comprend une syntaxe incorrecte ou non valide pour le nom de fichier, le nom de répertoire ou le nom de volume.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-240">
              <paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="9083a-241">Flux à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-241">The stream to be read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-242">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-242">The character encoding to use.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-243">Indique s'il faut rechercher les marques d'ordre des octets au début du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-243">Indicates whether to look for byte order marks at the beginning of the file.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="9083a-244">Taille minimale de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-244">The minimum buffer size.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-245">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié, avec l'encodage de caractères, l'option de détection de la marque d'ordre d'octet et la taille de mémoire tampon spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-245">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding, byte order mark detection option, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-246">La taille de mémoire tampon, en nombre de caractères de 16 bits, est définie par le `bufferSize` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-246">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="9083a-247">Si `bufferSize` est inférieure à la taille minimale autorisée (128 caractères), la taille minimale autorisée est utilisée.</span><span class="sxs-lookup"><span data-stu-id="9083a-247">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="9083a-248">Ce constructeur vous permet de modifier l’encodage de la première fois que vous lire à partir du <xref:System.IO.StreamReader> objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-248">This constructor allows you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="9083a-249">Le `detectEncodingFromByteOrderMarks` paramètre détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-249">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-250">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-250">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-251">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-251">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-252">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-252">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-253">Le <xref:System.IO.StreamReader> object appelle <xref:System.IO.Stream.Dispose> sur fourni <xref:System.IO.Stream> objet lorsque <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="9083a-253">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9083a-254">Lors de la lecture à partir d’un <xref:System.IO.Stream>, il est plus efficace d’utiliser une mémoire tampon qui est la même taille que la mémoire tampon interne du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-254">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-255">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-255">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-256">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-256">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-257">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-257">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-258">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-258">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-259">
            <paramref name="stream" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-259">
              <paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-260">
            <paramref name="bufferSize" /> est inférieur ou égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-260">
              <paramref name="bufferSize" /> is less than or equal to zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="9083a-261">Chemin d’accès complet au fichier à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-261">The complete file path to be read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-262">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-262">The character encoding to use.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-263">Indique s'il faut rechercher les marques d'ordre des octets au début du fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-263">Indicates whether to look for byte order marks at the beginning of the file.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="9083a-264">Taille minimale de la mémoire tampon, en nombre de caractères sur 16 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-264">The minimum buffer size, in number of 16-bit characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-265">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le nom de fichier spécifié, avec l'encodage de caractères, l'option de détection de la marque d'ordre d'octet et la taille de mémoire tampon spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-265">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding, byte order mark detection option, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-266">Ce constructeur initialise l’encodage tel que spécifié par le `encoding` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-266">This constructor initializes the encoding as specified by the `encoding` parameter.</span></span>  
  
 <span data-ttu-id="9083a-267">Ce constructeur vous permet de modifier l’encodage de la première fois que vous lire à partir du <xref:System.IO.StreamReader> objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-267">This constructor allows you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="9083a-268">Le `detectEncodingFromByteOrderMarks` paramètre détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-268">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-269">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-269">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-270">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-270">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-271">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-271">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="9083a-272">La taille de mémoire tampon, en nombre de caractères de 16 bits, est définie par le `bufferSize` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-272">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="9083a-273">Si `bufferSize` est inférieure à la taille minimale autorisée (128 caractères), la taille minimale autorisée est utilisée.</span><span class="sxs-lookup"><span data-stu-id="9083a-273">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="9083a-274">Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().</span><span class="sxs-lookup"><span data-stu-id="9083a-274">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="9083a-275">Le `path` paramètre n’est pas requis pour être un fichier stocké sur le disque ; il peut être n’importe quelle partie d’un système qui prend en charge l’accès à l’aide de flux de données.</span><span class="sxs-lookup"><span data-stu-id="9083a-275">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-276">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-276">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="9083a-277">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-277">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-278">L’exemple de code suivant illustre cela <xref:System.IO.StreamReader> constructeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-278">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-279">Le <paramref name="path" /> est une chaîne vide ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-279">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-280">
            <paramref name="path" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-280">
              <paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="9083a-281">Impossible de trouver le fichier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-281">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="9083a-282">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-282">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9083a-283">
            <paramref name="path" /> comprend une syntaxe incorrecte ou non valide pour le nom de fichier, le nom de répertoire ou le nom de volume.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-283">
              <paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-284">
            <paramref name="buffersize" /> est inférieur ou égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-284">
              <paramref name="buffersize" /> is less than or equal to zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="9083a-285">Flux à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-285">The stream to read.</span>
          </span>
        </param>
        <param name="encoding">
          <span data-ttu-id="9083a-286">Encodage des caractères à utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-286">The character encoding to use.</span>
          </span>
        </param>
        <param name="detectEncodingFromByteOrderMarks">
          <span data-ttu-id="9083a-287">
            <see langword="true" /> pour rechercher les marques d'ordre d'octet au début du fichier ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-287">
              <see langword="true" /> to look for byte order marks at the beginning of the file; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="9083a-288">Taille minimale de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-288">The minimum buffer size.</span>
          </span>
        </param>
        <param name="leaveOpen">
          <span data-ttu-id="9083a-289">
            <see langword="true" /> pour maintenir le flux ouvert après avoir supprimé l'objet <see cref="T:System.IO.StreamReader" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-289">
              <see langword="true" /> to leave the stream open after the <see cref="T:System.IO.StreamReader" /> object is disposed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-290">Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamReader" /> pour le flux spécifié en fonction de l'encodage de caractères, de l'option de détection de la marque d'ordre d'octet et de la taille de mémoire tampon spécifiés, et permet éventuellement de laisser le flux ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-290">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream based on the specified character encoding, byte order mark detection option, and buffer size, and optionally leaves the stream open.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-291">Sauf si vous définissez la `leaveOpen` paramètre `true`, la <xref:System.IO.StreamReader> object appelle <xref:System.IO.Stream.Dispose> sur fourni <xref:System.IO.Stream> objet lorsque <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> est appelée.</span><span class="sxs-lookup"><span data-stu-id="9083a-291">Unless you set the `leaveOpen` parameter to `true`, the <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
 <span data-ttu-id="9083a-292">La taille de mémoire tampon, en nombre de caractères de 16 bits, est définie par le `bufferSize` paramètre.</span><span class="sxs-lookup"><span data-stu-id="9083a-292">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="9083a-293">Si `bufferSize` est inférieure à la taille minimale autorisée (128 caractères), la taille minimale autorisée est utilisée.</span><span class="sxs-lookup"><span data-stu-id="9083a-293">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="9083a-294">Ce constructeur vous permet de modifier l’encodage de la première fois que vous lire à partir du <xref:System.IO.StreamReader> objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-294">This constructor enables you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="9083a-295">Si le `detectEncodingFromByteOrderMarks` paramètre est `true`, le constructeur détecte l’encodage en examinant les quatre premiers octets du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-295">If the `detectEncodingFromByteOrderMarks` parameter is `true`, the constructor detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="9083a-296">Il reconnaît automatiquement Unicode UTF-8, little-endian, Unicode big-endian, le texte de primauté UTF-32 et big-endian de UTF-32 si le fichier commence par les marques d’ordre d’octet appropriées.</span><span class="sxs-lookup"><span data-stu-id="9083a-296">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="9083a-297">Sinon, l’encodage fourni par l’utilisateur est utilisé.</span><span class="sxs-lookup"><span data-stu-id="9083a-297">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="9083a-298">Pour plus d’informations, consultez la méthode <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-298">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9083a-299">Lors de la lecture à partir d’un <xref:System.IO.Stream>, il est plus efficace d’utiliser une mémoire tampon qui est la même taille que la mémoire tampon interne du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-299">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9083a-300">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétées correctement et peut provoquer une exception levée.</span><span class="sxs-lookup"><span data-stu-id="9083a-300">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpreted correctly, and could cause an exception to be thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9083a-301">Retourne le flux sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-301">Returns the underlying stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9083a-302">Flux sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-302">The underlying stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-303">Cette propriété vous permet d’accéder au flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="9083a-303">You use this property to access the underlying stream.</span></span> <span data-ttu-id="9083a-304">Le <xref:System.IO.StreamReader> classe entrée de mémoires tampons dans le flux sous-jacent lorsque vous appelez une de la <xref:System.IO.StreamReader.Read%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="9083a-304">The <xref:System.IO.StreamReader> class buffers input from the underlying stream when you call one of the <xref:System.IO.StreamReader.Read%2A> methods.</span></span> <span data-ttu-id="9083a-305">Si vous manipulez la position du flux sous-jacent après avoir lu les données dans la mémoire tampon, la position du flux sous-jacent ne peut pas correspondre à la position de la mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="9083a-305">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="9083a-306">Pour rétablir la mémoire tampon interne, appelez le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode ; Toutefois, cette méthode ralentit les performances et doit être appelée uniquement lorsque cela est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9083a-306">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span> <span data-ttu-id="9083a-307">Le <xref:System.IO.StreamReader> constructeurs qui ont le `detectEncodingFromByteOrderMarks` paramètre permettre modifier l’encodage de la première fois que vous lire à partir du <xref:System.IO.StreamReader> objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-307">The <xref:System.IO.StreamReader> constructors that have the `detectEncodingFromByteOrderMarks` parameter can change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span>  
  
 <span data-ttu-id="9083a-308">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-308">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-309">Ferme l'objet <see cref="T:System.IO.StreamReader" /> et le flux sous-jacent, et libère toutes les ressources système associées au lecteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-309">Closes the <see cref="T:System.IO.StreamReader" /> object and the underlying stream, and releases any system resources associated with the reader.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-310">Cette méthode remplace la <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-310">This method overrides the <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="9083a-311">Cette implémentation de <xref:System.IO.StreamReader.Close%2A> appelle le <xref:System.IO.StreamReader.Dispose%2A> méthode en passant un `true` valeur.</span><span class="sxs-lookup"><span data-stu-id="9083a-311">This implementation of <xref:System.IO.StreamReader.Close%2A> calls the <xref:System.IO.StreamReader.Dispose%2A> method passing a `true` value.</span></span>  
  
 <span data-ttu-id="9083a-312">Vider le flux ne videra pas son encodeur sous-jacent, sauf si vous appelez explicitement <xref:System.IO.StreamReader.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="9083a-312">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.StreamReader.Close%2A>.</span></span> <span data-ttu-id="9083a-313">Paramètre <xref:System.IO.StreamWriter.AutoFlush%2A> à `true` signifie que les données sont vidées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé.</span><span class="sxs-lookup"><span data-stu-id="9083a-313">Setting <xref:System.IO.StreamWriter.AutoFlush%2A> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="9083a-314">Ainsi, l’encodeur afin de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères.</span><span class="sxs-lookup"><span data-stu-id="9083a-314">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="9083a-315">Ce scénario affecte UTF8 et UTF7, où certains caractères peuvent être codés uniquement après que l’encodeur a reçu les caractères adjacents.</span><span class="sxs-lookup"><span data-stu-id="9083a-315">This scenario affects UTF8 and UTF7, where certain characters can be encoded only after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="9083a-316">Suit un appel à <xref:System.IO.StreamReader.Close%2A>, toutes les opérations sur le lecteur peuvent lever des exceptions.</span><span class="sxs-lookup"><span data-stu-id="9083a-316">Following a call to <xref:System.IO.StreamReader.Close%2A>, any operations on the reader might raise exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9083a-317">Obtient l'encodage de caractères actuel utilisé par l'objet <see cref="T:System.IO.StreamReader" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-317">Gets the current character encoding that the current <see cref="T:System.IO.StreamReader" /> object is using.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9083a-318">Encodage des caractères actuel utilisé par le lecteur en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-318">The current character encoding used by the current reader.</span>
          </span>
          <span data-ttu-id="9083a-319">La valeur peut être différente après le premier appel à toute méthode <see cref="Overload:System.IO.StreamReader.Read" /> de <see cref="T:System.IO.StreamReader" />, car la détection automatique de l'encodage n'est effectuée qu'au premier appel à une méthode <see cref="Overload:System.IO.StreamReader.Read" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-319">The value can be different after the first call to any <see cref="Overload:System.IO.StreamReader.Read" /> method of <see cref="T:System.IO.StreamReader" />, since encoding autodetection is not done until the first call to a <see cref="Overload:System.IO.StreamReader.Read" /> method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-320">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-320">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-321">L’exemple de code suivant obtient l’encodage spécifié <xref:System.IO.StreamReader> objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-321">The following code example gets the encoding of the specified <xref:System.IO.StreamReader> object.</span></span>  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-322">Efface la mémoire tampon interne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-322">Clears the internal buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-323">Utilisez le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode pour réinitialiser la mémoire tampon interne pour le <xref:System.IO.StreamReader> objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-323">Use the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method to reset the internal buffer for the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="9083a-324">Vous devez appeler cette méthode uniquement lorsque la position de la mémoire tampon interne et le <xref:System.IO.StreamReader.BaseStream%2A> ne correspondent pas.</span><span class="sxs-lookup"><span data-stu-id="9083a-324">You need to call this method only when the position of the internal buffer and the <xref:System.IO.StreamReader.BaseStream%2A> do not match.</span></span> <span data-ttu-id="9083a-325">Ces positions peuvent être incompatibles lors de la lecture des données dans la mémoire tampon et de rechercher une nouvelle position dans le flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="9083a-325">These positions can become mismatched when you read data into the buffer and then seek a new position in the underlying stream.</span></span> <span data-ttu-id="9083a-326">Cette méthode ralentit les performances et doit être utilisée uniquement en cas d’absolue nécessité, par exemple lorsque vous souhaitez lire une partie du contenu d’un <xref:System.IO.StreamReader> objet plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="9083a-326">This method slows performance and should be used only when absolutely necessary, such as when you want to read a portion of the contents of a <xref:System.IO.StreamReader> object more than once.</span></span>  
  
 <span data-ttu-id="9083a-327">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-327">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-328">L’exemple suivant montre un scénario où le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode doit être appelée pour synchroniser la mémoire tampon interne et le flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="9083a-328">The following example shows a scenario where the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method must be called to synchronize the internal buffer and the underlying stream.</span></span> <span data-ttu-id="9083a-329">Le fichier dans l’exemple est utilisé pour illustrer la position et se compose du texte `abcdefghijklmnopqrstuvwxyz`.</span><span class="sxs-lookup"><span data-stu-id="9083a-329">The file in the example is used to illustrate position and consists of the text `abcdefghijklmnopqrstuvwxyz`.</span></span> <span data-ttu-id="9083a-330">En appelant <xref:System.IO.StreamReader.DiscardBufferedData%2A> une fois que les données sont lues, l’exemple fonctionne comme prévu.</span><span class="sxs-lookup"><span data-stu-id="9083a-330">By calling <xref:System.IO.StreamReader.DiscardBufferedData%2A> after the data is read, the example works as expected.</span></span> <span data-ttu-id="9083a-331">Une fois que les 15 premiers caractères sont lus, la position est réinitialisée à la valeur de décalage de 2 et les autres caractères sont lus.</span><span class="sxs-lookup"><span data-stu-id="9083a-331">After the first 15 characters are read, the position is reset to the offset value of 2 and all the remaining characters are read.</span></span> <span data-ttu-id="9083a-332">Si vous supprimez l’appel à <xref:System.IO.StreamReader.DiscardBufferedData%2A>, l’exemple ne fonctionne pas comme prévu.</span><span class="sxs-lookup"><span data-stu-id="9083a-332">If you remove the call to <xref:System.IO.StreamReader.DiscardBufferedData%2A>, the example does not work as expected.</span></span> <span data-ttu-id="9083a-333">Les 15 premiers caractères sont lus, mais uniquement la position du flux sous-jacent est réinitialisée.</span><span class="sxs-lookup"><span data-stu-id="9083a-333">The first 15 characters are read, but only the position of the underlying stream is reset.</span></span> <span data-ttu-id="9083a-334">La mémoire tampon interne de le <xref:System.IO.StreamReader> objet est toujours sur le 16ème caractère.</span><span class="sxs-lookup"><span data-stu-id="9083a-334">The internal buffer of the <xref:System.IO.StreamReader> object is still on the 16th character.</span></span> <span data-ttu-id="9083a-335">Par conséquent, <xref:System.IO.StreamReader.ReadToEnd%2A> retourne tous les caractères dans la mémoire tampon plus les caractères dans le flux sous-jacent à partir de la position de la réinitialisation.</span><span class="sxs-lookup"><span data-stu-id="9083a-335">Therefore, <xref:System.IO.StreamReader.ReadToEnd%2A> returns all the characters in the buffer plus the characters in the underlying stream starting from the reset position.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="9083a-336">
            <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-336">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-337">Ferme le flux sous-jacent, libère les ressources non managées utilisées par l'élément <see cref="T:System.IO.StreamReader" /> et libère éventuellement les ressources managées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-337">Closes the underlying stream, releases the unmanaged resources used by the <see cref="T:System.IO.StreamReader" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-338">Cette méthode est appelée par le public <xref:System.IDisposable.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-338">This method is called by the public <xref:System.IDisposable.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="9083a-339"><xref:System.IDisposable.Dispose%2A> appelle la méthode protégée <xref:System.IO.StreamReader.Dispose%2A> méthode avec le `disposing` est défini sur true.</span><span class="sxs-lookup"><span data-stu-id="9083a-339"><xref:System.IDisposable.Dispose%2A> invokes the protected <xref:System.IO.StreamReader.Dispose%2A> method with the `disposing` parameter set to true.</span></span> <span data-ttu-id="9083a-340"><xref:System.Object.Finalize%2A> appelle <xref:System.IO.StreamReader.Dispose%2A> avec `disposing` défini sur false.</span><span class="sxs-lookup"><span data-stu-id="9083a-340"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.StreamReader.Dispose%2A> with `disposing` set to false.</span></span>  
  
 <span data-ttu-id="9083a-341">Lorsque le `disposing` paramètre est `true`, cette méthode libère toutes les ressources détenues par les gérés objets qui la <xref:System.IO.StreamReader> références d’objet.</span><span class="sxs-lookup"><span data-stu-id="9083a-341">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that the <xref:System.IO.StreamReader> object references.</span></span> <span data-ttu-id="9083a-342">Cette méthode appelle la méthode <xref:System.IDisposable.Dispose%2A> de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="9083a-342">This method invokes the <xref:System.IDisposable.Dispose%2A> method of each referenced object.</span></span>  
  
 <span data-ttu-id="9083a-343">.</span><span class="sxs-lookup"><span data-stu-id="9083a-343">.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9083a-344">
            <para>Dispose peut être appelé plusieurs fois par d’autres objets. Lors de la substitution <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à Dispose [cref,...]. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Pour plus d’informations sur <see cref="M:System.IDisposable.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-344">
              <para>Dispose can be called multiple times by other objects. When overriding <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to Dispose[cref,...]. For more information about how to implement <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see cref="M:System.IDisposable.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9083a-345">Obtient une valeur qui indique si la position actuelle dans le flux est à la fin du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-345">Gets a value that indicates whether the current stream position is at the end of the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9083a-346">
            <see langword="true" /> si la position actuelle dans le flux est à la fin du flux ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-346">
              <see langword="true" /> if the current stream position is at the end of the stream; otherwise <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9083a-347">Le flux sous-jacent a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-347">The underlying stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9083a-348">Objet <see cref="T:System.IO.StreamReader" /> autour d'un flux vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-348">A <see cref="T:System.IO.StreamReader" /> object around an empty stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-349">Lors de la lecture méthodes sont appelées sur <xref:System.IO.StreamReader.Null>, zéro est toujours retourné.</span><span class="sxs-lookup"><span data-stu-id="9083a-349">When read methods are invoked on <xref:System.IO.StreamReader.Null>, zero is always returned.</span></span> <span data-ttu-id="9083a-350">Lorsque <xref:System.IO.StreamReader.ReadLine%2A> est appelée sur <xref:System.IO.StreamReader.Null>, `null` est retournée.</span><span class="sxs-lookup"><span data-stu-id="9083a-350">When <xref:System.IO.StreamReader.ReadLine%2A> is invoked on <xref:System.IO.StreamReader.Null>, `null` is returned.</span></span>  
  
 <span data-ttu-id="9083a-351">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-351">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-352">Retourne le caractère disponible suivant, mais ne le consomme pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-352">Returns the next available character but does not consume it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-353">Entier représentant le caractère suivant à lire, ou -1 s'il n'y a pas de caractère à lire ou si le flux ne prend pas en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-353">An integer representing the next character to be read, or -1 if there are no characters to be read or if the stream does not support seeking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-354">Le <xref:System.IO.StreamReader.Peek%2A> méthode retourne une valeur entière afin de déterminer si la fin du fichier ou une autre erreur s’est produite.</span><span class="sxs-lookup"><span data-stu-id="9083a-354">The <xref:System.IO.StreamReader.Peek%2A> method returns an integer value in order to determine whether the end of the file, or another error has occurred.</span></span> <span data-ttu-id="9083a-355">Cela permet à un utilisateur à vérifier au préalable si la valeur retournée est -1 avant un cast sur un <xref:System.Char> type.</span><span class="sxs-lookup"><span data-stu-id="9083a-355">This allows a user to first check if the returned value is -1 before casting it to a <xref:System.Char> type.</span></span>  
  
 <span data-ttu-id="9083a-356">Cette méthode se substitue à <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-356">This method overrides <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9083a-357">La position actuelle de la <xref:System.IO.StreamReader> objet n’est pas modifié par <xref:System.IO.StreamReader.Peek%2A>.</span><span class="sxs-lookup"><span data-stu-id="9083a-357">The current position of the <xref:System.IO.StreamReader> object is not changed by <xref:System.IO.StreamReader.Peek%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-358">L’exemple de code suivant lit les lignes d’un fichier jusqu'à la fin du fichier.</span><span class="sxs-lookup"><span data-stu-id="9083a-358">The following code example reads lines from a file until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-359">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-359">An I/O error occurs.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9083a-360">Lit le caractère ou l'ensemble de caractères suivant dans le flux d'entrée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-360">Reads the next character or next set of characters from the input stream.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-361">Lit le caractère suivant dans le flux d'entrée et avance la position d'un caractère.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-361">Reads the next character from the input stream and advances the character position by one character.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-362">Caractère suivant du flux d'entrée, représenté sous la forme d'un objet <see cref="T:System.Int32" />, ou -1 s'il n'y a plus de caractère disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-362">The next character from the input stream represented as an <see cref="T:System.Int32" /> object, or -1 if no more characters are available.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-363">Cette méthode se substitue à <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-363">This method overrides <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9083a-364">Cette méthode retourne un entier afin qu’elle peut retourner -1 si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-364">This method returns an integer so that it can return -1 if the end of the stream has been reached.</span></span> <span data-ttu-id="9083a-365">Si vous manipulez la position du flux sous-jacent après avoir lu les données dans la mémoire tampon, la position du flux sous-jacent ne peut pas correspondre à la position de la mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="9083a-365">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="9083a-366">Pour rétablir la mémoire tampon interne, appelez le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode ; Toutefois, cette méthode ralentit les performances et doit être appelée uniquement lorsque cela est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9083a-366">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="9083a-367">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-367">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-368">L’exemple de code suivant montre une utilisation simple du <xref:System.IO.StreamReader.Read%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-368">The following code example demonstrates a simple use of the <xref:System.IO.StreamReader.Read%2A> method.</span></span>  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 <span data-ttu-id="9083a-369">L’exemple de code suivant illustre la lecture d’un caractère unique à l’aide de la <xref:System.IO.StreamReader.Read> surcharge de méthode, la mise en forme de l’entier ASCII de sortie en tant que séparateur décimal et hexadécimal.</span><span class="sxs-lookup"><span data-stu-id="9083a-369">The following code example demonstrates reading a single character using the <xref:System.IO.StreamReader.Read> method overload, formatting the ASCII integer output as decimal and hexadecimal.</span></span>  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-370">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-370">An I/O error occurs.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="9083a-371">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <c>index</c> et (<c>index + count - 1</c>) sont remplacées par les caractères lus à partir de la source actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-371">When this method returns, contains the specified character array with the values between <c>index</c> and (<c>index + count - 1</c>) replaced by the characters read from the current source.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="9083a-372">Index de <c>buffer</c> où commencer l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-372">The index of <c>buffer</c> at which to begin writing.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="9083a-373">Nombre maximal de caractères à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-373">The maximum number of characters to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-374">Lit un nombre maximal de caractères spécifié du flux actuel dans une mémoire tampon, en commençant à l'index spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-374">Reads a specified maximum of characters from the current stream into a buffer, beginning at the specified index.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-375">Le nombre de caractères qui ont été lus, ou 0 si c'est la fin du flux et qu'aucune donnée n'a été lue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-375">The number of characters that have been read, or 0 if at the end of the stream and no data was read.</span>
          </span>
          <span data-ttu-id="9083a-376">Le nombre sera inférieur ou égal à la valeur du paramètre <paramref name="count" />, selon que les données sont, ou non, disponibles dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-376">The number will be less than or equal to the <paramref name="count" /> parameter, depending on whether the data is available within the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-377">Cette méthode se substitue à <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-377">This method overrides <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9083a-378">Cette méthode retourne un entier afin qu’elle peut retourner 0 si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-378">This method returns an integer so that it can return 0 if the end of the stream has been reached.</span></span>  
  
 <span data-ttu-id="9083a-379">Lorsque vous utilisez le <xref:System.IO.StreamReader.Read%2A> (méthode), il est plus efficace d’utiliser une mémoire tampon qui est la même taille que la mémoire tampon interne du flux, où la mémoire tampon interne est égale à la taille de bloc souhaitée et de toujours lire moins que la taille de bloc.</span><span class="sxs-lookup"><span data-stu-id="9083a-379">When using the <xref:System.IO.StreamReader.Read%2A> method, it is more efficient to use a buffer that is the same size as the internal buffer of the stream, where the internal buffer is set to your desired block size, and to always read less than the block size.</span></span> <span data-ttu-id="9083a-380">Si la taille de la mémoire tampon interne a été non spécifiée lors de la construction du flux, sa taille par défaut est 4 Ko (4 096 octets).</span><span class="sxs-lookup"><span data-stu-id="9083a-380">If the size of the internal buffer was unspecified when the stream was constructed, its default size is 4 kilobytes (4096 bytes).</span></span> <span data-ttu-id="9083a-381">Si vous manipulez la position du flux sous-jacent après avoir lu les données dans la mémoire tampon, la position du flux sous-jacent ne peut pas correspondre à la position de la mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="9083a-381">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="9083a-382">Pour rétablir la mémoire tampon interne, appelez le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode ; Toutefois, cette méthode ralentit les performances et doit être appelée uniquement lorsque cela est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9083a-382">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="9083a-383">Cette méthode retourne soit après le nombre de caractères spécifié par le `count` paramètre sont en lecture ou la fin du fichier est atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-383">This method returns after either the number of characters specified by the `count` parameter are read, or the end of the file is reached.</span></span> <span data-ttu-id="9083a-384"><xref:System.IO.TextReader.ReadBlock%2A> est une version de blocage de <xref:System.IO.StreamReader.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="9083a-384"><xref:System.IO.TextReader.ReadBlock%2A> is a blocking version of <xref:System.IO.StreamReader.Read%2A>.</span></span>  
  
 <span data-ttu-id="9083a-385">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-385">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-386">L’exemple de code suivant lit cinq caractères à la fois jusqu'à ce que la fin du fichier est atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-386">The following code example reads five characters at a time until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-387">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-387">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-388">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-388">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-389">
            <paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-389">
              <paramref name="index" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-390">Une erreur d’E/S, telle que la fermeture du flux, se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-390">An I/O error occurs, such as the stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="9083a-391">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <c>index</c> et (<c>index</c> + <c>count</c> - 1) sont remplacées par les caractères lus à partir de la source actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-391">When this method returns, contains the specified character array with the values between <c>index</c> and (<c>index</c> + <c>count</c> - 1) replaced by the characters read from the current source.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="9083a-392">Position dans <c>buffer</c> à partir de laquelle commencer l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-392">The position in <c>buffer</c> at which to begin writing.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="9083a-393">Nombre maximal de caractères à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-393">The maximum number of characters to read.</span>
          </span>
          <span data-ttu-id="9083a-394">Si la fin du flux est atteinte avant que le nombre de caractères spécifié soit écrit dans la mémoire tampon, la méthode en cours se termine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-394">If the end of the stream is reached before the specified number of characters is written into the buffer, the current method returns.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-395">Lit un nombre maximal spécifié de caractères dans le flux actuel de manière asynchrone, et écrit les données dans une mémoire tampon, en commençant à l'index spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-395">Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-396">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-396">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="9083a-397">La valeur du paramètre <paramref name="TResult" /> contient le nombre total de caractères lus dans la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-397">The value of the <paramref name="TResult" /> parameter contains the total number of characters read into the buffer.</span>
          </span>
          <span data-ttu-id="9083a-398">La valeur du résultat peut être inférieure au nombre de caractères demandés si le nombre de caractères actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-398">The result value can be less than the number of characters requested if the number of characters currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-399">La tâche termine après un nombre de caractères spécifié par le `count` paramètre sont en lecture ou la fin du flux est atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-399">The task completes after either the number of characters specified by the `count` parameter are read or the end of the stream is reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-400">L’exemple suivant montre comment lire tous les caractères dans un fichier à l’aide de la <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-400">The following example shows how to read all the characters in a file by using the <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="9083a-401">Il vérifie si chaque caractère est une lettre, un chiffre ou un espace blanc avant d’ajouter le caractère à une instance de la <xref:System.Text.StringBuilder> classe.</span><span class="sxs-lookup"><span data-stu-id="9083a-401">It checks whether each character is a letter, digit, or white space before adding the character to an instance of the <xref:System.Text.StringBuilder> class.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-402">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-402">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-403">
            <paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-403">
              <paramref name="index" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-404">La somme de <paramref name="index" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-404">The sum of <paramref name="index" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9083a-405">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-405">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9083a-406">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-406">The reader is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="9083a-407">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <c>index</c> et (<c>index + count - 1</c>) sont remplacées par les caractères lus à partir de la source actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-407">When this method returns, contains the specified character array with the values between <c>index</c> and (<c>index + count - 1</c>) replaced by the characters read from the current source.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="9083a-408">Position dans <c>buffer</c> à partir de laquelle commencer l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-408">The position in <c>buffer</c> at which to begin writing.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="9083a-409">Nombre maximal de caractères à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-409">The maximum number of characters to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-410">Lit un nombre maximal spécifié de caractères à partir du flux actuel et écrit les données dans une mémoire tampon, en commençant à l'index spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-410">Reads a specified maximum number of characters from the current stream and writes the data to a buffer, beginning at the specified index.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-411">Nombre de caractères lus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-411">The number of characters that have been read.</span>
          </span>
          <span data-ttu-id="9083a-412">Le nombre sera inférieur ou égal à <paramref name="count" />, selon que tous les caractères d'entrée ont été lus ou non.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-412">The number will be less than or equal to <paramref name="count" />, depending on whether all input characters have been read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-413">La position du flux sous-jacent est avancée par le nombre de caractères qui ont été lus dans `buffer`.</span><span class="sxs-lookup"><span data-stu-id="9083a-413">The position of the underlying stream is advanced by the number of characters that were read into `buffer`.</span></span>  
  
 <span data-ttu-id="9083a-414">La méthode se bloque jusqu'à ce que `count` caractères sont lus, ou la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-414">The method blocks until either `count` characters are read, or the end of the stream has been reached.</span></span> <span data-ttu-id="9083a-415">Il s’agit d’une version de blocage de <xref:System.IO.StreamReader.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="9083a-415">This is a blocking version of <xref:System.IO.StreamReader.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-416">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-416">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-417">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-417">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-418">
            <paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-418">
              <paramref name="index" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9083a-419">Le <see cref="T:System.IO.StreamReader" /> est fermé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-419">The <see cref="T:System.IO.StreamReader" /> is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-420">Une erreur d'E/S s'est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-420">An I/O error occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="9083a-421">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <c>index</c> et (<c>index</c> + <c>count</c> - 1) sont remplacées par les caractères lus à partir de la source actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-421">When this method returns, contains the specified character array with the values between <c>index</c> and (<c>index</c> + <c>count</c> - 1) replaced by the characters read from the current source.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="9083a-422">Position dans <c>buffer</c> à partir de laquelle commencer l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-422">The position in <c>buffer</c> at which to begin writing.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="9083a-423">Nombre maximal de caractères à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-423">The maximum number of characters to read.</span>
          </span>
          <span data-ttu-id="9083a-424">Si la fin du flux est atteinte avant que le nombre de caractères spécifié soit écrit dans la mémoire tampon, la méthode se termine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-424">If the end of the stream is reached before the specified number of characters is written into the buffer, the method returns.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9083a-425">Lit un nombre maximal spécifié de caractères dans le flux actuel de manière asynchrone, et écrit les données dans une mémoire tampon, en commençant à l'index spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-425">Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-426">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-426">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="9083a-427">La valeur du paramètre <paramref name="TResult" /> contient le nombre total de caractères lus dans la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-427">The value of the <paramref name="TResult" /> parameter contains the total number of characters read into the buffer.</span>
          </span>
          <span data-ttu-id="9083a-428">La valeur du résultat peut être inférieure au nombre de caractères demandés si le nombre de caractères actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-428">The result value can be less than the number of characters requested if the number of characters currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-429">La tâche ne termine pas tant que le nombre de caractères spécifié par le `count` paramètre sont en lecture ou la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-429">The task does not complete until either the number of characters specified by the `count` parameter are read, or the end of the stream has been reached.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9083a-430">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-430">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-431">
            <paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-431">
              <paramref name="index" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9083a-432">La somme de <paramref name="index" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-432">The sum of <paramref name="index" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9083a-433">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-433">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9083a-434">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-434">The reader is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-435">Lit une ligne de caractères du flux actuel et retourne les données sous forme de chaîne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-435">Reads a line of characters from the current stream and returns the data as a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-436">Ligne suivante du flux d'entrée, ou <see langword="null" /> si la fin du flux d'entrée est atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-436">The next line from the input stream, or <see langword="null" /> if the end of the input stream is reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-437">Une ligne est définie comme une séquence de caractères suivi d’une ligne du flux (« \n »), un retour chariot (« \r »), ou un retour chariot immédiatement suivi d’une ligne du flux (« \r\n »).</span><span class="sxs-lookup"><span data-stu-id="9083a-437">A line is defined as a sequence of characters followed by a line feed ("\n"), a carriage return ("\r"), or a carriage return immediately followed by a line feed ("\r\n").</span></span> <span data-ttu-id="9083a-438">La chaîne retournée ne contient pas le retour chariot ou saut de ligne.</span><span class="sxs-lookup"><span data-stu-id="9083a-438">The string that is returned does not contain the terminating carriage return or line feed.</span></span> <span data-ttu-id="9083a-439">La valeur retournée est `null` si la fin du flux d’entrée est atteinte.</span><span class="sxs-lookup"><span data-stu-id="9083a-439">The returned value is `null` if the end of the input stream is reached.</span></span>  
  
 <span data-ttu-id="9083a-440">Cette méthode se substitue à <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-440">This method overrides <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9083a-441">Si la méthode actuelle lève une <xref:System.OutOfMemoryException>, la position du lecteur dans sous-jacent <xref:System.IO.Stream> objet est avancé par le nombre de caractères que la méthode a été en mesure de lire, mais les caractères déjà lus dans le texte interne <xref:System.IO.StreamReader.ReadLine%2A> tampon sont ignorées. .</span><span class="sxs-lookup"><span data-stu-id="9083a-441">If the current method throws an <xref:System.OutOfMemoryException>, the reader's position in the underlying <xref:System.IO.Stream> object is advanced by the number of characters the method was able to read, but the characters already read into the internal <xref:System.IO.StreamReader.ReadLine%2A> buffer are discarded.</span></span> <span data-ttu-id="9083a-442">Si vous manipulez la position du flux sous-jacent après avoir lu les données dans la mémoire tampon, la position du flux sous-jacent ne peut pas correspondre à la position de la mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="9083a-442">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="9083a-443">Pour rétablir la mémoire tampon interne, appelez le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode ; Toutefois, cette méthode ralentit les performances et doit être appelée uniquement lorsque cela est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9083a-443">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="9083a-444">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-444">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-445">L’exemple de code suivant lit les lignes d’un fichier jusqu'à la fin du fichier.</span><span class="sxs-lookup"><span data-stu-id="9083a-445">The following code example reads lines from a file until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="9083a-446">La mémoire est insuffisante pour allouer une mémoire tampon à la chaîne retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-446">There is insufficient memory to allocate a buffer for the returned string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-447">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-447">An I/O error occurs.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-448">Lit une ligne de caractères de manière asynchrone dans le flux actuel et retourne les données sous forme de chaîne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-448">Reads a line of characters asynchronously from the current stream and returns the data as a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-449">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-449">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="9083a-450">La valeur du paramètre <paramref name="TResult" /> contient la ligne suivante du flux, ou a la valeur <see langword="null" /> si tous les caractères ont été lus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-450">The value of the <paramref name="TResult" /> parameter contains the next line from the stream, or is <see langword="null" /> if all the characters have been read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9083a-451">L’exemple suivant montre comment lire la première ligne d’un fichier à l’aide de la <xref:System.IO.StreamReader.ReadLineAsync> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-451">The following example shows how to read the first line of a file by using the <xref:System.IO.StreamReader.ReadLineAsync> method.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-452">Le nombre de caractères dans la ligne suivante est supérieur à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-452">The number of characters in the next line is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9083a-453">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-453">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9083a-454">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-454">The reader is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-455">Lit tous les caractères entre la position actuelle et la fin du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-455">Reads all characters from the current position to the end of the stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-456">Le reste du flux sous forme de chaîne, de la position actuelle jusqu'à la fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-456">The rest of the stream as a string, from the current position to the end.</span>
          </span>
          <span data-ttu-id="9083a-457">Si la position actuelle est à la fin du flux, retourne une chaîne vide ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-457">If the current position is at the end of the stream, returns an empty string ("").</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9083a-458">Cette méthode se substitue à <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9083a-458">This method overrides <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9083a-459"><xref:System.IO.StreamReader.ReadToEnd%2A> fonctionne mieux lorsque vous devez lire toutes les entrées à partir de la position actuelle jusqu'à la fin du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-459"><xref:System.IO.StreamReader.ReadToEnd%2A> works best when you need to read all the input from the current position to the end of the stream.</span></span> <span data-ttu-id="9083a-460">Si davantage de contrôle est nécessaire sur le nombre de caractères est lus à partir du flux, utilisez la <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode, qui offre généralement de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="9083a-460">If more control is needed over how many characters are read from the stream, use the <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method overload, which generally results in better performance.</span></span>  
  
 <span data-ttu-id="9083a-461"><xref:System.IO.StreamReader.ReadToEnd%2A> suppose que le flux de données sait quand il a atteint une fin.</span><span class="sxs-lookup"><span data-stu-id="9083a-461"><xref:System.IO.StreamReader.ReadToEnd%2A> assumes that the stream knows when it has reached an end.</span></span> <span data-ttu-id="9083a-462">Pour les protocoles interactifs dans lequel le serveur envoie des données uniquement lorsque vous demandez d’et ne fermez pas la connexion, <xref:System.IO.StreamReader.ReadToEnd%2A> peut se bloquer indéfiniment, car il n’atteint pas une fin et doit être évitée.</span><span class="sxs-lookup"><span data-stu-id="9083a-462">For interactive protocols in which the server sends data only when you ask for it and does not close the connection, <xref:System.IO.StreamReader.ReadToEnd%2A> might block indefinitely because it does not reach an end, and should be avoided.</span></span>  
  
 <span data-ttu-id="9083a-463">Notez que lorsque vous utilisez le <xref:System.IO.StreamReader.Read%2A> (méthode), il est plus efficace d’utiliser une mémoire tampon qui est la même taille que la mémoire tampon interne du flux.</span><span class="sxs-lookup"><span data-stu-id="9083a-463">Note that when using the <xref:System.IO.StreamReader.Read%2A> method, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span> <span data-ttu-id="9083a-464">Si la taille de la mémoire tampon a été non spécifiée lors de la construction du flux, sa taille par défaut est 4 Ko (4 096 octets).</span><span class="sxs-lookup"><span data-stu-id="9083a-464">If the size of the buffer was unspecified when the stream was constructed, its default size is 4 kilobytes (4096 bytes).</span></span>  
  
 <span data-ttu-id="9083a-465">Si la méthode actuelle lève une <xref:System.OutOfMemoryException>, la position du lecteur dans sous-jacent <xref:System.IO.Stream> objet est avancé par le nombre de caractères que la méthode a été en mesure de lire, mais les caractères déjà lus dans le texte interne <xref:System.IO.StreamReader.ReadLine%2A> tampon sont ignorées. .</span><span class="sxs-lookup"><span data-stu-id="9083a-465">If the current method throws an <xref:System.OutOfMemoryException>, the reader's position in the underlying <xref:System.IO.Stream> object is advanced by the number of characters the method was able to read, but the characters already read into the internal <xref:System.IO.StreamReader.ReadLine%2A> buffer are discarded.</span></span> <span data-ttu-id="9083a-466">Si vous manipulez la position du flux sous-jacent après avoir lu les données dans la mémoire tampon, la position du flux sous-jacent ne peut pas correspondre à la position de la mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="9083a-466">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="9083a-467">Pour rétablir la mémoire tampon interne, appelez le <xref:System.IO.StreamReader.DiscardBufferedData%2A> méthode ; Toutefois, cette méthode ralentit les performances et doit être appelée uniquement lorsque cela est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9083a-467">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="9083a-468">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="9083a-468">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9083a-469">L’exemple de code suivant lit jusqu'à la fin d’un fichier en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="9083a-469">The following code example reads all the way to the end of a file in one operation.</span></span>  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="9083a-470">La mémoire est insuffisante pour allouer une mémoire tampon à la chaîne retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-470">There is insufficient memory to allocate a buffer for the returned string.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9083a-471">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-471">An I/O error occurs.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9083a-472">Lit tous les caractères entre la position actuelle et la fin du flux de manière asynchrone, puis les retourne sous la forme d'une chaîne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-472">Reads all characters from the current position to the end of the stream asynchronously and returns them as one string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9083a-473">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-473">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="9083a-474">La valeur du paramètre <paramref name="TResult" /> contient une chaîne composée des caractères allant de la position actuelle à la fin du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-474">The value of the <paramref name="TResult" /> parameter contains a string with the characters from the current position to the end of the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9083a-475">L’exemple suivant montre comment lire le contenu d’un fichier à l’aide de la <xref:System.IO.StreamReader.ReadToEndAsync> (méthode).</span><span class="sxs-lookup"><span data-stu-id="9083a-475">The following example shows how to read the contents of a file by using the <xref:System.IO.StreamReader.ReadToEndAsync> method.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9083a-476">Le nombre de caractères est supérieur à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-476">The number of characters is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="9083a-477">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-477">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9083a-478">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9083a-478">The reader is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>