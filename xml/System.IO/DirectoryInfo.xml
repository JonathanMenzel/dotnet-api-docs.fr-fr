<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DirectoryInfo.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86cf57138ff45a8e0ac1237da3e85d3d72b784fca1c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f57138ff45a8e0ac1237da3e85d3d72b784fca1c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Exposes instance methods for creating, moving, and enumerating through directories and subdirectories.</source>
          <target state="translated">Expose des méthodes d'instance pour créer, se déplacer dans et énumérer des répertoires et sous-répertoires.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>This class cannot be inherited.</source>
          <target state="translated">Cette classe ne peut pas être héritée.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> class for typical operations such as copying, moving, renaming, creating, and deleting directories.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> classe pour les opérations courantes telles que copier, déplacer, renommer, création et supprimer des répertoires.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>If you are going to reuse an object several times, consider using the instance method of <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> instead of the corresponding static methods of the <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph> class, because a security check will not always be necessary.</source>
          <target state="translated">Si vous souhaitez réutiliser un objet plusieurs fois, envisagez d’utiliser la méthode d’instance de <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> au lieu de méthodes statiques correspondantes de la <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph> classe, car une vérification de sécurité n'est pas toujours nécessaire.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>In members that accept a path as an input string, that path must be well-formed or an exception is raised.</source>
          <target state="translated">Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement formé ou une exception est levée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</source>
          <target state="translated">Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>Therefore, the path is malformed and an exception is raised.</source>
          <target state="translated">Par conséquent, le chemin d’accès est incorrect et une exception est levée.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>Similarly, a path or a combination of paths cannot be fully qualified twice.</source>
          <target state="translated">De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>For example, "c:\temp c:\windows" also raises an exception in most cases.</source>
          <target state="translated">Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>Ensure that your paths are well-formed when using methods that accept a path string.</source>
          <target state="translated">Assurez-vous que vos chemins d’accès sont corrects lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>In members that accept a path, the path can refer to a file or just a directory.</source>
          <target state="translated">Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</source>
          <target state="translated">Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de partage et de serveur.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>For example, all the following are acceptable paths:</source>
          <target state="translated">Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</source>
          <target state="translated">« c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>"c:<ph id="ph1">\\</ph>\MyDir" in C#, or "c:\MyDir" in Visual Basic.</source>
          <target state="translated">« c:<ph id="ph1">\\</ph>\MyDir » en c# ou « c:\MyDir » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>"MyDir<ph id="ph1">\\</ph>\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</source>
          <target state="translated">« MyDir<ph id="ph1">\\</ph>\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#, or "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</source>
          <target state="translated">«<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare » en c#, ou «<ph id="ph5">\\</ph>\MyServer\MyShare » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>By default, full read/write access to new directories is granted to all users.</source>
          <target state="translated">Par défaut, l’accès complet en lecture/écriture aux nouveaux répertoires est accordé à tous les utilisateurs.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>The following example demonstrates some of the main members of the <ph id="ph1">`DirectoryInfo`</ph> class.</source>
          <target state="translated">L’exemple suivant illustre certains membres principaux de la <ph id="ph1">`DirectoryInfo`</ph> classe.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>The following example demonstrates how to copy a directory and its contents.</source>
          <target state="translated">L’exemple suivant montre comment copier un répertoire et son contenu.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>A string specifying the path on which to create the <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph>.</source>
          <target state="translated">Chaîne spécifiant le chemin d'accès où créer l'élément <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> class on the specified path.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> sur le chemin d'accès spécifié.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>This constructor does not check if a directory exists.</source>
          <target state="translated">Ce constructeur ne vérifie pas si un répertoire existe.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>This constructor is a placeholder for a string that is used to access the disk in subsequent operations.</source>
          <target state="translated">Ce constructeur est un espace réservé pour une chaîne qui est utilisée pour accéder au disque lors des opérations ultérieures.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">Le <ph id="ph1">`path`</ph> paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>The following example uses this constructor to create the specified directory and subdirectory, and demonstrates that a directory that contains subdirectories cannot be deleted.</source>
          <target state="translated">L’exemple suivant utilise ce constructeur pour créer le répertoire spécifié et un sous-répertoire et montre qu’un répertoire qui contient des sous-répertoires ne peut pas être supprimé.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains invalid characters such as ", <ph id="ph2">&amp;lt;</ph>, <ph id="ph3">&amp;gt;</ph>, or |.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient des caractères non valides tels que ", <ph id="ph2">&amp;lt;</ph>, <ph id="ph3">&amp;gt;</ph> ou |.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>The specified path, file name, or both are too long.</source>
          <target state="translated">Le chemin d’accès et/ou le nom de fichier spécifiés sont trop longs.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>for reading from files and directories.</source>
          <target state="translated">pour la lecture des fichiers et répertoires.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.#ctor(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Creates a directory.</source>
          <target state="translated">Crée un répertoire.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create">
          <source>Creates a directory.</source>
          <target state="translated">Crée un répertoire.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create">
          <source>If the directory already exists, this method does nothing.</source>
          <target state="translated">Si le répertoire existe déjà, cette méthode ne fait rien.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create">
          <source>The following example checks whether a specified directory exists, creates the directory if it does not exist, and deletes the directory.</source>
          <target state="translated">L’exemple suivant vérifie si un répertoire spécifié existe, crée le répertoire s’il n’existe pas et supprime le répertoire.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create">
          <source>The directory cannot be created.</source>
          <target state="translated">Impossible de créer le répertoire.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create">
          <source>for writing files.</source>
          <target state="translated">pour écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>The access control to apply to the directory.</source>
          <target state="translated">Contrôle d'accès à appliquer au répertoire.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>Creates a directory using a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> object.</source>
          <target state="translated">Crée un répertoire en utilisant un objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>Use this method overload to create a directory with access control, so there is no chance the directory can be accessed before security is applied.</source>
          <target state="translated">Utilisez cette surcharge de méthode pour créer un répertoire avec le contrôle d’accès, donc il n’existe aucun risque que le répertoire est accessible avant que la sécurité est appliquée.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>If the directory already exists, this method does nothing.</source>
          <target state="translated">Si le répertoire existe déjà, cette méthode ne fait rien.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>The directory specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is read-only or is not empty.</source>
          <target state="translated">Le répertoire spécifié par <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est en lecture seule ou n’est pas vide.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a zero-length string, contains only white space, or contains one or more invalid characters as defined by <ph id="ph2">&lt;see cref="F:System.IO.Path.InvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <ph id="ph2">&lt;see cref="F:System.IO.Path.InvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>Creating a directory with only the colon (:) character was attempted.</source>
          <target state="translated">La création d’un répertoire avec uniquement le caractère deux-points (:) a été tentée.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>for permission to create a directory.</source>
          <target state="translated">autorisation de créer un répertoire.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Creates a subdirectory or subdirectories on the specified path.</source>
          <target state="translated">Crée un ou plusieurs sous-répertoires dans le chemin d'accès spécifié.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>The specified path can be relative to this instance of the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> class.</source>
          <target state="translated">Le chemin d'accès spécifié peut être relatif à cette instance de la classe <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The specified path.</source>
          <target state="translated">Chemin d'accès spécifié.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>This cannot be a different disk volume or Universal Naming Convention (UNC) name.</source>
          <target state="translated">Il ne peut pas s'agir d'un nom de volume de disque ou UNC différent.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>Creates a subdirectory or subdirectories on the specified path.</source>
          <target state="translated">Crée un ou plusieurs sous-répertoires dans le chemin d'accès spécifié.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The specified path can be relative to this instance of the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> class.</source>
          <target state="translated">Le chemin d'accès spécifié peut être relatif à cette instance de la classe <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The last directory specified in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Dernier répertoire spécifié dans <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>Any and all directories specified in <ph id="ph1">`path`</ph> are created, unless some part of <ph id="ph2">`path`</ph> is invalid.</source>
          <target state="translated">Tous les répertoires spécifiés dans <ph id="ph1">`path`</ph> sont créés, sauf si une partie de <ph id="ph2">`path`</ph> n’est pas valide.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The <ph id="ph1">`path`</ph> parameter specifies a directory path, not a file path.</source>
          <target state="translated">Le <ph id="ph1">`path`</ph> paramètre spécifie un chemin de répertoire, pas un chemin d’accès de fichier.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>If the subdirectory already exists, this method does nothing.</source>
          <target state="translated">Si le sous-répertoire existe déjà, cette méthode ne fait rien.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>Path names are limited to 248 characters.</source>
          <target state="translated">Les noms de chemin d’accès sont limités à 248 caractères.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The following example demonstrates creating a subdirectory.</source>
          <target state="translated">L’exemple suivant illustre la création d’un sous-répertoire.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>In this example, the created directories are removed once created.</source>
          <target state="translated">Dans cet exemple, les répertoires créés sont supprimés une fois créés.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>Therefore, to test this sample, comment out the delete lines in the code.</source>
          <target state="translated">Par conséquent, pour tester cet exemple, mettez en commentaire les lignes supprimées dans le code.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not specify a valid file path or contains invalid <ph id="ph2">&lt;see langword="DirectoryInfo" /&gt;</ph> characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> ne spécifie pas un chemin de fichier valide ou contient des caractères <ph id="ph2">&lt;see langword="DirectoryInfo" /&gt;</ph> non valides.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The subdirectory cannot be created.</source>
          <target state="translated">Le sous-répertoire ne peut pas être créé.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>A file or directory already has the name specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Un fichier ou un répertoire possède déjà le nom spécifié par <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The specified path, file name, or both are too long.</source>
          <target state="translated">Le chemin d’accès et/ou le nom de fichier spécifiés sont trop longs.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The caller does not have code access permission to create the directory.</source>
          <target state="translated">L’appelant ne dispose pas d’autorisation d’accès du code pour créer le répertoire.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>The caller does not have code access permission to read the directory described by the returned <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object.</source>
          <target state="translated">L’appelant ne dispose pas d’autorisation d’accès du code pour lire le répertoire décrit par l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> retourné.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>This can occur when the <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter describes an existing directory.</source>
          <target state="translated">Cela peut se produire quand le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> décrit un répertoire existant.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon character (:) that is not part of a drive label ("C:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un signe deux-points (:) qui ne fait pas partie d’une étiquette de lecteur (" C:<ph id="ph2">\\</ph> ").</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path.</source>
          <target state="translated">Chemin d'accès spécifié.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>This cannot be a different disk volume or Universal Naming Convention (UNC) name.</source>
          <target state="translated">Il ne peut pas s'agir d'un nom de volume de disque ou UNC différent.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The security to apply.</source>
          <target state="translated">Sécurité à appliquer.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>Creates a subdirectory or subdirectories on the specified path with the specified security.</source>
          <target state="translated">Crée un ou plusieurs sous-répertoires dans le chemin d’accès spécifié avec la sécurité spécifiée.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path can be relative to this instance of the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> class.</source>
          <target state="translated">Le chemin d'accès spécifié peut être relatif à cette instance de la classe <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The last directory specified in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Dernier répertoire spécifié dans <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>Any and all directories specified in <ph id="ph1">`path`</ph> are created, unless some part of <ph id="ph2">`path`</ph> is invalid.</source>
          <target state="translated">Tous les répertoires spécifiés dans <ph id="ph1">`path`</ph> sont créés, sauf si une partie de <ph id="ph2">`path`</ph> n’est pas valide.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The <ph id="ph1">`path`</ph> parameter specifies a directory path, not a file path.</source>
          <target state="translated">Le <ph id="ph1">`path`</ph> paramètre spécifie un chemin de répertoire, pas un chemin d’accès de fichier.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>If the subdirectory already exists, this method does nothing.</source>
          <target state="translated">Si le sous-répertoire existe déjà, cette méthode ne fait rien.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>Path names are limited to 248 characters.</source>
          <target state="translated">Les noms de chemin d’accès sont limités à 248 caractères.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not specify a valid file path or contains invalid <ph id="ph2">&lt;see langword="DirectoryInfo" /&gt;</ph> characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> ne spécifie pas un chemin de fichier valide ou contient des caractères <ph id="ph2">&lt;see langword="DirectoryInfo" /&gt;</ph> non valides.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The subdirectory cannot be created.</source>
          <target state="translated">Le sous-répertoire ne peut pas être créé.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>A file or directory already has the name specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Un fichier ou un répertoire possède déjà le nom spécifié par <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The specified path, file name, or both are too long.</source>
          <target state="translated">Le chemin d’accès et/ou le nom de fichier spécifiés sont trop longs.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The caller does not have code access permission to create the directory.</source>
          <target state="translated">L’appelant ne dispose pas d’autorisation d’accès du code pour créer le répertoire.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>The caller does not have code access permission to read the directory described by the returned <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object.</source>
          <target state="translated">L’appelant ne dispose pas d’autorisation d’accès du code pour lire le répertoire décrit par l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> retourné.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>This can occur when the <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter describes an existing directory.</source>
          <target state="translated">Cela peut se produire quand le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> décrit un répertoire existant.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon character (:) that is not part of a drive label ("C:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un signe deux-points (:) qui ne fait pas partie d’une étiquette de lecteur (" C:<ph id="ph2">\\</ph> ").</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Deletes a <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> and its contents from a path.</source>
          <target state="translated">Supprime <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> et son contenu d'un chemin d'accès.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>Deletes this <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> if it is empty.</source>
          <target state="translated">Supprime cet élément <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> s'il est vide.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete">
          <source>The following example throws an exception if you attempt to delete a directory that is not empty.</source>
          <target state="translated">L’exemple suivant lève une exception si vous tentez de supprimer un répertoire qui n’est pas vide.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>The directory contains a read-only file.</source>
          <target state="translated">Le répertoire contient un fichier en lecture seule.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>The directory described by this <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object does not exist or could not be found.</source>
          <target state="translated">Le répertoire décrit par cet objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’existe pas ou est introuvable.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>The directory is not empty.</source>
          <target state="translated">Le répertoire n’est pas vide.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>The directory is the application's current working directory.</source>
          <target state="translated">Le répertoire correspond au répertoire de travail actuel de l’application.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>There is an open handle on the directory, and the operating system is Windows XP or earlier.</source>
          <target state="translated">Un handle est ouvert sur le répertoire, et le système d’exploitation est Windows XP ou une version antérieure.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>This open handle can result from enumerating directories.</source>
          <target state="translated">Ce handle ouvert peut être le résultat d’une énumération de répertoires.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Enumerate Directories and Files<ept id="p1">](~/docs/standard/io/how-to-enumerate-directories-and-files.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Comment : énumérer des répertoires et fichiers<ept id="p1">](~/docs/standard/io/how-to-enumerate-directories-and-files.md)</ept>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete">
          <source>for writing directories.</source>
          <target state="translated">pour écrire dans les répertoires.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to delete this directory, its subdirectories, and all files; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour supprimer ce répertoire, ses sous-répertoires et tous ses fichiers ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>Deletes this instance of a <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>, specifying whether to delete subdirectories and files.</source>
          <target state="translated">Supprime cette instance d'un élément <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>, en spécifiant si les sous-répertoires et les fichiers doivent être supprimés.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>If the <ph id="ph1">`DirectoryInfo`</ph> has no files or subdirectories, this method deletes the <ph id="ph2">`DirectoryInfo`</ph> even if <ph id="ph3">`recursive`</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si le <ph id="ph1">`DirectoryInfo`</ph> n’a aucun fichier ni sous-répertoire, cette méthode supprime le <ph id="ph2">`DirectoryInfo`</ph> même si <ph id="ph3">`recursive`</ph> est <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>Attempting to delete a <ph id="ph1">`DirectoryInfo`</ph> that is not empty when <ph id="ph2">`recursive`</ph> is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.IO.IOException&gt;</ph>.</source>
          <target state="translated">Essayez de supprimer un <ph id="ph1">`DirectoryInfo`</ph> qui n’est pas vide lorsque <ph id="ph2">`recursive`</ph> est <ph id="ph3">`false`</ph> lève une <ph id="ph4">&lt;xref:System.IO.IOException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The following example demonstrates deleting a directory.</source>
          <target state="translated">L’exemple suivant illustre la suppression d’un répertoire.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>Because the directory is removed, first comment out the <ph id="ph1">`Delete`</ph> line to test that the directory exists.</source>
          <target state="translated">Étant donné que le répertoire est supprimé, commentez tout d’abord le <ph id="ph1">`Delete`</ph> ligne afin de tester que le répertoire existe.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>Then uncomment the same line of code to test that the directory was removed successfully.</source>
          <target state="translated">Puis supprimez les commentaires de la même ligne de code pour tester si le répertoire a été supprimé avec succès.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The directory contains a read-only file.</source>
          <target state="translated">Le répertoire contient un fichier en lecture seule.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The directory described by this <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object does not exist or could not be found.</source>
          <target state="translated">Le répertoire décrit par cet objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’existe pas ou est introuvable.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The directory is read-only.</source>
          <target state="translated">Le répertoire est en lecture seule.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The directory contains one or more files or subdirectories and <ph id="ph1">&lt;paramref name="recursive" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Le répertoire contient un ou plusieurs fichiers ou sous-répertoires et <ph id="ph1">&lt;paramref name="recursive" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The directory is the application's current working directory.</source>
          <target state="translated">Le répertoire correspond au répertoire de travail actuel de l’application.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>There is an open handle on the directory or on one of its files, and the operating system is Windows XP or earlier.</source>
          <target state="translated">Un handle ouvert se trouve sur le répertoire ou sur l’un de ses fichiers, alors que le système d’exploitation est Windows XP ou une version antérieure.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>This open handle can result from enumerating directories and files.</source>
          <target state="translated">Ce handle ouvert peut être le résultat d’une énumération de répertoires et de fichiers.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Enumerate Directories and Files<ept id="p1">](~/docs/standard/io/how-to-enumerate-directories-and-files.md)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez <bpt id="p1">[</bpt>Comment : énumérer des répertoires et fichiers<ept id="p1">](~/docs/standard/io/how-to-enumerate-directories-and-files.md)</ept>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.Delete(System.Boolean)">
          <source>Write flag required for write permission to the <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> and subdirectories to be deleted.</source>
          <target state="translated">Indicateur d’écriture requis pour l’autorisation d’écriture dans le <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> et ses sous-répertoires à supprimer.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Returns an enumerable collection of directory information in the current directory.</source>
          <target state="translated">Retourne une collection énumérable d’informations de répertoire dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>Returns an enumerable collection of directory information in the current directory.</source>
          <target state="translated">Retourne une collection énumérable d’informations de répertoire dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>An enumerable collection of directories in the current directory.</source>
          <target state="translated">Collection énumérable des répertoires dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on  the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>The following example enumerates the subdirectories under the C:\Program Files directory and uses a LINQ query to return the names of all directories that were created before 2009 by checking the value of the <ph id="ph1">&lt;xref:System.IO.FileSystemInfo.CreationTimeUtc%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant énumère les sous-répertoires sous le répertoire C:\Program Files et utilise une requête LINQ pour retourner les noms de tous les répertoires qui ont été créés avant 2009 en vérifiant la valeur de la <ph id="ph1">&lt;xref:System.IO.FileSystemInfo.CreationTimeUtc%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>If you only need the names of the subdirectories, use the static <ph id="ph1">&lt;xref:System.IO.Directory&gt;</ph> class for better performance.</source>
          <target state="translated">Si vous devez uniquement les noms des sous-répertoires, utilisez la méthode statique <ph id="ph1">&lt;xref:System.IO.Directory&gt;</ph> classe pour de meilleures performances.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.IO.Directory.EnumerateDirectories%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un exemple, consultez la <ph id="ph1">&lt;xref:System.IO.Directory.EnumerateDirectories%28System.String%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The search string to match against the names of directories.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Returns an enumerable collection of directory information that matches a specified search pattern.</source>
          <target state="translated">Retourne une collection énumérable d’informations de répertoire qui correspond à un modèle de recherche spécifié.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>An enumerable collection of directories that matches <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.</source>
          <target state="translated">Collection énumérable de répertoires qui correspond à <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on  the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The search string to match against the names of directories.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</source>
          <target state="translated">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Returns an enumerable collection of directory information that matches a specified search pattern and search subdirectory option.</source>
          <target state="translated">Retourne une collection énumérable d’informations de répertoire qui correspond à un modèle de recherche spécifié et à une option de recherche de sous-répertoires.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>An enumerable collection of directories that matches <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> and <ph id="ph2">&lt;paramref name="searchOption" /&gt;</ph>.</source>
          <target state="translated">Collection énumérable de répertoires qui correspond à <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> et à <ph id="ph2">&lt;paramref name="searchOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetDirectories%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateDirectories%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on  the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The following example, starting from a specified directory, uses this method and the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> method to enumerate the files and directories within the start directory and display details of any files over 10 MB in size.</source>
          <target state="translated">L’exemple suivant, en commençant à partir d’un répertoire spécifié, utilise cette méthode et la <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> méthode pour énumérer les fichiers et les répertoires dans le répertoire de démarrage et d’afficher les détails des fichiers plus 10 Mo taille.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Returns an enumerable collection of file information in the current directory.</source>
          <target state="translated">Retourne une collection énumérable d’informations de fichier dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>Returns an enumerable collection of file information in the current directory.</source>
          <target state="translated">Retourne une collection énumérable d’informations de fichier dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>An enumerable collection of the files in the current directory.</source>
          <target state="translated">Collection énumérable des fichiers dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The following example enumerates the files under a specified directory and uses a LINQ query to return the names of all files that were created before 2009 by checking the value of the <ph id="ph1">&lt;xref:System.IO.FileSystemInfo.CreationTimeUtc%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant énumère les fichiers sous un répertoire spécifié et utilise une requête LINQ pour retourner les noms de tous les fichiers qui ont été créés avant 2009 en vérifiant la valeur de la <ph id="ph1">&lt;xref:System.IO.FileSystemInfo.CreationTimeUtc%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>If you only need the names of the files, use the static <ph id="ph1">&lt;xref:System.IO.Directory&gt;</ph> class for better performance.</source>
          <target state="translated">Si vous devez uniquement les noms des fichiers, utilisez la méthode statique <ph id="ph1">&lt;xref:System.IO.Directory&gt;</ph> classe pour de meilleures performances.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un exemple, consultez la <ph id="ph1">&lt;xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The following example shows how to enumerate files in a directory by using different search options.</source>
          <target state="translated">L’exemple suivant montre comment énumérer les fichiers dans un répertoire à l’aide de différentes options de recherche.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The example assumes a directory that has files named log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, and a subdirectory that has a file named SubFile.txt.</source>
          <target state="translated">L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The search string to match against the names of files.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Returns an enumerable collection of file information that matches a search pattern.</source>
          <target state="translated">Retourne une collection énumérable d’informations de fichier qui correspond à un modèle de recherche.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>An enumerable collection of files that matches <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.</source>
          <target state="translated">Collection énumérable de fichiers qui correspond à <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The following example shows how to enumerate files in a directory by using different search options.</source>
          <target state="translated">L’exemple suivant montre comment énumérer les fichiers dans un répertoire à l’aide de différentes options de recherche.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The example assumes a directory that has files named log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, and a subdirectory that has a file named SubFile.txt.</source>
          <target state="translated">L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid, (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The search string to match against the names of files.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</source>
          <target state="translated">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Returns an enumerable collection of file information that matches a specified search pattern and search subdirectory option.</source>
          <target state="translated">Retourne une collection énumérable d’informations de fichier qui correspond à un modèle de recherche spécifié et à une option de recherche de sous-répertoires.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>An enumerable collection of files that matches <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> and <ph id="ph2">&lt;paramref name="searchOption" /&gt;</ph>.</source>
          <target state="translated">Collection énumérable de fichiers qui correspond à <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> et à <ph id="ph2">&lt;paramref name="searchOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The following example shows how to enumerate files in a directory by using different search options.</source>
          <target state="translated">L’exemple suivant montre comment énumérer les fichiers dans un répertoire à l’aide de différentes options de recherche.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The example assumes a directory that has files named log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, and a subdirectory that has a file named SubFile.txt.</source>
          <target state="translated">L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Returns an enumerable collection of file system information in the current directory.</source>
          <target state="translated">Retourne une collection énumérable d’informations de système de fichiers dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>Returns an enumerable collection of file system information in the current directory.</source>
          <target state="translated">Retourne une collection énumérable d'informations de système de fichiers dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>An enumerable collection of file system information in the current directory.</source>
          <target state="translated">Collection énumérable d’informations de système de fichiers dans le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The search string to match against the names of directories.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Returns an enumerable collection of file system information that matches a specified search pattern.</source>
          <target state="translated">Retourne une collection énumérable d’informations de système de fichiers qui correspond à un modèle de recherche spécifié.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>An enumerable collection of file system information objects that matches <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.</source>
          <target state="translated">Collection énumérable d'objets d'informations de système de fichiers qui correspond à <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The search string to match against the names of directories.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</source>
          <target state="translated">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Returns an enumerable collection of file system information that matches a specified search pattern and search subdirectory option.</source>
          <target state="translated">Retourne une collection énumérable d’informations de système de fichiers qui correspond à un modèle de recherche spécifié et à une option de recherche de sous-répertoires.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>An enumerable collection of file system information objects that matches <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> and <ph id="ph2">&lt;paramref name="searchOption" /&gt;</ph>.</source>
          <target state="translated">Collection énumérable d'objets d'informations de système de fichiers qui correspond à <ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph>.et à <ph id="ph2">&lt;paramref name="searchOption" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The returned collection is not cached; each call to the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method on the collection will start a new enumeration.</source>
          <target state="translated">La collection retournée n’est pas mis en cache ; chaque appel à la <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> méthode sur la collection démarre une nouvelle énumération.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.Exists">
          <source>Gets a value indicating whether the directory exists.</source>
          <target state="translated">Obtient une valeur indiquant si le répertoire existe.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Exists">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the directory exists; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le répertoire existe ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Exists">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.Exists%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if any error occurs while trying to determine if the specified file exists.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.Exists%2A&gt;</ph> propriété renvoie <ph id="ph2">`false`</ph> si une erreur se produit lors de la tentative déterminer si le fichier spécifié existe.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Exists">
          <source>This can occur in situations that raise exceptions such as passing a file name with invalid characters or too many characters, a failing or missing disk, or if the caller does not have permission to read the file.</source>
          <target state="translated">Cela peut se produire dans les situations qui déclenchent des exceptions telles que la transmission d’un nom de fichier avec des caractères non valides ou trop de caractères, un disque défaillant ou manquant, ou si l’appelant n’a pas l’autorisation de lire le fichier.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Exists">
          <source>The following example demonstrates a use of the <ph id="ph1">`Exists`</ph> property in the context of copying a source directory to a target directory.</source>
          <target state="translated">L’exemple suivant illustre une utilisation de la <ph id="ph1">`Exists`</ph> propriété dans le contexte de copie d’un répertoire source vers un répertoire cible.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.FullName">
          <source>Gets the full path of the directory.</source>
          <target state="translated">Obtient le chemin d’accès complet du répertoire.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.FullName">
          <source>A string containing the full path.</source>
          <target state="translated">Chaîne contenant le chemin d’accès complet.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Gets the access control list (ACL) entries for the current directory.</source>
          <target state="translated">Obtient les entrées de la liste de contrôle d'accès (ACL) pour le répertoire actuel.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>Use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> methods to retrieve the access control list (ACL) entries for the current file.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> méthodes pour récupérer l’accès à contrôlent les entrées de liste (ACL) pour le fichier actuel.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.DirectoryInfo">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Pour plus d'informations, consultez <bpt id="p1">[</bpt>Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> object that encapsulates the access control list (ACL) entries for the directory described by the current <ph id="ph2">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object.</source>
          <target state="translated">Obtient un objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> qui encapsule les entrées de la liste de contrôle d'accès (ACL) pour le répertoire décrit par l'objet <ph id="ph2">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> object that encapsulates the access control rules for the directory.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> qui encapsule les règles de contrôle d'accès pour le répertoire.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.IO.Directory.GetAccessControl%2A&gt;</ph> method overload and specifying the access control sections <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Appel de cette surcharge de méthode équivaut à appeler le <ph id="ph1">&lt;xref:System.IO.Directory.GetAccessControl%2A&gt;</ph> surcharge de méthode et en spécifiant l’accès à des sections de contrôle <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph> <ph id="ph6">`Or`</ph> <ph id="ph7">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph> <ph id="ph8">`Or`</ph> <ph id="ph9">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> method to retrieve the access control list (ACL) entries for the current file.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> méthode pour récupérer les entrées (ACL) pour le fichier actuel.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file or directory.</source>
          <target state="translated">Une liste ACL décrit les individus ou des groupes qui disposent ou ne disposez pas des droits à des actions spécifiques sur le fichier ou le répertoire.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Pour plus d'informations, consultez <bpt id="p1">[</bpt>Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> methods to add and then remove an access control list (ACL) entry from a directory.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> méthodes pour ajouter et supprimer ensuite une entrée de liste (ACL) à partir d’un répertoire de contrôle.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>The directory could not be found or modified.</source>
          <target state="translated">Le répertoire est introuvable ou n'a pas pu être modifié.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>The directory is read-only.</source>
          <target state="translated">Le répertoire est en lecture seule.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>This operation is not supported on the current platform.</source>
          <target state="translated">Cette opération n'est pas prise en charge sur la plateforme actuelle.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>An I/O error occurred while opening the directory.</source>
          <target state="translated">Une erreur d'E/S s'est produite lors de l'ouverture du répertoire.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>The current operating system is not Microsoft Windows 2000 or later.</source>
          <target state="translated">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>for permission to enumerate an access control list (ACL) for a directory.</source>
          <target state="translated">pour l’autorisation énumérer une liste de contrôle d’accès (ACL) pour un répertoire.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.AccessControlActions.View" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.AccessControlActions.View" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlSections" /&gt;</ph> values that specifies the type of access control list (ACL) information to receive.</source>
          <target state="translated">Une des valeurs <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.AccessControlSections" /&gt;</ph> qui spécifie le type d'informations ACL à recevoir.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> object that encapsulates the specified type of access control list (ACL) entries for the directory described by the current <ph id="ph2">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object.</source>
          <target state="translated">Obtient un objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> qui encapsule le type spécifié des entrées de la liste de contrôle d'accès (ACL) pour le répertoire décrit par l'objet <ph id="ph2">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> object that encapsulates the access control rules for the file described by the <ph id="ph2">&lt;paramref name="path" /&gt;</ph> parameter.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> qui encapsule les règles de contrôle d'accès pour le fichier décrit par le paramètre <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Exception type</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Type d’exception</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.SystemException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> The directory could not be found or modified.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.SystemException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Le répertoire est introuvable ou n’a pas pu être modifié.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.UnauthorizedAccessException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> The current process does not have access to open the directory.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.UnauthorizedAccessException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Le processus en cours ne dispose pas de l’autorisation nécessaire pour ouvrir ce répertoire.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.IO.IOException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> An I/O error occurred while opening the directory.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.IO.IOException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Une erreur d’E/S s’est produite lors de l’ouverture du répertoire.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.PlatformNotSupportedException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> The current operating system is not Microsoft Windows 2000 or later.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.PlatformNotSupportedException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Le système d’exploitation actuel n’est pas Microsoft Windows 2000 ou version ultérieure.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.UnauthorizedAccessException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> The directory is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="T:System.UnauthorizedAccessException" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Le répertoire est en lecture seule.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>This operation is not supported on the current platform.</source>
          <target state="translated">Cette opération n'est pas prise en charge sur la plateforme actuelle.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> method to retrieve the access control list (ACL) entries for the current file.</source>
          <target state="translated">Utilisez la <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> méthode pour récupérer les entrées (ACL) pour le fichier actuel.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file or directory.</source>
          <target state="translated">Une liste ACL décrit les individus ou des groupes qui disposent ou ne disposez pas des droits à des actions spécifiques sur le fichier ou le répertoire.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Pour plus d'informations, consultez <bpt id="p1">[</bpt>Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>for permission to enumerate an access control list (ACL) for a directory.</source>
          <target state="translated">pour l’autorisation énumérer une liste de contrôle d’accès (ACL) pour un répertoire.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.AccessControlActions.View" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.AccessControlActions.View" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Returns the subdirectories of the current directory.</source>
          <target state="translated">Retourne les sous-répertoires du répertoire actuel.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>Returns the subdirectories of the current directory.</source>
          <target state="translated">Retourne les sous-répertoires du répertoire actuel.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> objects.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>If there are no subdirectories, this method returns an empty array.</source>
          <target state="translated">S’il n’y a pas de sous-répertoire, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>This method is not recursive.</source>
          <target state="translated">Cette méthode n’est pas récursive.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>The following example retrieves all the directories in the root directory and displays the directory names.</source>
          <target state="translated">L’exemple suivant récupère tous les répertoires dans le répertoire racine et affiche les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>The path encapsulated in the <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Le chemin d'accès encapsulé dans l'objet <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> n'est pas valide, il se trouve par exemple sur un lecteur non mappé.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>for reading directories.</source>
          <target state="translated">pour lire les répertoires.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>The search string to match against the names of directories.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Returns an array of directories in the current <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> matching the given search criteria.</source>
          <target state="translated">Retourne un tableau de répertoires dans l'élément <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> actuel satisfaisant aux critères de recherche spécifiés.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>An array of type <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> matching <ph id="ph2">&lt;paramref name="searchPattern" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> correspondant à <ph id="ph2">&lt;paramref name="searchPattern" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>The following example counts the directories in a path that contain the specified letter.</source>
          <target state="translated">L’exemple suivant compte les répertoires dans un chemin d’accès qui contiennent la lettre spécifiée.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contains one or more invalid characters defined by the <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contient un ou plusieurs caractères non valides définis par la méthode <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>for reading from files and directories and for access to the path.</source>
          <target state="translated">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>The search string to match against the names of directories.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</source>
          <target state="translated">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Returns an array of directories in the current <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> matching the given search criteria and using a value to determine whether to search subdirectories.</source>
          <target state="translated">Retourne un tableau de répertoires dans l'élément <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> actuel correspondant aux critères de recherche donnés et en utilisant une valeur pour déterminer s'il faut effectuer une recherche dans les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>An array of type <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> matching <ph id="ph2">&lt;paramref name="searchPattern" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> correspondant à <ph id="ph2">&lt;paramref name="searchPattern" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>If there are no subdirectories, or no subdirectories match the <ph id="ph1">`searchPattern`</ph> parameter, this method returns an empty array.</source>
          <target state="translated">Si il n’existe aucun sous-répertoire, ou si aucun sous-répertoire ne correspond à la <ph id="ph1">`searchPattern`</ph> , cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>The following example lists all of the directories and files that begin with the letter "c" in "c:<ph id="ph1">\\</ph>".</source>
          <target state="translated">L’exemple suivant répertorie tous les répertoires et fichiers qui commencent par la lettre « c » dans « c:<ph id="ph1">\\</ph>».</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contains one or more invalid characters defined by the <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contient un ou plusieurs caractères non valides définis par la méthode <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>The path encapsulated in the <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> object is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès encapsulé dans l’objet <ph id="ph1">&lt;see langword="DirectoryInfo" /&gt;</ph> n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>for reading from files and directories and for access to the path.</source>
          <target state="translated">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Returns a file list from the current directory.</source>
          <target state="translated">Retourne la liste des fichiers du répertoire actuel.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>Returns a file list from the current directory.</source>
          <target state="translated">Retourne la liste des fichiers du répertoire actuel.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.IO.FileInfo" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.IO.FileInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>If there are no files in the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">Si aucun fichier dans le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>The order of the returned file names is not guaranteed; use the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> method if a specific sort order is required.</source>
          <target state="translated">L’ordre des noms de fichiers retournée n’est pas garanti ; Utilisez la <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> méthode si un ordre de tri spécifique est requis.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>The following example shows how to get a list of files from a directory by using different search options.</source>
          <target state="translated">L’exemple suivant montre comment obtenir la liste des fichiers à partir d’un répertoire à l’aide de différentes options de recherche.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>The example assumes a directory that has files named log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, and a subdirectory that has a file named SubFile.txt.</source>
          <target state="translated">L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>The path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>for reading directories.</source>
          <target state="translated">pour lire les répertoires.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The search string to match against the names of files.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Returns a file list from the current directory matching the given search pattern.</source>
          <target state="translated">Retourne la liste des fichiers du répertoire actuel correspondant au modèle de recherche donné.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.IO.FileInfo" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.IO.FileInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>If there are no files in the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">Si aucun fichier dans le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The following wildcard specifiers are permitted in the <ph id="ph1">`searchPattern`</ph> parameter.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans les <ph id="ph1">`searchPattern`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Wildcard character</source>
          <target state="translated">Caractère générique</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Zero or more characters.</source>
          <target state="translated">Zéro ou plusieurs caractères.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Exactly zero or one character.</source>
          <target state="translated">Exactement zéro ou un caractère.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The order of the returned file names is not guaranteed; use the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> method if a specific sort order is required.</source>
          <target state="translated">L’ordre des noms de fichiers retournée n’est pas garanti ; Utilisez la <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> méthode si un ordre de tri spécifique est requis.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Wildcards are permitted.</source>
          <target state="translated">Les caractères génériques sont autorisés.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>For example, the <ph id="ph1">`searchPattern`</ph> string "*.txt" searches for all file names having an extension of "txt".</source>
          <target state="translated">Par exemple, le <ph id="ph1">`searchPattern`</ph> chaîne de recherche de « *.txt » pour tous les fichiers ayant l’extension « txt » des noms.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all file names beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms commençant par la lettre « s » de fichiers.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>If there are no files, or no files that match the <ph id="ph1">`searchPattern`</ph> string in the <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">S’il n’y aucun fichier ou non les fichiers qui correspondent à la <ph id="ph1">`searchPattern`</ph> de chaîne dans le <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>When using the asterisk wildcard character in a <ph id="ph1">`searchPattern`</ph> (for example, "*.txt"), the matching behavior varies depending on the length of the specified file extension.</source>
          <target state="translated">Lorsque vous utilisez le caractère générique astérisque dans un <ph id="ph1">`searchPattern`</ph> (par exemple, « *.txt »), le comportement correspondant varie en fonction de la longueur de l’extension de fichier spécifié.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>A <ph id="ph1">`searchPattern`</ph> with a file extension of exactly three characters returns files with an extension of three or more characters, where the first three characters match the file extension specified in the <ph id="ph2">`searchPattern`</ph>.</source>
          <target state="translated">A <ph id="ph1">`searchPattern`</ph> avec un fichier de l’extension d’exactement trois caractères retourne les fichiers avec une extension de trois caractères ou plus, où les trois premiers caractères correspondent à l’extension de fichier spécifiée dans le <ph id="ph2">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>A <ph id="ph1">`searchPattern`</ph> with a file extension of one, two, or more than three characters returns only files with extensions of exactly that length that match the file extension specified in the <ph id="ph2">`searchPattern`</ph>.</source>
          <target state="translated">A <ph id="ph1">`searchPattern`</ph> avec un fichier de l’extension d’une, deux ou plus de trois caractères retourne uniquement les fichiers avec les extensions de cette longueur exactement qui correspond à l’extension de fichier spécifiée dans le <ph id="ph2">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>When using the question mark wildcard character, this method returns only files that match the specified file extension.</source>
          <target state="translated">Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspond à l’extension de fichier spécifié.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>For example, given two files in a directory, "file1.txt" and "file1.txtother", a search pattern of "file?.txt" returns only the first file, while a search pattern of "file<ph id="ph1">\*</ph>.txt" returns both files.</source>
          <target state="translated">Par exemple, prenons deux fichiers dans un répertoire, « file1.txt » et « fichier1.txtautre » situés un modèle de recherche d’un « fichier ?. txt » retourne uniquement le premier fichier, lors d’un modèle de recherche de « fichier<ph id="ph1">\*</ph>.txt » renvoie les deux fichiers.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Because this method checks against file names with both the 8.3 file name format and the long file name format, a search pattern similar to "*1<ph id="ph1">\*</ph>.txt" may return unexpected file names.</source>
          <target state="translated">Étant donné que cette méthode vérifie par rapport aux noms de fichiers avec le format de nom de fichier au format 8.3 et le format de nom de fichier long, un modèle de recherche similaire à « * 1<ph id="ph1">\*</ph>.txt » peut retourner des noms de fichier inattendue.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>For example, using a search pattern of "<ph id="ph1">\*</ph>1<ph id="ph2">\*</ph>.txt" will return "longfilename.txt" because the equivalent 8.3 file name format would be "longf~1.txt".</source>
          <target state="translated">Par exemple, à l’aide d’un modèle de recherche de «<ph id="ph1">\*</ph>1<ph id="ph2">\*</ph>.txt » retournera « longfilename.txt », car le format de nom de 8.3 fichier équivalent serait « longf ~ 1.txt ».</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The following example shows how to get a list of files from a directory by using different search options.</source>
          <target state="translated">L’exemple suivant montre comment obtenir la liste des fichiers à partir d’un répertoire à l’aide de différentes options de recherche.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The example assumes a directory that has files named log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, and a subdirectory that has a file named SubFile.txt.</source>
          <target state="translated">L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contains one or more invalid characters defined by the <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contient un ou plusieurs caractères non valides définis par la méthode <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The path is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>for access to the path and for reading from files and directories.</source>
          <target state="translated">Pour accéder au chemin d’accès et pour la lecture des fichiers et répertoires.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The search string to match against the names of files.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</source>
          <target state="translated">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Returns a file list from the current directory matching the given search pattern and using a value to determine whether to search subdirectories.</source>
          <target state="translated">Retourne une liste des fichiers du répertoire actuel correspondant au modèle de recherche donné et en utilisant une valeur pour déterminer s’il faut effectuer une recherche dans les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.IO.FileInfo" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.IO.FileInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> methods differ as follows:</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph> méthodes diffèrent comme suit :</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, you can start enumerating the collection of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects before the whole collection is returned.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph>, vous pouvez commencer à énumérer la collection de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets avant que la collection entière est retournée.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>When you use <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, you must wait for the whole array of <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objects to be returned before you can access the array.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetFiles%2A&gt;</ph>, vous devez attendre la totalité du tableau de <ph id="ph2">&lt;xref:System.IO.FileInfo&gt;</ph> objets à retourner avant que vous pouvez accéder au tableau.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Therefore, when you are working with many files and directories, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> can be more efficient.</source>
          <target state="translated">Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.EnumerateFiles%2A&gt;</ph> peut être plus efficace.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>If there are no files in the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">Si aucun fichier dans le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Wildcard character</source>
          <target state="translated">Caractère générique</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Zero or more characters.</source>
          <target state="translated">Zéro ou plusieurs caractères.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Exactly zero or one character.</source>
          <target state="translated">Exactement zéro ou un caractère.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The order of the returned file names is not guaranteed; use the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> method if a specific sort order is required.</source>
          <target state="translated">L’ordre des noms de fichiers retournée n’est pas garanti ; Utilisez la <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> méthode si un ordre de tri spécifique est requis.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Wildcards are permitted.</source>
          <target state="translated">Les caractères génériques sont autorisés.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>For example, the <ph id="ph1">`searchPattern`</ph> string "*.txt" searches for all file names having an extension of "txt".</source>
          <target state="translated">Par exemple, le <ph id="ph1">`searchPattern`</ph> chaîne de recherche de « *.txt » pour tous les fichiers ayant l’extension « txt » des noms.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all file names beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms commençant par la lettre « s » de fichiers.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>If there are no files, or no files that match the <ph id="ph1">`searchPattern`</ph> string in the <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">S’il n’y aucun fichier ou non les fichiers qui correspondent à la <ph id="ph1">`searchPattern`</ph> de chaîne dans le <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>When using the asterisk wildcard character in a <ph id="ph1">`searchPattern`</ph> (for example, "*.txt"), the matching behavior varies depending on the length of the specified file extension.</source>
          <target state="translated">Lorsque vous utilisez le caractère générique astérisque dans un <ph id="ph1">`searchPattern`</ph> (par exemple, « *.txt »), le comportement correspondant varie en fonction de la longueur de l’extension de fichier spécifié.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>A <ph id="ph1">`searchPattern`</ph> with a file extension of exactly three characters returns files with an extension of three or more characters, where the first three characters match the file extension specified in the <ph id="ph2">`searchPattern`</ph>.</source>
          <target state="translated">A <ph id="ph1">`searchPattern`</ph> avec un fichier de l’extension d’exactement trois caractères retourne les fichiers avec une extension de trois caractères ou plus, où les trois premiers caractères correspondent à l’extension de fichier spécifiée dans le <ph id="ph2">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>A <ph id="ph1">`searchPattern`</ph> with a file extension of one, two, or more than three characters returns only files with extensions of exactly that length that match the file extension specified in the <ph id="ph2">`searchPattern`</ph>.</source>
          <target state="translated">A <ph id="ph1">`searchPattern`</ph> avec un fichier de l’extension d’une, deux ou plus de trois caractères retourne uniquement les fichiers avec les extensions de cette longueur exactement qui correspond à l’extension de fichier spécifiée dans le <ph id="ph2">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>When using the question mark wildcard character, this method returns only files that match the specified file extension.</source>
          <target state="translated">Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspond à l’extension de fichier spécifié.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>For example, given two files in a directory, "file1.txt" and "file1.txtother", a search pattern of "file?.txt" returns only the first file, while a search pattern of "file<ph id="ph1">\*</ph>.txt" returns both files.</source>
          <target state="translated">Par exemple, prenons deux fichiers dans un répertoire, « file1.txt » et « fichier1.txtautre » situés un modèle de recherche d’un « fichier ?. txt » retourne uniquement le premier fichier, lors d’un modèle de recherche de « fichier<ph id="ph1">\*</ph>.txt » renvoie les deux fichiers.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The following list shows the behavior of different lengths for the <ph id="ph1">`searchPattern`</ph> parameter:</source>
          <target state="translated">La liste suivante montre le comportement de longueurs différentes pour le <ph id="ph1">`searchPattern`</ph> paramètre :</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>"*.abc" returns files having an extension of.abc,.abcd,.abcde,.abcdef, and so on.</source>
          <target state="translated">« * .abc » retourne les fichiers ayant une extension of.abc,.abcd,.abcde,.abcdef, et ainsi de suite.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>"*.abcd" returns only files having an extension of.abcd.</source>
          <target state="translated">« *.abcd » retourne uniquement les fichiers avec l’extension .abcd.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>"*.abcde" returns only files having an extension of.abcde.</source>
          <target state="translated">« *.abcde » retourne uniquement les fichiers avec l’extension .abcde.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>"*.abcdef" returns only files having an extension of.abcdef.</source>
          <target state="translated">« *.abcdef » retourne uniquement les fichiers avec l’extension .abcdef.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Because this method checks against file names with both the 8.3 file name format and the long file name format, a search pattern similar to "*1<ph id="ph1">\*</ph>.txt" may return unexpected file names.</source>
          <target state="translated">Étant donné que cette méthode vérifie par rapport aux noms de fichiers avec le format de nom de fichier au format 8.3 et le format de nom de fichier long, un modèle de recherche similaire à « * 1<ph id="ph1">\*</ph>.txt » peut retourner des noms de fichier inattendue.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>For example, using a search pattern of "<ph id="ph1">\*</ph>1<ph id="ph2">\*</ph>.txt" will return "longfilename.txt" because the equivalent 8.3 file name format would be "longf~1.txt".</source>
          <target state="translated">Par exemple, à l’aide d’un modèle de recherche de «<ph id="ph1">\*</ph>1<ph id="ph2">\*</ph>.txt » retournera « longfilename.txt », car le format de nom de 8.3 fichier équivalent serait « longf ~ 1.txt ».</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The following example shows how to get a list of files from a directory by using different search options.</source>
          <target state="translated">L’exemple suivant montre comment obtenir la liste des fichiers à partir d’un répertoire à l’aide de différentes options de recherche.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The example assumes a directory that has files named log1.txt, log2.txt, test1.txt, test2.txt, test3.txt, and a subdirectory that has a file named SubFile.txt.</source>
          <target state="translated">L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contains one or more invalid characters defined by the <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contient un ou plusieurs caractères non valides définis par la méthode <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The path is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>for access to the path and for reading from files and directories.</source>
          <target state="translated">Pour accéder au chemin d’accès et pour la lecture des fichiers et répertoires.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="T:System.IO.DirectoryInfo">
          <source>Retrieves an array of strongly typed <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> objects representing files and subdirectories of the current directory.</source>
          <target state="translated">Récupère un tableau d'objets <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> fortement typés qui représentent des fichiers et des sous-répertoires du répertoire actif.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>Returns an array of strongly typed <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> entries representing all the files and subdirectories in a directory.</source>
          <target state="translated">Retourne un tableau d'entrées <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> fortement typées représentant tous les fichiers et sous-répertoires d'un répertoire.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>An array of strongly typed <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> entries.</source>
          <target state="translated">Tableau d'entrées <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> fortement typées.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>If there are no files or directories in the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">S’il n’y aucun fichier ou répertoire dans le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>This method is not recursive.</source>
          <target state="translated">Cette méthode n’est pas récursive.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>For subdirectories, the <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects returned by this method can be cast to the derived class <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>.</source>
          <target state="translated">Pour les sous-répertoires, les <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> les objets retournés par cette méthode peuvent être convertis en la classe dérivée <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileAttributes&gt;</ph> value returned by the <ph id="ph2">&lt;xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType&gt;</ph> property to determine whether the <ph id="ph3">&lt;xref:System.IO.FileSystemInfo&gt;</ph> represents a file or a directory.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.IO.FileAttributes&gt;</ph> valeur retournée par la <ph id="ph2">&lt;xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer si le <ph id="ph3">&lt;xref:System.IO.FileSystemInfo&gt;</ph> représente un fichier ou un répertoire.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>The following example counts the files and directories under the specified directory.</source>
          <target state="translated">L’exemple suivant compte les fichiers et répertoires sous le répertoire spécifié.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos">
          <source>The path is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The search string to match against the names of directories and files.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires et les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Retrieves an array of strongly typed <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> objects representing the files and subdirectories that match the specified search criteria.</source>
          <target state="translated">Récupère un tableau d'objets <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> fortement typés qui représentent les fichiers et sous-répertoires correspondant au critère de recherche spécifié.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>An array of strongly typed <ph id="ph1">&lt;see langword="FileSystemInfo" /&gt;</ph> objects matching the search criteria.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see langword="FileSystemInfo" /&gt;</ph> fortement typés satisfaisant aux critères de recherche spécifiés.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>This method is not recursive.</source>
          <target state="translated">Cette méthode n’est pas récursive.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>For subdirectories, the <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects returned by this method can be cast to the derived class <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>.</source>
          <target state="translated">Pour les sous-répertoires, les <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> les objets retournés par cette méthode peuvent être convertis en la classe dérivée <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileAttributes&gt;</ph> value returned by the <ph id="ph2">&lt;xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType&gt;</ph> property to determine whether the <ph id="ph3">&lt;xref:System.IO.FileSystemInfo&gt;</ph> represents a file or a directory.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.IO.FileAttributes&gt;</ph> valeur retournée par la <ph id="ph2">&lt;xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer si le <ph id="ph3">&lt;xref:System.IO.FileSystemInfo&gt;</ph> représente un fichier ou un répertoire.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Wild cards are permitted.</source>
          <target state="translated">Les caractères génériques sont autorisés.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>For example, the <ph id="ph1">`searchPattern`</ph> string "*t" searches for all directory names in <ph id="ph2">`path`</ph> ending with the letter "t".</source>
          <target state="translated">Par exemple, le <ph id="ph1">`searchPattern`</ph> chaîne « * t » recherche tous les noms de répertoire dans <ph id="ph2">`path`</ph> se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all directory names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms de répertoire dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The string ".." can only be used in <ph id="ph1">`searchPattern`</ph> if it is specified as a part of a valid directory name, such as in the directory name "a..b".</source>
          <target state="translated">La chaîne «.. » peut uniquement être utilisé dans <ph id="ph1">`searchPattern`</ph> si elle est spécifiée dans le cadre d’un nom de répertoire valide, comme dans le nom du répertoire « un.. b ».</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>It cannot be used to move up the directory hierarchy.</source>
          <target state="translated">Il ne peut pas être utilisé pour la déplacer vers le haut de la hiérarchie de répertoires.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>If there are no files or directories, or no files or directories that match the <ph id="ph1">`searchPattern`</ph> string in the <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, this method returns an empty array.</source>
          <target state="translated">S’il n’y aucune fichiers ou répertoires, sans fichiers ou répertoires qui correspondent à la <ph id="ph1">`searchPattern`</ph> de chaîne dans le <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>, cette méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The following example counts the files and directories that match the specified search pattern.</source>
          <target state="translated">L’exemple suivant compte les fichiers et les répertoires qui correspondent au modèle de recherche spécifié.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contains one or more invalid characters defined by the <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contient un ou plusieurs caractères non valides définis par la méthode <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The specified path is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>for reading from files and directories and for access to the path.</source>
          <target state="translated">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The search string to match against the names of directories and filesa.</source>
          <target state="translated">Chaîne recherchée à trouver parmi les noms de répertoires et les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</source>
          <target state="translated">Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</source>
          <target state="translated">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see cref="F:System.IO.SearchOption.TopDirectoryOnly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Retrieves an array of <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> objects that represent the files and subdirectories matching the specified search criteria.</source>
          <target state="translated">Récupère un tableau d'objets <ph id="ph1">&lt;see cref="T:System.IO.FileSystemInfo" /&gt;</ph> qui représentent les fichiers et sous-répertoires correspondant au critère de recherche spécifié.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>An array of file system entries that match the search criteria.</source>
          <target state="translated">Tableau d'entrées de système de fichiers qui satisfont aux critères de recherche.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">`searchPattern`</ph> can be a combination of literal and wildcard characters, but it doesn't support regular expressions.</source>
          <target state="translated"><ph id="ph1">`searchPattern`</ph> peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The following wildcard specifiers are permitted in <ph id="ph1">`searchPattern`</ph>.</source>
          <target state="translated">Les spécificateurs de caractères génériques suivants sont autorisés dans <ph id="ph1">`searchPattern`</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Wildcard specifier</source>
          <target state="translated">Spécificateur de caractère générique</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Matches</source>
          <target state="translated">Correspondances</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>* (asterisk)</source>
          <target state="translated">* (astérisque)</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Zero or more characters in that position.</source>
          <target state="translated">Zéro ou plusieurs caractères dans cette position.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>?</source>
          <target state="translated">?</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>(question mark)</source>
          <target state="translated">(point d’interrogation)</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Zero or one character in that position.</source>
          <target state="translated">Zéro ou un caractère à cette position.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Characters other than the wildcard are literal characters.</source>
          <target state="translated">Caractères autres que le caractère générique sont des caractères littéraux.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>For example, the  string "*t" searches for all names in  ending with the letter "t".</source>
          <target state="translated">Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ».</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>".</source>
          <target state="translated">".</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The <ph id="ph1">`searchPattern`</ph> string "s<ph id="ph2">\*</ph>" searches for all names in <ph id="ph3">`path`</ph> beginning with the letter "s".</source>
          <target state="translated">Le <ph id="ph1">`searchPattern`</ph> chaîne « s<ph id="ph2">\*</ph>» recherche tous les noms dans <ph id="ph3">`path`</ph> commençant par la lettre « s ».</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>For subdirectories, the <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> objects returned by this method can be cast to the derived class <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>.</source>
          <target state="translated">Pour les sous-répertoires, les <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> les objets retournés par cette méthode peuvent être convertis en la classe dérivée <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileAttributes&gt;</ph> value returned by the <ph id="ph2">&lt;xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType&gt;</ph> property to determine whether the <ph id="ph3">&lt;xref:System.IO.FileSystemInfo&gt;</ph> represents a file or a directory.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.IO.FileAttributes&gt;</ph> valeur retournée par la <ph id="ph2">&lt;xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType&gt;</ph> propriété pour déterminer si le <ph id="ph3">&lt;xref:System.IO.FileSystemInfo&gt;</ph> représente un fichier ou un répertoire.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>This method pre-populates the values of the following <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> properties:</source>
          <target state="translated">Cette méthode remplit les valeurs des éléments suivants au préalable <ph id="ph1">&lt;xref:System.IO.FileSystemInfo&gt;</ph> propriétés :</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contains one or more invalid characters defined by the <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> contient un ou plusieurs caractères non valides définis par la méthode <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchPattern" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="searchOption" /&gt;</ph> n’est pas une valeur de <ph id="ph2">&lt;see cref="T:System.IO.SearchOption" /&gt;</ph> valide.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The specified path is invalid (for example, it is on an unmapped drive).</source>
          <target state="translated">Le chemin d’accès spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The name and path to which to move this directory.</source>
          <target state="translated">Nom et chemin d’accès où déplacer ce répertoire.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The destination cannot be another disk volume or a directory with the identical name.</source>
          <target state="translated">La destination ne peut pas être un autre volume de disque ou un répertoire du même nom.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>It can be an existing directory to which you want to add this directory as a subdirectory.</source>
          <target state="translated">Il peut s'agir d'un répertoire existant où vous voulez ajouter ce répertoire comme sous-répertoire.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>Moves a <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> instance and its contents to a new path.</source>
          <target state="translated">Déplace une instance de <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> et son contenu dans un nouveau chemin d'accès.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>This method throws an <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> if, for example, you try to move c:\mydir to c:\public, and c:\public already exists.</source>
          <target state="translated">Cette méthode lève un <ph id="ph1">&lt;xref:System.IO.IOException&gt;</ph> si, par exemple, vous essayez de déplacer c:\mydir vers c:\public et c:\public existe déjà.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>You must specify "c:<ph id="ph1">\\</ph>\public<ph id="ph2">\\</ph>\mydir" as the <ph id="ph3">`destDirName`</ph> parameter, or specify a new directory name such as "c:<ph id="ph4">\\</ph>\newdir".</source>
          <target state="translated">Vous devez spécifier « c:<ph id="ph1">\\</ph>\public<ph id="ph2">\\</ph>\mydir » en tant que le <ph id="ph3">`destDirName`</ph> paramètre, ou spécifier un nouveau nom de répertoire comme « c:<ph id="ph4">\\</ph>\newdir ».</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>This method permits moving a directory to a read-only directory.</source>
          <target state="translated">Cette méthode permet de déplacer un répertoire vers un répertoire en lecture seule.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The read/write attribute of neither directory is affected.</source>
          <target state="translated">L’attribut de lecture/écriture d’aucun répertoire est affecté.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The following example demonstrates moving a directory.</source>
          <target state="translated">L’exemple suivant montre comment déplacer un répertoire.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="destDirName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destDirName" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="destDirName" /&gt;</ph> is an empty string (''").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destDirName" /&gt;</ph> est une chaîne vide (''").</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>An attempt was made to move a directory to a different volume.</source>
          <target state="translated">Une tentative a été effectuée pour déplacer un répertoire vers un autre volume.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="destDirName" /&gt;</ph> already exists.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destDirName" /&gt;</ph> existe déjà.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>You are not authorized to access this path.</source>
          <target state="translated">Vous n’êtes pas autorisé à accéder à ce chemin d’accès.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The directory being moved and the destination directory have the same name.</source>
          <target state="translated">Le répertoire déplacé et le répertoire de destination ont le même nom.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>The destination directory cannot be found.</source>
          <target state="translated">Le répertoire de destination est introuvable.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>for reading and writing files and directories and for access to the destination directory.</source>
          <target state="translated">pour lire et écrire des fichiers et des répertoires et pour l’accès au répertoire de destination.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.MoveTo(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.Name">
          <source>Gets the name of this <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> instance.</source>
          <target state="translated">Obtient le nom de cette instance de <ph id="ph1">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>The directory name.</source>
          <target state="translated">Nom du répertoire.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>This <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.Name%2A&gt;</ph> property returns only the name of the directory, such as "Bin".</source>
          <target state="translated">Cela <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.Name%2A&gt;</ph> propriété renvoie uniquement le nom du répertoire, tel que « Bin ».</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>To get the full path, such as "c:\public\Bin", use the <ph id="ph1">&lt;xref:System.IO.FileSystemInfo.FullName%2A&gt;</ph> property.</source>
          <target state="translated">Pour obtenir le chemin d’accès complet, tel que « c:\public\Bin », utilisez le <ph id="ph1">&lt;xref:System.IO.FileSystemInfo.FullName%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.Name%2A&gt;</ph> property of a <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> requires no permission (beyond the read permission to the directory necessary to construct the <ph id="ph3">&lt;xref:System.IO.DirectoryInfo.Exists%2A&gt;</ph>) but can give out the directory name.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.Name%2A&gt;</ph> propriété d’un <ph id="ph2">&lt;xref:System.IO.DirectoryInfo&gt;</ph> ne requiert aucune autorisation (au-delà de l’autorisation de lecture du répertoire nécessaire pour construire le <ph id="ph3">&lt;xref:System.IO.DirectoryInfo.Exists%2A&gt;</ph>) mais peut distribuer le nom du répertoire.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>If it is necessary to hand out a <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> to a protected directory with a cryptographically secure name, create a dummy directory for the untrusted code’s use.</source>
          <target state="translated">S’il est nécessaire de rendre du délai d’attente une <ph id="ph1">&lt;xref:System.IO.DirectoryInfo&gt;</ph> dans un répertoire protégé avec un nom sécurisé par chiffrement, créez un répertoire factice pour les utiliser du code non fiable.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Name">
          <source>The following example displays the name of the current <ph id="ph1">`DirectoryInfo`</ph> instance only.</source>
          <target state="translated">L’exemple suivant affiche le nom de l’actuel <ph id="ph1">`DirectoryInfo`</ph> uniquement de l’instance.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.Parent">
          <source>Gets the parent directory of a specified subdirectory.</source>
          <target state="translated">Obtient le répertoire parent d'un sous-répertoire spécifié.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Parent">
          <source>The parent directory, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the path is null or if the file path denotes a root (such as "<ph id="ph2">\\</ph>", "C:", or * "<ph id="ph3">\\</ph>\server\share").</source>
          <target state="translated">Le répertoire parent, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> si le chemin d’accès est null ou si le chemin d’accès du fichier désigne une racine (tel que «<ph id="ph2">\\</ph>», « C: », ou * «<ph id="ph3">\\</ph>\server\share »).</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Parent">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Parent">
          <source>The following example demonstrates referring to the parent directory of a specified directory.</source>
          <target state="translated">L’exemple suivant montre la référence au répertoire parent d’un répertoire spécifié.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.Parent">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Parent">
          <source>for reading from files and directories and for access to the path.</source>
          <target state="translated">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Parent">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.Root">
          <source>Gets the root portion of the directory.</source>
          <target state="translated">Obtient la partie racine du répertoire.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Root">
          <source>An object that represents the root of the directory.</source>
          <target state="translated">Objet qui représente la racine du répertoire.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Root">
          <source>The following example displays root locations for specified directories.</source>
          <target state="translated">L’exemple suivant affiche les emplacements racine pour les répertoires spécifiés.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="P:System.IO.DirectoryInfo.Root">
          <source>The caller does not have the required permission.</source>
          <target state="translated">L'appelant n'a pas l'autorisation requise.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Root">
          <source>for reading from files and directories and for access to the path.</source>
          <target state="translated">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.DirectoryInfo.Root">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>An object that describes an ACL entry to apply to the directory described by the <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">Objet qui décrit une entrée de liste de contrôle d’accès (ACL) à appliquer au répertoire décrit par le paramètre <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Applies access control list (ACL) entries described by a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> object to the directory described by the current <ph id="ph2">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> object.</source>
          <target state="translated">Applique les entrées de la liste de contrôle d'accès (ACL) décrites par un objet <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.DirectorySecurity" /&gt;</ph> au répertoire décrit par l'objet <ph id="ph2">&lt;see cref="T:System.IO.DirectoryInfo" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>An access control list (ACL) describes individuals and/or groups who have, or do not have, rights to specific actions on the given file or directory.</source>
          <target state="translated">Liste de contrôle d’accès (ACL) décrit les individus ou des groupes qui disposent ou ne disposez pas des droits à des actions spécifiques sur le fichier ou le répertoire.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Pour plus d'informations, consultez <bpt id="p1">[</bpt>Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> method applies ACL entries to a file that represents the noninherited ACL list.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> méthode s’applique les entrées ACL pour un fichier qui représente la liste ACL non héritée.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The ACL specified for <ph id="ph1">`directorySecurity`</ph> replaces the existing ACL for the directory.</source>
          <target state="translated">La liste ACL spécifiée pour <ph id="ph1">`directorySecurity`</ph> remplace la liste ACL existante pour le répertoire.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>To add permissions for a new user, use the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> method to obtain the existing ACL, and modify it.</source>
          <target state="translated">Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> méthode pour obtenir la liste ACL existante, puis modifiez-le.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> method persists only <ph id="ph2">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objects that have been modified after object creation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> méthode persiste uniquement <ph id="ph2">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> les objets qui ont été modifiés après la création d’objet.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>If a <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object has not been modified, it will not be persisted to a file.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objet n’a pas été modifié, il n’est pas conservé dans un fichier.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Therefore, it is not possible to retrieve a <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object from one file and reapply the same object to another file.</source>
          <target state="translated">Par conséquent, il n’est pas possible de récupérer un <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> de l’objet à partir d’un fichier et réappliquez le même objet dans un autre fichier.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>To copy ACL information from one file to another:</source>
          <target state="translated">Pour copier les informations ACL à partir d’un fichier vers un autre :</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> method to retrieve the <ph id="ph2">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object from the source file.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> pour récupérer le <ph id="ph2">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objet à partir du fichier source.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Create a new <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object for the destination file.</source>
          <target state="translated">Créer un nouveau <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objet pour le fichier de destination.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Use the <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A&gt;</ph> method of the source <ph id="ph3">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object to retrieve the ACL information.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A&gt;</ph> méthode de la source <ph id="ph3">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objet à récupérer les informations ACL.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Use the <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A&gt;</ph> method to copy the information retrieved in step 3 to the destination <ph id="ph3">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A&gt;</ph> méthode pour copier les informations récupérées à l’étape 3 vers la destination <ph id="ph3">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Set the destination <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> object to the destination file using the <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> method.</source>
          <target state="translated">Définir la destination <ph id="ph1">&lt;xref:System.Security.AccessControl.DirectorySecurity&gt;</ph> objet pour le fichier de destination à l’aide de la <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> methods to add and then remove an access control list (ACL) entry from a directory.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.IO.DirectoryInfo.GetAccessControl%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.DirectoryInfo.SetAccessControl%2A&gt;</ph> méthodes pour ajouter et supprimer ensuite une entrée de liste (ACL) à partir d’un répertoire de contrôle.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The <ph id="ph1">&lt;paramref name="directorySecurity" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="directorySecurity" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The file could not be found or modified.</source>
          <target state="translated">Le fichier est introuvable ou n’a pas pu être modifié.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The current process does not have access to open the file.</source>
          <target state="translated">Le processus en cours n’a pas l’accès requis pour ouvrir le fichier.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>The current operating system is not Microsoft Windows 2000 or later.</source>
          <target state="translated">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>for permission to enumerate access control list (ACL) for a directory.</source>
          <target state="translated">pour l’autorisation d’énumérer la liste de contrôle d’accès (ACL) pour un répertoire.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Action de sécurité : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.AccessControlActions.View" /&gt;</ph></source>
          <target state="translated">Énumérations associées : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.AccessControlActions.View" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.ToString">
          <source>Returns the original path that was passed by the user.</source>
          <target state="translated">Retourne le chemin d’accès d’origine passé par l’utilisateur.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.DirectoryInfo.ToString">
          <source>Returns the original path that was passed by the user.</source>
          <target state="translated">Retourne le chemin d’accès d’origine passé par l’utilisateur.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>