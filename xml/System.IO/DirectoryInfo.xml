<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f57138ff45a8e0ac1237da3e85d3d72b784fca1c" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911504" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expose des méthodes d'instance pour créer, se déplacer dans et énumérer des répertoires et sous-répertoires. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.IO.DirectoryInfo> classe pour les opérations courantes telles que copier, déplacer, renommer, création et supprimer des répertoires.  
  
 Si vous souhaitez réutiliser un objet plusieurs fois, envisagez d’utiliser la méthode d’instance de <xref:System.IO.DirectoryInfo> au lieu de méthodes statiques correspondantes de la <xref:System.IO.Directory> classe, car une vérification de sécurité n'est pas toujours nécessaire.  
  
> [!NOTE]
>  Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement formé ou une exception est levée. Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe. Par conséquent, le chemin d’accès est incorrect et une exception est levée. De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises. Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas. Assurez-vous que vos chemins d’accès sont corrects lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.  
  
 Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire. Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de partage et de serveur. Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :  
  
-   « c:\\\MyDir\\\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.  
  
-   « c:\\\MyDir » en c# ou « c:\MyDir » en Visual Basic.  
  
-   « MyDir\\\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.  
  
-   «\\\\\\\MyServer\\\MyShare » en c#, ou «\\\MyServer\MyShare » en Visual Basic.  
  
 Par défaut, l’accès complet en lecture/écriture aux nouveaux répertoires est accordé à tous les utilisateurs.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre certains membres principaux de la `DirectoryInfo` classe.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 L’exemple suivant montre comment copier un répertoire et son contenu.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chaîne spécifiant le chemin d'accès où créer l'élément <see langword="DirectoryInfo" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.DirectoryInfo" /> sur le chemin d'accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur ne vérifie pas si un répertoire existe. Ce constructeur est un espace réservé pour une chaîne qui est utilisée pour accéder au disque lors des opérations ultérieures.  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant utilise ce constructeur pour créer le répertoire spécifié et un sous-répertoire et montre qu’un répertoire qui contient des sous-répertoires ne peut pas être supprimé.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> contient des caractères non valides tels que ", &lt;, &gt; ou |.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système. Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères. Le chemin d’accès et/ou le nom de fichier spécifiés sont trop longs.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture des fichiers et répertoires. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire existe déjà, cette méthode ne fait rien.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant vérifie si un répertoire spécifié existe, crée le répertoire s’il n’existe pas et supprime le répertoire.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossible de créer le répertoire.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire des fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Contrôle d'accès à appliquer au répertoire.</param>
        <summary>Crée un répertoire en utilisant un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode pour créer un répertoire avec le contrôle d’accès, donc il n’existe aucun risque que le répertoire est accessible avant que la sécurité est appliquée.  
  
 Si le répertoire existe déjà, cette méthode ne fait rien.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié par <paramref name="path" /> est en lecture seule ou n’est pas vide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système. Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.NotSupportedException">La création d’un répertoire avec uniquement le caractère deux-points (:) a été tentée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de créer un répertoire. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un ou plusieurs sous-répertoires dans le chemin d'accès spécifié. Le chemin d'accès spécifié peut être relatif à cette instance de la classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès spécifié. Il ne peut pas s'agir d'un nom de volume de disque ou UNC différent.</param>
        <summary>Crée un ou plusieurs sous-répertoires dans le chemin d'accès spécifié. Le chemin d'accès spécifié peut être relatif à cette instance de la classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Dernier répertoire spécifié dans <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les répertoires spécifiés dans `path` sont créés, sauf si une partie de `path` n’est pas valide. Le `path` paramètre spécifie un chemin de répertoire, pas un chemin d’accès de fichier. Si le sous-répertoire existe déjà, cette méthode ne fait rien.  
  
> [!NOTE]
>  Les noms de chemin d’accès sont limités à 248 caractères.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre la création d’un sous-répertoire. Dans cet exemple, les répertoires créés sont supprimés une fois créés. Par conséquent, pour tester cet exemple, mettez en commentaire les lignes supprimées dans le code.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ne spécifie pas un chemin de fichier valide ou contient des caractères <see langword="DirectoryInfo" /> non valides.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException">Le sous-répertoire ne peut pas être créé.  
  
 - ou -  
  
 Un fichier ou un répertoire possède déjà le nom spécifié par <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système. Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères. Le chemin d’accès et/ou le nom de fichier spécifiés sont trop longs.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant ne dispose pas d’autorisation d’accès du code pour créer le répertoire.  
  
 - ou -  
  
 L’appelant ne dispose pas d’autorisation d’accès du code pour lire le répertoire décrit par l’objet <see cref="T:System.IO.DirectoryInfo" /> retourné.  Cela peut se produire quand le paramètre <paramref name="path" /> décrit un répertoire existant.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contient un signe deux-points (:) qui ne fait pas partie d’une étiquette de lecteur (" C:\\ ").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès spécifié. Il ne peut pas s'agir d'un nom de volume de disque ou UNC différent.</param>
        <param name="directorySecurity">Sécurité à appliquer.</param>
        <summary>Crée un ou plusieurs sous-répertoires dans le chemin d’accès spécifié avec la sécurité spécifiée. Le chemin d'accès spécifié peut être relatif à cette instance de la classe <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Dernier répertoire spécifié dans <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les répertoires spécifiés dans `path` sont créés, sauf si une partie de `path` n’est pas valide. Le `path` paramètre spécifie un chemin de répertoire, pas un chemin d’accès de fichier. Si le sous-répertoire existe déjà, cette méthode ne fait rien.  
  
> [!NOTE]
>  Les noms de chemin d’accès sont limités à 248 caractères.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ne spécifie pas un chemin de fichier valide ou contient des caractères <see langword="DirectoryInfo" /> non valides.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException">Le sous-répertoire ne peut pas être créé.  
  
 - ou -  
  
 Un fichier ou un répertoire possède déjà le nom spécifié par <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système. Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères. Le chemin d’accès et/ou le nom de fichier spécifiés sont trop longs.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant ne dispose pas d’autorisation d’accès du code pour créer le répertoire.  
  
 - ou -  
  
 L’appelant ne dispose pas d’autorisation d’accès du code pour lire le répertoire décrit par l’objet <see cref="T:System.IO.DirectoryInfo" /> retourné.  Cela peut se produire quand le paramètre <paramref name="path" /> décrit un répertoire existant.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contient un signe deux-points (:) qui ne fait pas partie d’une étiquette de lecteur (" C:\\ ").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime <see cref="T:System.IO.DirectoryInfo" /> et son contenu d'un chemin d'accès.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime cet élément <see cref="T:System.IO.DirectoryInfo" /> s'il est vide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant lève une exception si vous tentez de supprimer un répertoire qui n’est pas vide.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le répertoire contient un fichier en lecture seule.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire décrit par cet objet <see cref="T:System.IO.DirectoryInfo" /> n’existe pas ou est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire n’est pas vide.  
  
 - ou -  
  
 Le répertoire correspond au répertoire de travail actuel de l’application.  
  
 - ou -  
  
 Un handle est ouvert sur le répertoire, et le système d’exploitation est Windows XP ou une version antérieure. Ce handle ouvert peut être le résultat d’une énumération de répertoires. Pour plus d’informations, consultez [Comment : énumérer des répertoires et fichiers](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans les répertoires. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive">
          <see langword="true" /> pour supprimer ce répertoire, ses sous-répertoires et tous ses fichiers ; sinon, <see langword="false" />.</param>
        <summary>Supprime cette instance d'un élément <see cref="T:System.IO.DirectoryInfo" />, en spécifiant si les sous-répertoires et les fichiers doivent être supprimés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `DirectoryInfo` n’a aucun fichier ni sous-répertoire, cette méthode supprime le `DirectoryInfo` même si `recursive` est `false`. Essayez de supprimer un `DirectoryInfo` qui n’est pas vide lorsque `recursive` est `false` lève une <xref:System.IO.IOException>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre la suppression d’un répertoire. Étant donné que le répertoire est supprimé, commentez tout d’abord le `Delete` ligne afin de tester que le répertoire existe. Puis supprimez les commentaires de la même ligne de code pour tester si le répertoire a été supprimé avec succès.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le répertoire contient un fichier en lecture seule.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire décrit par cet objet <see cref="T:System.IO.DirectoryInfo" /> n’existe pas ou est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire est en lecture seule.  
  
 - ou -  
  
 Le répertoire contient un ou plusieurs fichiers ou sous-répertoires et <paramref name="recursive" /> a la valeur <see langword="false" />.  
  
 - ou -  
  
 Le répertoire correspond au répertoire de travail actuel de l’application.  
  
 - ou -  
  
 Un handle ouvert se trouve sur le répertoire ou sur l’un de ses fichiers, alors que le système d’exploitation est Windows XP ou une version antérieure. Ce handle ouvert peut être le résultat d’une énumération de répertoires et de fichiers. Pour plus d’informations, consultez [Comment : énumérer des répertoires et fichiers](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Indicateur d’écriture requis pour l’autorisation d’écriture dans le <see langword="DirectoryInfo" /> et ses sous-répertoires à supprimer.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection énumérable d’informations de répertoire dans le répertoire actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection énumérable d’informations de répertoire dans le répertoire actuel.</summary>
        <returns>Collection énumérable des répertoires dans le répertoire actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> et <xref:System.IO.DirectoryInfo.GetDirectories%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.DirectoryInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetDirectories%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.DirectoryInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.DirectoryInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant énumère les sous-répertoires sous le répertoire C:\Program Files et utilise une requête LINQ pour retourner les noms de tous les répertoires qui ont été créés avant 2009 en vérifiant la valeur de la <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> propriété.  
  
 Si vous devez uniquement les noms des sous-répertoires, utilisez la méthode statique <xref:System.IO.Directory> classe pour de meilleures performances. Pour obtenir un exemple, consultez la <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> (méthode).  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne une collection énumérable d’informations de répertoire qui correspond à un modèle de recherche spécifié.</summary>
        <returns>Collection énumérable de répertoires qui correspond à <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> et <xref:System.IO.DirectoryInfo.GetDirectories%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.DirectoryInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetDirectories%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.DirectoryInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.DirectoryInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires. La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne une collection énumérable d’informations de répertoire qui correspond à un modèle de recherche spécifié et à une option de recherche de sous-répertoires.</summary>
        <returns>Collection énumérable de répertoires qui correspond à <paramref name="searchPattern" /> et à <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> et <xref:System.IO.DirectoryInfo.GetDirectories%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.DirectoryInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetDirectories%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.DirectoryInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.DirectoryInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant, en commençant à partir d’un répertoire spécifié, utilise cette méthode et la <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> méthode pour énumérer les fichiers et les répertoires dans le répertoire de démarrage et d’afficher les détails des fichiers plus 10 Mo taille.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection énumérable d’informations de fichier dans le répertoire actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection énumérable d’informations de fichier dans le répertoire actuel.</summary>
        <returns>Collection énumérable des fichiers dans le répertoire actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> et <xref:System.IO.DirectoryInfo.GetFiles%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFiles%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant énumère les fichiers sous un répertoire spécifié et utilise une requête LINQ pour retourner les noms de tous les fichiers qui ont été créés avant 2009 en vérifiant la valeur de la <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> propriété.  
  
 Si vous devez uniquement les noms des fichiers, utilisez la méthode statique <xref:System.IO.Directory> classe pour de meilleures performances. Pour obtenir un exemple, consultez la <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 L’exemple suivant montre comment énumérer les fichiers dans un répertoire à l’aide de différentes options de recherche. L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne une collection énumérable d’informations de fichier qui correspond à un modèle de recherche.</summary>
        <returns>Collection énumérable de fichiers qui correspond à <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> et <xref:System.IO.DirectoryInfo.GetFiles%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFiles%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant montre comment énumérer les fichiers dans un répertoire à l’aide de différentes options de recherche. L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires. La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne une collection énumérable d’informations de fichier qui correspond à un modèle de recherche spécifié et à une option de recherche de sous-répertoires.</summary>
        <returns>Collection énumérable de fichiers qui correspond à <paramref name="searchPattern" /> et à <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> et <xref:System.IO.DirectoryInfo.GetFiles%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFiles%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant montre comment énumérer les fichiers dans un répertoire à l’aide de différentes options de recherche. L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection énumérable d’informations de système de fichiers dans le répertoire actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection énumérable d'informations de système de fichiers dans le répertoire actuel.</summary>
        <returns>Collection énumérable d’informations de système de fichiers dans le répertoire actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> et <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileSystemInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileSystemInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileSystemInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne une collection énumérable d’informations de système de fichiers qui correspond à un modèle de recherche spécifié.</summary>
        <returns>Collection énumérable d'objets d'informations de système de fichiers qui correspond à <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> et <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileSystemInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileSystemInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileSystemInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires. La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne une collection énumérable d’informations de système de fichiers qui correspond à un modèle de recherche spécifié et à une option de recherche de sous-répertoires.</summary>
        <returns>Collection énumérable d'objets d'informations de système de fichiers qui correspond à <paramref name="searchPattern" />.et à <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> et <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileSystemInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileSystemInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> peut être plus efficace.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileSystemInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> méthode sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see cref="T:System.IO.DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le répertoire existe.</summary>
        <value>
          <see langword="true" /> si le répertoire existe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DirectoryInfo.Exists%2A> propriété renvoie `false` si une erreur se produit lors de la tentative déterminer si le fichier spécifié existe. Cela peut se produire dans les situations qui déclenchent des exceptions telles que la transmission d’un nom de fichier avec des caractères non valides ou trop de caractères, un disque défaillant ou manquant, ou si l’appelant n’a pas l’autorisation de lire le fichier.  
  
   
  
## Examples  
 L’exemple suivant illustre une utilisation de la `Exists` propriété dans le contexte de copie d’un répertoire source vers un répertoire cible.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès complet du répertoire.</summary>
        <value>Chaîne contenant le chemin d’accès complet.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les entrées de la liste de contrôle d'accès (ACL) pour le répertoire actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.IO.DirectoryInfo.GetAccessControl%2A> méthodes pour récupérer l’accès à contrôlent les entrées de liste (ACL) pour le fichier actuel.  
  
 Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui encapsule les entrées de la liste de contrôle d'accès (ACL) pour le répertoire décrit par l'objet <see cref="T:System.IO.DirectoryInfo" /> actuel.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui encapsule les règles de contrôle d'accès pour le répertoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette surcharge de méthode équivaut à appeler le <xref:System.IO.Directory.GetAccessControl%2A> surcharge de méthode et en spécifiant l’accès à des sections de contrôle <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> en Visual Basic).  
  
 Utilisez la <xref:System.IO.DirectoryInfo.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour le fichier actuel.  
  
 Une liste ACL décrit les individus ou des groupes qui disposent ou ne disposez pas des droits à des actions spécifiques sur le fichier ou le répertoire. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.DirectoryInfo.GetAccessControl%2A> et <xref:System.IO.DirectoryInfo.SetAccessControl%2A> méthodes pour ajouter et supprimer ensuite une entrée de liste (ACL) à partir d’un répertoire de contrôle.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Le répertoire est introuvable ou n'a pas pu être modifié.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le répertoire est en lecture seule.  
  
 - ou -  
  
 Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
 - ou -  
  
 L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ouverture du répertoire.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation énumérer une liste de contrôle d’accès (ACL) pour un répertoire. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlSections" /> qui spécifie le type d'informations ACL à recevoir.</param>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui encapsule le type spécifié des entrées de la liste de contrôle d'accès (ACL) pour le répertoire décrit par l'objet <see cref="T:System.IO.DirectoryInfo" /> actuel.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui encapsule les règles de contrôle d'accès pour le fichier décrit par le paramètre <paramref name="path" />.  
  
 Exceptions  
  
 <list type="table"><listheader><term> Type d’exception  
  
 </term><description> Condition  
  
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> Le répertoire est introuvable ou n’a pas pu être modifié.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Le processus en cours ne dispose pas de l’autorisation nécessaire pour ouvrir ce répertoire.  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> Une erreur d’E/S s’est produite lors de l’ouverture du répertoire.  
  
 </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> Le système d’exploitation actuel n’est pas Microsoft Windows 2000 ou version ultérieure.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Le répertoire est en lecture seule.  
  
 - ou -  
  
 Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
 - ou -  
  
 L'appelant n'a pas l'autorisation requise.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.IO.DirectoryInfo.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour le fichier actuel.  
  
 Une liste ACL décrit les individus ou des groupes qui disposent ou ne disposez pas des droits à des actions spécifiques sur le fichier ou le répertoire. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation énumérer une liste de contrôle d’accès (ACL) pour un répertoire. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les sous-répertoires du répertoire actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les sous-répertoires du répertoire actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.IO.DirectoryInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il n’y a pas de sous-répertoire, cette méthode retourne un tableau vide. Cette méthode n’est pas récursive.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.DirectoryInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 L’exemple suivant récupère tous les répertoires dans le répertoire racine et affiche les noms de répertoires.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d'accès encapsulé dans l'objet <see cref="T:System.IO.DirectoryInfo" /> n'est pas valide, il se trouve par exemple sur un lecteur non mappé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les répertoires. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne un tableau de répertoires dans l'élément <see cref="T:System.IO.DirectoryInfo" /> actuel satisfaisant aux critères de recherche spécifiés.</summary>
        <returns>Tableau de type <see langword="DirectoryInfo" /> correspondant à <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.DirectoryInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 L’exemple suivant compte les répertoires dans un chemin d’accès qui contiennent la lettre spécifiée.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see langword="DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</param>
        <summary>Retourne un tableau de répertoires dans l'élément <see cref="T:System.IO.DirectoryInfo" /> actuel correspondant aux critères de recherche donnés et en utilisant une valeur pour déterminer s'il faut effectuer une recherche dans les sous-répertoires.</summary>
        <returns>Tableau de type <see langword="DirectoryInfo" /> correspondant à <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Si il n’existe aucun sous-répertoire, ou si aucun sous-répertoire ne correspond à la `searchPattern` , cette méthode retourne un tableau vide.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.DirectoryInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 L’exemple suivant répertorie tous les répertoires et fichiers qui commencent par la lettre « c » dans « c:\\».  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès encapsulé dans l’objet <see langword="DirectoryInfo" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la liste des fichiers du répertoire actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la liste des fichiers du répertoire actuel.</summary>
        <returns>Tableau de type <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> et <xref:System.IO.DirectoryInfo.GetFiles%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFiles%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> peut être plus efficace.  
  
 Si aucun fichier dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide.  
  
 L’ordre des noms de fichiers retournée n’est pas garanti ; Utilisez la <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir la liste des fichiers à partir d’un répertoire à l’aide de différentes options de recherche. L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les répertoires. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne la liste des fichiers du répertoire actuel correspondant au modèle de recherche donné.</summary>
        <returns>Tableau de type <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Le <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> et <xref:System.IO.DirectoryInfo.GetFiles%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFiles%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> peut être plus efficace.  
  
 Si aucun fichier dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide.  
  
 Les spécificateurs de caractères génériques suivants sont autorisés dans les `searchPattern` paramètre.  
  
|Caractère générique|Description |  
|------------------------|-----------------|  
|*|Zéro ou plusieurs caractères.|  
|?|Exactement zéro ou un caractère.|  
  
 L’ordre des noms de fichiers retournée n’est pas garanti ; Utilisez la <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 Les caractères génériques sont autorisés. Par exemple, le `searchPattern` chaîne de recherche de « *.txt » pour tous les fichiers ayant l’extension « txt » des noms. Le `searchPattern` chaîne « s\*» recherche tous les noms commençant par la lettre « s » de fichiers. S’il n’y aucun fichier ou non les fichiers qui correspondent à la `searchPattern` de chaîne dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide.  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` (par exemple, « *.txt »), le comportement correspondant varie en fonction de la longueur de l’extension de fichier spécifié. A `searchPattern` avec un fichier de l’extension d’exactement trois caractères retourne les fichiers avec une extension de trois caractères ou plus, où les trois premiers caractères correspondent à l’extension de fichier spécifiée dans le `searchPattern`. A `searchPattern` avec un fichier de l’extension d’une, deux ou plus de trois caractères retourne uniquement les fichiers avec les extensions de cette longueur exactement qui correspond à l’extension de fichier spécifiée dans le `searchPattern`. Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspond à l’extension de fichier spécifié. Par exemple, prenons deux fichiers dans un répertoire, « file1.txt » et « fichier1.txtautre » situés un modèle de recherche d’un « fichier ?. txt » retourne uniquement le premier fichier, lors d’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
> [!NOTE]
>  Étant donné que cette méthode vérifie par rapport aux noms de fichiers avec le format de nom de fichier au format 8.3 et le format de nom de fichier long, un modèle de recherche similaire à « * 1\*.txt » peut retourner des noms de fichier inattendue. Par exemple, à l’aide d’un modèle de recherche de «\*1\*.txt » retournera « longfilename.txt », car le format de nom de 8.3 fichier équivalent serait « longf ~ 1.txt ».  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir la liste des fichiers à partir d’un répertoire à l’aide de différentes options de recherche. L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès et pour la lecture des fichiers et répertoires. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires.</param>
        <summary>Retourne une liste des fichiers du répertoire actuel correspondant au modèle de recherche donné et en utilisant une valeur pour déterminer s’il faut effectuer une recherche dans les sous-répertoires.</summary>
        <returns>Tableau de type <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> et <xref:System.IO.DirectoryInfo.GetFiles%2A> méthodes diffèrent comme suit :  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de <xref:System.IO.FileInfo> objets avant que la collection entière est retournée.  
  
-   Lorsque vous utilisez <xref:System.IO.DirectoryInfo.GetFiles%2A>, vous devez attendre la totalité du tableau de <xref:System.IO.FileInfo> objets à retourner avant que vous pouvez accéder au tableau.  
  
 Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> peut être plus efficace.  
  
 Si aucun fichier dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide.  
  
 Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Caractère générique|Description |  
|------------------------|-----------------|  
|* (astérisque)|Zéro ou plusieurs caractères.|  
|? (point d’interrogation)|Exactement zéro ou un caractère.|  
  
 L’ordre des noms de fichiers retournée n’est pas garanti ; Utilisez la <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 Les caractères génériques sont autorisés. Par exemple, le `searchPattern` chaîne de recherche de « *.txt » pour tous les fichiers ayant l’extension « txt » des noms. Le `searchPattern` chaîne « s\*» recherche tous les noms commençant par la lettre « s » de fichiers. S’il n’y aucun fichier ou non les fichiers qui correspondent à la `searchPattern` de chaîne dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide.  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` (par exemple, « *.txt »), le comportement correspondant varie en fonction de la longueur de l’extension de fichier spécifié. A `searchPattern` avec un fichier de l’extension d’exactement trois caractères retourne les fichiers avec une extension de trois caractères ou plus, où les trois premiers caractères correspondent à l’extension de fichier spécifiée dans le `searchPattern`. A `searchPattern` avec un fichier de l’extension d’une, deux ou plus de trois caractères retourne uniquement les fichiers avec les extensions de cette longueur exactement qui correspond à l’extension de fichier spécifiée dans le `searchPattern`. Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspond à l’extension de fichier spécifié. Par exemple, prenons deux fichiers dans un répertoire, « file1.txt » et « fichier1.txtautre » situés un modèle de recherche d’un « fichier ?. txt » retourne uniquement le premier fichier, lors d’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 La liste suivante montre le comportement de longueurs différentes pour le `searchPattern` paramètre :  
  
-   « * .abc » retourne les fichiers ayant une extension of.abc,.abcd,.abcde,.abcdef, et ainsi de suite.  
  
-   « *.abcd » retourne uniquement les fichiers avec l’extension .abcd.  
  
-   « *.abcde » retourne uniquement les fichiers avec l’extension .abcde.  
  
-   « *.abcdef » retourne uniquement les fichiers avec l’extension .abcdef.  
  
> [!NOTE]
>  Étant donné que cette méthode vérifie par rapport aux noms de fichiers avec le format de nom de fichier au format 8.3 et le format de nom de fichier long, un modèle de recherche similaire à « * 1\*.txt » peut retourner des noms de fichier inattendue. Par exemple, à l’aide d’un modèle de recherche de «\*1\*.txt » retournera « longfilename.txt », car le format de nom de 8.3 fichier équivalent serait « longf ~ 1.txt ».  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileInfo> propriétés :  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir la liste des fichiers à partir d’un répertoire à l’aide de différentes options de recherche. L’exemple suppose un répertoire qui contient les fichiers nommés log1.txt, log2.txt, test1.txt, test2.txt, test3.txt et un sous-répertoire qui dispose d’un fichier nommé SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès et pour la lecture des fichiers et répertoires. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère un tableau d'objets <see cref="T:System.IO.FileSystemInfo" /> fortement typés qui représentent des fichiers et des sous-répertoires du répertoire actif.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau d'entrées <see cref="T:System.IO.FileSystemInfo" /> fortement typées représentant tous les fichiers et sous-répertoires d'un répertoire.</summary>
        <returns>Tableau d'entrées <see cref="T:System.IO.FileSystemInfo" /> fortement typées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il n’y aucun fichier ou répertoire dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide. Cette méthode n’est pas récursive.  
  
 Pour les sous-répertoires, les <xref:System.IO.FileSystemInfo> les objets retournés par cette méthode peuvent être convertis en la classe dérivée <xref:System.IO.DirectoryInfo>. Utilisez le <xref:System.IO.FileAttributes> valeur retournée par la <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> propriété pour déterminer si le <xref:System.IO.FileSystemInfo> représente un fichier ou un répertoire.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileSystemInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 L’exemple suivant compte les fichiers et répertoires sous le répertoire spécifié.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires et les noms de fichiers.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Récupère un tableau d'objets <see cref="T:System.IO.FileSystemInfo" /> fortement typés qui représentent les fichiers et sous-répertoires correspondant au critère de recherche spécifié.</summary>
        <returns>Tableau d'objets <see langword="FileSystemInfo" /> fortement typés satisfaisant aux critères de recherche spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Cette méthode n’est pas récursive.  
  
 Pour les sous-répertoires, les <xref:System.IO.FileSystemInfo> les objets retournés par cette méthode peuvent être convertis en la classe dérivée <xref:System.IO.DirectoryInfo>. Utilisez le <xref:System.IO.FileAttributes> valeur retournée par la <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> propriété pour déterminer si le <xref:System.IO.FileSystemInfo> représente un fichier ou un répertoire.  
  
 Les caractères génériques sont autorisés. Par exemple, le `searchPattern` chaîne « * t » recherche tous les noms de répertoire dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms de répertoire dans `path` commençant par la lettre « s ».  
  
 La chaîne «.. » peut uniquement être utilisé dans `searchPattern` si elle est spécifiée dans le cadre d’un nom de répertoire valide, comme dans le nom du répertoire « un.. b ». Il ne peut pas être utilisé pour la déplacer vers le haut de la hiérarchie de répertoires. S’il n’y aucune fichiers ou répertoires, sans fichiers ou répertoires qui correspondent à la `searchPattern` de chaîne dans le <xref:System.IO.DirectoryInfo>, cette méthode retourne un tableau vide.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileSystemInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 L’exemple suivant compte les fichiers et les répertoires qui correspondent au modèle de recherche spécifié.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires et les noms de fichiers.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou tous les sous-répertoires. La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Récupère un tableau d'objets <see cref="T:System.IO.FileSystemInfo" /> qui représentent les fichiers et sous-répertoires correspondant au critère de recherche spécifié.</summary>
        <returns>Tableau d'entrées de système de fichiers qui satisfont aux critères de recherche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère à cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, la chaîne « * t » recherche tous les noms se terminant par la lettre « t ». ". Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 Pour les sous-répertoires, les <xref:System.IO.FileSystemInfo> les objets retournés par cette méthode peuvent être convertis en la classe dérivée <xref:System.IO.DirectoryInfo>. Utilisez le <xref:System.IO.FileAttributes> valeur retournée par la <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> propriété pour déterminer si le <xref:System.IO.FileSystemInfo> représente un fichier ou un répertoire.  
  
 Cette méthode remplit les valeurs des éléments suivants au préalable <xref:System.IO.FileSystemInfo> propriétés :  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Nom et chemin d’accès où déplacer ce répertoire. La destination ne peut pas être un autre volume de disque ou un répertoire du même nom. Il peut s'agir d'un répertoire existant où vous voulez ajouter ce répertoire comme sous-répertoire.</param>
        <summary>Déplace une instance de <see cref="T:System.IO.DirectoryInfo" /> et son contenu dans un nouveau chemin d'accès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lève un <xref:System.IO.IOException> si, par exemple, vous essayez de déplacer c:\mydir vers c:\public et c:\public existe déjà. Vous devez spécifier « c:\\\public\\\mydir » en tant que le `destDirName` paramètre, ou spécifier un nouveau nom de répertoire comme « c:\\\newdir ».  
  
 Cette méthode permet de déplacer un répertoire vers un répertoire en lecture seule. L’attribut de lecture/écriture d’aucun répertoire est affecté.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment déplacer un répertoire.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destDirName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destDirName" /> est une chaîne vide (''").</exception>
        <exception cref="T:System.IO.IOException">Une tentative a été effectuée pour déplacer un répertoire vers un autre volume.  
  
 - ou -  
  
 <paramref name="destDirName" /> existe déjà.  
  
 - ou -  
  
 Vous n’êtes pas autorisé à accéder à ce chemin d’accès.  
  
 - ou -  
  
 Le répertoire déplacé et le répertoire de destination ont le même nom.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire de destination est introuvable.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers et des répertoires et pour l’accès au répertoire de destination. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de cette instance de <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <value>Nom du répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela <xref:System.IO.DirectoryInfo.Name%2A> propriété renvoie uniquement le nom du répertoire, tel que « Bin ». Pour obtenir le chemin d’accès complet, tel que « c:\public\Bin », utilisez le <xref:System.IO.FileSystemInfo.FullName%2A> propriété.  
  
 Le <xref:System.IO.DirectoryInfo.Name%2A> propriété d’un <xref:System.IO.DirectoryInfo> ne requiert aucune autorisation (au-delà de l’autorisation de lecture du répertoire nécessaire pour construire le <xref:System.IO.DirectoryInfo.Exists%2A>) mais peut distribuer le nom du répertoire. S’il est nécessaire de rendre du délai d’attente une <xref:System.IO.DirectoryInfo> dans un répertoire protégé avec un nom sécurisé par chiffrement, créez un répertoire factice pour les utiliser du code non fiable.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’actuel `DirectoryInfo` uniquement de l’instance.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le répertoire parent d'un sous-répertoire spécifié.</summary>
        <value>Le répertoire parent, ou <see langword="null" /> si le chemin d’accès est null ou si le chemin d’accès du fichier désigne une racine (tel que «\\», « C: », ou * «\\\server\share »).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre la référence au répertoire parent d’un répertoire spécifié.  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès. Énumérations associées : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la partie racine du répertoire.</summary>
        <value>Objet qui représente la racine du répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche les emplacements racine pour les répertoires spécifiés.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir des fichiers et des répertoires et pour accéder au chemin d’accès. Énumérations associées : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Objet qui décrit une entrée de liste de contrôle d’accès (ACL) à appliquer au répertoire décrit par le paramètre <c>path</c>.</param>
        <summary>Applique les entrées de la liste de contrôle d'accès (ACL) décrites par un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> au répertoire décrit par l'objet <see cref="T:System.IO.DirectoryInfo" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liste de contrôle d’accès (ACL) décrit les individus ou des groupes qui disposent ou ne disposez pas des droits à des actions spécifiques sur le fichier ou le répertoire. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Le <xref:System.IO.DirectoryInfo.SetAccessControl%2A> méthode s’applique les entrées ACL pour un fichier qui représente la liste ACL non héritée.  
  
> [!CAUTION]
>  La liste ACL spécifiée pour `directorySecurity` remplace la liste ACL existante pour le répertoire. Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <xref:System.IO.DirectoryInfo.GetAccessControl%2A> méthode pour obtenir la liste ACL existante, puis modifiez-le.  
  
 Le <xref:System.IO.DirectoryInfo.SetAccessControl%2A> méthode persiste uniquement <xref:System.Security.AccessControl.DirectorySecurity> les objets qui ont été modifiés après la création d’objet.  Si un <xref:System.Security.AccessControl.DirectorySecurity> objet n’a pas été modifié, il n’est pas conservé dans un fichier.  Par conséquent, il n’est pas possible de récupérer un <xref:System.Security.AccessControl.DirectorySecurity> de l’objet à partir d’un fichier et réappliquez le même objet dans un autre fichier.  
  
 Pour copier les informations ACL à partir d’un fichier vers un autre :  
  
1.  Utilisez le <xref:System.IO.DirectoryInfo.GetAccessControl%2A> pour récupérer le <xref:System.Security.AccessControl.DirectorySecurity> objet à partir du fichier source.  
  
2.  Créer un nouveau <xref:System.Security.AccessControl.DirectorySecurity> objet pour le fichier de destination.  
  
3.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode de la source <xref:System.Security.AccessControl.DirectorySecurity> objet à récupérer les informations ACL.  
  
4.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> méthode pour copier les informations récupérées à l’étape 3 vers la destination <xref:System.Security.AccessControl.DirectorySecurity> objet.  
  
5.  Définir la destination <xref:System.Security.AccessControl.DirectorySecurity> objet pour le fichier de destination à l’aide de la <xref:System.IO.DirectoryInfo.SetAccessControl%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.DirectoryInfo.GetAccessControl%2A> et <xref:System.IO.DirectoryInfo.SetAccessControl%2A> méthodes pour ajouter et supprimer ensuite une entrée de liste (ACL) à partir d’un répertoire de contrôle.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="directorySecurity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable ou n’a pas pu être modifié.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le processus en cours n’a pas l’accès requis pour ouvrir le fichier.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation d’énumérer la liste de contrôle d’accès (ACL) pour un répertoire. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le chemin d’accès d’origine passé par l’utilisateur.</summary>
        <returns>Retourne le chemin d’accès d’origine passé par l’utilisateur.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>