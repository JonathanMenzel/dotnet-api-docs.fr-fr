<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1a8d5-101">Crée un flux dont le magasin de stockage est la mémoire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-101">Creates a stream whose backing store is memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-102">La position actuelle d’un flux est la position à laquelle la prochaine lecture ou d’écriture opération puisse avoir lieu.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-102">The current position of a stream is the position at which the next read or write operation could take place.</span></span> <span data-ttu-id="1a8d5-103">La position actuelle peut être récupérée ou définie par le <xref:System.IO.MemoryStream.Seek%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-103">The current position can be retrieved or set through the <xref:System.IO.MemoryStream.Seek%2A> method.</span></span> <span data-ttu-id="1a8d5-104">Lorsqu’une nouvelle instance de <xref:System.IO.MemoryStream> est créé, en cours position est définie à zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-104">When a new instance of <xref:System.IO.MemoryStream> is created, the current position is set to zero.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 <span data-ttu-id="1a8d5-105">Flux de mémoire créés avec un tableau d’octets non signés fournissent un flux non redimensionnable des données.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-105">Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</span></span> <span data-ttu-id="1a8d5-106">Lorsque vous utilisez un tableau d’octets, vous pouvez ajouter à ni réduire le flux, bien que vous ne pourrez pas modifier le contenu existant, selon les paramètres passés au constructeur.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-106">When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</span></span> <span data-ttu-id="1a8d5-107">Les flux de mémoire vide sont redimensionnables et peuvent être écrits dans et lire à partir de.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-107">Empty memory streams are resizable, and can be written to and read from.</span></span>  
  
 <span data-ttu-id="1a8d5-108">Si un <xref:System.IO.MemoryStream> objet est ajouté à un fichier ResX ou un fichier .resources, appelez le <xref:System.Resources.ResourceManager.GetStream%2A> méthode lors de l’exécution pour le récupérer.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-108">If a <xref:System.IO.MemoryStream> object is added to a ResX file or a .resources file, call the <xref:System.Resources.ResourceManager.GetStream%2A> method at runtime to retrieve it.</span></span>  
  
 <span data-ttu-id="1a8d5-109">Si un <xref:System.IO.MemoryStream> objet est sérialisé en un fichier de ressources qu’il sera réellement sérialisé comme un <xref:System.IO.UnmanagedMemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-109">If a <xref:System.IO.MemoryStream> object is serialized to a resource file it will actually be serialized as an <xref:System.IO.UnmanagedMemoryStream>.</span></span> <span data-ttu-id="1a8d5-110">Ce comportement offre de meilleures performances, ainsi que la possibilité d’obtenir un pointeur vers les données directement, sans avoir à passer par <xref:System.IO.Stream> méthodes.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-110">This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <xref:System.IO.Stream> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-111">L’exemple de code suivant montre comment lire et écrire des données à l’aide de la mémoire comme magasin de stockage.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-111">The following code example shows how to read and write data using memory as a backing store.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1a8d5-112">Initialise une nouvelle instance de la classe <see cref="T:System.IO.MemoryStream" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-112">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a8d5-113">Initialise une nouvelle instance de la classe <see cref="T:System.IO.MemoryStream" /> avec une capacité extensible initialisée à zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-113">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-114">Le <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, et <xref:System.IO.MemoryStream.CanWrite%2A> propriétés ont la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-114">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="1a8d5-115">La capacité du flux en cours augmente automatiquement lorsque vous utilisez le <xref:System.IO.MemoryStream.SetLength%2A> pour définir la longueur à une valeur supérieure à la capacité du flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-115">The capacity of the current stream automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span>  
  
 <span data-ttu-id="1a8d5-116">Ce constructeur expose sous-jacent flux <xref:System.IO.MemoryStream.GetBuffer%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-116">This constructor exposes the underlying stream, which <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-117">Tableau d'octets non signés à partir duquel créer le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-117">The array of unsigned bytes from which to create the current stream.</span></span></param>
        <summary><span data-ttu-id="1a8d5-118">Initialise une nouvelle instance non redimensionnable de la classe <see cref="T:System.IO.MemoryStream" /> en fonction du tableau d'octets spécifié.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-118">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-119">Le <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, et <xref:System.IO.MemoryStream.CanWrite%2A> propriétés ont la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-119">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span> <span data-ttu-id="1a8d5-120"><xref:System.IO.MemoryStream.Capacity%2A> est défini sur la longueur du tableau d’octets spécifié.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-120"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span> <span data-ttu-id="1a8d5-121">Nouveau flux de données n’est possible, mais n’est pas redimensionnable.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-121">The new stream can be written to, but is not resizable.</span></span>  
  
 <span data-ttu-id="1a8d5-122">La longueur du flux ne peut pas être définie sur une valeur supérieure à la longueur initiale du tableau d’octets spécifié ; Toutefois, le flux peut être tronqué (voir <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-122">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="1a8d5-123">Ce constructeur n’expose pas le flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-123">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="1a8d5-124"><xref:System.IO.MemoryStream.GetBuffer%2A> lève <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-124"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-125"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-125"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="1a8d5-126">Taille initiale du tableau interne, en octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-126">The initial size of the internal array in bytes.</span></span></param>
        <summary><span data-ttu-id="1a8d5-127">Initialise une nouvelle instance de la classe <see cref="T:System.IO.MemoryStream" /> avec une capacité extensible initialisée à la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-127">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-128">Le <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, et <xref:System.IO.MemoryStream.CanWrite%2A> propriétés ont la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-128">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="1a8d5-129">La capacité augmente automatiquement lorsque vous utilisez le <xref:System.IO.MemoryStream.SetLength%2A> pour définir la longueur à une valeur supérieure à la capacité du flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-129">The capacity automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span> <span data-ttu-id="1a8d5-130">À l’exception d’un `MemoryStream` construit avec un paramètre byte [], écrire des opérations à la fin d’un `MemoryStream` développer le `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-130">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
 <span data-ttu-id="1a8d5-131">Ce constructeur expose sous-jacent flux de données <xref:System.IO.MemoryStream.GetBuffer%2A> retourne.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-131">This constructor exposes the underlying stream that <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-132">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-132">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-133"><paramref name="capacity" /> est un nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-133"><paramref name="capacity" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-134">Tableau d'octets non signés à partir duquel créer ce flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-134">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="writable"><span data-ttu-id="1a8d5-135">Définition de la propriété <see cref="P:System.IO.MemoryStream.CanWrite" />, qui détermine si le flux prend en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-135">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="1a8d5-136">Initialise une nouvelle instance non redimensionnable de la classe <see cref="T:System.IO.MemoryStream" /> en fonction du tableau d'octets spécifié, avec la propriété <see cref="P:System.IO.MemoryStream.CanWrite" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-136">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-137">Le <xref:System.IO.MemoryStream.CanRead%2A> et <xref:System.IO.MemoryStream.CanSeek%2A> propriétés sont définies sur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-137">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="1a8d5-138"><xref:System.IO.MemoryStream.Capacity%2A> est défini sur la longueur du tableau d’octets spécifié.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-138"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span>  
  
 <span data-ttu-id="1a8d5-139">La longueur du flux ne peut pas être définie sur une valeur supérieure à la longueur initiale du tableau d’octets spécifié ; Toutefois, le flux peut être tronqué (voir <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-139">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="1a8d5-140">Ce constructeur n’expose pas le flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-140">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="1a8d5-141"><xref:System.IO.MemoryStream.GetBuffer%2A> lève <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-141"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-142"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-142"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-143">Tableau d'octets non signés à partir duquel créer ce flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-143">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="1a8d5-144">Index dans <c>buffer</c> où commence le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-144">The index into <c>buffer</c> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-145">Longueur du flux en octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-145">The length of the stream in bytes.</span></span></param>
        <summary><span data-ttu-id="1a8d5-146">Initialise une nouvelle instance non redimensionnable de la classe <see cref="T:System.IO.MemoryStream" /> en fonction de la région (index) spécifiée d'un tableau d'octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-146">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-147">Le <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, et <xref:System.IO.MemoryStream.CanWrite%2A> propriétés ont la valeur `true`, mais la capacité ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-147">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`, but the capacity cannot be changed.</span></span> <span data-ttu-id="1a8d5-148"><xref:System.IO.MemoryStream.Capacity%2A> a la valeur `count`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-148"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="1a8d5-149">La longueur du flux ne peut pas être définie sur une valeur supérieure à la longueur initiale du tableau d’octets spécifié ; Toutefois, le flux peut être tronqué (voir <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-149">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="1a8d5-150">Ce constructeur n’expose pas le flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-150">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="1a8d5-151"><xref:System.IO.MemoryStream.GetBuffer%2A> lève <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-151"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="1a8d5-152">Toutefois, vous pouvez écrire dans le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-152">However, you can write to the stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-153"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-153"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-154"><paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-154"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1a8d5-155">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-155">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-156">Tableau d'octets non signés à partir duquel créer ce flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-156">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="1a8d5-157">Index dans <c>buffer</c> où commence le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-157">The index in <c>buffer</c> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-158">Longueur du flux en octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-158">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="1a8d5-159">Définition de la propriété <see cref="P:System.IO.MemoryStream.CanWrite" />, qui détermine si le flux prend en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-159">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="1a8d5-160">Initialise une nouvelle instance non redimensionnable de la classe <see cref="T:System.IO.MemoryStream" /> en fonction de la région spécifiée d'un tableau d'octets, avec la propriété <see cref="P:System.IO.MemoryStream.CanWrite" /> spécifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-160">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-161">Le <xref:System.IO.MemoryStream.CanRead%2A> et <xref:System.IO.MemoryStream.CanSeek%2A> propriétés sont définies sur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-161">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="1a8d5-162"><xref:System.IO.MemoryStream.Capacity%2A> a la valeur `count`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-162"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="1a8d5-163">La longueur du flux ne peut pas être définie sur une valeur supérieure à la longueur initiale du tableau d’octets spécifié ; Toutefois, le flux peut être tronqué (voir <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-163">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="1a8d5-164">Ce constructeur n’expose pas le flux sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-164">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="1a8d5-165"><xref:System.IO.MemoryStream.GetBuffer%2A> lève <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-165"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="1a8d5-166">Toutefois, vous pouvez écrire dans le flux si `writable` est `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-166">However, you can write to the stream if `writable` is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-167"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-167"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-168"><paramref name="index" /> ou <paramref name="count" /> est négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-168"><paramref name="index" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1a8d5-169">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-169">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-170">Tableau d'octets non signés à partir duquel créer ce flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-170">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="1a8d5-171">Index dans <c>buffer</c> où commence le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-171">The index into <c>buffer</c> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-172">Longueur du flux en octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-172">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="1a8d5-173">Définition de la propriété <see cref="P:System.IO.MemoryStream.CanWrite" />, qui détermine si le flux prend en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-173">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <param name="publiclyVisible">
          <span data-ttu-id="1a8d5-174"><see langword="true" /> pour activer <see cref="M:System.IO.MemoryStream.GetBuffer" />, qui retourne le tableau d'octets non signés à partir duquel le flux a été créé ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-174"><see langword="true" /> to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1a8d5-175">Initialise une nouvelle instance de la classe <see cref="T:System.IO.MemoryStream" /> en fonction de la région spécifiée d'un tableau d'octets, avec la propriété <see cref="P:System.IO.MemoryStream.CanWrite" /> spécifiée et la possibilité d'appeler <see cref="M:System.IO.MemoryStream.GetBuffer" /> comme spécifié.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-175">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-176">Le <xref:System.IO.MemoryStream.CanRead%2A> et <xref:System.IO.MemoryStream.CanSeek%2A> propriétés sont définies sur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-176">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="1a8d5-177"><xref:System.IO.MemoryStream.Capacity%2A> a la valeur `count`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-177"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="1a8d5-178">La nouvelle instance de flux de données n’est possible, mais le <xref:System.IO.MemoryStream.Capacity%2A> de l’octet sous-jacent tableau ne peut pas être modifié.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-178">The new stream instance can be written to, but the <xref:System.IO.MemoryStream.Capacity%2A> of the underlying byte array cannot be changed.</span></span> <span data-ttu-id="1a8d5-179">La longueur du flux ne peut pas être définie sur une valeur supérieure à la longueur initiale du tableau d’octets spécifié ; Toutefois, le flux peut être tronqué (voir <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-179">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-180"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-180"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-181"><paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-181"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1a8d5-182">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-182">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1a8d5-183">Obtient une valeur indiquant si le flux actuel prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-183">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value>
          <span data-ttu-id="1a8d5-184"><see langword="true" /> si le flux est ouvert.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-184"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-185">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la lecture, les appels à la <xref:System.IO.MemoryStream.Read%2A> et <xref:System.IO.MemoryStream.ReadByte%2A> méthodes lèvent une <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-185">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.MemoryStream.Read%2A> and <xref:System.IO.MemoryStream.ReadByte%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="1a8d5-186">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-186">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1a8d5-187">Obtient une valeur indiquant si le flux actuel prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-187">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value>
          <span data-ttu-id="1a8d5-188"><see langword="true" /> si le flux est ouvert.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-188"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-189">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la recherche, les appels à <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, et <xref:System.IO.MemoryStream.Seek%2A> lever un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-189">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, and <xref:System.IO.MemoryStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="1a8d5-190">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-190">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1a8d5-191">Obtient une valeur indiquant si le flux actuel prend en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-191">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value>
          <span data-ttu-id="1a8d5-192"><see langword="true" /> si le flux prend en charge l'écriture ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-192"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-193">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge l’écriture, un appel à <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, ou <xref:System.IO.Stream.WriteByte%2A> lève une <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-193">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="1a8d5-194">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-194">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1a8d5-195">Obtient ou définit le nombre d'octets alloués pour ce flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-195">Gets or sets the number of bytes allocated for this stream.</span></span></summary>
        <value><span data-ttu-id="1a8d5-196">Longueur de la partie de la mémoire tampon qui peut être utilisée pour le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-196">The length of the usable portion of the buffer for the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-197">`Capacity` est la longueur du tampon pour les tableaux d’octets fournis par le système.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-197">`Capacity` is the buffer length for system-provided byte arrays.</span></span> <span data-ttu-id="1a8d5-198">`Capacity` Impossible de définir une valeur inférieure à la longueur actuelle du flux de données.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-198">`Capacity` cannot be set to a value less than the current length of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-199">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-199">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1a8d5-200">La capacité définie est négative ou inférieure à la longueur actuelle du flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-200">A capacity is set that is negative or less than the current length of the stream.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-201">Le flux actuel est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-201">The current stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="1a8d5-202"><see langword="set" /> est appelé sur un flux dont la capacité ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-202"><see langword="set" /> is invoked on a stream whose capacity cannot be modified.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="1a8d5-203">Flux vers lequel le contenu du flux actuel sera copié.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-203">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="1a8d5-204">Taille en octets de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-204">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="1a8d5-205">Cette valeur doit être supérieure à zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-205">This value must be greater than zero.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="1a8d5-206">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-206">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="1a8d5-207">Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon et un jeton d'annulation spécifiés.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-207">Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-208">Tâche qui représente l’opération de copie asynchrone.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-208">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-209"><paramref name="destination" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-209"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-210"><paramref name="buffersize" /> est négatif ou égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-210"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-211">Le flux de données actuel ou le flux de données de destination est supprimé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-211">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1a8d5-212">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-212">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="1a8d5-213"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-213"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="1a8d5-214">Libère les ressources non managées utilisées par la classe <see cref="T:System.IO.MemoryStream" /> et libère éventuellement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-214">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-215">Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-215">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="1a8d5-216"><xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.MemoryStream.Dispose%2A> méthode avec la `disposing` paramètre la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-216"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.MemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="1a8d5-217"><xref:System.Object.Finalize%2A> appelle <xref:System.IO.MemoryStream.Dispose%2A> avec `disposing` la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-217"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.MemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="1a8d5-218">Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.MemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-218">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.MemoryStream> references.</span></span> <span data-ttu-id="1a8d5-219">Cette méthode appelle la méthode <xref:System.ComponentModel.Component.Dispose%2A> de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-219">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="1a8d5-220"><see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-220"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="1a8d5-221">Lors de la substitution <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-221">When overriding <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="1a8d5-222">Pour plus d’informations sur l’implémentation <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-222">For more information about how to implement <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
 <span data-ttu-id="1a8d5-223">Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-223">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a8d5-224">Remplace la méthode <see cref="M:System.IO.Stream.Flush" /> afin qu'aucune action ne soit effectuée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-224">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-225">Cette méthode remplace la <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-225">This method overrides the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1a8d5-226">Étant donné que les données écrites dans un <xref:System.IO.MemoryStream> objet est écrit dans la mémoire RAM, cette méthode est redondante.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-226">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="1a8d5-227">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-227">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="1a8d5-228">Efface de façon asynchrone toutes les mémoires tampons pour ce flux et surveille les demandes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-228">Asynchronously clears all buffers for this stream, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-229">Tâche qui représente l’opération de vidage asynchrone.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-229">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-230">Étant donné que les données écrites dans un <xref:System.IO.MemoryStream> objet est écrit dans la mémoire RAM, cette méthode est redondante.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-230">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 <span data-ttu-id="1a8d5-231">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> la valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-231">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="1a8d5-232">Vous pouvez créer un jeton d’annulation en créant une instance de la <xref:System.Threading.CancellationTokenSource> classe et en passant le <xref:System.Threading.CancellationTokenSource.Token%2A> propriété en tant que le `cancellationToken` paramètre.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-232">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-233">Le flux a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-233">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a8d5-234">Retourne le tableau d'octets non signés à partir duquel ce flux a été créé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-234">Returns the array of unsigned bytes from which this stream was created.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-235">Tableau d'octets à partir duquel ce flux a été créé, ou le tableau sous-jacent si aucun tableau d'octets n'a été fourni au constructeur <see cref="T:System.IO.MemoryStream" /> pendant la construction de l'instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-235">The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-236">Notez que la mémoire tampon contient des octets alloués qui peuvent être inutilisés.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-236">Note that the buffer contains allocated bytes which might be unused.</span></span> <span data-ttu-id="1a8d5-237">Par exemple, si la chaîne « test » est écrite dans le <xref:System.IO.MemoryStream> (objet), la longueur de la mémoire tampon retournée à partir de <xref:System.IO.MemoryStream.GetBuffer%2A> est 256, et non pas 4, avec 252 octets inutilisés.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-237">For example, if the string "test" is written into the <xref:System.IO.MemoryStream> object, the length of the buffer returned from <xref:System.IO.MemoryStream.GetBuffer%2A> is 256, not 4, with 252 bytes unused.</span></span> <span data-ttu-id="1a8d5-238">Pour obtenir uniquement les données de la mémoire tampon, utilisez la <xref:System.IO.MemoryStream.ToArray%2A> méthode ; Toutefois, <xref:System.IO.MemoryStream.ToArray%2A> crée une copie des données en mémoire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-238">To obtain only the data in the buffer, use the <xref:System.IO.MemoryStream.ToArray%2A> method; however, <xref:System.IO.MemoryStream.ToArray%2A> creates a copy of the data in memory.</span></span>  
  
 <span data-ttu-id="1a8d5-239">La mémoire tampon peut également être `null`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-239">The buffer can also be `null`.</span></span>  
  
 <span data-ttu-id="1a8d5-240">Pour créer un `MemoryStream` instance avec une mémoire tampon visible publiquement, utilisez <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, ou <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-240">To create a `MemoryStream` instance with a publicly visible buffer, use <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, or <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span></span> <span data-ttu-id="1a8d5-241">Si le flux actuel est redimensionnable, deux appels à cette méthode ne retournent pas le même groupe si le tableau d’octets sous-jacent est redimensionné entre les appels.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-241">If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</span></span> <span data-ttu-id="1a8d5-242">Pour plus d'informations, consultez <xref:System.IO.MemoryStream.Capacity%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-242">For additional information, see <xref:System.IO.MemoryStream.Capacity%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a8d5-243">Cette méthode fonctionne lorsque le flux de mémoire est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-243">This method works when the memory stream is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="1a8d5-244">L’instance <see langword="MemoryStream" /> n’a pas été créée avec une mémoire tampon visible publiquement.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-244">The <see langword="MemoryStream" /> instance was not created with a publicly visible buffer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1a8d5-245">Obtient la longueur du flux en octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-245">Gets the length of the stream in bytes.</span></span></summary>
        <value><span data-ttu-id="1a8d5-246">Longueur du flux en octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-246">The length of the stream in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1a8d5-247">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-247">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-248">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-248">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1a8d5-249">Obtient ou définit la position actuelle dans le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-249">Gets or sets the current position within the stream.</span></span></summary>
        <value><span data-ttu-id="1a8d5-250">Position actuelle dans le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-250">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1a8d5-251">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-251">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1a8d5-252">La position correspond à une valeur négative ou à une valeur supérieure à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-252">The position is set to a negative value or a value greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-253">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-253">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-254">Quand cette méthode retourne un résultat, contient le tableau d’octets spécifié dont les valeurs comprises entre <c>offset</c> et (<c>offset</c> + <c>count</c> - 1) sont remplacées par les caractères lus dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-254">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the characters read from the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="1a8d5-255">Dans <c>buffer</c>, décalage d’octet de base zéro auquel commencer le stockage des données à partir du flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-255">The zero-based byte offset in <c>buffer</c> at which to begin storing data from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-256">Nombre maximal d'octets à lire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-256">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="1a8d5-257">Lit un bloc d'octets à partir du flux actuel et écrit les données dans une mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-257">Reads a block of bytes from the current stream and writes the data to a buffer.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-258">Nombre total d'octets écrits dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-258">The total number of bytes written into the buffer.</span></span> <span data-ttu-id="1a8d5-259">Ce total peut être inférieur au nombre d'octets demandés si ce nombre d'octets n'est pas actuellement disponible, ou égal à zéro si la fin du flux a été atteinte avant que des octets soient lus.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-259">This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-260">Cette méthode se substitue à <xref:System.IO.Stream.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-260">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="1a8d5-261">Le `offset` paramètre indique l’offset du premier octet dans `buffer` les données dans le flux actuel sont écrit.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-261">The `offset` parameter gives the offset of the first byte in `buffer` to which data from the current stream is written.</span></span> <span data-ttu-id="1a8d5-262">Le `count` paramètre indique le nombre maximal d’octets à lire à partir du flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-262">The `count` parameter gives the maximum number of bytes to read from the current stream.</span></span> <span data-ttu-id="1a8d5-263">La valeur retournée est le nombre réel d’octets lus, ou zéro si la fin du flux est atteinte.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-263">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span>  
  
 <span data-ttu-id="1a8d5-264">Si l’opération de lecture réussit, la position actuelle dans le flux avance du nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-264">If the read operation is successful, the current position within the stream advances by the number of bytes read.</span></span> <span data-ttu-id="1a8d5-265">Si une exception se produit, la position actuelle dans le flux de données reste inchangée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-265">If an exception occurs, the current position within the stream remains unchanged.</span></span>  
  
 <span data-ttu-id="1a8d5-266">Le `Read` méthode retourne zéro uniquement si la fin du flux est atteinte.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-266">The `Read` method will return zero only if the end of the stream is reached.</span></span> <span data-ttu-id="1a8d5-267">Dans tous les autres cas, `Read` lit toujours au moins un octet du flux avant de retourner.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-267">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="1a8d5-268">Par définition, si aucune donnée n’est disponible dans le flux lors d’un appel à `Read`, la `Read` retourne la valeur zéro (la fin du flux est automatiquement atteinte).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-268">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns zero (the end of the stream is reached automatically).</span></span> <span data-ttu-id="1a8d5-269">Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux de données n’a pas été atteint.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-269">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="1a8d5-270">Utilisez <xref:System.IO.BinaryReader> pour la lecture des types de données primitifs.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-270">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1a8d5-271">Si le tableau d’octets spécifié dans le `buffer` paramètre est la mémoire tampon sous-jacente retournée par la <xref:System.IO.MemoryStream.GetBuffer%2A> (méthode), le contenu du tableau est remplacé, et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-271">If the byte array specified in the `buffer` parameter is the underlying buffer returned by the <xref:System.IO.MemoryStream.GetBuffer%2A> method, the array contents are overwritten, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-272">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-272">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-273"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-273"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-274"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-274"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1a8d5-275"><paramref name="offset" /> soustrait de la longueur de la mémoire tampon est inférieur à <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-275"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-276">L’instance du flux actuel est fermée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-276">The current stream instance is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-277">Mémoire tampon dans laquelle les données sont écrites.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-277">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="1a8d5-278">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données à partir du flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-278">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-279">Nombre maximal d'octets à lire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-279">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="1a8d5-280">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-280">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="1a8d5-281">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-281">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="1a8d5-282">Lit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position dans le flux du nombre d'octets lus et surveille les demandes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-282">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-283">Tâche qui représente l'opération de lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-283">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="1a8d5-284">La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-284">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="1a8d5-285">La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-285">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-286">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> la valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-286">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="1a8d5-287">Vous pouvez créer un jeton d’annulation en créant une instance de la <xref:System.Threading.CancellationTokenSource> classe et en passant le <xref:System.Threading.CancellationTokenSource.Token%2A> propriété en tant que le `cancellationToken` paramètre.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-287">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-288"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-288"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-289"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-289"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1a8d5-290">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-290">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1a8d5-291">Le flux ne prend pas en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-291">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-292">Le flux a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-292">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1a8d5-293">Le flux est actuellement utilisé par une opération de lecture antérieure.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-293">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a8d5-294">Lit un octet dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-294">Reads a byte from the current stream.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-295">Conversion du type (transtypage) de l'octet en <see cref="T:System.Int32" />, ou -1 si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-295">The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-296">Cette méthode se substitue à <xref:System.IO.Stream.ReadByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-296">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
 <span data-ttu-id="1a8d5-297">Si l’opération de lecture réussit, la position actuelle dans le flux est avancée d’un octet.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-297">If the read operation is successful, the current position within the stream is advanced by one byte.</span></span> <span data-ttu-id="1a8d5-298">Si une exception se produit, la position actuelle dans le flux de données est inchangée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-298">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-299">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-299">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-300">L’instance du flux actuel est fermée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-300">The current stream instance is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="1a8d5-301">Nouvelle position dans le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-301">The new position within the stream.</span></span> <span data-ttu-id="1a8d5-302">Elle est relative au paramètre <c>loc</c> et peut être positive ou négative.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-302">This is relative to the <c>loc</c> parameter, and can be positive or negative.</span></span></param>
        <param name="loc"><span data-ttu-id="1a8d5-303">Valeur de type <see cref="T:System.IO.SeekOrigin" />, qui sert de point de référence à la recherche.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-303">A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point.</span></span></param>
        <summary><span data-ttu-id="1a8d5-304">Définit la position dans le flux actuel à la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-304">Sets the position within the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-305">Nouvelle position dans le flux, calculée en combinant le point de référence initial et le décalage.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-305">The new position within the stream, calculated by combining the initial reference point and the offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-306">Cette méthode se substitue à <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-306">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1a8d5-307">La recherche au-delà de la longueur du flux de données est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-307">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="1a8d5-308">N’utilisez pas le <xref:System.IO.MemoryStream.Seek%2A> pour déterminer la nouvelle position dans le flux de données si le <xref:System.IO.MemoryStream> a été initialisée avec un décalage de zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-308">Do not use the <xref:System.IO.MemoryStream.Seek%2A> method to determine the new position in the stream if the <xref:System.IO.MemoryStream> was initialized with a non-zero offset.</span></span> <span data-ttu-id="1a8d5-309">Si vous le faites, <xref:System.IO.MemoryStream.Seek%2A> retourne une valeur inexacte.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-309">If you do, <xref:System.IO.MemoryStream.Seek%2A> will return an inaccurate value.</span></span> <span data-ttu-id="1a8d5-310">Utilisez plutôt le <xref:System.IO.MemoryStream.Position%2A> propriété à obtenir la nouvelle position du flux de données.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-310">Instead, use the <xref:System.IO.MemoryStream.Position%2A> property to get the new position of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-311">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-311">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="1a8d5-312">Tentative de recherche avant le début du flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-312">Seeking is attempted before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-313"><paramref name="offset" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-313"><paramref name="offset" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1a8d5-314">Un <see cref="T:System.IO.SeekOrigin" /> n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-314">There is an invalid <see cref="T:System.IO.SeekOrigin" />.</span></span>  
  
 <span data-ttu-id="1a8d5-315">- ou -</span><span class="sxs-lookup"><span data-stu-id="1a8d5-315">-or-</span></span>  
  
 <span data-ttu-id="1a8d5-316"><paramref name="offset" /> a entraîné un débordement arithmétique.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-316"><paramref name="offset" /> caused an arithmetic overflow.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-317">L’instance du flux actuel est fermée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-317">The current stream instance is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1a8d5-318">Valeur à laquelle définir la longueur.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-318">The value at which to set the length.</span></span></param>
        <summary><span data-ttu-id="1a8d5-319">Définit la longueur du flux actuel à la valeur spécifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-319">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-320">Cette méthode se substitue à <xref:System.IO.Stream.SetLength%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-320">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="1a8d5-321">Si la valeur spécifiée est inférieure à la longueur actuelle du flux de données, le flux est tronqué.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-321">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="1a8d5-322">Si après la troncation de la position actuelle dans le flux de données a dépassé la fin du flux, le <xref:System.IO.MemoryStream.ReadByte%2A> méthode retourne -1, le <xref:System.IO.MemoryStream.Read%2A> méthode lit zéro octets dans le tableau d’octets fourni, et <xref:System.IO.MemoryStream.Write%2A> et <xref:System.IO.MemoryStream.WriteByte%2A> ajoutent des méthodes octets spécifiés à la fin du flux de données, l’augmentation de sa longueur.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-322">If after the truncation the current position within the stream is past the end of the stream, the <xref:System.IO.MemoryStream.ReadByte%2A> method returns -1, the <xref:System.IO.MemoryStream.Read%2A> method reads zero bytes into the provided byte array, and <xref:System.IO.MemoryStream.Write%2A> and <xref:System.IO.MemoryStream.WriteByte%2A> methods append specified bytes at the end of the stream, increasing its length.</span></span> <span data-ttu-id="1a8d5-323">Si la valeur spécifiée est supérieure à la capacité actuelle et le flux est redimensionnable, la capacité est augmentée et la position actuelle dans le flux de données est inchangée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-323">If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</span></span> <span data-ttu-id="1a8d5-324">Si la longueur est augmentée, le contenu du flux de données entre l’ancienne et la nouvelle longueur est initialisé à zéro.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-324">If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a8d5-325">A <xref:System.IO.MemoryStream> instance doit prendre en charge l’écriture de cette méthode fonctionne.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-325">A <xref:System.IO.MemoryStream> instance must support writing for this method to work.</span></span> <span data-ttu-id="1a8d5-326">Utilisez le <xref:System.IO.MemoryStream.CanWrite%2A> propriété pour déterminer si l’instance actuelle prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-326">Use the <xref:System.IO.MemoryStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="1a8d5-327">Pour plus d'informations, consultez <xref:System.IO.Stream.CanWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-327">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1a8d5-328">Le flux actuel n’est pas redimensionnable et <paramref name="value" /> est supérieur à la capacité actuelle.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-328">The current stream is not resizable and <paramref name="value" /> is larger than the current capacity.</span></span>  
  
 <span data-ttu-id="1a8d5-329">- ou -</span><span class="sxs-lookup"><span data-stu-id="1a8d5-329">-or-</span></span>  
  
 <span data-ttu-id="1a8d5-330">Le flux actuel ne prend pas en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-330">The current stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-331"><paramref name="value" /> est négatif ou supérieur à la longueur maximale de <see cref="T:System.IO.MemoryStream" />, où la longueur maximale est (<see cref="F:System.Int32.MaxValue" /> - origine), et l’origine est l’index dans la mémoire tampon sous-jacente auquel commence le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-331"><paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />, where the maximum length is(<see cref="F:System.Int32.MaxValue" /> - origin), and origin is the index into the underlying buffer at which the stream starts.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1a8d5-332">Écrit le contenu du flux dans un tableau d'octets, indépendamment de la propriété <see cref="P:System.IO.MemoryStream.Position" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-332">Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-333">Nouveau tableau d'octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-333">A new byte array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-334">Cette méthode omet les octets inutilisés dans <xref:System.IO.MemoryStream> à partir du tableau.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-334">This method omits unused bytes in <xref:System.IO.MemoryStream> from the array.</span></span> <span data-ttu-id="1a8d5-335">Pour obtenir la mémoire tampon entière, utilisez la <xref:System.IO.MemoryStream.GetBuffer%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1a8d5-335">To get the entire buffer, use the <xref:System.IO.MemoryStream.GetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="1a8d5-336">Cette méthode retourne une copie du contenu de la <xref:System.IO.MemoryStream> en tant que tableau d’octets.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-336">This method returns a copy of the contents of the <xref:System.IO.MemoryStream> as a byte array.</span></span> <span data-ttu-id="1a8d5-337">Si l’instance actuelle a été construite sur un tableau d’octets fourni, une copie de la section du tableau à laquelle cette instance peut accéder est retournée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-337">If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</span></span> <span data-ttu-id="1a8d5-338">Consultez le <xref:System.IO.MemoryStream.%23ctor%2A> constructeur pour plus d’informations.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-338">See the <xref:System.IO.MemoryStream.%23ctor%2A> constructor for details.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1a8d5-339">Cette méthode fonctionne quand le <xref:System.IO.MemoryStream> est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-339">This method works when the <xref:System.IO.MemoryStream> is closed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-340">Segment de tableau d'octets à partir duquel ce flux a été créé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-340">The byte array segment from which this stream was created.</span></span></param>
        <summary><span data-ttu-id="1a8d5-341">Retourne le tableau d'octets non signés à partir duquel ce flux a été créé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-341">Returns the array of unsigned bytes from which this stream was created.</span></span> <span data-ttu-id="1a8d5-342">La valeur de retour indique si la conversion a réussi.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-342">The return value indicates whether the conversion succeeded.</span></span></summary>
        <returns>
          <span data-ttu-id="1a8d5-343"><see langword="true" /> si la conversion a réussi ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-343"><see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-344">Mémoire tampon dont sont issues les données à écrire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-344">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="1a8d5-345">Dans <c>buffer</c>, décalage d’octet de base zéro auquel commencer la copie des octets dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-345">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-346">Nombre maximal d'octets à écrire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-346">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="1a8d5-347">Écrit un bloc d'octets dans le flux actuel en utilisant des données lues dans une mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-347">Writes a block of bytes to the current stream using data read from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-348">Cette méthode se substitue à <xref:System.IO.Stream.Write%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-348">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="1a8d5-349">Le `offset` paramètre indique l’offset du premier octet dans `buffer` écrire à partir et le `count` paramètre indique le nombre d’octets à écrire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-349">The `offset` parameter gives the offset of the first byte in `buffer` to write from, and the `count` parameter gives the number of bytes to write.</span></span> <span data-ttu-id="1a8d5-350">Si l’opération d’écriture réussit, la position actuelle dans le flux est avancée par le nombre d’octets écrits.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-350">If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="1a8d5-351">Si une exception se produit, la position actuelle dans le flux de données est inchangée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-351">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
 <span data-ttu-id="1a8d5-352">À l’exception d’un `MemoryStream` construit avec un paramètre byte [], écrire des opérations à la fin d’un `MemoryStream` développer le `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-352">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-353">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-353">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-354"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-354"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1a8d5-355">Le flux ne prend pas en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-355">The stream does not support writing.</span></span> <span data-ttu-id="1a8d5-356">Pour plus d’informations, consultez <see cref="P:System.IO.Stream.CanWrite" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-356">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
 <span data-ttu-id="1a8d5-357">- ou -</span><span class="sxs-lookup"><span data-stu-id="1a8d5-357">-or-</span></span>  
  
 <span data-ttu-id="1a8d5-358">La position actuelle est à moins de <paramref name="count" /> octets de la fin du flux et la capacité ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-358">The current position is closer than <paramref name="count" /> bytes to the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1a8d5-359"><paramref name="offset" /> soustrait de la longueur de la mémoire tampon est inférieur à <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-359"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-360"><paramref name="offset" /> ou <paramref name="count" /> est négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-360"><paramref name="offset" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="1a8d5-361">Une erreur d’E/S se produit.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-361">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-362">L’instance du flux actuel est fermée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-362">The current stream instance is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="1a8d5-363">Mémoire tampon dont sont issues les données à écrire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-363">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="1a8d5-364">Le décalage en octets, commençant à zéro, dans <c>buffer</c>, où commencer la copie des octets dans le flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-364">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="1a8d5-365">Nombre maximal d'octets à écrire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-365">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="1a8d5-366">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-366">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="1a8d5-367">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-367">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="1a8d5-368">Écrit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position actuelle dans ce flux du nombre d'octets écrits et surveille les demandes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-368">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="1a8d5-369">Tâche qui représente l’opération d’écriture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-369">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-370">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> la valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-370">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="1a8d5-371">Vous pouvez créer un jeton d’annulation en créant une instance de la <xref:System.Threading.CancellationTokenSource> classe et en passant le <xref:System.Threading.CancellationTokenSource.Token%2A> propriété en tant que le `cancellationToken` paramètre.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-371">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-372"><paramref name="buffer" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-372"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1a8d5-373"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-373"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1a8d5-374">La somme de <paramref name="offset" /> et de <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-374">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1a8d5-375">Le flux ne prend pas en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-375">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-376">Le flux a été supprimé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-376">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1a8d5-377">Le flux est actuellement utilisé par une opération d’écriture précédente.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-377">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1a8d5-378">Octet à écrire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-378">The byte to write.</span></span></param>
        <summary><span data-ttu-id="1a8d5-379">Écrit un octet à la position actuelle dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-379">Writes a byte to the current stream at the current position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-380">Cette méthode se substitue à <xref:System.IO.Stream.WriteByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-380">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="1a8d5-381">À l’exception d’un `MemoryStream` construit avec un paramètre byte [], écrire des opérations à la fin d’un `MemoryStream` développer le `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-381">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1a8d5-382">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.MemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-382">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1a8d5-383">Le flux ne prend pas en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-383">The stream does not support writing.</span></span> <span data-ttu-id="1a8d5-384">Pour plus d’informations, consultez <see cref="P:System.IO.Stream.CanWrite" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-384">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
 <span data-ttu-id="1a8d5-385">- ou -</span><span class="sxs-lookup"><span data-stu-id="1a8d5-385">-or-</span></span>  
  
 <span data-ttu-id="1a8d5-386">La position actuelle est à la fin du flux et la capacité ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-386">The current position is at the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-387">Le flux actuel est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-387">The current stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="1a8d5-388">Flux dans lequel écrire ce flux de mémoire.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-388">The stream to write this memory stream to.</span></span></param>
        <summary><span data-ttu-id="1a8d5-389">Écrit le contenu complet de ce flux de mémoire dans un autre flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-389">Writes the entire contents of this memory stream to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1a8d5-390">Lorsque le flux actuel est ouvert, cette méthode équivaut à appeler la méthode <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> sur la mémoire tampon sous-jacente de ce flux.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-390">When the current stream is open, this method is equivalent to calling <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> on the underlying buffer of this stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1a8d5-391"><paramref name="stream" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-391"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1a8d5-392">Le flux en cours ou le flux cible est fermé.</span><span class="sxs-lookup"><span data-stu-id="1a8d5-392">The current or target stream is closed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>