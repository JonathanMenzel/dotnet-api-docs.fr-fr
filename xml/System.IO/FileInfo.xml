<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5bb0629ac68cce7c7d9a16d415f8de1fd8dbe289" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52213518" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type FileInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des propriétés et des méthodes d'instance pour créer, copier, supprimer, déplacer et ouvrir des fichiers, et facilite la création d'objets <see cref="T:System.IO.FileStream" />. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.IO.FileInfo> classe pour les opérations courantes telles que la copie, déplacer, renommer, création, ouverture, la suppression et ajout de fichiers.  
  
 Si vous effectuez plusieurs opérations sur le même fichier, il peut être plus efficace d’utiliser <xref:System.IO.FileInfo> des méthodes au lieu de méthodes statiques correspondantes de l’instance la <xref:System.IO.File> classe, parce qu’une vérification de sécurité n'est pas toujours nécessaire.  
  
 Un grand nombre de la <xref:System.IO.FileInfo> méthodes retournent des autres types d’e/s lorsque vous créez ou ouvrez des fichiers. Vous pouvez utiliser ces autres types pour manipuler un fichier. Pour plus d’informations, consultez spécifique <xref:System.IO.FileInfo> membres comme <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>, ou <xref:System.IO.FileInfo.Create%2A>.  
  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs.  
  
 Le tableau suivant décrit les énumérations qui sont utilisées pour personnaliser le comportement de divers <xref:System.IO.FileInfo> méthodes.  
  
|Énumération|Description |  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Spécifie l’accès en lecture et écriture dans un fichier.|  
|<xref:System.IO.FileShare>|Spécifie le niveau d’accès autorisé pour un fichier qui est déjà en cours d’utilisation.|  
|<xref:System.IO.FileMode>|Spécifie si le contenu d’un fichier existant est conservé ou remplacé, et si les demandes de création d’un fichier existant provoquent une exception.|  
  
> [!NOTE]
>  Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement construit, ou une exception est levée. Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe. Par conséquent, le chemin d’accès est incorrect et une exception est levée. De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises. Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas. Assurez-vous que vos chemins sont correctement construits lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.  
  
 Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire. Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de serveur et le partage. Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :  
  
-   « c:\\\MyDir\\\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.  
  
-   « c:\\\MyDir » en c# ou « c:\MyDir » en Visual Basic.  
  
-   « MyDir\\\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.  
  
-   «\\\\\\\MyServer\\\MyShare » en c#, ou «\\\MyServer\MyShare » en Visual Basic.  
  
 Le <xref:System.IO.FileInfo> classe fournit les propriétés suivantes qui vous permettent de récupérer des informations sur un fichier. Pour obtenir un exemple montrant comment utiliser chaque propriété, consultez les pages de propriétés.  
  
-   Le <xref:System.IO.FileInfo.Directory%2A> propriété récupère un objet qui représente le répertoire parent d’un fichier.  
  
-   Le <xref:System.IO.FileInfo.DirectoryName%2A> propriété récupère le chemin d’accès complet du répertoire parent d’un fichier.  
  
-   Le <xref:System.IO.FileInfo.Exists%2A> propriété vérifie la présence d’un fichier avant de l’utiliser.  
  
-   Le <xref:System.IO.FileInfo.IsReadOnly%2A> propriété récupère ou définit une valeur qui spécifie si un fichier peut être modifié.  
  
-   Le <xref:System.IO.FileInfo.Length%2A> récupère la taille d’un fichier.  
  
-   Le <xref:System.IO.FileInfo.Name%2A> récupère le nom d’un fichier.  
  
   
  
## Examples  
 L’exemple suivant illustre certains membres principaux de la `FileInfo` classe.  
  
 Lorsque les propriétés sont extraites en premier, <xref:System.IO.FileInfo> appelle le <xref:System.IO.FileSystemInfo.Refresh%2A> (méthode) et les caches des informations sur le fichier. Lors des appels ultérieurs, vous devez appeler <xref:System.IO.FileSystemInfo.Refresh%2A> pour obtenir la dernière copie des informations.  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 Cet exemple produit une sortie similaire à ce qui suit.  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.IO.FileInfo : string -&gt; System.IO.FileInfo" Usage="new System.IO.FileInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom qualifié complet du nouveau fichier, ou nom de fichier relatif. Ne placez pas de caractère de séparation de répertoire à la fin du chemin d’accès.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileInfo" />, qui sert de wrapper pour un chemin d’accès de fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier qualifié complet ou le nom de fichier relatif, mais la vérification de sécurité Obtient le nom qualifié complet.  
  
   
  
## Examples  
 L’exemple suivant utilise ce constructeur pour créer deux fichiers, qui sont ensuite écrites pour lire à partir, copiés et supprimés.  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 L’exemple suivant ouvre un fichier existant ou crée un fichier, ajoute du texte au fichier et affiche les résultats.  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException">Le nom de fichier est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’accès à <paramref name="fileName" /> a été refusé.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="fileName" /> contient un signe deux-points (:) au milieu de la chaîne.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberSignature Language="F#" Value="member this.AppendText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.AppendText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément <see cref="T:System.IO.StreamWriter" /> qui ajoute du texte au fichier représenté par cette instance de <see cref="T:System.IO.FileInfo" />.</summary>
        <returns>Nouveau <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant ajoute du texte dans un fichier et lit à partir du fichier.  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 L’exemple suivant illustre l’ajout de texte à la fin d’un fichier et affiche également le résultat de l’opération d’ajout dans la console. La première fois que cette routine est appelée, le fichier est créé s’il n’existe pas. Après cela, le texte spécifié est ajouté au fichier.  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture et l’ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie un fichier existant vers un nouveau fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">Nom du nouveau fichier de destination de la copie.</param>
        <summary>Copie un fichier existant vers un nouveau fichier, en interdisant le remplacement d'un fichier existant.</summary>
        <returns>Nouveau fichier avec un chemin d'accès qualifié complet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.CopyTo(System.String,System.Boolean)> méthode pour autoriser le remplacement d’un fichier existant.  
  
> [!CAUTION]
>  Si possible, évitez d’utiliser des noms de fichiers courts (tels que xxxxxx ~ 1.xxx) avec cette méthode. Si deux fichiers ont équivalent court des noms de fichiers, cette méthode peut échouer et lever une exception et/ou entraîner un comportement indésirable  
  
   
  
## Examples  
 L’exemple suivant illustre les deux surcharges de la `CopyTo` (méthode).  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 L’exemple suivant illustre la copie d’un fichier vers un autre fichier, en levant une exception si le fichier de destination existe déjà.  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur se produit ou le fichier de destination existe déjà.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un chemin de répertoire est passé ou le fichier est déplacé vers un autre lecteur.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié dans <paramref name="destFileName" /> n’existe pas.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> contient un deux-points (:) dans la chaîne mais ne spécifie pas le volume.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">Nom du nouveau fichier de destination de la copie.</param>
        <param name="overwrite">
          <see langword="true" /> pour autoriser le remplacement d'un fichier existant ; sinon, <see langword="false" />.</param>
        <summary>Copie un fichier existant vers un nouveau fichier, en autorisant le remplacement d'un fichier existant.</summary>
        <returns>Nouveau fichier ou remplacement d'un fichier existant si <paramref name="overwrite" /> est défini à <see langword="true" />. Si le fichier existe et que <paramref name="overwrite" /> est défini à <see langword="false" />, une exception <see cref="T:System.IO.IOException" /> est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour autoriser ou empêcher le remplacement d’un fichier existant. Utilisez le <xref:System.IO.FileInfo.CopyTo(System.String)> méthode pour empêcher le remplacement d’un fichier existant par défaut.  
  
> [!CAUTION]
>  Si possible, évitez d’utiliser des noms de fichiers courts (tels que xxxxxx ~ 1.xxx) avec cette méthode. Si deux fichiers ont équivalent court des noms de fichiers, cette méthode peut échouer et lever une exception et/ou entraîner un comportement indésirable  
  
   
  
## Examples  
 L’exemple suivant illustre les deux surcharges de la `CopyTo` (méthode).  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 L’exemple suivant illustre la copie d’un fichier à un autre fichier, en spécifiant s’il faut remplacer un fichier qui existe déjà.  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.IO.IOException">Une erreur se produit, ou le fichier de destination existe déjà et <paramref name="overwrite" /> a la valeur <see langword="false" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié dans <paramref name="destFileName" /> n’existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un chemin de répertoire est passé ou le fichier est déplacé vers un autre lecteur.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> contient un signe deux-points (:) au milieu de la chaîne.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; System.IO.FileStream" Usage="fileInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un fichier.</summary>
        <returns>Nouveau fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs.  
  
 Cette méthode est un wrapper pour la fonctionnalité fournie par <xref:System.IO.File.Create%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant crée une référence à un fichier et crée ensuite le fichier sur disque à l’aide `FileInfo.Create()`.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 L’exemple suivant crée un fichier, il ajoute du texte et lit à partir du fichier.  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberSignature Language="F#" Value="member this.CreateText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.CreateText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément <see cref="T:System.IO.StreamWriter" /> qui écrit un nouveau fichier texte.</summary>
        <returns>Nouveau <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs.  
  
   
  
## Examples  
 L’exemple suivant montre le `CreateText` (méthode).  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le nom de fichier est un répertoire.</exception>
        <exception cref="T:System.IO.IOException">Le disque est en lecture seule.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberSignature Language="F#" Value="member this.Decrypt : unit -&gt; unit" Usage="fileInfo.Decrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déchiffre un fichier qui a été chiffré par le compte actuel à l'aide de la méthode <see cref="M:System.IO.FileInfo.Encrypt" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileInfo.Decrypt%2A> méthode vous permet de déchiffrer un fichier qui a été chiffré à l’aide de la <xref:System.IO.FileInfo.Encrypt%2A> (méthode).  Le <xref:System.IO.FileInfo.Decrypt%2A> méthode peut déchiffrer que les fichiers qui ont été chiffrées à l’aide de compte d’utilisateur actuel.  
  
 Les deux le <xref:System.IO.FileInfo.Encrypt%2A> (méthode) et le <xref:System.IO.FileInfo.Decrypt%2A> méthode utilise le fournisseur de services de chiffrement (CSP) installé sur l’ordinateur et les clés de chiffrement de fichier du processus appelant la méthode.  
  
 Le système de fichiers doit être converti au format NTFS et le système d’exploitation actuel doivent être Microsoft Windows NT ou version ultérieure.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.FileInfo.Encrypt%2A> (méthode) et le <xref:System.IO.FileInfo.Decrypt%2A> (méthode) pour chiffrer et puis déchiffrer un fichier.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Un lecteur non valide a été spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.NotSupportedException">Le système de fichiers n’est pas un système NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Microsoft Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est accessible en lecture seule.  
  
- ou - 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
- ou - 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
Action de sécurité : la demande.  
  
Autorisation de lire et écrire dans le fichier décrit par l’actuel <see cref="T:System.IO.FileInfo" /> objet.</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="fileInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime définitivement un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier n’existe pas, cette méthode ne fait rien.  
  
   
  
## Examples  
 L’exemple suivant montre le `Delete` (méthode).  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 L’exemple suivant crée, ferme et supprime un fichier.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le fichier cible est ouvert ou mappé en mémoire sur un ordinateur exécutant Microsoft Windows NT.  
  
- ou - 
Un handle est ouvert sur le fichier, et le système d’exploitation est Windows XP ou une version antérieure. Ce handle ouvert peut être le résultat d’une énumération de répertoires et de fichiers. Pour plus d’informations, consultez [Comment : énumérer des répertoires et fichiers](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le chemin est un répertoire.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Directory : System.IO.DirectoryInfo" Usage="System.IO.FileInfo.Directory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une instance du répertoire parent.</summary>
        <value>Objet <see cref="T:System.IO.DirectoryInfo" /> représentant le répertoire parent de ce fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir le répertoire parent sous forme de chaîne, utilisez la <xref:System.IO.FileInfo.DirectoryName%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant ouvre ou crée un fichier, détermine son chemin d’accès complet et détermine et affiche le contenu complet du répertoire.  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryName : string" Usage="System.IO.FileInfo.DirectoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une chaîne représentant le chemin d’accès complet du répertoire.</summary>
        <value>Chaîne représentant le chemin d’accès complet du répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir le répertoire parent comme une <xref:System.IO.DirectoryInfo> de l’objet, utilisez le <xref:System.IO.FileInfo.Directory%2A> propriété.  
  
 Lors du premier appel, <xref:System.IO.FileInfo> appels <xref:System.IO.FileSystemInfo.Refresh%2A> et met en cache des informations sur le fichier. Lors des appels ultérieurs, vous devez appeler <xref:System.IO.FileSystemInfo.Refresh%2A> pour obtenir la dernière copie des informations.  
  
   
  
## Examples  
 L’exemple suivant récupère le chemin d’accès complet du fichier spécifié.  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="null" /> a été transmis pour le nom du répertoire.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom du chemin complet dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberSignature Language="F#" Value="member this.Encrypt : unit -&gt; unit" Usage="fileInfo.Encrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiffre un fichier de sorte que seul le compte utilisé pour chiffrer le fichier peut le déchiffrer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileInfo.Encrypt%2A> méthode vous permet de chiffrer un fichier afin que seul le compte utilisé pour appeler cette méthode puisse le déchiffrer.  Utilisez le <xref:System.IO.FileInfo.Decrypt%2A> méthode pour déchiffrer un fichier chiffré par le <xref:System.IO.FileInfo.Encrypt%2A> (méthode).  
  
 Les deux le <xref:System.IO.FileInfo.Encrypt%2A> (méthode) et le <xref:System.IO.FileInfo.Decrypt%2A> méthode utilise le fournisseur de services de chiffrement (CSP) installé sur l’ordinateur et les clés de chiffrement de fichier du processus appelant la méthode.  
  
 Le système de fichiers doit être converti au format NTFS et le système d’exploitation actuel doivent être Microsoft Windows NT ou version ultérieure.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.FileInfo.Encrypt%2A> (méthode) et le <xref:System.IO.FileInfo.Decrypt%2A> (méthode) pour chiffrer un fichier puis de le déchiffrer.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Un lecteur non valide a été spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.NotSupportedException">Le système de fichiers n’est pas un système NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Microsoft Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est accessible en lecture seule.  
  
- ou - 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
- ou - 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
Action de sécurité : la demande.  
  
Autorisation de lire et écrire dans le fichier décrit par l’actuel <see cref="T:System.IO.FileInfo" /> objet.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.FileInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si un fichier existe.</summary>
        <value>
          <see langword="true" /> si le fichier existe ; <see langword="false" /> si le fichier n'existe pas ou si le fichier est un répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du premier appel, <xref:System.IO.FileInfo> appels <xref:System.IO.FileSystemInfo.Refresh%2A> et met en cache des informations sur le fichier. Lors des appels ultérieurs, vous devez appeler <xref:System.IO.FileSystemInfo.Refresh%2A> pour obtenir la dernière copie des informations.  
  
 Le <xref:System.IO.FileInfo.Exists%2A> retourne de la propriété `false` si une erreur se produit lors de la tentative déterminer si le fichier spécifié existe. Cela peut se produire dans les situations qui déclenchent des exceptions telles que la transmission d’un nom de fichier avec des caractères non valides ou trop de caractères, un disque défectueux ou manquant, ou si l’appelant n’a pas l’autorisation de lire le fichier.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.FileInfo.Exists%2A> propriété garantir un fichier existe avant de l’ouvrir.  Vous pouvez utiliser cette technique pour lever une exception personnalisée lorsque le fichier est introuvable.  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les entrées de la liste de contrôle d'accès (ACL) pour le fichier décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.GetAccessControl%2A> méthodes pour récupérer l’accès à contrôlent les entrées de liste (ACL) pour le fichier actuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les entrées de la liste de contrôle d'accès (ACL) pour le fichier décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les règles de contrôle d'accès pour le fichier actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour le fichier actuel.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.FileInfo.GetAccessControl%2A> (méthode) et le <xref:System.IO.FileInfo.SetAccessControl%2A> méthode pour ajouter et supprimer ensuite une entrée de contrôle d’accès (ACL) de liste à partir d’un fichier.  Vous devez entrer un compte d'utilisateur ou de groupe valide pour exécuter cet exemple.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">Le compte système actuel ne dispose pas de privilèges d’administrateur.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
- ou - 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Action de sécurité : la demande.  
  
Pour l’autorisation de lire la liste de contrôle d’accès.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Une des valeurs de <see cref="T:System.Security.AccessControl.AccessControlSections" /> qui spécifie quel groupe d'entrées de contrôle d'accès récupérer.</param>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule le type spécifié des entrées de la liste de contrôle d'accès (ACL) pour le répertoire décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les règles de contrôle d'accès pour le fichier actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour le fichier actuel.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">Le compte système actuel ne dispose pas de privilèges d’administrateur.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
- ou - 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Action de sécurité : la demande.  
  
Pour l’autorisation de lire la liste de contrôle d’accès.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.IO.FileInfo.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine si le fichier actuel est en lecture seule.</summary>
        <value>
          <see langword="true" /> si le fichier actuel est en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.IsReadOnly%2A> propriété pour déterminer rapidement et de choisir si le fichier actuel est en lecture seule.  
  
 Lors du premier appel, <xref:System.IO.FileInfo> appels <xref:System.IO.FileSystemInfo.Refresh%2A> et met en cache des informations sur le fichier. Lors des appels ultérieurs, vous devez appeler <xref:System.IO.FileSystemInfo.Refresh%2A> pour obtenir la dernière copie des informations.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.FileInfo.IsReadOnly%2A> propriété pour marquer un fichier en lecture seule, puis le marquer comme étant en lecture-écriture.  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
- ou - 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException">L’utilisateur ne dispose pas d’autorisation d’écriture, mais il a essayé de définir cette propriété sur <see langword="false" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" />  
  
Action de sécurité : la demande.  
  
Autorisation de lire et écrire dans le fichier décrit par l’actuel <see cref="T:System.IO.FileInfo" /> objet.</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileInfo.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille en octets du fichier actuel.</summary>
        <value>Taille du fichier actuel en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.IO.FileInfo.Length%2A> propriété est préalablement mis en cache si l’instance actuelle de la <xref:System.IO.FileInfo> objet a été retourné par une des opérations suivantes <xref:System.IO.DirectoryInfo> méthodes :  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 Pour obtenir la valeur la plus récente, appelez le <xref:System.IO.FileSystemInfo.Refresh%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche la taille des fichiers spécifiés.  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <see cref="M:System.IO.FileSystemInfo.Refresh" /> ne peut pas mettre à jour l’état du fichier ou du répertoire.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.  
  
- ou - 
La propriété <see langword="Length" /> est appelée pour un répertoire.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="fileInfo.MoveTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">Chemin d’accès de destination du fichier, qui peut spécifier un autre nom de fichier.</param>
        <summary>Déplace un fichier spécifié à un nouvel emplacement, en permettant de spécifier un nouveau nom.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur plusieurs volumes de disque. Par exemple, le fichier c:\MyFile.txt peut être déplacé vers d:\public et renommé NouveauFichier.txt.  
  
   
  
## Examples  
 L’exemple suivant illustre le déplacement d’un fichier vers un autre emplacement et renommer le fichier.  
  
 [!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
 [!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit (par exemple, le fichier de destination existe déjà ou l’appareil de destination n’est pas prêt).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="destFileName" /> est en lecture seule ou est un répertoire.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> contient un signe deux-points (:) au milieu de la chaîne.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom du fichier.</summary>
        <value>Nom du fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du premier appel, <xref:System.IO.FileInfo> appels <xref:System.IO.FileSystemInfo.Refresh%2A> et met en cache des informations sur le fichier. Lors des appels ultérieurs, vous devez appeler <xref:System.IO.FileSystemInfo.Refresh%2A> pour obtenir la dernière copie des informations.  
  
 Le nom du fichier inclut l’extension de fichier.  
  
   
  
## Examples  
 L’exemple suivant utilise le `Name` propriété à afficher les noms des fichiers dans le répertoire actif.  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un fichier avec différents privilèges de lecture/écriture et de partage.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode -&gt; System.IO.FileStream" Usage="fileInfo.Open mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Constante <see cref="T:System.IO.FileMode" /> spécifiant le mode (par exemple <see langword="Open" /> ou <see langword="Append" />) dans lequel ouvrir le fichier.</param>
        <summary>Ouvre un fichier dans le mode spécifié.</summary>
        <returns>Fichier ouvert dans le mode spécifié, avec accès en lecture/écriture et non partagé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant ouvre un fichier, ajoute des informations au fichier et lit le fichier.  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le fichier est en lecture seule ou est un répertoire.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est déjà ouvert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’écriture et lecture de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Constante <see cref="T:System.IO.FileMode" /> spécifiant le mode (par exemple <see langword="Open" /> ou <see langword="Append" />) dans lequel ouvrir le fichier.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> spécifiant si le fichier doit être ouvert avec l'accès <see langword="Read" />, <see langword="Write" /> ou <see langword="ReadWrite" />.</param>
        <summary>Ouvre un fichier dans le mode spécifié, avec accès en lecture, en écriture ou en lecture/écriture.</summary>
        <returns>Objet <see cref="T:System.IO.FileStream" /> ouvert dans le mode et l'accès spécifiés, et non partagé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant ouvre un fichier en lecture seule et lit à partir du fichier.  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> est en lecture seule ou est un répertoire.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est déjà ouvert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’écriture et lecture de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">Constante <see cref="T:System.IO.FileMode" /> spécifiant le mode (par exemple <see langword="Open" /> ou <see langword="Append" />) dans lequel ouvrir le fichier.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> spécifiant si le fichier doit être ouvert avec l'accès <see langword="Read" />, <see langword="Write" /> ou <see langword="ReadWrite" />.</param>
        <param name="share">Constante <see cref="T:System.IO.FileShare" /> spécifiant le type d'accès qu'ont d'autres objets <see langword="FileStream" /> à ce fichier.</param>
        <summary>Ouvre un fichier dans le mode spécifié, avec accès en lecture, en écriture ou en lecture/écriture, et l'option de partage spécifiée.</summary>
        <returns>Objet <see cref="T:System.IO.FileStream" /> ouvert avec le mode, l'accès et les options de partage spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre l’ouverture d’un fichier pour lecture et écriture, mais interdit l’accès à d’autres utilisateurs ou d’un processus.  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> est en lecture seule ou est un répertoire.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est déjà ouvert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’écriture et lecture de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberSignature Language="F#" Value="member this.OpenRead : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément <see cref="T:System.IO.FileStream" /> en lecture seule.</summary>
        <returns>Nouvel objet <see cref="T:System.IO.FileStream" /> en lecture seule.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est retournée en lecture seule <xref:System.IO.FileStream> de l’objet avec le <xref:System.IO.FileShare> mode la valeur <xref:System.IO.FileShare.Read>.  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier en lecture seule et lit à partir de celui-ci.  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> est en lecture seule ou est un répertoire.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est déjà ouvert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberSignature Language="F#" Value="member this.OpenText : unit -&gt; System.IO.StreamReader" Usage="fileInfo.OpenText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément <see cref="T:System.IO.StreamReader" /> avec encodage UTF-8 qui lit un fichier texte existant.</summary>
        <returns>Nouvel élément <see langword="StreamReader" /> avec encodage UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant lit du texte dans un fichier.  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> est en lecture seule ou est un répertoire.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberSignature Language="F#" Value="member this.OpenWrite : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenWrite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un élément <see cref="T:System.IO.FileStream" /> en écriture seule.</summary>
        <returns>Objet <see cref="T:System.IO.FileStream" /> en écriture seule non partagé pour un fichier nouveau ou existant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileInfo.OpenWrite%2A> méthode ouvre un fichier si une existe déjà pour le chemin d’accès de fichier ou crée un nouveau fichier s’il n’existe pas. Pour un fichier existant, il n’ajoute pas le nouveau texte au texte existant. Au lieu de cela, il remplace les caractères existants par les nouveaux caractères. Si vous remplacez une chaîne plus longue (tel que « Il s’agit d’un test de la méthode OpenWrite ») avec une chaîne plus courte (comme « deuxième exécuter »), le fichier contiendra une combinaison de chaînes (« deuxième passage de la méthode OpenWrite »).  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier en écriture et puis lit à partir du fichier.  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le chemin spécifié pendant la création d’une instance de l’objet <see cref="T:System.IO.FileInfo" /> est en lecture seule ou correspond à un répertoire.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié pendant la création d’une instance de l’objet <see cref="T:System.IO.FileInfo" /> n’est pas valide . il est, par exemple, sur un lecteur non mappé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplace le contenu d'un fichier spécifié par le fichier décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel, en supprimant le fichier d'origine et en créant une sauvegarde du fichier remplacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.Replace%2A> méthodes lorsque vous avez besoin de remplacer rapidement un fichier avec le contenu du fichier décrit par l’actuel <xref:System.IO.FileInfo> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Nom d'un fichier à remplacer par le fichier actuel.</param>
        <param name="destinationBackupFileName">Nom d'un fichier avec lequel créer une sauvegarde du fichier décrit par le paramètre <paramref name="destFileName" />.</param>
        <summary>Remplace le contenu d'un fichier spécifié par le fichier décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel, en supprimant le fichier d'origine et en créant une sauvegarde du fichier remplacé.</summary>
        <returns>Objet <see cref="T:System.IO.FileInfo" /> qui encapsule des informations à propos du fichier décrit par le paramètre <paramref name="destFileName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileInfo.Replace%2A> méthode remplace le contenu d’un fichier spécifié par le contenu du fichier décrit par l’actuel <xref:System.IO.FileInfo> objet.  Il crée également une sauvegarde du fichier qui a été remplacé.  Enfin, il retourne un nouvel <xref:System.IO.FileInfo> objet qui décrit le fichier remplacé.  
  
> [!CAUTION]
>  Cette méthode réussit dans les environnements Windows 2000 si le `destFileName` est en lecture seule et ne lève pas d’exception. Utilisez le <xref:System.IO.FileInfo.IsReadOnly%2A> propriété pour vérifier si le fichier de destination est en lecture seule avant de tenter de le remplacer.  
  
 Passer `null` à la `destBackupFileName` paramètre si vous ne souhaitez pas créer une sauvegarde du fichier remplacé.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.File.Replace%2A> méthode pour remplacer un fichier par un autre fichier et créer une sauvegarde du fichier remplacé.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin décrit par le <paramref name="destFileName" /> paramètre n’avait pas une forme conforme.  
  
- ou - 
Le chemin décrit par le paramètre <paramref name="destBackupFileName" /> n’avait pas une forme conforme.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="destFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.  
  
- ou - 
Le fichier décrit par le paramètre <paramref name="destinationFileName" /> est introuvable.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Microsoft Windows NT ou version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
Action de sécurité : la demande.  
  
Pour l’autorisation en écriture au fichier décrit par le <paramref name="destBackupFileName" /> paramètre le cas échéant.</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Nom d'un fichier à remplacer par le fichier actuel.</param>
        <param name="destinationBackupFileName">Nom d'un fichier avec lequel créer une sauvegarde du fichier décrit par le paramètre <paramref name="destFileName" />.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> pour ignorer les erreurs de fusion (comme les attributs et les listes ACL) du fichier remplacé au fichier de remplacement ; sinon, <see langword="false" />.</param>
        <summary>Remplace le contenu d'un fichier spécifié par le fichier décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel, en supprimant le fichier d'origine et en créant une sauvegarde du fichier remplacé.  Spécifie également s’il faut ignorer les erreurs de fusion.</summary>
        <returns>Objet <see cref="T:System.IO.FileInfo" /> qui encapsule des informations à propos du fichier décrit par le paramètre <paramref name="destFileName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileInfo.Replace%2A> méthode remplace le contenu d’un fichier spécifié par le contenu du fichier décrit par l’actuel <xref:System.IO.FileInfo> objet.  Il crée également une sauvegarde du fichier qui a été remplacé.  Enfin, il retourne un nouvel <xref:System.IO.FileInfo> objet qui décrit le fichier remplacé.  
  
> [!CAUTION]
>  Cette méthode réussit dans les environnements Windows 2000 si le `destFileName` est en lecture seule et ne lève pas d’exception. Utilisez le <xref:System.IO.FileInfo.IsReadOnly%2A> propriété pour vérifier si le fichier de destination est en lecture seule avant de tenter de le remplacer.  
  
 Passer `null` à la `destBackupFileName` paramètre si vous ne souhaitez pas créer une sauvegarde du fichier remplacé.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.File.Replace%2A> méthode pour remplacer un fichier par un autre fichier et créer une sauvegarde du fichier remplacé.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin décrit par le <paramref name="destFileName" /> paramètre n’avait pas une forme conforme.  
  
- ou - 
Le chemin décrit par le paramètre <paramref name="destBackupFileName" /> n’avait pas une forme conforme.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="destFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.  
  
- ou - 
Le fichier décrit par le paramètre <paramref name="destinationFileName" /> est introuvable.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Microsoft Windows NT ou version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />  
  
Action de sécurité : la demande.  
  
Pour l’autorisation en écriture au fichier décrit par le <paramref name="destBackupFileName" /> paramètre le cas échéant.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileInfo.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui décrit une entrée de liste de contrôle d'accès (ACL) à appliquer au fichier actuel.</param>
        <summary>Applique les entrées ACL décrites par un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> au fichier décrit par l'objet <see cref="T:System.IO.FileInfo" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileInfo.SetAccessControl%2A> méthode applique les entrées de contrôle d’accès (ACL) de liste au fichier actuel qui représente la liste ACL non héritée.  
  
 Utilisez le <xref:System.IO.FileInfo.SetAccessControl%2A> méthode chaque fois que vous avez besoin ajouter ou supprimer des entrées ACL à partir d’un fichier.  
  
> [!CAUTION]
>  La liste ACL spécifiée pour le `fileSecurity` paramètre remplace la liste ACL existante pour le fichier. Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <xref:System.IO.Directory.GetAccessControl%2A> méthode pour obtenir la liste ACL existante, modifiez-la et ensuite utiliser <xref:System.IO.FileInfo.SetAccessControl%2A> pour l’appliquer au fichier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Le <xref:System.IO.FileInfo.SetAccessControl%2A> méthode persiste uniquement <xref:System.Security.AccessControl.FileSecurity> les objets qui ont été modifiées après la création d’objets.  Si un <xref:System.Security.AccessControl.FileSecurity> objet n’a pas été modifié, il ne sera pas conservé dans un fichier.  Par conséquent, il n’est pas possible de récupérer un <xref:System.Security.AccessControl.FileSecurity> de l’objet à partir d’un fichier et de réappliquer le même objet à un autre fichier.  
  
 Pour copier les informations ACL à partir d’un fichier vers un autre :  
  
1.  Utilisez le <xref:System.IO.FileInfo.GetAccessControl%2A> méthode pour récupérer le <xref:System.Security.AccessControl.FileSecurity> objet à partir du fichier source.  
  
2.  Créer un nouveau <xref:System.Security.AccessControl.FileSecurity> objet pour le fichier de destination.  
  
3.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode de la source <xref:System.Security.AccessControl.FileSecurity> objet pour récupérer les informations ACL.  
  
4.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> méthode pour copier les informations récupérées à l’étape 3 vers la destination <xref:System.Security.AccessControl.FileSecurity> objet.  
  
5.  Définir la destination <xref:System.Security.AccessControl.FileSecurity> objet pour le fichier de destination à l’aide de la <xref:System.IO.FileInfo.SetAccessControl%2A> (méthode).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.FileInfo.GetAccessControl%2A> (méthode) et le <xref:System.IO.FileInfo.SetAccessControl%2A> méthode pour ajouter et supprimer ensuite une entrée ACL à partir d’un fichier.  Vous devez entrer un compte d'utilisateur ou de groupe valide pour exécuter cet exemple.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="fileSecurity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable ou n’a pas pu être modifié.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le processus en cours n’a pas l’accès requis pour ouvrir le fichier.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d'exploitation actuel n'est pas Microsoft Windows 2000 ou ultérieur.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" />  
  
Action de sécurité : la demande 
pour l’autorisation d’accès au fichier.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="fileInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le chemin d’accès sous forme de chaîne.</summary>
        <returns>Chaîne représentant le chemin d’accès.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne retournée par la <xref:System.IO.FileInfo.ToString%2A> méthode représente le chemin d’accès qui a été passé au constructeur.  Lorsque vous créez un <xref:System.IO.FileInfo> objet à l’aide des constructeurs, le <xref:System.IO.FileInfo.ToString%2A> méthode retourne le chemin d’accès qualifié complet.  Toutefois, il existe des cas où la chaîne retournée par la <xref:System.IO.FileInfo.ToString%2A> méthode ne représente pas le chemin d’accès qualifié complet.  Par exemple, lorsque vous créez un <xref:System.IO.FileInfo> à l’aide de l’objet le <xref:System.IO.DirectoryInfo.GetFiles%2A> (méthode), le <xref:System.IO.FileInfo.ToString%2A> méthode ne représente pas le chemin d’accès qualifié complet.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
  </Members>
</Type>