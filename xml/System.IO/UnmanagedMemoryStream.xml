<Type Name="UnmanagedMemoryStream" FullName="System.IO.UnmanagedMemoryStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa47d0b12150002326e3d2e834f22ed3c19485d6" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52597782" /></Metadata><TypeSignature Language="C#" Value="public class UnmanagedMemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UnmanagedMemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.UnmanagedMemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class UnmanagedMemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnmanagedMemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type UnmanagedMemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.CLSCompliant(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="343e7-101">Fournit l'accès aux blocs non managés de la mémoire à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-101">Provides access to unmanaged blocks of memory from managed code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-102">Cette classe prend en charge les accès mémoire non managée en utilisant le modèle de flux de données existant et ne nécessite pas que le contenu dans la mémoire non managée être copié dans le tas.</span><span class="sxs-lookup"><span data-stu-id="343e7-102">This class supports access to unmanaged memory using the existing stream-based model and does not require that the contents in the unmanaged memory be copied to the heap.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
## Examples  
 <span data-ttu-id="343e7-103">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-103">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="343e7-104">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-104">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="343e7-105">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-105">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnmanagedMemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UnmanagedMemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="343e7-106">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-106">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="343e7-107">L’utilisateur ne dispose pas de l’autorisation nécessaire.</span><span class="sxs-lookup"><span data-stu-id="343e7-107">The user does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="343e7-108">pour l’accès à la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-108">for accessing unmanaged memory.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : nativeptr&lt;byte&gt; * int64 -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="343e7-109">Pointeur vers un emplacement de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-109">A pointer to an unmanaged memory location.</span></span></param>
        <param name="length"><span data-ttu-id="343e7-110">Longueur de la mémoire à utiliser.</span><span class="sxs-lookup"><span data-stu-id="343e7-110">The length of the memory to use.</span></span></param>
        <summary><span data-ttu-id="343e7-111">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> à l'aide de l'emplacement et de la taille de la mémoire spécifiés.</span><span class="sxs-lookup"><span data-stu-id="343e7-111">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location and memory length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-112">Ce constructeur crée une nouvelle instance de la <xref:System.IO.UnmanagedMemoryStream> classe et par défaut définit les <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriété `false` et le <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> propriété `true`.</span><span class="sxs-lookup"><span data-stu-id="343e7-112">This constructor creates a new instance of the <xref:System.IO.UnmanagedMemoryStream> class, and by default sets the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property to `false` and the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property to `true`.</span></span> <span data-ttu-id="343e7-113">Le <xref:System.IO.UnmanagedMemoryStream.Length%2A> propriété est définie sur la valeur de la `length` paramètre et ne peut pas être modifié.</span><span class="sxs-lookup"><span data-stu-id="343e7-113">The <xref:System.IO.UnmanagedMemoryStream.Length%2A> property is set to the value of the `length` parameter and cannot be changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-114">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-114">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="343e7-115">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-115">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="343e7-116">L’utilisateur ne dispose pas de l’autorisation nécessaire.</span><span class="sxs-lookup"><span data-stu-id="343e7-116">The user does not have the required permission.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="343e7-117"><paramref name="pointer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-117">The <paramref name="pointer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-118">La valeur <paramref name="length" /> est inférieure à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-118">The <paramref name="length" /> value is less than zero.</span></span>  
  
<span data-ttu-id="343e7-119">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-119">\- or -</span></span> 
<span data-ttu-id="343e7-120">La longueur (<paramref name="length" />) est suffisamment grande pour provoquer un dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="343e7-120">The <paramref name="length" /> is large enough to cause an overflow.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="343e7-121">pour l’accès à la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-121">for accessing unmanaged memory.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="343e7-122">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="343e7-122">requires full trust for the immediate caller.</span></span> <span data-ttu-id="343e7-123">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="343e7-123">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : System.Runtime.InteropServices.SafeBuffer * int64 * int64 -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (buffer, offset, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-124">Mémoire tampon devant contenir le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-124">The buffer to contain the unmanaged memory stream.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-125">Position d'octet dans la mémoire tampon à partir de laquelle commencer le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-125">The byte position in the buffer at which to start the unmanaged memory stream.</span></span></param>
        <param name="length"><span data-ttu-id="343e7-126">Longueur du flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-126">The length of the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="343e7-127">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> dans une mémoire tampon sécurisée avec un décalage et une longueur spécifiés.</span><span class="sxs-lookup"><span data-stu-id="343e7-127">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset and length.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : nativeptr&lt;byte&gt; * int64 * int64 * System.IO.FileAccess -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (pointer, length, capacity, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="343e7-128">Pointeur vers un emplacement de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-128">A pointer to an unmanaged memory location.</span></span></param>
        <param name="length"><span data-ttu-id="343e7-129">Longueur de la mémoire à utiliser.</span><span class="sxs-lookup"><span data-stu-id="343e7-129">The length of the memory to use.</span></span></param>
        <param name="capacity"><span data-ttu-id="343e7-130">Quantité totale de mémoire assignée au flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-130">The total amount of memory assigned to the stream.</span></span></param>
        <param name="access"><span data-ttu-id="343e7-131">Une des valeurs de <see cref="T:System.IO.FileAccess" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-131">One of the <see cref="T:System.IO.FileAccess" /> values.</span></span></param>
        <summary><span data-ttu-id="343e7-132">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> à l'aide des valeurs spécifiées pour l'emplacement, la taille et la quantité totale de la mémoire, ainsi que l'accès au fichier.</span><span class="sxs-lookup"><span data-stu-id="343e7-132">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location, memory length, total amount of memory, and file access values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-133">Le `length` paramètre définit la quantité de mémoire actuellement en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="343e7-133">The `length` parameter defines the current amount of memory in use.</span></span> <span data-ttu-id="343e7-134">Si la lecture ou l’ajout de données dans le flux, le `length` valeur doit être égale à la quantité de données valides dans le flux à lire à partir d’ou conservé.</span><span class="sxs-lookup"><span data-stu-id="343e7-134">If reading or appending data to the stream, the `length` value should be equal to the amount of valid data in the stream to be read from or preserved.</span></span> <span data-ttu-id="343e7-135">Si l’écriture dans le flux de données, cette valeur doit être égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-135">If writing to the stream, this value should be zero.</span></span>  
  
 <span data-ttu-id="343e7-136">Le `capacity` paramètre indique la quantité de mémoire totale disponible.</span><span class="sxs-lookup"><span data-stu-id="343e7-136">The `capacity` parameter indicates the amount of total memory available.</span></span> <span data-ttu-id="343e7-137">Cette valeur peut décrire une région qui est supérieure à la longueur spécifiée, ou indiquer une région qui peut être ajoutée aux.</span><span class="sxs-lookup"><span data-stu-id="343e7-137">This value can describe a region that is longer than the length specified, or indicate a region that can be appended to.</span></span> <span data-ttu-id="343e7-138">Toute tentative d’écriture au-delà de cette valeur échouera.</span><span class="sxs-lookup"><span data-stu-id="343e7-138">Any attempt to write beyond this value will fail.</span></span>  
  
 <span data-ttu-id="343e7-139">Le `access` jeux de paramètres le <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, et <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="343e7-139">The `access` parameter sets the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, and <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> properties.</span></span> <span data-ttu-id="343e7-140">Notez que la spécification <xref:System.IO.FileAccess.Write> ne garantit pas que le flux soit accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="343e7-140">Note that specifying <xref:System.IO.FileAccess.Write> does not guarantee that the stream will be writable.</span></span> <span data-ttu-id="343e7-141">Les paramètres d’accès permettent à l’implémenteur créer un objet dont l’implémentation peut faire correspondre le flux réel qui est exposé.</span><span class="sxs-lookup"><span data-stu-id="343e7-141">The access parameters allow the implementer to create an object whose implementation can match the actual stream that is exposed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-142">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-142">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="343e7-143">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-143">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="343e7-144">L’utilisateur ne dispose pas de l’autorisation nécessaire.</span><span class="sxs-lookup"><span data-stu-id="343e7-144">The user does not have the required permission.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="343e7-145"><paramref name="pointer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-145">The <paramref name="pointer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-146">La valeur <paramref name="length" /> est inférieure à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-146">The <paramref name="length" /> value is less than zero.</span></span>  
  
<span data-ttu-id="343e7-147">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-147">\- or -</span></span> 
<span data-ttu-id="343e7-148">La valeur <paramref name="capacity" /> est inférieure à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-148">The <paramref name="capacity" /> value is less than zero.</span></span>  
  
<span data-ttu-id="343e7-149">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-149">\- or -</span></span> 
<span data-ttu-id="343e7-150">La valeur <paramref name="length" /> est supérieure à la valeur <paramref name="capacity" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-150">The <paramref name="length" /> value is greater than the <paramref name="capacity" /> value.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="343e7-151">pour l’accès à la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-151">for accessing unmanaged memory.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="343e7-152">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="343e7-152">requires full trust for the immediate caller.</span></span> <span data-ttu-id="343e7-153">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="343e7-153">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : System.Runtime.InteropServices.SafeBuffer * int64 * int64 * System.IO.FileAccess -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (buffer, offset, length, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-154">Mémoire tampon devant contenir le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-154">The buffer to contain the unmanaged memory stream.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-155">Position d'octet dans la mémoire tampon à partir de laquelle commencer le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-155">The byte position in the buffer at which to start the unmanaged memory stream.</span></span></param>
        <param name="length"><span data-ttu-id="343e7-156">Longueur du flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-156">The length of the unmanaged memory stream.</span></span></param>
        <param name="access"><span data-ttu-id="343e7-157">Mode d'accès au fichier sur le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-157">The mode of file access to the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="343e7-158">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> dans une mémoire tampon sécurisée avec un décalage, une longueur et l'accès au fichier spécifiés.</span><span class="sxs-lookup"><span data-stu-id="343e7-158">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-159">Obtient une valeur indiquant si un flux prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="343e7-159">Gets a value indicating whether a stream supports reading.</span></span></summary>
        <value><span data-ttu-id="343e7-160"><see langword="false" /> si l'objet a été créé par un constructeur avec un paramètre <paramref name="access" /> qui n'inclut pas la lecture du flux, et si le flux est fermé ; sinon, <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-160"><see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter that did not include reading the stream and if the stream is closed; otherwise, <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-161">Cette propriété indique si l’objet de flux actuel prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="343e7-161">This property indicates whether the current stream object supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-162">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-162">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="343e7-163">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-163">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="343e7-164">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie le <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> propriété avant de tenter d’afficher le contenu dans la console.</span><span class="sxs-lookup"><span data-stu-id="343e7-164">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-165">Obtient une valeur indiquant si un flux prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="343e7-165">Gets a value indicating whether a stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="343e7-166"><see langword="false" /> si le flux est fermé ; sinon, <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-166"><see langword="false" /> if the stream is closed; otherwise, <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-167">Cette propriété indique si l’objet de flux actuel prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="343e7-167">This property indicates whether the current stream object supports seeking.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-168">Obtient une valeur indiquant si un flux prend en charge l'écriture.</span><span class="sxs-lookup"><span data-stu-id="343e7-168">Gets a value indicating whether a stream supports writing.</span></span></summary>
        <value><span data-ttu-id="343e7-169"><see langword="false" /> si l'objet a été créé par un constructeur avec une valeur de paramètre <paramref name="access" /> prenant en charge l'écriture, s'il a été créé par un constructeur sans paramètres ou si le flux est fermé ; sinon, <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-169"><see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter value that supports writing or was created by a constructor that had no parameters, or if the stream is closed; otherwise, <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-170">Cette propriété indique si l’objet de flux actuel prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="343e7-170">This property indicates whether the current stream object supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-171">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-171">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="343e7-172">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-172">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="343e7-173">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie le <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriété avant de tenter d’écrire les données dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-173">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public long Capacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Capacity As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Capacity { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int64" Usage="System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-174">Obtient la longueur de flux (taille) ou la quantité totale de mémoire assignée au flux (capacité).</span><span class="sxs-lookup"><span data-stu-id="343e7-174">Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</span></span></summary>
        <value><span data-ttu-id="343e7-175">Taille ou capacité du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-175">The size or capacity of the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-176">Cette propriété retourne le `capacity` valeur fournie au constructeur.</span><span class="sxs-lookup"><span data-stu-id="343e7-176">This property returns the `capacity` value provided to the constructor.</span></span> <span data-ttu-id="343e7-177">Si aucun `capacity` valeur a été spécifiée quand le flux a été initialisé, cette propriété retourne la longueur du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-177">If no `capacity` value was specified when the stream was initialized, this property returns the stream length.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-178">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-178">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="unmanagedMemoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="343e7-179"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="343e7-179"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="343e7-180">Libère les ressources non managées utilisées par <see cref="T:System.IO.UnmanagedMemoryStream" /> et libère éventuellement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="343e7-180">Releases the unmanaged resources used by the <see cref="T:System.IO.UnmanagedMemoryStream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-181">Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="343e7-181">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="343e7-182"><xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> méthode avec le `disposing` paramètre défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="343e7-182"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="343e7-183"><xref:System.Object.Finalize%2A> appelle <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> avec `disposing` défini sur `false`.</span><span class="sxs-lookup"><span data-stu-id="343e7-183"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="343e7-184">Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.UnmanagedMemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="343e7-184">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.UnmanagedMemoryStream> references.</span></span> <span data-ttu-id="343e7-185">Cette méthode appelle la méthode <xref:System.ComponentModel.Component.Dispose%2A> de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="343e7-185">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="343e7-186">
            <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d'autres objets.</span><span class="sxs-lookup"><span data-stu-id="343e7-186">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="343e7-187">Lors de la substitution <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-187">When overriding <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="343e7-188">Pour plus d’informations sur l’implémentation <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="343e7-188">For more information about how to implement <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="343e7-189">Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="343e7-189">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="unmanagedMemoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="343e7-190">Remplace la méthode <see cref="M:System.IO.Stream.Flush" /> afin qu'aucune action ne soit effectuée.</span><span class="sxs-lookup"><span data-stu-id="343e7-190">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-191">Cette méthode n’effectue aucune action pour cette classe, mais est incluse dans le cadre de la <xref:System.IO.Stream> classe de base.</span><span class="sxs-lookup"><span data-stu-id="343e7-191">This method performs no action for this class but is included as part of the <xref:System.IO.Stream> base class.</span></span> <span data-ttu-id="343e7-192">Dans la mesure où les données sont écrites en mémoire vive, cette méthode est redondante.</span><span class="sxs-lookup"><span data-stu-id="343e7-192">Since any data is written to RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-193">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-193">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="unmanagedMemoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="343e7-194">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="343e7-194">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="343e7-195">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-195">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="343e7-196">Substitue la méthode <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /> pour que l'opération soit annulée si spécifié, mais sans qu'aucune autre action ne soit effectuée.</span><span class="sxs-lookup"><span data-stu-id="343e7-196">Overrides the <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /> method so that the operation is cancelled if specified, but no other action is performed.</span></span>  
  
<span data-ttu-id="343e7-197">Disponible à partir de .NET Framework 4.6</span><span class="sxs-lookup"><span data-stu-id="343e7-197">Available starting in .NET Framework 4.6</span></span></summary>
        <returns><span data-ttu-id="343e7-198">Tâche qui représente l’opération de vidage asynchrone.</span><span class="sxs-lookup"><span data-stu-id="343e7-198">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-199">Si l’opération n’est pas annulée, la <xref:System.IO.UnmanagedMemoryStream> appelle le <xref:System.IO.UnmanagedMemoryStream.Flush%2A> (méthode), ce qui signifie qu’aucune action n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="343e7-199">If the operation isn't cancelled, the <xref:System.IO.UnmanagedMemoryStream> calls the <xref:System.IO.UnmanagedMemoryStream.Flush%2A> method, which means that no action performed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="343e7-200">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> dans une mémoire tampon sécurisée, ou en utilisant un pointeur vers un emplacement de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-200">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer, or by using a pointer to an unmanaged memory location.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Initialize : nativeptr&lt;byte&gt; * int64 * int64 * System.IO.FileAccess -&gt; unit" Usage="unmanagedMemoryStream.Initialize (pointer, length, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="343e7-201">Pointeur vers un emplacement de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-201">A pointer to an unmanaged memory location.</span></span></param>
        <param name="length"><span data-ttu-id="343e7-202">Longueur de la mémoire à utiliser.</span><span class="sxs-lookup"><span data-stu-id="343e7-202">The length of the memory to use.</span></span></param>
        <param name="capacity"><span data-ttu-id="343e7-203">Quantité totale de mémoire assignée au flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-203">The total amount of memory assigned to the stream.</span></span></param>
        <param name="access"><span data-ttu-id="343e7-204">Une des valeurs de <see cref="T:System.IO.FileAccess" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-204">One of the <see cref="T:System.IO.FileAccess" /> values.</span></span></param>
        <summary><span data-ttu-id="343e7-205">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> à l'aide d'un pointeur vers un emplacement de la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-205">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class by using a pointer to an unmanaged memory location.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-206">Cette méthode est équivalente à la <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructeur.</span><span class="sxs-lookup"><span data-stu-id="343e7-206">This method is equivalent to the <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructor.</span></span> <span data-ttu-id="343e7-207">Il prend en charge les méthodes que vous avez besoin d’initialiser le pointeur avant de définir des variables de flux de données et, par conséquent, ne peut pas appeler le constructeur paramétrable.</span><span class="sxs-lookup"><span data-stu-id="343e7-207">It supports methods that need to initialize the pointer before setting stream variables and, therefore, cannot call the parameterized constructor.</span></span> <span data-ttu-id="343e7-208">Ces méthodes doivent utiliser le constructeur par défaut, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialiser le pointeur, puis appeler la <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="343e7-208">Such methods should use the default constructor, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialize the pointer, and then invoke the <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="343e7-209">L’utilisateur ne dispose pas de l’autorisation nécessaire.</span><span class="sxs-lookup"><span data-stu-id="343e7-209">The user does not have the required permission.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="343e7-210"><paramref name="pointer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-210">The <paramref name="pointer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-211">La valeur <paramref name="length" /> est inférieure à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-211">The <paramref name="length" /> value is less than zero.</span></span>  
  
<span data-ttu-id="343e7-212">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-212">\- or -</span></span> 
<span data-ttu-id="343e7-213">La valeur <paramref name="capacity" /> est inférieure à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-213">The <paramref name="capacity" /> value is less than zero.</span></span>  
  
<span data-ttu-id="343e7-214">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-214">\- or -</span></span> 
<span data-ttu-id="343e7-215">La valeur <paramref name="length" /> est suffisamment grande pour provoquer un dépassement de capacité.</span><span class="sxs-lookup"><span data-stu-id="343e7-215">The <paramref name="length" /> value is large enough to cause an overflow.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="343e7-216">pour l’accès à la mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="343e7-216">for accessing unmanaged memory.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="343e7-217">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="343e7-217">requires full trust for the immediate caller.</span></span> <span data-ttu-id="343e7-218">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="343e7-218">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Initialize : System.Runtime.InteropServices.SafeBuffer * int64 * int64 * System.IO.FileAccess -&gt; unit" Usage="unmanagedMemoryStream.Initialize (buffer, offset, length, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-219">Mémoire tampon devant contenir le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-219">The buffer to contain the unmanaged memory stream.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-220">Position d'octet dans la mémoire tampon à partir de laquelle commencer le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-220">The byte position in the buffer at which to start the unmanaged memory stream.</span></span></param>
        <param name="length"><span data-ttu-id="343e7-221">Longueur du flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-221">The length of the unmanaged memory stream.</span></span></param>
        <param name="access"><span data-ttu-id="343e7-222">Mode d'accès au fichier sur le flux de mémoire non managé.</span><span class="sxs-lookup"><span data-stu-id="343e7-222">The mode of file access to the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="343e7-223">Initialise une nouvelle instance de la classe <see cref="T:System.IO.UnmanagedMemoryStream" /> dans une mémoire tampon sécurisée avec un décalage, une longueur et l'accès au fichier spécifiés.</span><span class="sxs-lookup"><span data-stu-id="343e7-223">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.UnmanagedMemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-224">Obtient la longueur des données dans un flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-224">Gets the length of the data in a stream.</span></span></summary>
        <value><span data-ttu-id="343e7-225">Longueur des données dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-225">The length of the data in the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-226">Si elle reste inchangée dans la mesure où le flux a été initialisé, cette propriété retourne la valeur de la longueur fournie au constructeur.</span><span class="sxs-lookup"><span data-stu-id="343e7-226">If unchanged since the stream was initialized, this property returns the length value provided to the constructor.</span></span> <span data-ttu-id="343e7-227">Si les modifications dans le flux se sont produites, cette propriété reflète toutes les modifications à la longueur des données.</span><span class="sxs-lookup"><span data-stu-id="343e7-227">If changes to the stream have occurred, this property reflects any changes to the length of the data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-228">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-228">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="343e7-229">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-229">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-230">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-230">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.UnmanagedMemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-231">Obtient ou définit la position actuelle dans un flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-231">Gets or sets the current position in a stream.</span></span></summary>
        <value><span data-ttu-id="343e7-232">Position actuelle dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-232">The current position in the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-233">Lorsqu’un flux de données est initialisé, cette propriété est définie à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-233">When a stream is initialized, this property is set to zero.</span></span>  
  
 <span data-ttu-id="343e7-234">Bien que vous pouvez définir la position du flux au-delà de sa capacité, vous ne serez pas en mesure d’accéder à cette zone à l’aide de la <xref:System.IO.UnmanagedMemoryStream.Read%2A> et <xref:System.IO.UnmanagedMemoryStream.Write%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="343e7-234">Although you can set the position of the stream beyond the stream's capacity, you will not be able to access that area using the <xref:System.IO.UnmanagedMemoryStream.Read%2A> and <xref:System.IO.UnmanagedMemoryStream.Write%2A> methods.</span></span> <span data-ttu-id="343e7-235"><xref:System.IO.UnmanagedMemoryStream.Read%2A> retourne 0 et <xref:System.IO.UnmanagedMemoryStream.Write%2A> lèvera une <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="343e7-235"><xref:System.IO.UnmanagedMemoryStream.Read%2A> will return 0 and <xref:System.IO.UnmanagedMemoryStream.Write%2A> will throw a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="343e7-236">Cette prise en charge est principalement pour la compatibilité de conception et du code avec les opérations de flux de base.</span><span class="sxs-lookup"><span data-stu-id="343e7-236">This support is primarily for design and code compatibility with basic stream operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-237">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-237">The stream is closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-238">La valeur de la position est inférieure à zéro, ou est supérieure à <see cref="F:System.Int32.MaxValue" /> ou aux résultats du dépassement de capacité, au moment de l’ajout au pointeur actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-238">The position is set to a value that is less than zero, or the position is larger than <see cref="F:System.Int32.MaxValue" /> or results in overflow when added to the current pointer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PositionPointer">
      <MemberSignature Language="C#" Value="public byte* PositionPointer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8* PositionPointer" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte* PositionPointer { System::Byte* get(); void set(System::Byte* value); };" />
      <MemberSignature Language="F#" Value="member this.PositionPointer : nativeptr&lt;byte&gt; with get, set" Usage="System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte*</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="343e7-239">Obtient ou définit un pointeur d'octet vers un flux basé sur la position actuelle.</span><span class="sxs-lookup"><span data-stu-id="343e7-239">Gets or sets a byte pointer to a stream based on the current position in the stream.</span></span></summary>
        <value><span data-ttu-id="343e7-240">Pointeur d'octet.</span><span class="sxs-lookup"><span data-stu-id="343e7-240">A byte pointer.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-241">Pour retourner un pointeur vers l’intégralité du flux, définissez le <xref:System.IO.UnmanagedMemoryStream.Position%2A> propriété sur zéro, puis appelez cette propriété.</span><span class="sxs-lookup"><span data-stu-id="343e7-241">To return a pointer to the entire stream, set the <xref:System.IO.UnmanagedMemoryStream.Position%2A> property to zero, and then call this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="343e7-242">La position actuelle dépasse la capacité du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-242">The current position is larger than the capacity of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-243">La position est définie comme non valide dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-243">The position is being set is not a valid position in the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="343e7-244">Une valeur inférieure à la position de départ du flux est affectée au pointeur.</span><span class="sxs-lookup"><span data-stu-id="343e7-244">The pointer is being set to a lower value than the starting position of the stream.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="343e7-245">Le flux a été initialisé pour une utilisation avec <see cref="T:System.Runtime.InteropServices.SafeBuffer" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-245">The stream was initialized for use with a <see cref="T:System.Runtime.InteropServices.SafeBuffer" />.</span></span> <span data-ttu-id="343e7-246">La propriété <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /> est uniquement valide pour les flux de données initialisés avec un pointeur <see cref="T:System.Byte" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-246">The <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /> property is valid only for streams that are initialized with a <see cref="T:System.Byte" /> pointer.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="343e7-247">pour appeler du code non managé, telles que l’appel de code natif avec platform invoke ou l’intégration de COM.</span><span class="sxs-lookup"><span data-stu-id="343e7-247">for calling unmanaged code, such as calling native code with platform invoke or COM integration.</span></span> <span data-ttu-id="343e7-248">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-248">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="343e7-249">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="343e7-249">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="343e7-250">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="343e7-250">requires full trust for the immediate caller.</span></span> <span data-ttu-id="343e7-251">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="343e7-251">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="unmanagedMemoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="unmanagedMemoryStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-252">Quand cette méthode est retournée, contient le tableau d’octets spécifié dont les valeurs comprises entre <paramref name="offset" /> et (<paramref name="offset" /> + <paramref name="count" /> - 1) sont remplacées par les octets lus dans la source actuelle.</span><span class="sxs-lookup"><span data-stu-id="343e7-252">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span> <span data-ttu-id="343e7-253">Ce paramètre est passé sans être initialisé.</span><span class="sxs-lookup"><span data-stu-id="343e7-253">This parameter is passed uninitialized.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-254">Dans <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer le stockage des données lues dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-254">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="343e7-255">Nombre maximal d'octets à lire à partir du flux actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-255">The maximum number of bytes to read from the current stream.</span></span></param>
        <summary><span data-ttu-id="343e7-256">Lit le nombre d'octets spécifié dans le tableau indiqué.</span><span class="sxs-lookup"><span data-stu-id="343e7-256">Reads the specified number of bytes into the specified array.</span></span></summary>
        <returns><span data-ttu-id="343e7-257">Nombre total d'octets lus dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="343e7-257">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="343e7-258">Le nombre d'octets peut être inférieur au nombre d'octets demandés si ce nombre n'est pas actuellement disponible ou égal à zéro (0) si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="343e7-258">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-259">Le `offset` paramètre indique l’offset d’octet dans le `array` paramètre (l’index de la mémoire tampon) à partir duquel commencer la lecture et le `count` paramètre indique le nombre maximal d’octets à lire à partir de ce flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-259">The `offset` parameter gives the offset of the byte in the `array` parameter (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="343e7-260">La valeur retournée est le nombre réel d’octets lus, ou zéro si la fin du flux est atteinte.</span><span class="sxs-lookup"><span data-stu-id="343e7-260">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="343e7-261">Si l’opération de lecture réussite, la position actuelle du flux est avancée par le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="343e7-261">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="343e7-262">Si une exception se produit, la position actuelle du flux est inchangée.</span><span class="sxs-lookup"><span data-stu-id="343e7-262">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="343e7-263">Le <xref:System.IO.UnmanagedMemoryStream.Read%2A> méthode retourne zéro uniquement après avoir atteint la fin du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-263">The <xref:System.IO.UnmanagedMemoryStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="343e7-264">Sinon, <xref:System.IO.UnmanagedMemoryStream.Read%2A> lit toujours au moins un octet à partir du flux avant de retourner.</span><span class="sxs-lookup"><span data-stu-id="343e7-264">Otherwise, <xref:System.IO.UnmanagedMemoryStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="343e7-265">Si aucune donnée n’est disponible à partir du flux lors d’un appel à <xref:System.IO.UnmanagedMemoryStream.Read%2A>, la méthode se bloque jusqu'à ce qu’au moins un octet de données peut être retourné.</span><span class="sxs-lookup"><span data-stu-id="343e7-265">If no data is available from the stream upon a call to <xref:System.IO.UnmanagedMemoryStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="343e7-266">Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux n’a pas été atteinte.</span><span class="sxs-lookup"><span data-stu-id="343e7-266">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-267">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-267">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="343e7-268">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-268">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-269">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-269">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="343e7-270">La mémoire sous-jacente ne prend pas en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="343e7-270">The underlying memory does not support reading.</span></span>  
  
<span data-ttu-id="343e7-271">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-271">\- or -</span></span> 
<span data-ttu-id="343e7-272">La propriété <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /> a la valeur <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-272">The <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /> property is set to <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="343e7-273">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-273">The <paramref name="buffer" /> parameter is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-274">Le paramètre <paramref name="offset" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-274">The <paramref name="offset" /> parameter is less than zero.</span></span>  
  
<span data-ttu-id="343e7-275">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-275">\- or -</span></span> 
<span data-ttu-id="343e7-276">Le paramètre <paramref name="count" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-276">The <paramref name="count" /> parameter is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="343e7-277">La longueur du tableau mis en mémoire tampon moins le paramètre <paramref name="offset" /> est inférieure au paramètre <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-277">The length of the buffer array minus the <paramref name="offset" /> parameter is less than the <paramref name="count" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="unmanagedMemoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-278">Mémoire tampon dans laquelle les données sont écrites.</span><span class="sxs-lookup"><span data-stu-id="343e7-278">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-279">Dans <paramref name="buffer" />, décalage d'octet auquel commencer l'écriture des données à partir du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-279">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="343e7-280">Nombre maximal d'octets à lire.</span><span class="sxs-lookup"><span data-stu-id="343e7-280">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="343e7-281">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="343e7-281">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="343e7-282">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-282">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="343e7-283">Lit de manière asynchrone le nombre d'octets spécifié dans le tableau indiqué.</span><span class="sxs-lookup"><span data-stu-id="343e7-283">Asynchronously reads the specified number of bytes into the specified array.</span></span>  
  
<span data-ttu-id="343e7-284">Disponible à partir de .NET Framework 4.6</span><span class="sxs-lookup"><span data-stu-id="343e7-284">Available starting in .NET Framework 4.6</span></span></summary>
        <returns><span data-ttu-id="343e7-285">Tâche qui représente l'opération de lecture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="343e7-285">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="343e7-286">La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="343e7-286">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="343e7-287">La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="343e7-287">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-288">Si une exception se produit pendant l’opération de lecture, elle sera définie en tant que le <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> de la propriété de la tâche retournée.</span><span class="sxs-lookup"><span data-stu-id="343e7-288">If an exception occurs during the read operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="unmanagedMemoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="343e7-289">Lit un octet à partir d'un flux et avance d'un octet la position au sein du flux, ou retourne -1 s'il se situe à la fin du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-289">Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="343e7-290">Conversion de type (transtypage) de l'octet non signé en objet <see cref="T:System.Int32" />, ou -1 si la fin du flux a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="343e7-290">The unsigned byte cast to an <see cref="T:System.Int32" /> object, or -1 if at the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-291">Utilisez cette méthode pour retourner des valeurs entières à partir du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-291">Use this method to return integer values from the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-292">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-292">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="343e7-293">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-293">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="343e7-294">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie le <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> propriété avant d’essayer de lire et afficher le contenu dans la console.</span><span class="sxs-lookup"><span data-stu-id="343e7-294">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-295">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-295">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="343e7-296">La mémoire sous-jacente ne prend pas en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="343e7-296">The underlying memory does not support reading.</span></span>  
  
<span data-ttu-id="343e7-297">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-297">\- or -</span></span> 
<span data-ttu-id="343e7-298">La position actuelle se situe à la fin du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-298">The current position is at the end of the stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="unmanagedMemoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="343e7-299">Point par rapport à <c>origin</c> à partir duquel la recherche doit commencer.</span><span class="sxs-lookup"><span data-stu-id="343e7-299">The point relative to <c>origin</c> to begin seeking from.</span></span></param>
        <param name="loc"><span data-ttu-id="343e7-300">Spécifie le début, la fin ou la position actuelle comme point de référence pour<c>origin</c>, en utilisant une valeur de type <see cref="T:System.IO.SeekOrigin" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-300">Specifies the beginning, the end, or the current position as a reference point for <c>origin</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="343e7-301">Affecte la valeur donnée à la position actuelle du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-301">Sets the current position of the current stream to the given value.</span></span></summary>
        <returns><span data-ttu-id="343e7-302">Nouvelle position dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-302">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-303">Pour plus d’informations sur la recherche, consultez <xref:System.IO.FileStream.Seek%2A>.</span><span class="sxs-lookup"><span data-stu-id="343e7-303">For more information about seeking, see <xref:System.IO.FileStream.Seek%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="343e7-304">Tentative de recherche avant le début du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-304">An attempt was made to seek before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-305">La valeur <paramref name="offset" /> dépasse la taille maximale du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-305">The <paramref name="offset" /> value is larger than the maximum size of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="343e7-306"><paramref name="loc" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="343e7-306"><paramref name="loc" /> is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-307">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-307">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="unmanagedMemoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="343e7-308">Longueur du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-308">The length of the stream.</span></span></param>
        <summary><span data-ttu-id="343e7-309">Affecte la valeur spécifiée à la longueur d'un flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-309">Sets the length of a stream to a specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-310">Si la valeur donnée est inférieure à la longueur actuelle du flux de données, le flux est tronqué.</span><span class="sxs-lookup"><span data-stu-id="343e7-310">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="343e7-311">Si la valeur donnée est supérieure à la longueur actuelle du flux de données, le flux est développé.</span><span class="sxs-lookup"><span data-stu-id="343e7-311">If the given value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="343e7-312">Si le flux est développé, le contenu du flux de données entre l’ancienne et la nouvelle longueur est non défini.</span><span class="sxs-lookup"><span data-stu-id="343e7-312">If the stream is expanded, the contents of the stream between the old and the new lengths are undefined.</span></span>  
  
 <span data-ttu-id="343e7-313">Un flux doit prendre en charge écriture et la recherche pour <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> fonctionne.</span><span class="sxs-lookup"><span data-stu-id="343e7-313">A stream must support both writing and seeking for <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="343e7-314">Une erreur d’E/S s’est produite.</span><span class="sxs-lookup"><span data-stu-id="343e7-314">An I/O error has occurred.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-315">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-315">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="343e7-316">La mémoire sous-jacente ne prend pas en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="343e7-316">The underlying memory does not support writing.</span></span>  
  
<span data-ttu-id="343e7-317">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-317">\- or -</span></span> 
<span data-ttu-id="343e7-318">Une tentative d’écriture dans le flux a été effectuée, et la propriété <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-318">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-319">La valeur spécifiée (<paramref name="value" />) dépasse la capacité du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-319">The specified <paramref name="value" /> exceeds the capacity of the stream.</span></span>  
  
<span data-ttu-id="343e7-320">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-320">\- or -</span></span> 
<span data-ttu-id="343e7-321">La valeur spécifiée (<paramref name="value" />) est négative.</span><span class="sxs-lookup"><span data-stu-id="343e7-321">The specified <paramref name="value" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="unmanagedMemoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="unmanagedMemoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-322">Tableau d'octets à partir duquel les octets peuvent être copiés vers le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-322">The byte array from which to copy bytes to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-323">Dans la mémoire tampon, offset à partir duquel commence la copie des octets dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-323">The offset in the buffer at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="343e7-324">Nombre d'octets à écrire dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="343e7-324">The number of bytes to write to the current stream.</span></span></param>
        <summary><span data-ttu-id="343e7-325">Écrit un bloc d'octets dans le flux actuel en utilisant les données d'une mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="343e7-325">Writes a block of bytes to the current stream using data from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-326">Écriture se produit à la position actuelle dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-326">Writing occurs at the current position in the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="343e7-327">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-327">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="343e7-328">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-328">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-329">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-329">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="343e7-330">La mémoire sous-jacente ne prend pas en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="343e7-330">The underlying memory does not support writing.</span></span>  
  
<span data-ttu-id="343e7-331">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-331">\- or -</span></span> 
<span data-ttu-id="343e7-332">Une tentative d’écriture dans le flux a été effectuée, et la propriété <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-332">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="343e7-333">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-333">\- or -</span></span> 
<span data-ttu-id="343e7-334">La valeur <paramref name="count" /> est supérieure à la capacité du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-334">The <paramref name="count" /> value is greater than the capacity of the stream.</span></span>  
  
<span data-ttu-id="343e7-335">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-335">\- or -</span></span> 
<span data-ttu-id="343e7-336">La position est à la fin de la capacité du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-336">The position is at the end of the stream capacity.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="343e7-337">Une erreur d’E/S se produit.</span><span class="sxs-lookup"><span data-stu-id="343e7-337">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="343e7-338">Un des paramètres spécifiés est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="343e7-338">One of the specified parameters is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="343e7-339">Le paramètre <paramref name="offset" /> moins la longueur du paramètre <paramref name="buffer" /> est inférieur au paramètre <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-339">The <paramref name="offset" /> parameter minus the length of the <paramref name="buffer" /> parameter is less than the <paramref name="count" /> parameter.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="343e7-340">Le paramètre <paramref name="buffer" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-340">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="unmanagedMemoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="343e7-341">Mémoire tampon dont sont issues les données à écrire.</span><span class="sxs-lookup"><span data-stu-id="343e7-341">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="343e7-342">Dans <paramref name="buffer" />, décalage d'octet de base zéro à partir duquel commencer la copie des octets dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-342">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="343e7-343">Nombre maximal d'octets à écrire.</span><span class="sxs-lookup"><span data-stu-id="343e7-343">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="343e7-344">Jeton pour surveiller les requêtes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="343e7-344">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="343e7-345">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-345">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="343e7-346">Écrit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position actuelle dans ce flux du nombre d'octets écrits et surveille les demandes d'annulation.</span><span class="sxs-lookup"><span data-stu-id="343e7-346">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span>  
  
<span data-ttu-id="343e7-347">Disponible à partir de .NET Framework 4.6</span><span class="sxs-lookup"><span data-stu-id="343e7-347">Available starting in .NET Framework 4.6</span></span></summary>
        <returns><span data-ttu-id="343e7-348">Tâche qui représente l’opération d’écriture asynchrone.</span><span class="sxs-lookup"><span data-stu-id="343e7-348">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="343e7-349">Si une exception se produit pendant l’opération d’écriture, elle sera définie en tant que le <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> de la propriété de la tâche retournée.</span><span class="sxs-lookup"><span data-stu-id="343e7-349">If an exception occurs during the write operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="unmanagedMemoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="343e7-350">Valeur d'octet écrite dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-350">A byte value written to the stream.</span></span></param>
        <summary><span data-ttu-id="343e7-351">Écrit un octet à la position actuelle dans le flux de fichier.</span><span class="sxs-lookup"><span data-stu-id="343e7-351">Writes a byte to the current position in the file stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="343e7-352">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-352">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="343e7-353">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="343e7-353">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="343e7-354">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie le <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriété avant de tenter d’écrire les données dans le flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-354">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="343e7-355">Le flux est fermé.</span><span class="sxs-lookup"><span data-stu-id="343e7-355">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="343e7-356">La mémoire sous-jacente ne prend pas en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="343e7-356">The underlying memory does not support writing.</span></span>  
  
<span data-ttu-id="343e7-357">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-357">\- or -</span></span> 
<span data-ttu-id="343e7-358">Une tentative d’écriture dans le flux a été effectuée, et la propriété <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> est <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="343e7-358">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="343e7-359">\- ou -</span><span class="sxs-lookup"><span data-stu-id="343e7-359">\- or -</span></span> 
<span data-ttu-id="343e7-360">La position actuelle se situe à la fin de la capacité du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-360">The current position is at the end of the capacity of the stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="343e7-361">La valeur fournie (<paramref name="value" />) provoque un dépassement de la capacité maximale du flux.</span><span class="sxs-lookup"><span data-stu-id="343e7-361">The supplied <paramref name="value" /> causes the stream exceed its maximum capacity.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>