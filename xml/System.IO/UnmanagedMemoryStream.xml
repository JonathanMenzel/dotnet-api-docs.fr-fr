<Type Name="UnmanagedMemoryStream" FullName="System.IO.UnmanagedMemoryStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb4c975faf277d108657da605c92e4d25ec392c7" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36483837" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnmanagedMemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UnmanagedMemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.UnmanagedMemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class UnmanagedMemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnmanagedMemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type UnmanagedMemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="19f9a-101">Provides access to unmanaged blocks of memory from managed code.</span>
      <span class="sxs-lookup">
        <span data-stu-id="19f9a-101">Provides access to unmanaged blocks of memory from managed code.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-102">Cette classe prend en charge les accès mémoire non managée en utilisant le modèle basé sur les flux de données existant et ne nécessite pas que le contenu dans la mémoire non managée est copié dans le tas.</span><span class="sxs-lookup"><span data-stu-id="19f9a-102">This class supports access to unmanaged memory using the existing stream-based model and does not require that the contents in the unmanaged memory be copied to the heap.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
## Examples  
 <span data-ttu-id="19f9a-103">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-103">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="19f9a-104">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-104">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-105">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-105">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnmanagedMemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UnmanagedMemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-106">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-106">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="19f9a-107">The user does not have the required permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-107">The user does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="19f9a-108">Pour accéder à une mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-108">for accessing unmanaged memory.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : nativeptr&lt;byte&gt; * int64 -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="19f9a-109">A pointer to an unmanaged memory location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-109">A pointer to an unmanaged memory location.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="19f9a-110">The length of the memory to use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-110">The length of the memory to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-111">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location and memory length.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-111">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location and memory length.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-112">Ce constructeur crée une nouvelle instance de la <xref:System.IO.UnmanagedMemoryStream> de classe et affecte par défaut la <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriété `false` et <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> propriété `true`.</span><span class="sxs-lookup"><span data-stu-id="19f9a-112">This constructor creates a new instance of the <xref:System.IO.UnmanagedMemoryStream> class, and by default sets the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property to `false` and the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property to `true`.</span></span> <span data-ttu-id="19f9a-113">Le <xref:System.IO.UnmanagedMemoryStream.Length%2A> est définie sur la valeur de le `length` paramètre et ne peut pas être modifié.</span><span class="sxs-lookup"><span data-stu-id="19f9a-113">The <xref:System.IO.UnmanagedMemoryStream.Length%2A> property is set to the value of the `length` parameter and cannot be changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-114">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-114">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="19f9a-115">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-115">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="19f9a-116">The user does not have the required permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-116">The user does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="19f9a-117">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-117">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-118">The <paramref name="length" /> value is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-118">The <paramref name="length" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="19f9a-119">\- or -  The <paramref name="length" /> is large enough to cause an overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-119">\- or -  The <paramref name="length" /> is large enough to cause an overflow.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="19f9a-120">Pour accéder à une mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-120">for accessing unmanaged memory.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="19f9a-121">Requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-121">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="19f9a-122">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-122">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : System.Runtime.InteropServices.SafeBuffer * int64 * int64 -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (buffer, offset, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-123">The buffer to contain the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-123">The buffer to contain the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-124">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-124">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="19f9a-125">The length of the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-125">The length of the unmanaged memory stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-126">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset and length.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-126">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset and length.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : nativeptr&lt;byte&gt; * int64 * int64 * System.IO.FileAccess -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (pointer, length, capacity, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="19f9a-127">A pointer to an unmanaged memory location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-127">A pointer to an unmanaged memory location.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="19f9a-128">The length of the memory to use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-128">The length of the memory to use.</span>
          </span>
        </param>
        <param name="capacity">
          <span data-ttu-id="19f9a-129">The total amount of memory assigned to the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-129">The total amount of memory assigned to the stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="19f9a-130">One of the <see cref="T:System.IO.FileAccess" /> values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-130">One of the <see cref="T:System.IO.FileAccess" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-131">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location, memory length, total amount of memory, and file access values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-131">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location, memory length, total amount of memory, and file access values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-132">Le `length` paramètre définit la quantité de mémoire actuellement en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="19f9a-132">The `length` parameter defines the current amount of memory in use.</span></span> <span data-ttu-id="19f9a-133">Si la lecture ou de l’ajout de données dans le flux de la `length` valeur doit être égale à la quantité de données valides dans le flux à lire à partir d’ou conservés.</span><span class="sxs-lookup"><span data-stu-id="19f9a-133">If reading or appending data to the stream, the `length` value should be equal to the amount of valid data in the stream to be read from or preserved.</span></span> <span data-ttu-id="19f9a-134">Si l’écriture dans le flux de données, cette valeur doit être zéro.</span><span class="sxs-lookup"><span data-stu-id="19f9a-134">If writing to the stream, this value should be zero.</span></span>  
  
 <span data-ttu-id="19f9a-135">Le `capacity` paramètre indique la quantité de mémoire totale disponible.</span><span class="sxs-lookup"><span data-stu-id="19f9a-135">The `capacity` parameter indicates the amount of total memory available.</span></span> <span data-ttu-id="19f9a-136">Cette valeur peut décrire une zone qui est plus longue que la longueur spécifiée, ou indiquer une région qui peut être ajoutée à.</span><span class="sxs-lookup"><span data-stu-id="19f9a-136">This value can describe a region that is longer than the length specified, or indicate a region that can be appended to.</span></span> <span data-ttu-id="19f9a-137">Toute tentative d’écriture au-delà de cette valeur échouera.</span><span class="sxs-lookup"><span data-stu-id="19f9a-137">Any attempt to write beyond this value will fail.</span></span>  
  
 <span data-ttu-id="19f9a-138">Le `access` jeux de paramètres la <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, et <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="19f9a-138">The `access` parameter sets the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, and <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> properties.</span></span> <span data-ttu-id="19f9a-139">Notez que la spécification <xref:System.IO.FileAccess.Write> ne garantit pas que le flux soit accessible en écriture.</span><span class="sxs-lookup"><span data-stu-id="19f9a-139">Note that specifying <xref:System.IO.FileAccess.Write> does not guarantee that the stream will be writable.</span></span> <span data-ttu-id="19f9a-140">Les paramètres d’accès permettent à l’implémenteur créer un objet dont l’implémentation peut correspondre à des flux de données réel qui est exposé.</span><span class="sxs-lookup"><span data-stu-id="19f9a-140">The access parameters allow the implementer to create an object whose implementation can match the actual stream that is exposed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-141">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-141">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="19f9a-142">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-142">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="19f9a-143">The user does not have the required permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-143">The user does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="19f9a-144">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-144">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-145">The <paramref name="length" /> value is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-145">The <paramref name="length" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="19f9a-146">\- or -  The <paramref name="capacity" /> value is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-146">\- or -  The <paramref name="capacity" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="19f9a-147">\- or -  The <paramref name="length" /> value is greater than the <paramref name="capacity" /> value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-147">\- or -  The <paramref name="length" /> value is greater than the <paramref name="capacity" /> value.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="19f9a-148">Pour accéder à une mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-148">for accessing unmanaged memory.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="19f9a-149">Requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-149">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="19f9a-150">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-150">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : System.Runtime.InteropServices.SafeBuffer * int64 * int64 * System.IO.FileAccess -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (buffer, offset, length, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-151">The buffer to contain the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-151">The buffer to contain the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-152">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-152">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="19f9a-153">The length of the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-153">The length of the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="19f9a-154">The mode of file access to the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-154">The mode of file access to the unmanaged memory stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-155">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-155">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-156">Gets a value indicating whether a stream supports reading.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-156">Gets a value indicating whether a stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-157">
            <see langword="false" /> si l'objet a été créé par un constructeur avec un paramètre <paramref name="access" /> qui n'inclut pas la lecture du flux, et si le flux est fermé ; sinon, <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-157">
              <see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter that did not include reading the stream and if the stream is closed; otherwise, <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-158">Cette propriété indique si l’objet de flux actuel prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="19f9a-158">This property indicates whether the current stream object supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-159">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-159">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="19f9a-160">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-160">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="19f9a-161">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie la <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> propriété avant d’essayer d’afficher le contenu dans la console.</span><span class="sxs-lookup"><span data-stu-id="19f9a-161">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-162">Gets a value indicating whether a stream supports seeking.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-162">Gets a value indicating whether a stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-163">
            <see langword="false" /> si le flux est fermé ; sinon, <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-163">
              <see langword="false" /> if the stream is closed; otherwise, <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-164">Cette propriété indique si l’objet de flux actuel prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="19f9a-164">This property indicates whether the current stream object supports seeking.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-165">Gets a value indicating whether a stream supports writing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-165">Gets a value indicating whether a stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-166">
            <see langword="false" /> si l'objet a été créé par un constructeur avec une valeur de paramètre <paramref name="access" /> prenant en charge l'écriture, s'il a été créé par un constructeur sans paramètres ou si le flux est fermé ; sinon, <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-166">
              <see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter value that supports writing or was created by a constructor that had no parameters, or if the stream is closed; otherwise, <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-167">Cette propriété indique si l’objet de flux actuel prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="19f9a-167">This property indicates whether the current stream object supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-168">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-168">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="19f9a-169">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-169">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="19f9a-170">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie la <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriété avant de tenter d’écrire les données dans le flux.</span><span class="sxs-lookup"><span data-stu-id="19f9a-170">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public long Capacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Capacity As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Capacity { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int64" Usage="System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-171">Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-171">Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-172">Taille ou capacité du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-172">The size or capacity of the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-173">Cette propriété retourne la `capacity` valeur fournie au constructeur.</span><span class="sxs-lookup"><span data-stu-id="19f9a-173">This property returns the `capacity` value provided to the constructor.</span></span> <span data-ttu-id="19f9a-174">Si aucun `capacity` valeur a été spécifiée lors de l’initialisation du flux, cette propriété retourne la longueur du flux.</span><span class="sxs-lookup"><span data-stu-id="19f9a-174">If no `capacity` value was specified when the stream was initialized, this property returns the stream length.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-175">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-175">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="unmanagedMemoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="19f9a-176">
            <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-176">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-177">Releases the unmanaged resources used by the <see cref="T:System.IO.UnmanagedMemoryStream" /> and optionally releases the managed resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-177">Releases the unmanaged resources used by the <see cref="T:System.IO.UnmanagedMemoryStream" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-178">Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="19f9a-178">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="19f9a-179"><xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> méthode avec la `disposing` paramètre la valeur `true`.</span><span class="sxs-lookup"><span data-stu-id="19f9a-179"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="19f9a-180"><xref:System.Object.Finalize%2A> appelle <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> avec `disposing` la valeur `false`.</span><span class="sxs-lookup"><span data-stu-id="19f9a-180"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="19f9a-181">Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.UnmanagedMemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="19f9a-181">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.UnmanagedMemoryStream> references.</span></span> <span data-ttu-id="19f9a-182">Cette méthode appelle la méthode <xref:System.ComponentModel.Component.Dispose%2A> de chaque objet référencé.</span><span class="sxs-lookup"><span data-stu-id="19f9a-182">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="19f9a-183">
            <para>
              <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, consultez [implémentation d’un Method](~/docs/standard/garbage-collection/implementing-dispose.md) de suppression.  Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [nettoyage de non managé Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-183">
              <para>
                <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />. For more information about how to implement <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="unmanagedMemoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-184">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-184">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-185">Cette méthode n’effectue aucune action pour cette classe, mais est incluse dans le cadre de la <xref:System.IO.Stream> classe de base.</span><span class="sxs-lookup"><span data-stu-id="19f9a-185">This method performs no action for this class but is included as part of the <xref:System.IO.Stream> base class.</span></span> <span data-ttu-id="19f9a-186">Étant donné que les données sont écrites dans la RAM, cette méthode est redondante.</span><span class="sxs-lookup"><span data-stu-id="19f9a-186">Since any data is written to RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-187">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-187">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="unmanagedMemoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="19f9a-188">The token to monitor for cancellation requests.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-188">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="19f9a-189">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-189">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-190">Overrides the <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /> method so that the operation is cancelled if specified, but no other action is performed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-190">Overrides the <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /> method so that the operation is cancelled if specified, but no other action is performed.</span>
          </span>
          <span data-ttu-id="19f9a-191">Available starting in .NET Framework 4.6</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-191">Available starting in .NET Framework 4.6</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="19f9a-192">A task that represents the asynchronous flush operation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-192">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-193">Si l’opération n’est pas annulée, la <xref:System.IO.UnmanagedMemoryStream> appelle la <xref:System.IO.UnmanagedMemoryStream.Flush%2A> (méthode), ce qui signifie qu’aucune action n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="19f9a-193">If the operation isn’t cancelled, the <xref:System.IO.UnmanagedMemoryStream> calls the <xref:System.IO.UnmanagedMemoryStream.Flush%2A> method, which means that no action performed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-194">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer, or by using a pointer to an unmanaged memory location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-194">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer, or by using a pointer to an unmanaged memory location.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Initialize : nativeptr&lt;byte&gt; * int64 * int64 * System.IO.FileAccess -&gt; unit" Usage="unmanagedMemoryStream.Initialize (pointer, length, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="19f9a-195">A pointer to an unmanaged memory location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-195">A pointer to an unmanaged memory location.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="19f9a-196">The length of the memory to use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-196">The length of the memory to use.</span>
          </span>
        </param>
        <param name="capacity">
          <span data-ttu-id="19f9a-197">The total amount of memory assigned to the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-197">The total amount of memory assigned to the stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="19f9a-198">One of the <see cref="T:System.IO.FileAccess" /> values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-198">One of the <see cref="T:System.IO.FileAccess" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-199">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class by using a pointer to an unmanaged memory location.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-199">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class by using a pointer to an unmanaged memory location.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-200">Cette méthode est équivalente à la <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructeur.</span><span class="sxs-lookup"><span data-stu-id="19f9a-200">This method is equivalent to the <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructor.</span></span> <span data-ttu-id="19f9a-201">Il prend en charge les méthodes que vous avez besoin d’initialiser le pointeur avant de définir des variables de flux de données et, par conséquent, Impossible d’appeler le constructeur paramétrable.</span><span class="sxs-lookup"><span data-stu-id="19f9a-201">It supports methods that need to initialize the pointer before setting stream variables and, therefore, cannot call the parameterized constructor.</span></span> <span data-ttu-id="19f9a-202">Ces méthodes doivent utiliser le constructeur par défaut, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialiser le pointeur, puis appelez le <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="19f9a-202">Such methods should use the default constructor, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialize the pointer, and then invoke the <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="19f9a-203">The user does not have the required permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-203">The user does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="19f9a-204">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-204">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-205">The <paramref name="length" /> value is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-205">The <paramref name="length" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="19f9a-206">\- or -  The <paramref name="capacity" /> value is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-206">\- or -  The <paramref name="capacity" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="19f9a-207">\- or -  The <paramref name="length" /> value is large enough to cause an overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-207">\- or -  The <paramref name="length" /> value is large enough to cause an overflow.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="19f9a-208">Pour accéder à une mémoire non managée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-208">for accessing unmanaged memory.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="19f9a-209">Requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-209">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="19f9a-210">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-210">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Initialize : System.Runtime.InteropServices.SafeBuffer * int64 * int64 * System.IO.FileAccess -&gt; unit" Usage="unmanagedMemoryStream.Initialize (buffer, offset, length, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-211">The buffer to contain the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-211">The buffer to contain the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-212">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-212">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="19f9a-213">The length of the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-213">The length of the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="19f9a-214">The mode of file access to the unmanaged memory stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-214">The mode of file access to the unmanaged memory stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-215">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-215">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.UnmanagedMemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-216">Gets the length of the data in a stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-216">Gets the length of the data in a stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-217">Longueur des données dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-217">The length of the data in the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-218">Si elle reste inchangée, car le flux a été initialisé, cette propriété retourne la valeur de la longueur fournie au constructeur.</span><span class="sxs-lookup"><span data-stu-id="19f9a-218">If unchanged since the stream was initialized, this property returns the length value provided to the constructor.</span></span> <span data-ttu-id="19f9a-219">Si les modifications dans le flux se sont produites, cette propriété indique toute modification apportée à la longueur des données.</span><span class="sxs-lookup"><span data-stu-id="19f9a-219">If changes to the stream have occurred, this property reflects any changes to the length of the data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-220">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-220">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="19f9a-221">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-221">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-222">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-222">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.UnmanagedMemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-223">Gets or sets the current position in a stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-223">Gets or sets the current position in a stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-224">Position actuelle dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-224">The current position in the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-225">Lorsqu’un flux de données est initialisé, cette propriété est définie à zéro.</span><span class="sxs-lookup"><span data-stu-id="19f9a-225">When a stream is initialized, this property is set to zero.</span></span>  
  
 <span data-ttu-id="19f9a-226">Bien que vous pouvez définir la position du flux au-delà de sa capacité, vous ne pourrez pas accéder à cette zone à l’aide de la <xref:System.IO.UnmanagedMemoryStream.Read%2A> et <xref:System.IO.UnmanagedMemoryStream.Write%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="19f9a-226">Although you can set the position of the stream beyond the stream's capacity, you will not be able to access that area using the <xref:System.IO.UnmanagedMemoryStream.Read%2A> and <xref:System.IO.UnmanagedMemoryStream.Write%2A> methods.</span></span> <span data-ttu-id="19f9a-227"><xref:System.IO.UnmanagedMemoryStream.Read%2A> Renvoie la valeur 0 et <xref:System.IO.UnmanagedMemoryStream.Write%2A> lèvera une <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="19f9a-227"><xref:System.IO.UnmanagedMemoryStream.Read%2A> will return 0 and <xref:System.IO.UnmanagedMemoryStream.Write%2A> will throw a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="19f9a-228">Cette prise en charge est principalement pour la conception et code compatibilité avec les opérations de flux de base.</span><span class="sxs-lookup"><span data-stu-id="19f9a-228">This support is primarily for design and code compatibility with basic stream operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-229">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-229">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-230">The position is set to a value that is less than zero, or the position is larger than <see cref="F:System.Int32.MaxValue" /> or results in overflow when added to the current pointer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-230">The position is set to a value that is less than zero, or the position is larger than <see cref="F:System.Int32.MaxValue" /> or results in overflow when added to the current pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="PositionPointer">
      <MemberSignature Language="C#" Value="public byte* PositionPointer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8* PositionPointer" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte* PositionPointer { System::Byte* get(); void set(System::Byte* value); };" />
      <MemberSignature Language="F#" Value="member this.PositionPointer : nativeptr&lt;byte&gt; with get, set" Usage="System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte*</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-231">Gets or sets a byte pointer to a stream based on the current position in the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-231">Gets or sets a byte pointer to a stream based on the current position in the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="19f9a-232">Pointeur d'octet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-232">A byte pointer.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-233">Pour retourner un pointeur à l’intégralité du flux, définissez le <xref:System.IO.UnmanagedMemoryStream.Position%2A> propriété sur zéro, puis appelez cette propriété.</span><span class="sxs-lookup"><span data-stu-id="19f9a-233">To return a pointer to the entire stream, set the <xref:System.IO.UnmanagedMemoryStream.Position%2A> property to zero, and then call this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="19f9a-234">The current position is larger than the capacity of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-234">The current position is larger than the capacity of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-235">The position is being set is not a valid position in the current stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-235">The position is being set is not a valid position in the current stream.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="19f9a-236">The pointer is being set to a lower value than the starting position of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-236">The pointer is being set to a lower value than the starting position of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="19f9a-237">The stream was initialized for use with a <see cref="T:System.Runtime.InteropServices.SafeBuffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-237">The stream was initialized for use with a <see cref="T:System.Runtime.InteropServices.SafeBuffer" />.</span>
          </span>
          <span data-ttu-id="19f9a-238">The <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /> property is valid only for streams that are initialized with a <see cref="T:System.Byte" /> pointer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-238">The <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /> property is valid only for streams that are initialized with a <see cref="T:System.Byte" /> pointer.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="19f9a-239">pour appeler du code non managé, telles que l’appel de code natif dans un appel invoke ou intégration COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-239">for calling unmanaged code, such as calling native code with platform invoke or COM integration.</span>
          </span>
          <span data-ttu-id="19f9a-240">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-240">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="19f9a-241">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-241">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="19f9a-242">Requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-242">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="19f9a-243">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-243">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="unmanagedMemoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="unmanagedMemoryStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-244">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the bytes read from the current source.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-244">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the bytes read from the current source.</span>
          </span>
          <span data-ttu-id="19f9a-245">This parameter is passed uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-245">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-246">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-246">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="19f9a-247">The maximum number of bytes to read from the current stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-247">The maximum number of bytes to read from the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-248">Reads the specified number of bytes into the specified array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-248">Reads the specified number of bytes into the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="19f9a-249">The total number of bytes read into the buffer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-249">The total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="19f9a-250">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-250">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-251">Le `offset` paramètre indique l’offset d’octet dans le `array` paramètre (l’index de la mémoire tampon) à partir duquel commencer la lecture et le `count` paramètre indique le nombre maximal d’octets à lire à partir de ce flux.</span><span class="sxs-lookup"><span data-stu-id="19f9a-251">The `offset` parameter gives the offset of the byte in the `array` parameter (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="19f9a-252">La valeur retournée est le nombre réel d’octets lus, ou zéro si la fin du flux est atteinte.</span><span class="sxs-lookup"><span data-stu-id="19f9a-252">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="19f9a-253">Si l’opération de lecture réussit, la position actuelle du flux est avancée par le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="19f9a-253">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="19f9a-254">Si une exception se produit, la position actuelle du flux de données est inchangée.</span><span class="sxs-lookup"><span data-stu-id="19f9a-254">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="19f9a-255">La <xref:System.IO.UnmanagedMemoryStream.Read%2A> retourne la valeur zéro uniquement après avoir atteint la fin du flux de données.</span><span class="sxs-lookup"><span data-stu-id="19f9a-255">The <xref:System.IO.UnmanagedMemoryStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="19f9a-256">Dans le cas contraire, <xref:System.IO.UnmanagedMemoryStream.Read%2A> lit toujours au moins un octet du flux avant de retourner.</span><span class="sxs-lookup"><span data-stu-id="19f9a-256">Otherwise, <xref:System.IO.UnmanagedMemoryStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="19f9a-257">Si aucune donnée n’est disponible à partir du flux lors d’un appel à <xref:System.IO.UnmanagedMemoryStream.Read%2A>, la méthode se bloque jusqu'à ce qu’au moins un octet de données peuvent être retourné.</span><span class="sxs-lookup"><span data-stu-id="19f9a-257">If no data is available from the stream upon a call to <xref:System.IO.UnmanagedMemoryStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="19f9a-258">Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux de données n’a pas été atteint.</span><span class="sxs-lookup"><span data-stu-id="19f9a-258">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-259">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-259">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="19f9a-260">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-260">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-261">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-261">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="19f9a-262">The underlying memory does not support reading.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-262">The underlying memory does not support reading.</span>
          </span>
          <span data-ttu-id="19f9a-263">\- or -  The <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /> property is set to <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-263">\- or -  The <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /> property is set to <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="19f9a-264">The <paramref name="buffer" /> parameter is set to <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-264">The <paramref name="buffer" /> parameter is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-265">The <paramref name="offset" /> parameter is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-265">The <paramref name="offset" /> parameter is less than zero.</span>
          </span>
          <span data-ttu-id="19f9a-266">\- or -  The <paramref name="count" /> parameter is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-266">\- or -  The <paramref name="count" /> parameter is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="19f9a-267">The length of the buffer array minus the <paramref name="offset" /> parameter is less than the <paramref name="count" /> parameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-267">The length of the buffer array minus the <paramref name="offset" /> parameter is less than the <paramref name="count" /> parameter.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="unmanagedMemoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-268">The buffer to write the data into.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-268">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-269">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-269">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="19f9a-270">The maximum number of bytes to read.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-270">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="19f9a-271">The token to monitor for cancellation requests.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-271">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="19f9a-272">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-272">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-273">Asynchronously reads the specified number of bytes into the specified array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-273">Asynchronously reads the specified number of bytes into the specified array.</span>
          </span>
          <span data-ttu-id="19f9a-274">Available starting in .NET Framework 4.6</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-274">Available starting in .NET Framework 4.6</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="19f9a-275">A task that represents the asynchronous read operation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-275">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="19f9a-276">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-276">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="19f9a-277">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-277">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-278">Si une exception se produit pendant l’opération de lecture, elle est définie en tant que le <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> de la propriété de la tâche retournée.</span><span class="sxs-lookup"><span data-stu-id="19f9a-278">If an exception occurs during the read operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="unmanagedMemoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="19f9a-279">Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-279">Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="19f9a-280">The unsigned byte cast to an <see cref="T:System.Int32" /> object, or -1 if at the end of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-280">The unsigned byte cast to an <see cref="T:System.Int32" /> object, or -1 if at the end of the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-281">Utilisez cette méthode pour retourner des valeurs entières à partir du flux.</span><span class="sxs-lookup"><span data-stu-id="19f9a-281">Use this method to return integer values from the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-282">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-282">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="19f9a-283">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-283">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="19f9a-284">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie la <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> propriété avant de tenter de lire et d’afficher le contenu dans la console.</span><span class="sxs-lookup"><span data-stu-id="19f9a-284">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-285">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-285">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="19f9a-286">The underlying memory does not support reading.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-286">The underlying memory does not support reading.</span>
          </span>
          <span data-ttu-id="19f9a-287">\- or -  The current position is at the end of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-287">\- or -  The current position is at the end of the stream.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="unmanagedMemoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="19f9a-288">The point relative to <c>origin</c> to begin seeking from.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-288">The point relative to <c>origin</c> to begin seeking from.</span>
          </span>
        </param>
        <param name="loc">
          <span data-ttu-id="19f9a-289">Specifies the beginning, the end, or the current position as a reference point for <c>origin</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-289">Specifies the beginning, the end, or the current position as a reference point for <c>origin</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-290">Sets the current position of the current stream to the given value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-290">Sets the current position of the current stream to the given value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="19f9a-291">The new position in the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-291">The new position in the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-292">Pour plus d’informations sur la recherche, consultez <xref:System.IO.FileStream.Seek%2A>.</span><span class="sxs-lookup"><span data-stu-id="19f9a-292">For more information about seeking, see <xref:System.IO.FileStream.Seek%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="19f9a-293">An attempt was made to seek before the beginning of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-293">An attempt was made to seek before the beginning of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-294">The <paramref name="offset" /> value is larger than the maximum size of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-294">The <paramref name="offset" /> value is larger than the maximum size of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="19f9a-295">
            <paramref name="loc" /> is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-295">
              <paramref name="loc" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-296">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-296">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="unmanagedMemoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="19f9a-297">The length of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-297">The length of the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-298">Sets the length of a stream to a specified value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-298">Sets the length of a stream to a specified value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-299">Si la valeur spécifiée est inférieure à la longueur actuelle du flux de données, le flux est tronqué.</span><span class="sxs-lookup"><span data-stu-id="19f9a-299">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="19f9a-300">Si la valeur donnée est supérieure à la longueur actuelle du flux de données, le flux de données est développé.</span><span class="sxs-lookup"><span data-stu-id="19f9a-300">If the given value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="19f9a-301">Si le flux est étendu, le contenu du flux de données entre l’ancienne et la nouvelle longueur n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="19f9a-301">If the stream is expanded, the contents of the stream between the old and the new lengths are undefined.</span></span>  
  
 <span data-ttu-id="19f9a-302">Un flux doit prendre en charge l’écriture et la recherche pour <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> pour fonctionner.</span><span class="sxs-lookup"><span data-stu-id="19f9a-302">A stream must support both writing and seeking for <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="19f9a-303">An I/O error has occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-303">An I/O error has occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-304">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-304">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="19f9a-305">The underlying memory does not support writing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-305">The underlying memory does not support writing.</span>
          </span>
          <span data-ttu-id="19f9a-306">\- or -  An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-306">\- or -  An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-307">The specified <paramref name="value" /> exceeds the capacity of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-307">The specified <paramref name="value" /> exceeds the capacity of the stream.</span>
          </span>
          <span data-ttu-id="19f9a-308">\- or -  The specified <paramref name="value" /> is negative.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-308">\- or -  The specified <paramref name="value" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="unmanagedMemoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="unmanagedMemoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-309">The byte array from which to copy bytes to the current stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-309">The byte array from which to copy bytes to the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-310">The offset in the buffer at which to begin copying bytes to the current stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-310">The offset in the buffer at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="19f9a-311">The number of bytes to write to the current stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-311">The number of bytes to write to the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-312">Writes a block of bytes to the current stream using data from a buffer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-312">Writes a block of bytes to the current stream using data from a buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-313">L’écriture se produit à la position actuelle dans le flux de données.</span><span class="sxs-lookup"><span data-stu-id="19f9a-313">Writing occurs at the current position in the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19f9a-314">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-314">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="19f9a-315">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-315">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-316">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-316">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="19f9a-317">The underlying memory does not support writing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-317">The underlying memory does not support writing.</span>
          </span>
          <span data-ttu-id="19f9a-318">\- or -  An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-318">\- or -  An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="19f9a-319">\- or -  The <paramref name="count" /> value is greater than the capacity of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-319">\- or -  The <paramref name="count" /> value is greater than the capacity of the stream.</span>
          </span>
          <span data-ttu-id="19f9a-320">\- or -  The position is at the end of the stream capacity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-320">\- or -  The position is at the end of the stream capacity.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="19f9a-321">An I/O error occurs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-321">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="19f9a-322">One of the specified parameters is less than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-322">One of the specified parameters is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="19f9a-323">The <paramref name="offset" /> parameter minus the length of the <paramref name="buffer" /> parameter is less than the <paramref name="count" /> parameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-323">The <paramref name="offset" /> parameter minus the length of the <paramref name="buffer" /> parameter is less than the <paramref name="count" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="19f9a-324">The <paramref name="buffer" /> parameter is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-324">The <paramref name="buffer" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="unmanagedMemoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="19f9a-325">The buffer to write data from.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-325">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="19f9a-326">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-326">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="19f9a-327">The maximum number of bytes to write.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-327">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="19f9a-328">The token to monitor for cancellation requests.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-328">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="19f9a-329">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-329">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-330">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-330">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
          <span data-ttu-id="19f9a-331">Available starting in .NET Framework 4.6</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-331">Available starting in .NET Framework 4.6</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="19f9a-332">A task that represents the asynchronous write operation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-332">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19f9a-333">Si une exception se produit pendant l’opération d’écriture, elle est définie en tant que le <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> de la propriété de la tâche retournée.</span><span class="sxs-lookup"><span data-stu-id="19f9a-333">If an exception occurs during the write operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="unmanagedMemoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="19f9a-334">A byte value written to the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-334">A byte value written to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="19f9a-335">Writes a byte to the current position in the file stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-335">Writes a byte to the current position in the file stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="19f9a-336">L’exemple de code suivant montre comment lire et écrire dans la mémoire non managée à l’aide de la <xref:System.IO.UnmanagedMemoryStream> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-336">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="19f9a-337">Un bloc de mémoire non managée est alloué et libéré à l’aide de la <xref:System.Runtime.InteropServices.Marshal> classe.</span><span class="sxs-lookup"><span data-stu-id="19f9a-337">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="19f9a-338">Dans cet exemple, un <xref:System.IO.UnmanagedMemoryStream> objet est passé à une méthode qui vérifie la <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> propriété avant de tenter d’écrire les données dans le flux.</span><span class="sxs-lookup"><span data-stu-id="19f9a-338">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="19f9a-339">The stream is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-339">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="19f9a-340">The underlying memory does not support writing.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-340">The underlying memory does not support writing.</span>
          </span>
          <span data-ttu-id="19f9a-341">\- or -  An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-341">\- or -  An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="19f9a-342">\- or -  The current position is at the end of the capacity of the stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-342">\- or -  The current position is at the end of the capacity of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="19f9a-343">The supplied <paramref name="value" /> causes the stream exceed its maximum capacity.</span>
          <span class="sxs-lookup">
            <span data-stu-id="19f9a-343">The supplied <paramref name="value" /> causes the stream exceed its maximum capacity.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>