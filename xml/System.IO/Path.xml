<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Path.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c0ef473bd6615db5908afedacb6564d0e78685953.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0ef473bd6615db5908afedacb6564d0e78685953</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Performs operations on <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> instances that contain file or directory path information.</source>
          <target state="translated">Effectue des opérations sur des instances de <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> qui contiennent des informations relatives au chemin d'accès d'un fichier ou d'un répertoire.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>These operations are performed in a cross-platform manner.</source>
          <target state="translated">Ces opérations sont effectuées différemment selon la plateforme.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0 ».</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path is a string that provides the location of a file or directory.</source>
          <target state="translated">Un chemin d’accès est une chaîne qui fournit l’emplacement d’un fichier ou répertoire.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</source>
          <target state="translated">Un chemin d’accès ne pointe pas nécessairement vers un emplacement sur le disque ; par exemple, un chemin d’accès peuvent être mappées à un emplacement en mémoire ou sur un appareil.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The exact format of a path is determined by the current platform.</source>
          <target state="translated">Le format exact d’un chemin d’accès est déterminé par la plateforme actuelle.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</source>
          <target state="translated">Par exemple, sur certains systèmes, un chemin d’accès peut commencer par une lettre de lecteur ou volume, alors que cet élément n’est pas présent dans d’autres systèmes.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</source>
          <target state="translated">Sur certains systèmes, les chemins d’accès de fichier peuvent contenir des extensions, qui indiquent le type d’informations stockées dans le fichier.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</source>
          <target state="translated">Le format d’une extension de nom de fichier est dépendante de la plateforme ; par exemple, certains systèmes limitent les extensions à trois caractères, et d’autres ne le font pas.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</source>
          <target state="translated">La plateforme actuelle détermine également le jeu de caractères utilisé pour séparer les éléments d’un chemin d’accès et le jeu de caractères qui ne peut pas être utilisé lors de la spécification des chemins d’accès.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because of these differences, the fields of the <ph id="ph1">`Path`</ph> class as well as the exact behavior of some members of the <ph id="ph2">`Path`</ph> class are platform-dependent.</source>
          <target state="translated">En raison de ces différences, les champs de la <ph id="ph1">`Path`</ph> classe, ainsi que le comportement exact de certains membres de la <ph id="ph2">`Path`</ph> classe sont dépendants de la plateforme.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path can contain absolute or relative location information.</source>
          <target state="translated">Un chemin d’accès peut contenir des informations d’emplacement absolu ou relatif.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</source>
          <target state="translated">Chemins d’accès absolus spécifient un emplacement : le fichier ou le répertoire peut être identifiée, quelle que soit l’emplacement actuel.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</source>
          <target state="translated">Chemins d’accès relatifs spécifient un emplacement partiel : l’emplacement actuel est utilisé comme point de départ lors de la localisation d’un fichier spécifié avec un chemin d’accès relatif.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>To determine the current directory, call <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour déterminer le répertoire actif, appelez <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Most members of the <ph id="ph1">`Path`</ph> class do not interact with the file system and do not verify the existence of the file specified by a path string.</source>
          <target state="translated">La plupart des membres de la <ph id="ph1">`Path`</ph> n’interagissent pas avec le système de fichiers de classe et ne pas vérifier l’existence du fichier spécifié par une chaîne de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> class members that modify a path string, such as <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, have no effect on names of files in the file system.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> classe les membres qui modifient une chaîne de chemin d’accès, tel que <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, n’ont aucun effet sur les noms de fichiers dans le système de fichiers.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> members do, however, validate the contents of a specified path string, and throw an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> membres faire, toutefois, valider le contenu d’une chaîne de chemin d’accès spécifié et lève un <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception si la chaîne contient des caractères qui ne sont pas valides dans les chaînes de chemin d’accès, tel que défini dans les caractères renvoyés à partir de la <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</source>
          <target state="translated">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure les guillemets («), inférieur à (<ph id="ph1">\&lt;</ph>), supérieur à (&gt;), canal (&amp;#124;), retour arrière (\b), null (\0) et les caractères Unicode 16 et 18 et 20 et 25.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The members of the <ph id="ph1">`Path`</ph> class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</source>
          <target state="translated">Les membres de la <ph id="ph1">`Path`</ph> classe permettent d’exécuter rapidement et facilement des opérations courantes telles que la détermination de si une extension de nom de fichier fait partie d’un chemin d’accès et combiner deux chaînes en un nom d’un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>All members of the <ph id="ph1">`Path`</ph> class are static and can therefore be called without having an instance of a path.</source>
          <target state="translated">Tous les membres de la <ph id="ph1">`Path`</ph> classe sont statique et peuvent donc être appelés sans disposer d’une instance d’un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path as an input string, that path must be well-formed or an exception is raised.</source>
          <target state="translated">Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement formé ou une exception est levée.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</source>
          <target state="translated">Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Therefore, the path is malformed and an exception is raised.</source>
          <target state="translated">Par conséquent, le chemin d’accès est incorrect et une exception est levée.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Similarly, a path or a combination of paths cannot be fully qualified twice.</source>
          <target state="translated">De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, "c:\temp c:\windows" also raises an exception in most cases.</source>
          <target state="translated">Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Ensure that your paths are well-formed when using methods that accept a path string.</source>
          <target state="translated">Assurez-vous que vos chemins d’accès sont corrects lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path, the path can refer to a file or just a directory.</source>
          <target state="translated">Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</source>
          <target state="translated">Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de partage et de serveur.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, all the following are acceptable paths:</source>
          <target state="translated">Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</source>
          <target state="translated">« c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir" in C#, or "c:\MyDir" in Visual Basic.</source>
          <target state="translated">« c:<ph id="ph1">\\</ph>\MyDir » en c# ou « c:\MyDir » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"MyDir<ph id="ph1">\\</ph>\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</source>
          <target state="translated">« MyDir<ph id="ph1">\\</ph>\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#, or "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</source>
          <target state="translated">«<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare » en c#, ou «<ph id="ph5">\\</ph>\MyServer\MyShare » en Visual Basic.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</source>
          <target state="translated">Toutes ces opérations sont effectuées sur les chaînes, il est impossible de vérifier que les résultats sont valides dans tous les scénarios.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, the <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> method parses a string that you pass to it and returns the extension from that string.</source>
          <target state="translated">Par exemple, le <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> méthode analyse une chaîne que vous passez à celui-ci et retourne l’extension de cette chaîne.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>However, this does not mean that a file with that extension exists on the disk.</source>
          <target state="translated">Toutefois, cela ne signifie pas qu’un fichier avec cette extension existe sur le disque.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The following code example demonstrates some of the main members of the <ph id="ph1">`Path`</ph> class.</source>
          <target state="translated">L’exemple de code suivant illustre certains membres principaux de la <ph id="ph1">`Path`</ph> classe.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Fournit un caractère de remplacement spécifique à la plateforme, utilisé pour séparer les niveaux de répertoire dans une chaîne de chemin d'accès qui reflète une organisation de système de fichiers hiérarchique.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">Le caractère stocké dans ce champ ne peut pas être <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>This field can be set to the same value as <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Ce champ peut être défini sur la même valeur que <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source><ph id="ph1">`AltDirectorySeparatorChar`</ph> and <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">`AltDirectorySeparatorChar`</ph> et <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> sont toutes deux valides pour séparer les niveaux de répertoire dans une chaîne de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</source>
          <target state="translated">La valeur de ce champ est une barre oblique (« / ») sur les systèmes d’exploitation Windows, UNIX et Macintosh.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The following code example demonstrates a use of the <ph id="ph1">`AltDirectorySeparatorChar`</ph> field.</source>
          <target state="translated">L’exemple de code suivant illustre une utilisation de la <ph id="ph1">`AltDirectorySeparatorChar`</ph> champ.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path information to modify.</source>
          <target state="translated">Informations relatives au chemin d’accès à modifier.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path cannot contain any of the characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Le chemin d'accès ne peut contenir aucun des caractères définis dans <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The new extension (with or without a leading period).</source>
          <target state="translated">Nouvelle extension (avec ou sans point de début).</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> to remove an existing extension from <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see langword="null" /&gt;</ph> pour supprimer une extension existante de <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Changes the extension of a path string.</source>
          <target state="translated">Modifie l’extension d’une chaîne de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The modified path information.</source>
          <target state="translated">Informations relatives au chemin d’accès modifiées.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>On Windows-based desktop platforms, if <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string (""), the path information is returned unmodified.</source>
          <target state="translated">Sur les plateformes de bureau Windows, si <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou est une chaîne vide (""), les informations relatives au chemin d'accès sont retournées inchangées.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the returned string contains the specified path with its extension removed.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, la chaîne retournée contient le chemin d'accès spécifié avec l'extension supprimée.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> has no extension, and <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the returned path string contains <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> appended to the end of <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="path" /&gt;</ph> ne possède pas d'extension et si <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> n'est pas <ph id="ph3">&lt;see langword="null" /&gt;</ph>, la chaîne du chemin d'accès retournée contient <ph id="ph4">&lt;paramref name="extension" /&gt;</ph>, ajouté à la fin de <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If neither <ph id="ph1">`path`</ph> nor <ph id="ph2">`extension`</ph> contains a period (.), <ph id="ph3">`ChangeExtension`</ph> adds the period.</source>
          <target state="translated">Si ni <ph id="ph1">`path`</ph> ni <ph id="ph2">`extension`</ph> contient un point (.), <ph id="ph3">`ChangeExtension`</ph> ajoute le point.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The <ph id="ph1">`extension`</ph> parameter can contain multiple periods and any valid path characters, and can be any length.</source>
          <target state="translated">Le <ph id="ph1">`extension`</ph> paramètre peut contenir plusieurs périodes et les caractères de chemin d’accès valide et peut être n’importe quelle longueur.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is <ph id="ph2">`null`</ph>, the returned string contains the contents of <ph id="ph3">`path`</ph> with the last period and all characters following it removed.</source>
          <target state="translated">Si <ph id="ph1">`extension`</ph> est <ph id="ph2">`null`</ph>, la chaîne retournée contient le contenu de <ph id="ph3">`path`</ph> avec la dernière période et tous les caractères après celui-ci supprimé.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is an empty string, the returned path string contains the contents of <ph id="ph2">`path`</ph> with any characters following the last period removed.</source>
          <target state="translated">Si <ph id="ph1">`extension`</ph> est une chaîne vide, la chaîne de chemin d’accès retournée contient le contenu de <ph id="ph2">`path`</ph> avec les caractères après le dernier point supprimé.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> does not have an extension and <ph id="ph2">`extension`</ph> is not <ph id="ph3">`null`</ph>, the returned string contains <ph id="ph4">`path`</ph> followed by <ph id="ph5">`extension`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> ne possède pas d’extension et <ph id="ph2">`extension`</ph> n’est pas <ph id="ph3">`null`</ph>, la chaîne retournée contient <ph id="ph4">`path`</ph> suivie <ph id="ph5">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is not <ph id="ph2">`null`</ph> and does not contain a leading period, the period is added.</source>
          <target state="translated">Si <ph id="ph1">`extension`</ph> n’est pas <ph id="ph2">`null`</ph> et ne contient pas de point de début, la période est ajoutée.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> contains a multiple extension separated by multiple periods, the returned string contains the contents of <ph id="ph2">`path`</ph> with the last period and all characters following it replaced by <ph id="ph3">`extension`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> contient plusieurs extensions séparées par plusieurs points, la chaîne retournée contient le contenu de <ph id="ph2">`path`</ph> avec la dernière période et tous les caractères suivant remplacé par <ph id="ph3">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is "\Dir1\examples\pathtests.csx.txt" and <ph id="ph2">`extension`</ph> is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</source>
          <target state="translated">Par exemple, si <ph id="ph1">`path`</ph> est « \Dir1\examples\pathtests.csx.txt » et <ph id="ph2">`extension`</ph> est « cs », le chemin d’accès modifié est « \Dir1\examples\pathtests.csx.cs ».</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>It is not possible to verify that the returned results are valid in all scenarios.</source>
          <target state="translated">Il n’est pas possible de vérifier que les résultats retournés sont valides dans tous les scénarios.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is empty, <ph id="ph2">`extension`</ph> is appended.</source>
          <target state="translated">Par exemple, si <ph id="ph1">`path`</ph> est vide, <ph id="ph2">`extension`</ph> est ajouté.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`ChangeExtension`</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une utilisation de la <ph id="ph1">`ChangeExtension`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Combines strings into a path.</source>
          <target state="translated">Combine des chaînes en un chemin d'accès.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>An array of parts of the path.</source>
          <target state="translated">Tableau de parties du chemin d’accès.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Combines an array of strings into a path.</source>
          <target state="translated">Combine un tableau de chaînes en un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The combined paths.</source>
          <target state="translated">Chemins d'accès combinés.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source><ph id="ph1">`paths`</ph> should be an array of the parts of the path to combine.</source>
          <target state="translated"><ph id="ph1">`paths`</ph> doit être un tableau des parties du chemin d’accès à combiner.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</source>
          <target state="translated">Si l’un des chemins d’accès suivants est un chemin d’accès absolu, l’opération de combinaison réinitialise commençant par ce chemin d’accès absolu, en ignorant tous les chemins d’accès combinés précédents.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Chaînes de longueur nulle sont omises dans le chemin combiné.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par la <ph id="ph1">`Combine`</ph> (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Par exemple, <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> peut être incorrect si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Il est donc interprété correctement par le <ph id="ph1">`Combine`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The following example combines an array of strings into a path.</source>
          <target state="translated">L’exemple suivant combine un tableau de chaînes en un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array contains one or more of the invalid characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">L’une des chaînes du tableau contient un ou plusieurs des caractères non valides définis dans <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L’une des chaînes du tableau est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Premier chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Deuxième chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Combines two strings into a path.</source>
          <target state="translated">Combine deux chaînes en un chemin d’accès.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Chemins d'accès combinés.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If one of the specified paths is a zero-length string, this method returns the other path.</source>
          <target state="translated">Si un des chemins d’accès spécifiés est une chaîne de longueur zéro, cette méthode retourne l’autre chemin d’accès.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contains an absolute path, this method returns <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contient un chemin d'accès absolu, cette méthode retourne <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Si <ph id="ph1">`path1`</ph> n’est pas une référence de lecteur (« C: » ou « D ») et ne se termine pas par un caractère de séparation valide comme défini dans <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, ou <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> est ajouté à <ph id="ph6">`path1`</ph> avant la concaténation.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> n’inclut pas de racine (par exemple, si <ph id="ph2">`path2`</ph> ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> inclut une racine, <ph id="ph2">`path2`</ph> est retourné.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph> instead of returning only <ph id="ph5">`path2`</ph>.</source>
          <target state="translated">Par conséquent, si <ph id="ph1">`path2`</ph> inclut un espace blanc (par exemple, « \file.txt »), le <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> méthode ajoute <ph id="ph3">`path2`</ph> à <ph id="ph4">`path1`</ph> au lieu de retourner uniquement <ph id="ph5">`path2`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par la <ph id="ph1">`Combine`</ph> (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Par exemple, <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> peut être incorrect si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Il est donc interprété correctement par le <ph id="ph1">`Combine`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`Combine`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser la <ph id="ph1">`Combine`</ph> méthode sur une plateforme de bureau Windows.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Premier chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Deuxième chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Troisième chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Combines three strings into a path.</source>
          <target state="translated">Combine trois chaînes en un chemin d'accès.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Chemins d'accès combinés.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").</source>
          <target state="translated"><ph id="ph1">`path1`</ph> doit être un chemin d’accès absolu (par exemple, « d:\archives » ou «<ph id="ph2">\\</ph>\archives\public »).</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> or <ph id="ph2">`path3`</ph> is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> ou <ph id="ph2">`path3`</ph> est également un chemin d’accès absolu, les chemins d’accès de combiner opération ignore tout précédemment combinés et réinitialise ce chemin d’accès absolu.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Chaînes de longueur nulle sont omises dans le chemin combiné.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Si <ph id="ph1">`path1`</ph> n’est pas une référence de lecteur (« C: » ou « D ») et ne se termine pas par un caractère de séparation valide comme défini dans <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, ou <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> est ajouté à <ph id="ph6">`path1`</ph> avant la concaténation.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> n’inclut pas de racine (par exemple, si <ph id="ph2">`path2`</ph> ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> inclut une racine, <ph id="ph2">`path2`</ph> est retourné.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">Par conséquent, si <ph id="ph1">`path2`</ph> inclut un espace blanc (par exemple, « \file.txt »), le <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> méthode ajoute <ph id="ph3">`path2`</ph> à <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par la <ph id="ph1">`Combine`</ph> (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Par exemple, <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> peut être incorrect si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Il est donc interprété correctement par le <ph id="ph1">`Combine`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The following example combines three paths.</source>
          <target state="translated">L’exemple suivant combine trois chemins d’accès.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> est <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Premier chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Deuxième chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Troisième chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The fourth path to combine.</source>
          <target state="translated">Quatrième chemin d'accès à combiner.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Combines four strings into a path.</source>
          <target state="translated">Combine quatre chaînes en un chemin d'accès.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Chemins d'accès combinés.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated"><ph id="ph1">`path1`</ph> doit être un chemin d’accès absolu (par exemple, « d:\archives » ou «<ph id="ph2">\\</ph>\archives\public »). Si un des chemins d’accès suivants est également un chemin d’accès absolu, l’opération de combinaison ignore tous les chemins d’accès précédemment combinés et réinitialise ce chemin d’accès absolu.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Chaînes de longueur nulle sont omises dans le chemin combiné.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Si <ph id="ph1">`path1`</ph> n’est pas une référence de lecteur (« C: » ou « D ») et ne se termine pas par un caractère de séparation valide comme défini dans <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, ou <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> est ajouté à <ph id="ph6">`path1`</ph> avant la concaténation.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> n’inclut pas de racine (par exemple, si <ph id="ph2">`path2`</ph> ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">`path2`</ph> inclut une racine, <ph id="ph2">`path2`</ph> est retourné.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">Par conséquent, si <ph id="ph1">`path2`</ph> inclut un espace blanc (par exemple, « \file.txt »), le <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> méthode ajoute <ph id="ph3">`path2`</ph> à <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par la <ph id="ph1">`Combine`</ph> (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Par exemple, <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> peut être incorrect si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Il est donc interprété correctement par le <ph id="ph1">`Combine`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The following example combines four paths.</source>
          <target state="translated">L’exemple suivant combine quatre chemins d’accès.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> ou <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> ou <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> a la valeur <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Fournit un caractère spécifique à la plateforme, utilisé pour séparer les niveaux de répertoire dans une chaîne de chemin d'accès qui reflète une organisation de système de fichiers hiérarchique.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">Le caractère stocké dans ce champ ne peut pas être <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> and <ph id="ph2">`DirectorySeparatorChar`</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> et <ph id="ph2">`DirectorySeparatorChar`</ph> sont toutes deux valides pour séparer les niveaux de répertoire dans une chaîne de chemin d’accès.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`DirectorySeparatorChar`</ph> field.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">`DirectorySeparatorChar`</ph> champ.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The path of a file or directory.</source>
          <target state="translated">Chemin d’accès d’un fichier ou d’un répertoire.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns the directory information for the specified path string.</source>
          <target state="translated">Retourne les informations relatives au répertoire pour la chaîne de chemin d’accès spécifiée.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Directory information for <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if <ph id="ph3">&lt;paramref name="path" /&gt;</ph> denotes a root directory or is null.</source>
          <target state="translated">Informations relatives au répertoire pour <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> si <ph id="ph3">&lt;paramref name="path" /&gt;</ph> indique un répertoire racine ou est null.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> does not contain directory information.</source>
          <target state="translated">Retourne un élément <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> si <ph id="ph2">&lt;paramref name="path" /&gt;</ph> ne contient pas d'informations relatives au répertoire.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In most cases, the string returned by this method consists of all characters in the path up to but not including the last <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Dans la plupart des cas, la chaîne retournée par cette méthode comprend tous les caractères dans le chemin d’accès des mais sans inclure le dernier <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> ou <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>If the path consists of a root directory, such as "c:<ph id="ph1">\\</ph>", null is returned.</source>
          <target state="translated">Si le chemin d’accès se compose d’un répertoire racine, telle que « c:<ph id="ph1">\\</ph>», la valeur null est retournée.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Note that this method does not support paths using "file:".</source>
          <target state="translated">Notez que cette méthode ne prend pas en charge les chemins d’accès à l’aide de « fichier : ».</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Because the returned path does not include the <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, passing the returned path back into the <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will result in the truncation of one folder level per subsequent call on the result string.</source>
          <target state="translated">Étant donné que le chemin d’accès retourné n’inclut pas le <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> ou <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, en passant le chemin d’accès retourné de nouveau la <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> méthode entraînera la troncation d’un niveau de dossier chaque appel suivant sur la chaîne de résultat.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will return "C:\Directory\SubDirectory".</source>
          <target state="translated">Par exemple, en passant le chemin d’accès « C:\Directory\SubDirectory\test.txt » dans la <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> méthode retournera « C:\Directory\SubDirectory ».</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Passing that string, "C:\Directory\SubDirectory", into <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> will result in "C:\Directory".</source>
          <target state="translated">Passage de cette chaîne, « C:\Directory\SubDirectory », dans <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> entraîne « C:\Directory ».</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetDirectoryName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser la <ph id="ph1">`GetDirectoryName`</ph> méthode sur une plateforme de bureau Windows.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter contains invalid characters, is empty, or contains only white spaces.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Dans <bpt id="p1">[</bpt>.NET pour les applications du Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou la <bpt id="p2">[</bpt>Bibliothèque de classes portable<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, interceptez l’exception de la classe de base, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, à la place.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is longer than the system-defined maximum length.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est plus long que la longueur maximale définie par le système.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The path string from which to get the extension.</source>
          <target state="translated">Chaîne de chemin d’accès pour laquelle obtenir l’extension.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>Returns the extension of the specified path string.</source>
          <target state="translated">Retourne l’extension de la chaîne de chemin d’accès spécifiée.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of the specified path (including the period "."), or <ph id="ph1">&lt;see langword="null" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Extension du chemin d'accès spécifié (y compris le point ".") ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> retourne <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not have extension information, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="path" /&gt;</ph> ne contient pas d'informations relatives à l'extension, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> retourne <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of <ph id="ph1">`path`</ph> is obtained by searching <ph id="ph2">`path`</ph> for a period (.), starting with the last character in path and continuing toward the start of path.</source>
          <target state="translated">L’extension de <ph id="ph1">`path`</ph> s’obtient en recherchant <ph id="ph2">`path`</ph> pour un point (.), en commençant par le dernier caractère du chemin d’accès et en continuant vers le début du chemin d’accès.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If a period is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> character, the returned string contains the period and the characters after it; otherwise, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> is returned.</source>
          <target state="translated">Si un point est trouvé avant un <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> ou <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> caractères, la chaîne retournée contient la période et les caractères après celui-ci ; sinon, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> est retourné.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetExtension`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser la <ph id="ph1">`GetExtension`</ph> méthode sur une plateforme de bureau Windows.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The path string from which to obtain the file name and extension.</source>
          <target state="translated">Chaîne de chemin d’accès à partir de laquelle obtenir le nom et l’extension de fichier.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>Returns the file name and extension of the specified path string.</source>
          <target state="translated">Retourne le nom et l’extension de fichier de la chaîne de chemin d’accès spécifiée.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The characters after the last directory character in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Caractères situés après le dernier caractère du répertoire dans <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If the last character of <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a directory or volume separator character, this method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Si le dernier caractère de <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est un caractère de séparation de répertoire ou de volume, cette méthode retourne <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>, cette méthode retourne <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The returned value is <ph id="ph1">`null`</ph> if the file path is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">La valeur retournée est <ph id="ph1">`null`</ph> si le chemin d’accès du fichier est <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The separator characters used to determine the start of the file name are <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Les caractères de séparation utilisés pour déterminer le début du nom de fichier sont <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The following code example demonstrates the behavior of the <ph id="ph1">`GetFileName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">L’exemple de code suivant illustre le comportement de la <ph id="ph1">`GetFileName`</ph> méthode sur une plateforme de bureau Windows.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The path of the file.</source>
          <target state="translated">Chemin d’accès au fichier.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>Returns the file name of the specified path string without the extension.</source>
          <target state="translated">Retourne le nom de fichier de la chaîne de chemin d’accès spécifiée sans l’extension.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The string returned by <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, minus the last period (.) and all characters following it.</source>
          <target state="translated">Chaîne retournée par <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, moins le dernier point (.) et tous les caractères après celui-ci.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetFileNameWithoutExtension`</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une utilisation de la <ph id="ph1">`GetFileNameWithoutExtension`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory for which to obtain absolute path information.</source>
          <target state="translated">Fichier ou répertoire pour lequel obtenir les informations sur le chemin d’accès absolu.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Returns the absolute path for the specified path string.</source>
          <target state="translated">Retourne le chemin d’accès absolu de la chaîne de chemin d’accès spécifiée.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The fully qualified location of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:\MyFile.txt".</source>
          <target state="translated">Emplacement qualifié complet de <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, par exemple « C:\MonFichier.txt ».</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0 ».</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The absolute path includes all information required to locate a file or directory on a system.</source>
          <target state="translated">Le chemin d’accès absolu inclut toutes les informations requises pour rechercher un fichier ou répertoire sur un système.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory specified by <ph id="ph1">`path`</ph> is not required to exist.</source>
          <target state="translated">Le fichier ou le répertoire spécifié par <ph id="ph1">`path`</ph> n’est pas requis pour exister.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, if c:\temp\newdir is the current directory, calling <ph id="ph1">`GetFullPath`</ph> on a file name such as test.txt returns c:\temp\newdir\test.txt.</source>
          <target state="translated">Par exemple, si c:\temp\newdir est le répertoire actif, l’appel <ph id="ph1">`GetFullPath`</ph> sur un fichier de nom, tel que test.txt retourne c:\temp\newdir\test.txt.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file need not exist.</source>
          <target state="translated">Le fichier ne doit pas exister.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>However, if <ph id="ph1">`path`</ph> does exist, the caller must have permission to obtain path information for <ph id="ph2">`path`</ph>.</source>
          <target state="translated">Toutefois, si <ph id="ph1">`path`</ph> existe, l’appelant doit avoir l’autorisation pour obtenir des informations de chemin d’accès pour <ph id="ph2">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Note that unlike most members of the <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> class, this method accesses the file system.</source>
          <target state="translated">Notez que contrairement à la plupart des membres de la <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> (classe), cette méthode accède au système de fichiers.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>This method uses current directory and current volume information to fully qualify <ph id="ph1">`path`</ph>.</source>
          <target state="translated">Cette méthode utilise Active directory et les informations de volume actuel pour qualifier complètement <ph id="ph1">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you specify a file name only in <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> returns the fully qualified path of the current directory.</source>
          <target state="translated">Si vous spécifiez un fichier de nom uniquement dans <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> retourne le chemin d’accès qualifié complet du répertoire actuel.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you pass in a short file name, it is expanded to a long file name.</source>
          <target state="translated">Si vous passez dans un nom de fichier court, il est étendu à un nom de fichier long.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</source>
          <target state="translated">Si un chemin d’accès ne contient pas de caractères significatifs qu’il n’est pas valide, sauf si elle contient un ou plusieurs «. « caractères suivis par n’importe quel nombre d’espaces, puis il sera analysé en tant que ». « ou ».. ».</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The following code example demonstrates the <ph id="ph1">`GetFullPath`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">`GetFullPath`</ph> méthode sur une plateforme de bureau Windows.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est une chaîne de longueur nulle, ne contient que des espaces blancs ou contient un ou plusieurs des caractères non valides définis par <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The system could not retrieve the absolute path.</source>
          <target state="translated">Le système n’a pas pu récupérer le chemin d’accès absolu.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">L’appelant n’a pas les autorisations requises.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon (":") that is not part of a volume identifier (for example, "c:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un caractère deux-points (« : ») qui ne fait pas partie d’un identificateur de volume (par exemple, « c:<ph id="ph2">\\</ph> »).</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Par exemple, sur les plateformes Windows, les chemins ne doivent pas dépasser 248 caractères et les noms de fichiers ne doivent pas dépasser 260 caractères.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>for access to the path.</source>
          <target state="translated">Pour accéder au chemin d’accès.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>Gets an array containing the characters that are not allowed in file names.</source>
          <target state="translated">Obtient un tableau contenant les caractères qui ne sont pas autorisés dans les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>An array containing the characters that are not allowed in file names.</source>
          <target state="translated">Tableau contenant les caractères qui ne sont pas autorisés dans les noms de fichiers.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Le tableau retourné par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">L’ensemble complet des caractères non valides peut varier selon le système de fichier.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin d’accès non valide peuvent contenir des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (<ph id="ph1">\&lt;</ph>), supérieur à (&gt;), canal (&amp;#124;), retour arrière (\b), null (\0) et tabulation (\t).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> pour récupérer les caractères non valides.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>Gets an array containing the characters that are not allowed in path names.</source>
          <target state="translated">Obtient un tableau contenant les caractères qui ne sont pas autorisés dans les noms de chemins d’accès.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>An array containing the characters that are not allowed in path names.</source>
          <target state="translated">Tableau contenant les caractères qui ne sont pas autorisés dans les noms de chemins d’accès.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Le tableau retourné par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">L’ensemble complet des caractères non valides peut varier selon le système de fichier.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin d’accès non valide peuvent contenir des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (<ph id="ph1">\&lt;</ph>), supérieur à (&gt;), canal (&amp;#124;), retour arrière (\b), null (\0) et tabulation (\t).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">L’exemple de code suivant montre la <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> pour récupérer les caractères non valides.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The path from which to obtain root directory information.</source>
          <target state="translated">Chemin d’accès à partir duquel obtenir les informations relatives au répertoire racine.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Gets the root directory information of the specified path.</source>
          <target state="translated">Obtient les informations relatives au répertoire racine du chemin d’accès spécifié.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The root directory of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:<ph id="ph2">\\</ph>", or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if <ph id="ph4">&lt;paramref name="path" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>, or an empty string if <ph id="ph6">&lt;paramref name="path" /&gt;</ph> does not contain root directory information.</source>
          <target state="translated">Répertoire racine de <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, par exemple « C:<ph id="ph2">\\</ph> », ou <ph id="ph3">&lt;see langword="null" /&gt;</ph> si <ph id="ph4">&lt;paramref name="path" /&gt;</ph> est <ph id="ph5">&lt;see langword="null" /&gt;</ph>, ou une chaîne vide si <ph id="ph6">&lt;paramref name="path" /&gt;</ph> ne contient pas d’informations relatives au répertoire racine.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Possible patterns for the string returned by this method are as follows:</source>
          <target state="translated">Les modèles possibles pour la chaîne retournée par cette méthode sont les suivantes :</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>An empty string (<ph id="ph1">`path`</ph> specified a relative path on the current drive or volume).</source>
          <target state="translated">Une chaîne vide (<ph id="ph1">`path`</ph> spécifié un chemin d’accès relatif sur le lecteur en cours ou le volume).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"/" (<ph id="ph1">`path`</ph> specified an absolute path on the current drive).</source>
          <target state="translated">« / » (<ph id="ph1">`path`</ph> spécifié un chemin d’accès absolu sur le lecteur actif).</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:" (<ph id="ph1">`path`</ph> specified a relative path on a drive, where X represents a drive or volume letter).</source>
          <target state="translated">« X » (<ph id="ph1">`path`</ph> spécifié un chemin d’accès relatif sur un lecteur, où X représente une lettre de lecteur ou volume).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:/" (<ph id="ph1">`path`</ph> specified an absolute path on a given drive).</source>
          <target state="translated">« X: / » (<ph id="ph1">`path`</ph> spécifié un chemin d’accès absolu sur un lecteur donné).</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (a UNC path).</source>
          <target state="translated">«<ph id="ph1">\\</ph>\ComputerName\SharedFolder » (un chemin d’accès UNC).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0 ».</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetPathRoot`</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre une utilisation de la <ph id="ph1">`GetPathRoot`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> was passed to <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> a été passé à <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>Returns a random folder name or file name.</source>
          <target state="translated">Retourne un nom de dossier ou de fichier aléatoire.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>A random folder name or file name.</source>
          <target state="translated">Nom de dossier ou de fichier aléatoire.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> méthode retourne une chaîne aléatoire et forte qui peut être utilisée comme nom de dossier ou un nom de fichier.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>Unlike <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> does not create a file.</source>
          <target state="translated">Contrairement aux <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> ne crée pas un fichier.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>When the security of your file system is paramount, this method should be used instead of <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</source>
          <target state="translated">Lorsque la sécurité de votre système de fichiers est primordiale, cette méthode doit être utilisée à la place de <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The following example show output from the <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant montre la sortie de la <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</source>
          <target state="translated">Crée un fichier temporaire de zéro octet nommé de façon univoque sur le disque et retourne le chemin d’accès complet de ce fichier.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>The full path of the temporary file.</source>
          <target state="translated">Chemin d’accès complet du fichier temporaire.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>This method creates a temporary file with a .TMP file extension.</source>
          <target state="translated">Cette méthode crée un fichier temporaire avec un. Extension de fichier TMP.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The temporary file is created within the user’s temporary folder, which is the path returned by the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Le fichier temporaire est créé dans le dossier temporaire de l’utilisateur, qui est le chemin d’accès retourné par la <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if it is used to create more than 65535 files without deleting previous temporary files.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> méthode déclenchera un <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> s’il est utilisé pour créer plus de 65 535 fichiers sans supprimer les fichiers temporaires précédents.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if no unique temporary file name is available.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> méthode déclenchera un <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> si aucun nom de fichier temporaire unique n’est disponible.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>To resolve this error, delete all unneeded temporary files.</source>
          <target state="translated">Pour résoudre cette erreur, supprimez tous les fichiers temporaires inutiles.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>An I/O error occurs, such as no unique temporary file name is available.</source>
          <target state="translated">Une erreur d’E/S se produit, par exemple si aucun nom de fichier temporaire unique n’est disponible.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> ou -</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>This method was unable to create a temporary file.</source>
          <target state="translated">Cette méthode n’a pas pu créer un fichier temporaire.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>for writing to the temporary directory.</source>
          <target state="translated">pour écrire dans le répertoire temporaire.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>Returns the path of the current user's temporary folder.</source>
          <target state="translated">Retourne le chemin d’accès du dossier temporaire de l’utilisateur actuel.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The path to the temporary folder, ending with a backslash.</source>
          <target state="translated">Chemin d’accès au dossier temporaire, se terminant par une barre oblique inverse.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This method checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">Cette méthode vérifie l’existence de variables d’environnement dans l’ordre suivant et utilise le premier chemin d’accès trouvé :</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TMP environment variable.</source>
          <target state="translated">Le chemin d’accès spécifié par la variable d’environnement TMP.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TEMP environment variable.</source>
          <target state="translated">Le chemin d’accès spécifié par la variable d’environnement TEMP.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the USERPROFILE environment variable.</source>
          <target state="translated">Le chemin d’accès spécifié par la variable d’environnement USERPROFILE.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The Windows directory.</source>
          <target state="translated">Le répertoire Windows.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The following code shows how to call the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Le code suivant montre comment appeler la méthode <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This example produces output similar to the following.</source>
          <target state="translated">Cet exemple génère la sortie est similaire à ce qui suit.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">L’appelant n’a pas les autorisations requises.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>for unrestricted access to environment variables.</source>
          <target state="translated">pour un accès illimité aux variables d’environnement.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The path to search for an extension.</source>
          <target state="translated">Chemin d’accès où rechercher une extension.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Determines whether a path includes a file name extension.</source>
          <target state="translated">Détermine si un chemin d’accès inclut une extension de nom de fichier.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the characters that follow the last directory separator (<ph id="ph2">\\</ph>\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si les caractères qui suivent le dernier séparateur de répertoire (<ph id="ph2">\\</ph>\ ou /) ou le dernier séparateur de volume (:) dans le chemin d’accès incluent un point (.) suivi d’un ou plusieurs caractères ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Starting from the end of <ph id="ph1">`path`</ph>, this method searches for a period (.) followed by at least one character.</source>
          <target state="translated">À partir de la fin de <ph id="ph1">`path`</ph>, cette méthode recherche un point (.) suivi d’au moins un caractère.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>If this pattern is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> character is encountered, this method returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Si ce modèle est trouvé avant un <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, ou <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> caractère est rencontré, cette méthode retourne <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The following code example demonstrates the use of the <ph id="ph1">`HasExtension`</ph> method.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">`HasExtension`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.IO.Path.InvalidPathChars">
          <source>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> class.</source>
          <target state="translated">Fournit un tableau de caractères (spécifique à la plateforme) qui ne peuvent pas être spécifiés dans des arguments de chaîne de chemin d'accès passés aux membres de la classe <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Le tableau retourné par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">L’ensemble complet des caractères non valides peut varier selon le système de fichier.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin d’accès non valide peuvent contenir des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (<ph id="ph1">\&lt;</ph>), supérieur à (&gt;), canal (&amp;#124;), retour arrière (\b), null (\0) et tabulation (\t).</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>Do not use <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> if you think your code might execute in the same application domain as untrusted code.</source>
          <target state="translated">N’utilisez pas <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> si vous pensez que votre code peut s’exécuter dans le même domaine d’application en tant que code non fiable.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> is an array, so its elements can be overwritten.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> est un tableau, donc ses éléments peuvent être remplacés.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>If untrusted code overwrites elements of <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, it might cause your code to malfunction in ways that could be exploited.</source>
          <target state="translated">Si le code non fiable remplace des éléments de <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, elle peut entraîner votre code un dysfonctionnement d’une manière qui pourrait être exploitée.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The following code example demonstrates the use of the <ph id="ph1">`InvalidPathChars`</ph> property.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">`InvalidPathChars`</ph> propriété.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The path to test.</source>
          <target state="translated">Chemin d’accès à tester.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>Gets a value indicating whether the specified path string contains a root.</source>
          <target state="translated">Obtient une valeur indiquant si la chaîne de chemin d’accès spécifiée contient une racine.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contains a root; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contient une racine ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the first character is a directory separator character such as "<ph id="ph3">\\</ph>", or if the path starts with a drive letter and colon (:).</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> méthode retourne <ph id="ph2">`true`</ph> si le premier caractère est un caractère de séparation de répertoire tel que «<ph id="ph3">\\</ph>», ou si le chemin d’accès commence par une lettre de lecteur et le signe deux-points ( :).</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For example, it returns <ph id="ph1">`true`</ph> for <ph id="ph2">`path`</ph> strings such as "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "C:<ph id="ph5">\\</ph>\MyDir", or "C:MyDir".</source>
          <target state="translated">Par exemple, elle retourne <ph id="ph1">`true`</ph> pour <ph id="ph2">`path`</ph> tels que des chaînes «<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt », « C:<ph id="ph5">\\</ph>\MyDir », ou « C : mydir ».</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>It returns <ph id="ph1">`false`</ph> for <ph id="ph2">`path`</ph> strings such as "MyDir".</source>
          <target state="translated">Elle retourne <ph id="ph1">`false`</ph> pour <ph id="ph2">`path`</ph> chaînes telles que « MyDir ».</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Pour obtenir la liste des tâches d’e/s courantes, consultez <bpt id="p1">[</bpt>des tâches d’e/s courantes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The following code example demonstrates how the <ph id="ph1">`IsPathRooted`</ph> method can be used to test three strings.</source>
          <target state="translated">L’exemple de code suivant montre comment la <ph id="ph1">`IsPathRooted`</ph> méthode peut être utilisée pour tester trois chaînes.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contient un ou plusieurs caractères non valides définis dans <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="F:System.IO.Path.PathSeparator">
          <source>A platform-specific separator character used to separate path strings in environment variables.</source>
          <target state="translated">Caractère de séparation spécifique à la plateforme, utilisé pour séparer les chaînes de chemin d’accès dans les variables d’environnement.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</source>
          <target state="translated">Sur les plateformes de bureau Windows, la valeur de ce champ est le point-virgule ( ;) par défaut, mais peut varier sur d’autres plateformes.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>The following code example demonstrates the use of the <ph id="ph1">`PathSeparator`</ph> field.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">`PathSeparator`</ph> champ.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>Provides a platform-specific volume separator character.</source>
          <target state="translated">Fournit un caractère de séparation de volume spécifique à la plateforme.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</source>
          <target state="translated">La valeur de ce champ est un signe deux-points ( :) sur Windows, Macintosh et une barre oblique (/) sur les systèmes d’exploitation UNIX.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</source>
          <target state="translated">Cela est particulièrement utile pour l’analyse des chemins d’accès tel que « c:\windows » ou « Dossier MacVolume : System ».</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`VolumeSeparatorChar`</ph> field.</source>
          <target state="translated">L’exemple de code suivant illustre l’utilisation de la <ph id="ph1">`VolumeSeparatorChar`</ph> champ.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>