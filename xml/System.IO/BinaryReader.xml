<Type Name="BinaryReader" FullName="System.IO.BinaryReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="22a75f9b356ec6c35a6b7fdfaaf1447ea2b69f02" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420013" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BinaryReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BinaryReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.BinaryReader" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryReader : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Lit les types de données primitifs sous forme de valeurs binaires avec un encodage spécifique.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.IO.BinaryReader> classe fournit des méthodes qui simplifient la lecture des types de données primitifs à partir d’un flux de données. Par exemple, vous pouvez utiliser le <xref:System.IO.BinaryReader.ReadBoolean%2A> pour lire l’octet suivant comme une valeur booléenne et avance la position actuelle dans le flux d’un octet. La classe inclut des méthodes de lecture qui prennent en charge différents types de données.  
  
 Lorsque vous créez une nouvelle instance de la <xref:System.IO.BinaryReader> (classe), vous fournissez le flux à lire et éventuellement de spécifier le type de codage et s’il faut maintenir le flux ouvrez après avoir supprimé le <xref:System.IO.BinaryReader> objet. Si vous ne spécifiez pas un type de codage, UTF-8 est utilisé.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement. Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment stocker et récupérer des paramètres d’application dans un fichier.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.BinaryReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryReader(System::IO::Stream ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Flux d'entrée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.BinaryReader" /> en fonction du flux spécifié et à l'aide de l'encodage UTF-8.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment stocker et récupérer des paramètres d’application dans un fichier.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge l’écriture, il est <see langword="null" /> ou bien il est déjà fermé.</exception>
        <altmember cref="T:System.Text.UTF8Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryReader (System.IO.Stream input, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryReader(System::IO::Stream ^ input, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="input">Flux d'entrée.</param>
        <param name="encoding">Encodage des caractères à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.BinaryReader" /> en fonction du flux et l'encodage de caractères spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge l’écriture, il est <see langword="null" /> ou bien il est déjà fermé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="encoding" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BinaryReader (System.IO.Stream input, System.Text.Encoding encoding, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Text.Encoding encoding, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BinaryReader(System::IO::Stream ^ input, System::Text::Encoding ^ encoding, bool leaveOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="input">Flux d'entrée.</param>
        <param name="encoding">Encodage des caractères à utiliser.</param>
        <param name="leaveOpen">
          <see langword="true" /> pour maintenir le flux ouvert après avoir supprimé l'objet <see cref="T:System.IO.BinaryReader" /> ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.BinaryReader" /> en fonction du flux et de l'encodage de caractères spécifiés, et permet éventuellement de laisser le flux ouvert.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge l’écriture, il est <see langword="null" /> ou bien il est déjà fermé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="encoding" /> ou <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BinaryReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Expose l'accès au flux sous-jacent de l'élément <see cref="T:System.IO.BinaryReader" />.</summary>
        <value>Flux sous-jacent associé à l'élément <see langword="BinaryReader" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Utiliser le flux sous-jacent pendant la lecture ou l’utilisation du `BinaryReader` peut entraîner une perte de données et de la corruption. Par exemple, les mêmes octets peuvent être lus plusieurs fois, peuvent être omis ou la lecture des caractères peut devenir imprévisible.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment lire et écrire `Double` mémoire à l’aide de la `BinaryReader` et <xref:System.IO.BinaryWriter> classes par-dessus la <xref:System.IO.MemoryStream> classe. `MemoryStream` seulement lit et écrit `Byte` données.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CPP/rwdouble.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CS/rwdouble.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/VB/rwdouble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le lecteur actuel et le flux sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation de `Close` appelle la <xref:System.IO.BinaryReader.Dispose%2A> méthode en passant un `true` valeur.  
  
 Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement <xref:System.IO.Stream.Flush%2A> ou `Close`. Paramètre <xref:System.IO.StreamWriter.AutoFlush%2A> à `true` signifie que les données sont supprimées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Cela permet à l’encodeur de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7 où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.IO.BinaryReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.IO.BinaryReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.IO.BinaryReader>. La méthode `Dispose` rend le <xref:System.IO.BinaryReader> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.IO.BinaryReader> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.IO.BinaryReader> occupée.  
  
 Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.IO.BinaryReader>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.IO.BinaryReader> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par la classe <see cref="T:System.IO.BinaryReader" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par `Dispose` et <xref:System.Object.Finalize%2A>. Par défaut, cette méthode spécifie les `disposing` paramètre en tant que `true`. <xref:System.Object.Finalize%2A> Spécifie le `disposing` paramètre en tant que `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.BinaryReader>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.BinaryReader.Dispose(System.Boolean)" /> peut être appelée plusieurs fois par d'autres objets. Lorsque vous substituez cette méthode, veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur la façon d’implémenter cette méthode, consultez [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Pour plus d’informations sur <see cref="M:System.IDisposable.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillBuffer">
      <MemberSignature Language="C#" Value="protected virtual void FillBuffer (int numBytes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FillBuffer(int32 numBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.FillBuffer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub FillBuffer (numBytes As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void FillBuffer(int numBytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="numBytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="numBytes">Nombre d'octets à lire.</param>
        <summary>Remplit la mémoire tampon interne avec le nombre spécifié d'octets lus à partir du flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La taille de la mémoire tampon interne est la plus grande valeur entre 16 et la valeur retournée par <xref:System.Text.Encoding.GetMaxByteCount%2A> pour l’encodage spécifié.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte avant que <paramref name="numBytes" /> n’ait pu être lu.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="numBytes" /> demandé est plus grand que la taille de la mémoire tampon interne.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekChar">
      <MemberSignature Language="C#" Value="public virtual int PeekChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 PeekChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.PeekChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PeekChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int PeekChar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le prochain caractère disponible et n'avance pas la position de caractère ou d'octet.</summary>
        <returns>Prochain caractère disponible, ou -1 si aucun caractère n'est disponible ou si le flux ne prend pas en charge la recherche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les caractères de substitution peuvent être attendus dans le flux, utilisez la <xref:System.IO.BinaryReader.ReadChars%2A> (méthode), puis définissez le flux de données à la position d’origine.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ArgumentException">Le caractère actuel ne peut pas être décodé dans la mémoire tampon de caractères interne à l’aide du <see cref="T:System.Text.Encoding" /> sélectionné pour le flux de données.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit les octets du flux sous-jacent et avance la position actuelle du flux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit les caractères du flux sous-jacent et avance la position actuelle du flux conformément à la valeur <see langword="Encoding" /> utilisée et au caractère spécifique en cours de lecture dans le flux.</summary>
        <returns>Caractère suivant du flux d'entrée, ou -1 si aucun caractère n'est actuellement disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment lire et écrire des données à l’aide de la mémoire comme magasin de stockage. Cet exemple affiche une liste de caractères de chemin d’accès de fichier non valide dans la console. Bien que le code tente d’afficher une liste de tous les caractères de chemin d’accès de fichier non valide, tous les caractères sont dans le jeu de caractères peut être affichée. Étant donné que la liste des caractères non valides peut varier selon le système, la sortie de ce code peut également varier.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChar2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar2/CPP/rwreadchar.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChar2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar2/CS/rwreadchar.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChar2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar2/VB/rwreadchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle lire les données.</param>
        <param name="index">Point de départ, dans la mémoire tampon, à partir duquel commencer la lecture de la mémoire tampon.</param>
        <param name="count">Nombre d'octets à lire.</param>
        <summary>Lit le nombre spécifié d'octets dans le flux, en commençant à un point spécifié dans le tableau d'octets.</summary>
        <returns>Nombre d'octets lus dans <paramref name="buffer" />. Ce total peut être inférieur au nombre d'octets demandé si ce nombre d'octets n'est pas disponible, ou il peut être égal à zéro si la fin du flux est atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment écrire des données binaires à l’aide de la mémoire comme magasin de stockage. Il affiche un message à la console qui indique si les données ont été écrites correctement.  
  
 [!code-csharp[System.IO.BinaryReaderWriter.RWBytes2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes2/CS/rwreadbytes.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWBytes2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes2/VB/rwreadbytes.vb#1)]  
  
 Cet exemple lit le contenu d’un fichier et affiche la valeur numérique du chaque octet format 16 colonnes. La fin du fichier qui est lu est détectée lorsque la <xref:System.IO.BinaryReader.Read%2A> méthode retourne zéro octet.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source5.cs#6)]
 [!code-vb[System.IO.BinaryReaderWriter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source5.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.  
  
 - ou -  
  
 Le nombre de caractères décodés à lire est supérieur à <paramref name="count" />. Cela peut arriver si un décodeur Unicode retourne des caractères de secours ou une paire de substitution.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle lire les données.</param>
        <param name="index">Point de départ, dans la mémoire tampon, à partir duquel commencer la lecture de la mémoire tampon.</param>
        <param name="count">Nombre de caractères à lire.</param>
        <summary>Lit le nombre spécifié de caractères du flux, en commençant à un point spécifié dans le tableau de caractères.</summary>
        <returns>Nombre total de caractères lus dans la mémoire tampon. Ce total peut être inférieur au nombre de caractères demandé si ce nombre de caractères n'est pas disponible actuellement, ou il peut être égal à zéro si la fin du flux est atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment lire et écrire des données à l’aide de la mémoire comme magasin de stockage. Cet exemple affiche une liste de caractères de chemin d’accès de fichier non valide dans la console. Bien que le code tente d’afficher une liste de tous les caractères de chemin d’accès de fichier non valide, tous les caractères sont dans le jeu de caractères peut être affichée. Étant donné que la liste des caractères non valides peut varier selon le système, la sortie de ce code peut également varier.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChars2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars2/CPP/rwreadchars.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChars2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars2/CS/rwreadchars.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChars2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars2/VB/rwreadchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.  
  
 - ou -  
  
 Le nombre de caractères décodés à lire est supérieur à <paramref name="count" />. Cela peut arriver si un décodeur Unicode retourne des caractères de secours ou une paire de substitution.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read7BitEncodedInt">
      <MemberSignature Language="C#" Value="protected internal int Read7BitEncodedInt ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance int32 Read7BitEncodedInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.Read7BitEncodedInt" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function Read7BitEncodedInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; int Read7BitEncodedInt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier 32 bits au format compressé.</summary>
        <returns>Entier 32 bits au format compressé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Si l’entier tient dans sept bits, l’entier prend un seul octet de l’espace. L’entier doit avoir été écrit par <xref:System.IO.BinaryWriter.Write7BitEncodedInt%2A?displayProperty=nameWithType>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.FormatException">Le flux est endommagé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadBoolean();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une valeur <see langword="Boolean" /> à partir du flux actuel et avance la position actuelle du flux d'un octet.</summary>
        <returns>
          <see langword="true" /> si l'octet est différent de zéro ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment stocker et récupérer des paramètres d’application dans un fichier.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual byte ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Byte ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'octet suivant du flux actuel et avance la position actuelle du flux d'un octet.</summary>
        <returns>Octet suivant lu dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 En raison de conflits de mise en forme de données, à l’aide de cette méthode avec les encodages suivants n’est pas recommandée :  
  
-   UTF-7  
  
-   ISO-2022-JP  
  
-   ISCII  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment écrire des données binaires à l’aide de la mémoire comme magasin de sauvegarde et vérifiez que les données ont été écrites correctement.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWByte#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWByte/CPP/rwbyte.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWByte/CS/rwbyte.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWByte/VB/rwbyte.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] ReadBytes (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ReadBytes(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBytes (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ReadBytes(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Nombre d'octets à lire. Cette valeur doit être 0 ou un nombre non négatif, sinon une exception se produit.</param>
        <summary>Lit le nombre spécifié d'octets du flux actuel dans un tableau d'octets et avance la position actuelle de ce nombre d'octets.</summary>
        <returns>Tableau d'octets contenant les données lues dans le flux sous-jacent. Cette valeur peut être inférieure au nombre d'octets demandé si la fin du flux est atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment écrire des données binaires à l’aide de la mémoire comme magasin de sauvegarde et vérifiez que les données ont été écrites correctement.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWBytes1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes1/CPP/rwbytes.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWBytes1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes1/CS/rwbytes.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWBytes1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWBytes1/VB/rwbytes.vb#1)]  
  
 Cet exemple lit le contenu d’un fichier et l’affiche dans la console sous forme de texte de vidage. La fin du fichier qui est lu est détectée lorsque la longueur de la <xref:System.Byte> tableau retourné à partir de <xref:System.IO.BinaryReader.ReadBytes%2A> est égale à zéro.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source5.cs#6)]
 [!code-vb[System.IO.BinaryReaderWriter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source5.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nombre de caractères décodés à lire est supérieur à <paramref name="count" />. Cela peut arriver si un décodeur Unicode retourne des caractères de secours ou une paire de substitution.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public virtual char ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadChar () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual char ReadChar();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le caractère suivant dans le flux actuel et avance la position actuelle du flux conformément à la valeur <see langword="Encoding" /> utilisée et du caractère spécifique en cours de lecture dans le flux.</summary>
        <returns>Caractère lu dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.IO.BinaryReader.ReadChar%2A> méthode tente de lire un caractère de substitution dans le flux d’une exception est levée et avance la position dans le flux de données. La position est restaurée à l’emplacement d’origine avant <xref:System.IO.BinaryReader.ReadChar%2A> a été appelé si le flux est identifiable ; Toutefois, si le flux est unseekable, la position n’est pas corrigée. Si les caractères de substitution peuvent être attendus dans le flux de données, utilisez la <xref:System.IO.BinaryReader.ReadChars%2A> méthode à la place.  
  
 En raison de conflits de mise en forme de données, à l’aide de cette méthode avec les encodages suivants n’est pas recommandée :  
  
-   UTF-7  
  
-   ISO-2022-JP  
  
-   ISCII  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment lire et écrire des données à l’aide de la mémoire comme magasin de stockage.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChar1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar1/CPP/rwchar.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChar1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar1/CS/rwchar.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChar1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChar1/VB/rwchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ArgumentException">Un caractère de substitution a été lu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public virtual char[] ReadChars (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] ReadChars(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadChars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadChars (count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ ReadChars(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Nombre de caractères à lire.</param>
        <summary>Lit le nombre spécifié de caractères dans le flux actuel, retourne les données dans un tableau de caractères et avance la position actuelle conformément à la valeur <see langword="Encoding" /> utilisée et au caractère spécifique en cours de lecture dans le flux.</summary>
        <returns>Tableau de caractères contenant des données lues dans le flux sous-jacent. Cette valeur peut être inférieure au nombre de caractères demandés si la fin du flux est atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Lors de la lecture à partir de flux de réseau, dans certains cas rares, le <xref:System.IO.BinaryReader.ReadChars%2A> méthode peut lire un caractère supplémentaire dans le flux si le <xref:System.IO.BinaryReader> a été construit avec Unicode encodage. Si cela se produit, vous pouvez utiliser la <xref:System.IO.BinaryReader.ReadBytes%2A> méthode pour lire un tableau d’octets de longueur fixe, puis passer ce tableau à la <xref:System.IO.BinaryReader.ReadChars%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment lire et écrire des données à l’aide de la mémoire comme magasin de stockage.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWChars1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars1/CPP/rwchars.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWChars1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars1/CS/rwchars.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWChars1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWChars1/VB/rwchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nombre de caractères décodés à lire est supérieur à <paramref name="count" />. Cela peut arriver si un décodeur Unicode retourne des caractères de secours ou une paire de substitution.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ReadDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadDecimal();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une valeur décimale dans le flux actuel et avance la position actuelle du flux de 16 octets.</summary>
        <returns>Valeur décimale lue dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadDouble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une valeur à virgule flottante de 8 octets dans le flux actuel et avance la position actuelle du flux de huit octets.</summary>
        <returns>Valeur à virgule flottante de 8 octets lue dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment lire et écrire `Double` mémoire à l’aide de la `BinaryReader` et <xref:System.IO.BinaryWriter> classes par-dessus la <xref:System.IO.MemoryStream> classe. `MemoryStream` seulement lit et écrit `Byte` données.  
  
 [!code-cpp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CPP/rwdouble.cpp#1)]
 [!code-csharp[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/CS/rwdouble.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter.RWDouble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter.RWDouble/VB/rwdouble.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public virtual short ReadInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int16 ReadInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadInt16" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInt16 () As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual short ReadInt16();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier signé de 2 octets dans le flux actuel et avance la position actuelle du flux de deux octets.</summary>
        <returns>Entier signé de 2 octets lu dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public virtual int ReadInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadInt32" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier signé de 4 octets dans le flux actuel et avance la position actuelle du flux de quatre octets.</summary>
        <returns>Entier signé de 4 octets lu dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 <xref:System.IO.BinaryReader> lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment stocker et récupérer des paramètres d’application dans un fichier.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public virtual long ReadInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadInt64" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier signé de 8 octets dans le flux actuel et avance la position actuelle du flux de huit octets.</summary>
        <returns>Entier signé de 8 octets lu dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSByte">
      <MemberSignature Language="C#" Value="public virtual sbyte ReadSByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int8 ReadSByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadSByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSByte () As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::SByte ReadSByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un octet signé dans ce flux et avance la position actuelle du flux d'un octet.</summary>
        <returns>Octet signé lu dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingle">
      <MemberSignature Language="C#" Value="public virtual float ReadSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadSingle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadSingle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une valeur à virgule flottante de 4 octets dans le flux actuel et avance la position actuelle du flux de quatre octets.</summary>
        <returns>Valeur à virgule flottante de 4 octets lue dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment stocker et récupérer des paramètres d’application dans un fichier.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une chaîne dans le flux actuel. La chaîne est précédée de la longueur, encodée sous la forme d'un entier de sept bits à la fois.</summary>
        <returns>Chaîne en cours de lecture.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment stocker et récupérer des paramètres d’application dans un fichier.  
  
 [!code-csharp[System.IO.BinaryReaderWriter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/CS/source.cs#1)]
 [!code-vb[System.IO.BinaryReaderWriter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BinaryReaderWriter/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16">
      <MemberSignature Language="C#" Value="public virtual ushort ReadUInt16 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int16 ReadUInt16() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadUInt16" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadUInt16 () As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::UInt16 ReadUInt16();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier non signé de 2 octets dans le flux actuel à l'aide de l’encodage Little Endian et avance la position du flux de deux octets.</summary>
        <returns>Entier non signé de 2 octets lu dans ce flux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32">
      <MemberSignature Language="C#" Value="public virtual uint ReadUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int32 ReadUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::UInt32 ReadUInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier non signé de 4 octets dans le flux actuel et avance la position du flux de quatre octets.</summary>
        <returns>Entier non signé de 4 octets lu dans ce flux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64">
      <MemberSignature Language="C#" Value="public virtual ulong ReadUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int64 ReadUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BinaryReader.ReadUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::UInt64 ReadUInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un entier non signé de 8 octets dans le flux actuel et avance la position du flux de huit octets.</summary>
        <returns>Entier non signé de 8 octets lu dans ce flux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.BinaryReader> ne restaure pas la position de fichier après une lecture infructueuse.  
  
 `BinaryReader` lit ce type de données dans un format little-endian.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du flux est atteinte.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
      </Docs>
    </Member>
  </Members>
</Type>