<Type Name="InternalBufferOverflowException" FullName="System.IO.InternalBufferOverflowException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d302fb9fa155b4a2a1109ae7ee326321d6b25975" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30417013" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InternalBufferOverflowException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InternalBufferOverflowException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.IO.InternalBufferOverflowException" />
  <TypeSignature Language="VB.NET" Value="Public Class InternalBufferOverflowException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InternalBufferOverflowException : SystemException" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Exception levée en cas de dépassement de la mémoire tampon interne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans un <xref:System.IO.FileSystemWatcher>, lorsque vous êtes informé des modifications de fichier, les magasins système ces modifications dans une mémoire tampon le composant crée et passe pour les Interfaces de programmation d’Application (API). Si plusieurs modifications sont apportées dans une courte période, la mémoire tampon peut facilement de dépassement de capacité, ce qui entraîne une exception est levée, ce qui entraîne la perte de toutes les modifications. Pour éviter un dépassement de la mémoire tampon, utilisez la <xref:System.IO.FileSystemWatcher.NotifyFilter%2A?displayProperty=nameWithType> et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A?displayProperty=nameWithType> propriétés à filtrer les notifications de modifications indésirables. Vous pouvez également augmenter la taille de la mémoire tampon interne via la propriété <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A?displayProperty=nameWithType>. Toutefois, augmenter la taille de la mémoire tampon est coûteuse, donc conserver la mémoire tampon aussi petite que possible.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer FileSystemWatcher pour surveiller les modifications de fichier (crée, supprime, renomme, modifications) se produisant sur un lecteur de disque. L’exemple montre également comment recevoir correctement des notifications d’erreur.  
  
 [!code-csharp[FileSystemWatcher#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileSystemWatcher/cs/filesystemwatcher.cs#1)]
 [!code-vb[FileSystemWatcher#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileSystemWatcher/VB/FileSystemWatcher.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.InternalBufferOverflowException" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalBufferOverflowException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.InternalBufferOverflowException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InternalBufferOverflowException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance par défaut de la classe <see cref="T:System.IO.InternalBufferOverflowException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces constructeurs sont utilisés par le composant pour indiquer une erreur. Utilisez-les uniquement si l’extension de la classe ou le .NET Framework. Cette exception indique une mémoire tampon interne a débordé et que les utilisateurs doivent prendre les mesures appropriées dans leur code pour assurer que sa récupération. Provoqué le dépassement de capacité est souvent trop de modifications dans une courte période de temps, à l’origine de la mémoire tampon de notification interne un dépassement de capacité. Pour résoudre ce problème, utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A?displayProperty=nameWithType> et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A?displayProperty=nameWithType> notifications de modification des propriétés à filtrer indésirables. Vous pouvez également augmenter la taille de la mémoire tampon interne via la propriété <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A?displayProperty=nameWithType>. Toutefois, augmenter la taille de la mémoire tampon est coûteuse, donc conserver la mémoire tampon aussi petite que possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalBufferOverflowException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.InternalBufferOverflowException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InternalBufferOverflowException(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à assigner à l’exception.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.InternalBufferOverflowException" /> avec le message d’erreur à afficher spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces constructeurs sont utilisés par le composant pour indiquer une erreur. Utilisez-les uniquement si l’extension de la classe ou le .NET Framework. Cette exception indique une mémoire tampon interne a débordé et que les utilisateurs doivent prendre les mesures appropriées dans leur code pour assurer que sa récupération. Provoqué le dépassement de capacité est souvent trop de modifications dans une courte période de temps, à l’origine de la mémoire tampon de notification interne un dépassement de capacité. Pour résoudre ce problème, utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A?displayProperty=nameWithType> et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A?displayProperty=nameWithType> notifications de modification des propriétés à filtrer indésirables. Vous pouvez également augmenter la taille de la mémoire tampon interne via la propriété <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A?displayProperty=nameWithType>. Toutefois, augmenter la taille de la mémoire tampon est coûteuse, donc conserver la mémoire tampon aussi petite que possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InternalBufferOverflowException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.InternalBufferOverflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InternalBufferOverflowException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Informations obligatoires pour sérialiser l’objet T:System.IO.InternalBufferOverflowException.</param>
        <param name="context">Les source et destination du flux sérialisé associées à l’objet T:System.IO.InternalBufferOverflowException.</param>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.IO.InternalBufferOverflowException" /> qui est sérialisable à l’aide des objets<see cref="T:System.Runtime.Serialization.SerializationInfo" /> et <see cref="T:System.Runtime.Serialization.StreamingContext" /> spécifiés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InternalBufferOverflowException (string message, Exception inner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.InternalBufferOverflowException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, inner As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InternalBufferOverflowException(System::String ^ message, Exception ^ inner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="inner" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Message à assigner à l’exception.</param>
        <param name="inner">Exception interne.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.InternalBufferOverflowException" /> avec le message à afficher et l’exception interne générée spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces constructeurs sont utilisés par le composant pour indiquer une erreur. Utilisez-les uniquement si l’extension de la classe ou le .NET Framework. Cette exception indique une mémoire tampon interne a débordé et que les utilisateurs doivent prendre les mesures appropriées dans leur code pour assurer que sa récupération. Provoqué le dépassement de capacité est souvent trop de modifications dans une courte période de temps, à l’origine de la mémoire tampon de notification interne un dépassement de capacité. Pour résoudre ce problème, utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A?displayProperty=nameWithType> et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A?displayProperty=nameWithType> notifications de modification des propriétés à filtrer indésirables. Vous pouvez également augmenter la taille de la mémoire tampon interne via la propriété <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A?displayProperty=nameWithType>. Toutefois, augmenter la taille de la mémoire tampon est coûteuse, donc conserver la mémoire tampon aussi petite que possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
  </Members>
</Type>