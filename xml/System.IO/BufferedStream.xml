<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3657feec7393bd216f7cadd535cf758269717342" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36561070" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a9aec-101">Ajoute une couche de mise en mémoire tampon aux opérations de lecture et d’écriture sur un autre flux.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a9aec-101">Adds a buffering layer to read and write operations on another stream.</span>
      </span>
      <span data-ttu-id="a9aec-102">Cette classe ne peut pas être héritée.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a9aec-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-103">Une mémoire tampon est un bloc d’octets dans la mémoire utilisée pour les données du cache, ce qui réduit le nombre d’appels au système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="a9aec-103">A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</span></span> <span data-ttu-id="a9aec-104">Mémoires tampons améliorent en lecture et d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a9aec-104">Buffers improve read and write performance.</span></span> <span data-ttu-id="a9aec-105">Une mémoire tampon peut être utilisée pour la lecture ou l’écriture, mais jamais les deux simultanément.</span><span class="sxs-lookup"><span data-stu-id="a9aec-105">A buffer can be used for either reading or writing, but never both simultaneously.</span></span> <span data-ttu-id="a9aec-106">Le <xref:System.IO.BufferedStream.Read%2A> et <xref:System.IO.BufferedStream.Write%2A> méthodes de `BufferedStream` automatiquement à jour la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="a9aec-106">The <xref:System.IO.BufferedStream.Read%2A> and <xref:System.IO.BufferedStream.Write%2A> methods of `BufferedStream` automatically maintain the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a9aec-107">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="a9aec-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a9aec-108">Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="a9aec-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="a9aec-109">Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="a9aec-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="a9aec-110">Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a9aec-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="a9aec-111">Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="a9aec-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="a9aec-112">`BufferedStream` peut être créé à partir de certains types de flux.</span><span class="sxs-lookup"><span data-stu-id="a9aec-112">`BufferedStream` can be composed around certain types of streams.</span></span> <span data-ttu-id="a9aec-113">Il fournit des implémentations pour lire et écrire des octets dans une source de données sous-jacente ou le référentiel.</span><span class="sxs-lookup"><span data-stu-id="a9aec-113">It provides implementations for reading and writing bytes to an underlying data source or repository.</span></span> <span data-ttu-id="a9aec-114">Utilisez <xref:System.IO.BinaryReader> et <xref:System.IO.BinaryWriter> pour lire et écrire d’autres types de données.</span><span class="sxs-lookup"><span data-stu-id="a9aec-114">Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types.</span></span> <span data-ttu-id="a9aec-115">`BufferedStream` est conçu pour empêcher la mémoire tampon de ralentir l’entrée et la sortie lorsque la mémoire tampon n’est pas nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a9aec-115">`BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</span></span> <span data-ttu-id="a9aec-116">Si la lecture ou écriture puis de taille supérieure à la taille de la mémoire tampon interne, toujours `BufferedStream` risque de ne pas allouer la mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="a9aec-116">If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer.</span></span> <span data-ttu-id="a9aec-117">`BufferedStream` également mémoire tampon les lectures et écritures dans une mémoire tampon partagée.</span><span class="sxs-lookup"><span data-stu-id="a9aec-117">`BufferedStream` also buffers reads and writes in a shared buffer.</span></span> <span data-ttu-id="a9aec-118">Il est supposé que vous sera presque toujours être réaliser une série de lectures ou écritures, mais rarement alterner entre les deux d'entre eux.</span><span class="sxs-lookup"><span data-stu-id="a9aec-118">It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-119">Les exemples de code suivants montrent comment utiliser le `BufferedStream` classe via la `NetworkStream` classe pour augmenter les performances de certaines opérations d’e/s.</span><span class="sxs-lookup"><span data-stu-id="a9aec-119">The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations.</span></span> <span data-ttu-id="a9aec-120">Démarrez le serveur sur un ordinateur distant avant de démarrer le client.</span><span class="sxs-lookup"><span data-stu-id="a9aec-120">Start the server on a remote computer before starting the client.</span></span> <span data-ttu-id="a9aec-121">Spécifiez le nom de l’ordinateur distant en tant qu’un argument de ligne de commande lors du démarrage du client.</span><span class="sxs-lookup"><span data-stu-id="a9aec-121">Specify the remote computer name as a command-line argument when starting the client.</span></span> <span data-ttu-id="a9aec-122">Faire varier la `dataArraySize` et `streamBufferSize` constantes pour afficher leur impact sur les performances.</span><span class="sxs-lookup"><span data-stu-id="a9aec-122">Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.</span></span>  
  
 <span data-ttu-id="a9aec-123">Le premier exemple montre le code qui s’exécute sur le client et le deuxième exemple montre le code qui s’exécute sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="a9aec-123">The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</span></span>  
  
 <span data-ttu-id="a9aec-124">**Exemple 1 : Code qui s’exécute sur le client**</span><span class="sxs-lookup"><span data-stu-id="a9aec-124">**Example 1: Code that runs on the client**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 <span data-ttu-id="a9aec-125">**Exemple 2 : Code qui s’exécute sur le serveur**</span><span class="sxs-lookup"><span data-stu-id="a9aec-125">**Example 2: Code that runs on the server**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-126">Initialise une nouvelle instance de la classe <see cref="T:System.IO.BufferedStream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-126">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="a9aec-127">Flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-127">The current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-128">Initialise une nouvelle instance de la classe <see cref="T:System.IO.BufferedStream" />, avec une taille de mémoire tampon par défaut égale à 4 096 octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-128">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with a default buffer size of 4096 bytes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-129">Une mémoire tampon en lecture/écriture partagée est allouée à la première fois un `BufferedStream` objet est initialisé avec ce constructeur.</span><span class="sxs-lookup"><span data-stu-id="a9aec-129">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="a9aec-130">La mémoire tampon partagée n’est pas utilisée si toutes les lectures et écritures sont supérieurs ou égaux à `bufferSize`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-130">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-131">
            <paramref name="stream" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-131">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="a9aec-132">Flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-132">The current stream.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="a9aec-133">Taille de la mémoire tampon en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-133">The buffer size in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-134">Initialise une nouvelle instance de la classe <see cref="T:System.IO.BufferedStream" /> avec la taille de mémoire tampon spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-134">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with the specified buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-135">Une mémoire tampon en lecture/écriture partagée est allouée à la première fois un `BufferedStream` objet est initialisé avec ce constructeur.</span><span class="sxs-lookup"><span data-stu-id="a9aec-135">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="a9aec-136">La mémoire tampon partagée n’est pas utilisée si toutes les lectures et écritures sont supérieurs ou égaux à `bufferSize`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-136">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-137">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-137">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-138">
            <paramref name="stream" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-138">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-139">
            <paramref name="bufferSize" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-139">
              <paramref name="bufferSize" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="a9aec-140">Mémoire tampon dans laquelle lire les données.buffer</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-140">The buffer to read the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="a9aec-141">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données lues à partir du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-141">The byte offset in <c>buffer</c> at which to begin writing data read from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="a9aec-142">Nombre maximal d'octets à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-142">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="a9aec-143">Rappel asynchrone facultatif, à appeler quand la lecture est terminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-143">An optional asynchronous callback, to be called when the read is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a9aec-144">Objet fourni par l'utilisateur qui distingue cette requête de lecture asynchrone des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-144">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-145">Débute une opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-145">Begins an asynchronous read operation.</span>
          </span>
          <span data-ttu-id="a9aec-146">(Utilisez <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-146">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-147">Objet représentant la lecture asynchrone qui pourrait toujours être en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-147">An object that represents the asynchronous read, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-148">Dans le .NET Framework 4 et les versions antérieures, vous devez utiliser des méthodes telles que <xref:System.IO.Stream.BeginRead%2A> et <xref:System.IO.Stream.EndRead%2A> pour implémenter des opérations de fichier asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a9aec-148">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a9aec-149">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, et <xref:System.IO.BufferedStream.FlushAsync%2A>, aide vous implémentez des opérations de fichier asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="a9aec-149">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a9aec-150"><xref:System.IO.BufferedStream.EndWrite%2A> doit être appelée une seule fois pour chaque appel à <xref:System.IO.BufferedStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-150"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="a9aec-151">Impossibilité de terminer un processus de lecture avant de commencer une autre lecture peut provoquer des comportements indésirables tels que de blocage.</span><span class="sxs-lookup"><span data-stu-id="a9aec-151">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a9aec-152">Utilisez le <xref:System.IO.BufferedStream.CanRead%2A> propriété pour déterminer si l’instance actuelle prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="a9aec-152">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="a9aec-153"><xref:System.IO.BufferedStream.EndRead%2A> doit être appelé avec ce <xref:System.IAsyncResult> pour déterminer le nombre d’octets qui ont été lus.</span><span class="sxs-lookup"><span data-stu-id="a9aec-153"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-154">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-154">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-155">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-155">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-156">A tenté une lecture asynchrone au-delà de la fin du fichier du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-156">Attempted an asynchronous read past the end of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-157">La longueur de la mémoire tampon moins <paramref name="offset" /> est inférieure à <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-157">The buffer length minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-158">Le flux actuel ne prend pas en charge l’opération de lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-158">The current stream does not support the read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="a9aec-159">Mémoire tampon qui contient les données à écrire dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-159">The buffer containing data to write to the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="a9aec-160">Dans <c>buffer</c>, décalage d’octet de base zéro auquel commencer la copie des octets dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-160">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="a9aec-161">Nombre maximal d'octets à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-161">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="a9aec-162">Méthode à appeler quand l'opération d'écriture asynchrone est terminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-162">The method to be called when the asynchronous write operation is completed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a9aec-163">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-163">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-164">Débute une opération d'écriture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-164">Begins an asynchronous write operation.</span>
          </span>
          <span data-ttu-id="a9aec-165">(Utilisez <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-165">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-166">Objet qui référence l’écriture asynchrone qui pourrait toujours être en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-166">An object that references the asynchronous write which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-167">Dans le .NET Framework 4 et les versions antérieures, vous devez utiliser des méthodes telles que <xref:System.IO.Stream.BeginWrite%2A> et <xref:System.IO.Stream.EndWrite%2A> pour implémenter des opérations de fichier asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a9aec-167">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a9aec-168">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, et <xref:System.IO.BufferedStream.FlushAsync%2A>, aide vous implémentez des opérations de fichier asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="a9aec-168">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a9aec-169"><xref:System.IO.BufferedStream.EndWrite%2A> doit être appelée une seule fois pour chaque <xref:System.IAsyncResult> de <xref:System.IO.BufferedStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-169"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.BufferedStream.BeginWrite%2A>.</span></span> <span data-ttu-id="a9aec-170"><xref:System.IO.BufferedStream.EndWrite%2A> se bloque jusqu'à ce que l’opération d’e/s est terminée.</span><span class="sxs-lookup"><span data-stu-id="a9aec-170"><xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-171">La longueur de <paramref name="buffer" /> moins <paramref name="offset" /> est inférieure à <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-171">
              <paramref name="buffer" /> length minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-172">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-172">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-173">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-173">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-174">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-174">The stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-175">Obtient une valeur indiquant si le flux actuel prend en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-175">Gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a9aec-176">
            <see langword="true" /> si le flux prend en charge la lecture ; <see langword="false" /> si le flux est fermé ou a été ouvert avec un accès en écriture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-176">
              <see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-177">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la lecture, les appels à la <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>et le `Peek` méthodes de <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, et <xref:System.IO.TextReader> lever un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-177">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a9aec-178">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-178">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-179">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-179">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-180">Obtient une valeur indiquant si le flux actuel prend en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-180">Gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a9aec-181">
            <see langword="true" /> si le flux prend en charge la recherche ; <see langword="false" /> si le flux est fermé ou s'il a été construit à partir d'un handle de système d'exploitation tel qu'un canal ou une sortie console.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-181">
              <see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-182">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la recherche, les appels à <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, et <xref:System.IO.BufferedStream.Seek%2A> lever un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-182">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a9aec-183">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-183">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-184">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-184">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-185">Obtient une valeur indiquant si le flux actuel prend en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-185">Gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a9aec-186">
            <see langword="true" /> si le flux prend en charge l'écriture ; <see langword="false" /> si le flux est fermé ou a été ouvert avec un accès en lecture seule.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-186">
              <see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-187">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge l’écriture, un appel à <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, ou <xref:System.IO.BufferedStream.WriteByte%2A> lève une <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-187">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a9aec-188">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-188">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-189">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-189">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="a9aec-190">Référence à la requête asynchrone en attente qu'il faut attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-190">The reference to the pending asynchronous request to wait for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-191">Attend que l'opération de lecture asynchrone en attente se termine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-191">Waits for the pending asynchronous read operation to complete.</span>
          </span>
          <span data-ttu-id="a9aec-192">(Utilisez <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-192">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-193">Nombre d'octets lus à partir du flux, entre zéro (0) et le nombre d'octets demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-193">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span>
          </span>
          <span data-ttu-id="a9aec-194">Les flux retournent uniquement 0 à la fin du flux, sinon ils devraient être bloqués jusqu’à ce qu’au moins 1 octet soit disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-194">Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-195">Dans le .NET Framework 4 et les versions antérieures, vous devez utiliser des méthodes telles que <xref:System.IO.Stream.BeginRead%2A> et <xref:System.IO.Stream.EndRead%2A> pour implémenter des opérations de fichier asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a9aec-195">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a9aec-196">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, et <xref:System.IO.BufferedStream.FlushAsync%2A>, aide vous implémentez des opérations de fichier asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="a9aec-196">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a9aec-197"><xref:System.IO.BufferedStream.EndRead%2A> doit être appelé avec ce <xref:System.IAsyncResult> pour déterminer le nombre d’octets qui ont été lus.</span><span class="sxs-lookup"><span data-stu-id="a9aec-197"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-198">
            <paramref name="asyncResult" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-198">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-199">Cet objet <see cref="T:System.IAsyncResult" /> n’a pas été créé en appelant <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-199">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="a9aec-200">Requête asynchrone en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-200">The pending asynchronous request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-201">Termine une opération d'écriture asynchrone et se bloque jusqu'à la fin de l'opération d'E/S.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-201">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span>
          </span>
          <span data-ttu-id="a9aec-202">(Utilisez <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-202">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-203">Dans le .NET Framework 4 et les versions antérieures, vous devez utiliser des méthodes telles que <xref:System.IO.Stream.BeginWrite%2A> et <xref:System.IO.Stream.EndWrite%2A> pour implémenter des opérations de fichier asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a9aec-203">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a9aec-204">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, et <xref:System.IO.BufferedStream.FlushAsync%2A>, aide vous implémentez des opérations de fichier asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="a9aec-204">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a9aec-205"><xref:System.IO.BufferedStream.EndWrite%2A> doit être appelée une seule fois pour chaque appel à <xref:System.IO.BufferedStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-205"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="a9aec-206">Impossibilité de terminer un processus de lecture avant de commencer une autre opération de lecture peut entraîner le blocage ou autres comportements indésirables.</span><span class="sxs-lookup"><span data-stu-id="a9aec-206">Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-207">
            <paramref name="asyncResult" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-207">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-208">Cet objet <see cref="T:System.IAsyncResult" /> n’a pas été créé en appelant <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-208">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-209">Efface toutes les mémoires tampons pour ce flux et provoque l’écriture des données mises en mémoire tampon sur l’appareil sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-209">Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-210">Vider le flux n’effacera pas son encodeur sous-jacent sauf si vous appelez explicitement `Flush` ou <xref:System.IO.Stream.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-210">Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.</span></span>  
  
 <span data-ttu-id="a9aec-211">Si vous utilisez la <xref:System.IO.BufferedStream.%23ctor%2A> constructeur, par conséquent, en spécifiant la taille de mémoire tampon lors de la création du `BufferedStream` de l’objet, le contenu est vidé lorsqu’il atteint la taille de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="a9aec-211">If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size.</span></span> <span data-ttu-id="a9aec-212">Par exemple, un code tel que `BufferedStream bs = new BufferedStream(bs, 5)` effacera le contenu lorsque la taille de mémoire tampon atteint 5 octets.</span><span class="sxs-lookup"><span data-stu-id="a9aec-212">For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.</span></span>  
  
 <span data-ttu-id="a9aec-213">Toutes les méthodes de lecture et d’écriture de `BufferedStream` automatiquement mettre à jour de la mémoire tampon, il est donc inutile d’appeler `Flush` lors du basculement dans les deux sens entre lecture et en écriture.</span><span class="sxs-lookup"><span data-stu-id="a9aec-213">All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-214">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-214">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-215">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-215">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-216">La source de données ou le référentiel n’est pas ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-216">The data source or repository is not open.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.Stream.Close" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="a9aec-217">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-217">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-218">Efface de façon asynchrone toutes les mémoires tampons pour ce flux, provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent et surveille les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-218">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-219">Tâche qui représente l’opération de vidage asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-219">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-220">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-220">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-221">Obtient la longueur du flux en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-221">Gets the stream length in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a9aec-222">Longueur du flux en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-222">The stream length in bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-223">Le flux sous-jacent est <see langword="null" /> ou fermé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-223">The underlying stream is <see langword="null" /> or closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-224">Le flux ne prend pas en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-224">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-225">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-225">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-226">Obtient la position dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-226">Gets the position within the current stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a9aec-227">Position dans le flux en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-227">The position within the current stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-228">Le `get` accesseur appelle <xref:System.IO.BufferedStream.Seek%2A> pour obtenir la position actuelle dans le flux sous-jacent, puis ajuste cette valeur en fonction de la position actuelle dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="a9aec-228">The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</span></span>  
  
 <span data-ttu-id="a9aec-229">Le `set` accesseur copie les données précédemment écrites dans la mémoire tampon dans le flux sous-jacent, puis appelle <xref:System.IO.BufferedStream.Seek%2A>.</span><span class="sxs-lookup"><span data-stu-id="a9aec-229">The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.</span></span>  
  
 <span data-ttu-id="a9aec-230">La recherche au-delà de la longueur du flux de données est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="a9aec-230">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-231">La valeur passée à <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> est négative.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-231">The value passed to <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-232">Une erreur d’E/S s’est produite, telle que la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-232">An I/O error occurs, such as the stream being closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-233">Le flux ne prend pas en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-233">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-234">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-234">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="a9aec-235">Mémoire tampon dans laquelle les octets sont copiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-235">The buffer to which bytes are to be copied.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="a9aec-236">Dans la mémoire tampon, offset d’octet à partir duquel commence la lecture des octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-236">The byte offset in the buffer at which to begin reading bytes.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="a9aec-237">Nombre d'octets à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-237">The number of bytes to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-238">Copie les octets du flux actuel figurant dans la mémoire tampon dans un tableau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-238">Copies bytes from the current buffered stream to an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-239">Nombre total d’octets lus dans <paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-239">The total number of bytes read into <paramref name="array" />.</span>
          </span>
          <span data-ttu-id="a9aec-240">Le total peut être inférieur au nombre d’octets demandé si ce nombre n’est pas actuellement disponible, ou il peut être égal à 0 si la fin du flux a été atteinte avant la lecture des données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-240">This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-241">Le `Read` méthode retourne 0 uniquement si la fin du flux est atteinte.</span><span class="sxs-lookup"><span data-stu-id="a9aec-241">The `Read` method will return 0 only if the end of the stream is reached.</span></span> <span data-ttu-id="a9aec-242">Dans tous les autres cas, `Read` lit toujours au moins un octet du flux avant de retourner.</span><span class="sxs-lookup"><span data-stu-id="a9aec-242">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="a9aec-243">Par définition, si aucune donnée n’est disponible dans le flux lors d’un appel à `Read`, le `Read` méthode retourne 0 (la fin du flux est automatiquement atteinte).</span><span class="sxs-lookup"><span data-stu-id="a9aec-243">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically).</span></span> <span data-ttu-id="a9aec-244">Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux de données n’a pas été atteint.</span><span class="sxs-lookup"><span data-stu-id="a9aec-244">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="a9aec-245">Utilisez <xref:System.IO.BinaryReader> pour la lecture des types de données primitifs.</span><span class="sxs-lookup"><span data-stu-id="a9aec-245">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a9aec-246">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-246">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-247">La longueur de <paramref name="array" /> moins <paramref name="offset" /> est inférieure à <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-247">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-248">
            <paramref name="array" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-248">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-249">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-249">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-250">Le flux n’est pas ouvert ou bien il est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-250">The stream is not open or is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-251">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-251">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-252">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-252">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="a9aec-253">Mémoire tampon dans laquelle les données sont écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-253">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="a9aec-254">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données à partir du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-254">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="a9aec-255">Nombre maximal d'octets à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-255">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="a9aec-256">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-256">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-257">Lit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position dans le flux du nombre d'octets lus et surveille les demandes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-257">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-258">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-258">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="a9aec-259">La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-259">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="a9aec-260">La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-260">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-261">Vous pouvez créer un jeton d’annulation en créant une instance de la <xref:System.Threading.CancellationTokenSource> classe et en passant le <xref:System.Threading.CancellationTokenSource.Token%2A> propriété en tant que le `cancellationToken` paramètre.</span><span class="sxs-lookup"><span data-stu-id="a9aec-261">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-262">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-262">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-263">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-263">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-264">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-264">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-265">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-265">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-266">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-266">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a9aec-267">Le flux est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-267">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a9aec-268">Lit un octet dans le flux sous-jacent et retourne un octet casté en <see langword="int" />, ou retourne -1 en cas de lecture à partir de la fin du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-268">Reads a byte from the underlying stream and returns the byte cast to an <see langword="int" />, or returns -1 if reading from the end of the stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-269">Octet casté en <see langword="int" /> ou en -1 en cas de lecture à partir de la fin du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-269">The byte cast to an <see langword="int" />, or -1 if reading from the end of the stream.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-270">Une erreur d’E/S s’est produite, telle que la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-270">An I/O error occurs, such as the stream being closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-271">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-271">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-272">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-272">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="a9aec-273">
            <para>L’implémentation par défaut sur <see langword="Stream" /> crée un nouveau tableau sur un octet, puis appelle <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Bien que cela soit correct, il est inefficace. Un flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui lit la mémoire tampon directement, vous évitant l’allocation de tableau supplémentaire à chaque appel.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-273">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="a9aec-274">Offset d’octet par rapport à <c>origin</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-274">A byte offset relative to <c>origin</c>.</span>
          </span>
        </param>
        <param name="origin">
          <span data-ttu-id="a9aec-275">Valeur de type <see cref="T:System.IO.SeekOrigin" /> indiquant le point de référence à partir duquel la nouvelle position est obtenue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-275">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point from which to obtain the new position.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-276">Définit la position dans le flux actuel mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-276">Sets the position within the current buffered stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-277">Nouvelle position dans le flux actuel mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-277">The new position within the current buffered stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-278">Si `offset` est négatif, la nouvelle position précède la position spécifiée par `origin` du nombre d'octets spécifié par `offset`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-278">If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="a9aec-279">Si `offset` est 0, la nouvelle position sera la position spécifiée par `origin`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-279">If `offset` is 0, the new position will be the position specified by `origin`.</span></span> <span data-ttu-id="a9aec-280">Si `offset` est positif, la nouvelle position suit la position spécifiée par `origin` du nombre d'octets spécifié par `offset`.</span><span class="sxs-lookup"><span data-stu-id="a9aec-280">If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="a9aec-281">Quand un <xref:System.IO.BufferedStream> objet est le flux de base pour un <xref:System.IO.StreamReader> de l’objet, l’appel le <xref:System.IO.BufferedStream.Seek%2A> méthode peut entraîner la position du flux de données ne correspondent plus à la position de la mémoire tampon interne dans le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a9aec-281">When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the <xref:System.IO.BufferedStream.Seek%2A> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</span></span> <span data-ttu-id="a9aec-282">Pour rétablir la mémoire tampon interne, appelez le <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> méthode ; Toutefois, cette méthode ralentit les performances et doit être appelée uniquement lorsque cela est absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a9aec-282">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="a9aec-283">La recherche au-delà de la longueur du flux de données est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="a9aec-283">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-284">Le flux n’est pas ouvert ou bien il est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-284">The stream is not open or is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-285">Le flux ne prend pas en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-285">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-286">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-286">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.IO.SeekOrigin" />
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="a9aec-287">Entier indiquant la longueur (en octets) requise pour le flux actuel mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-287">An integer indicating the desired length of the current buffered stream in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-288">Définit la longueur du flux mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-288">Sets the length of the buffered stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-289">La mémoire tampon est vidée avant de définir la longueur de la source de données sous-jacente ou le référentiel.</span><span class="sxs-lookup"><span data-stu-id="a9aec-289">The buffer is flushed before setting the length of the underlying data source or repository.</span></span> <span data-ttu-id="a9aec-290">Si la valeur spécifiée est inférieure à la longueur actuelle du flux mis en mémoire tampon, le flux mis en mémoire tampon est tronqué.</span><span class="sxs-lookup"><span data-stu-id="a9aec-290">If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</span></span> <span data-ttu-id="a9aec-291">Si la valeur spécifiée est supérieure à la longueur actuelle du flux mis en mémoire tampon, le flux mis en mémoire tampon est développé.</span><span class="sxs-lookup"><span data-stu-id="a9aec-291">If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</span></span> <span data-ttu-id="a9aec-292">Si le flux mis en mémoire tampon est développé, le contenu du flux mis en mémoire tampon entre l’ancienne et la nouvelle longueur n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="a9aec-292">If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</span></span>  
  
 <span data-ttu-id="a9aec-293">`SetLength` vide toutes les écritures en mémoire tampon, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a9aec-293">`SetLength` flushes any buffered writes if necessary.</span></span>  
  
 <span data-ttu-id="a9aec-294">Un flux doit prendre en charge l’écriture et la recherche pour `SetLength` pour fonctionner.</span><span class="sxs-lookup"><span data-stu-id="a9aec-294">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-295">
            <paramref name="value" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-295">
              <paramref name="value" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-296">Le flux n’est pas ouvert ou bien il est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-296">The stream is not open or is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-297">Le flux ne prend pas en charge l’écriture et la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-297">The stream does not support both writing and seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-298">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-298">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="a9aec-299">Tableau d’octets à partir duquel <c>count</c> octets sont copiés vers le flux actuel mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-299">The byte array from which to copy <c>count</c> bytes to the current buffered stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="a9aec-300">Dans la mémoire tampon, offset à partir duquel commence la copie des octets dans le flux actuel mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-300">The offset in the buffer at which to begin copying bytes to the current buffered stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="a9aec-301">Nombre d’octets à écrire dans le flux actuel mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-301">The number of bytes to be written to the current buffered stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-302">Copie les octets dans le flux mis en mémoire tampon et avance la position actuelle dans ce flux du nombre d’octets écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-302">Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a9aec-303">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.BufferedStream> classe.</span><span class="sxs-lookup"><span data-stu-id="a9aec-303">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-304">La longueur de <paramref name="array" /> moins <paramref name="offset" /> est inférieure à <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-304">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-305">
            <paramref name="array" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-305">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-306">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-306">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a9aec-307">Le flux est fermé ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-307">The stream is closed or <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-308">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-308">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-309">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-309">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="a9aec-310">Mémoire tampon dont sont issues les données à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-310">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="a9aec-311">Le décalage en octets, commençant à zéro, dans <c>buffer</c>, où commencer la copie des octets dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-311">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="a9aec-312">Nombre maximal d'octets à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-312">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="a9aec-313">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-313">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-314">Écrit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position actuelle dans ce flux du nombre d'octets écrits et surveille les demandes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-314">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a9aec-315">Tâche qui représente l’opération d’écriture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-315">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a9aec-316">Vous pouvez créer un jeton d’annulation en créant une instance de la <xref:System.Threading.CancellationTokenSource> classe et en passant le <xref:System.Threading.CancellationTokenSource.Token%2A> propriété en tant que le `cancellationToken` paramètre.</span><span class="sxs-lookup"><span data-stu-id="a9aec-316">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-317">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-317">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a9aec-318">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-318">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a9aec-319">La somme de <paramref name="offset" /> et de <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-319">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-320">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-320">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-321">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-321">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a9aec-322">Le flux est actuellement utilisé par une opération d’écriture précédente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-322">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="a9aec-323">Octet à écrire dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-323">A byte to write to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a9aec-324">Écrit un octet à la position actuelle dans le flux mis en mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-324">Writes a byte to the current position in the buffered stream.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a9aec-325">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-325">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a9aec-326">
            <paramref name="value" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-326">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a9aec-327">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a9aec-327">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>