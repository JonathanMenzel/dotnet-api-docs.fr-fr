<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9804627f9162207d228105246faab6e636e6c42c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58735973" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Écoute les notifications de modifications du système de fichiers et déclenche un événement lorsqu'un répertoire ou un fichier d'un répertoire est modifié.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.IO.FileSystemWatcher> pour surveiller les modifications dans un répertoire spécifié. Vous pouvez surveiller les modifications de fichiers et sous-répertoires du répertoire spécifié. Vous pouvez créer un composant pour regarder les fichiers sur un ordinateur local, un lecteur réseau ou un ordinateur distant.  
  
 Pour surveiller les modifications dans tous les fichiers, définissez le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété sur une chaîne vide (« ») ou utiliser des caractères génériques (« *.\*»). Pour visionner un fichier spécifique, définissez la <xref:System.IO.FileSystemWatcher.Filter%2A> propriété le nom de fichier. Par exemple, pour surveiller les modifications apportées au fichier mondoc.txt, définissez le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété « Doit être mondoc.txt ». Vous pouvez également surveiller les modifications apportées à un certain type de fichier. Par exemple, pour surveiller les modifications apportées aux fichiers de texte, définissez la <xref:System.IO.FileSystemWatcher.Filter%2A> propriété à «\*.txt ».  
  
 Il existe plusieurs types de modifications que vous pouvez surveiller les dans un fichier ou répertoire. Par exemple, vous pouvez observer les modifications de `Attributes`, le `LastWrite` date et l’heure, ou le `Size` de fichiers ou répertoires. Cela en définissant le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propriété de la <xref:System.IO.NotifyFilters> valeurs. Pour plus d’informations sur le type de modifications que vous pouvez regarder, consultez <xref:System.IO.NotifyFilters>.  
  
 Vous pouvez regarder de changement de nom, suppression ou la création de fichiers ou répertoires. Par exemple, pour surveiller le changement de nom des fichiers texte, définissez la <xref:System.IO.FileSystemWatcher.Filter%2A> propriété « *.txt » et appelez le <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> méthode avec un <xref:System.IO.WatcherChangeTypes.Renamed> spécifié pour son paramètre.  
  
 Le système d’exploitation Windows notifie votre composant de modifications de fichiers dans une mémoire tampon créée par le <xref:System.IO.FileSystemWatcher>. Si plusieurs modifications sont apportées dans une courte période, la mémoire tampon peut provoquer un débordement. Cela entraîne le composant de perdre la trace des modifications dans le répertoire, et il ne sera qu’une notification standard. Augmentation de la taille de la mémoire tampon avec la <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriété est coûteuse, car elle provient d’une mémoire non paginée ne peut pas être transférée sur le disque, donc conserver la mémoire tampon en tant que petite encore une grande suffisant pour ne manquez pas n’importe quel fichier événements de modification. Pour éviter un dépassement de capacité de mémoire tampon, utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> notifications de modifications de propriétés afin de filtrer les indésirables.  
  
 Pour obtenir la liste des valeurs initiales des propriétés d’une instance de <xref:System.IO.FileSystemWatcher>, consultez le <xref:System.IO.FileSystemWatcher.%23ctor%2A> constructeur.  
  
 Notez les points suivants lorsque vous utilisez la <xref:System.IO.FileSystemWatcher> classe.  
  
-   Fichiers masqués ne sont pas ignorés.  
  
-   Dans certains systèmes, <xref:System.IO.FileSystemWatcher> signale les modifications apportées aux fichiers à l’aide du format de nom de 8.3 fichier court. Par exemple, une modification apportée à « LongFileName.LongExtension » peut être signalée comme « LongFi ~. LON ».  
  
-   Cette classe contient une demande de liaison et une demande d’héritage au niveau de la classe qui s’applique à tous les membres. Un <xref:System.Security.SecurityException> est levée lorsque l’appelant immédiat ou la classe dérivée n’a pas d’autorisations de confiance totale. Pour plus d’informations sur les demandes de sécurité, consultez [demandes de liaison](~/docs/framework/misc/link-demands.md).  
  
-   La taille maximale que vous pouvez définir pour le <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriété pour la surveillance d’un répertoire sur le réseau est de 64 Ko.  
  
> [!NOTE]
>  En cours d’exécution <xref:System.IO.FileSystemWatcher> sur Windows 98 n’est pas pris en charge.  
  
## <a name="copying-and-moving-folders"></a>Copier et déplacer des dossiers  
 Le système d’exploitation et <xref:System.IO.FileSystemWatcher> objet interpréter une action Couper-coller ou une action de déplacement comme une action de changement de nom pour un dossier et son contenu. Si vous coupez et collez un dossier avec des fichiers dans un dossier suivi, le <xref:System.IO.FileSystemWatcher> objet signale uniquement le dossier en tant que nouveau, mais pas son contenu, car ils sont essentiellement renommés.  
  
 Pour être averti que le contenu des dossiers ont été déplacé ou copié dans un dossier de contrôle, fournir <xref:System.IO.FileSystemWatcher.OnChanged%2A> et <xref:System.IO.FileSystemWatcher.OnRenamed%2A> méthodes de gestionnaire d’événements comme indiqué dans le tableau suivant.  
  
|Gestionnaire d’événements|Événements gérés|Effectue|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Signaler les modifications dans les attributs de fichier, les fichiers créés et les fichiers supprimés.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Répertorier les anciens et nouveaux chemins d’accès des fichiers renommés et des dossiers, développez de manière récursive si nécessaire.|  
  
## <a name="events-and-buffer-sizes"></a>Événements et les tailles de mémoire tampon  
 Notez que plusieurs facteurs peuvent affecter les événements de changement de système de fichiers sont déclenchés, comme décrit par ce qui suit :  
  
-   Opérations de système de fichiers courantes peuvent déclencher plusieurs événements. Par exemple, lorsqu’un fichier est déplacé d’un répertoire à un autre, plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> et certains <xref:System.IO.FileSystemWatcher.OnCreated%2A> et <xref:System.IO.FileSystemWatcher.OnDeleted%2A> événements peuvent être déclenchés. Déplacement de qu'un fichier est une opération complexe qui se compose de plusieurs opérations simples, déclenchant donc plusieurs événements. De même, certaines applications (par exemple, les logiciels antivirus) peuvent entraîner des événements de système de fichiers supplémentaires qui sont détectés par <xref:System.IO.FileSystemWatcher>.  
  
-   Le <xref:System.IO.FileSystemWatcher> peut regarder les disques tant qu’ils ne sont pas basculés ou supprimés. Le <xref:System.IO.FileSystemWatcher> ne déclenche pas d’événements pour les CD et DVD, étant donné que les horodatages et les propriétés ne peuvent pas modifier. Ordinateurs distants doivent avoir une des plateformes requises installés pour le composant de fonctionner correctement.  
  
-   Si plusieurs <xref:System.IO.FileSystemWatcher> objets voient le même chemin d’accès UNC dans XP de Windows antérieure au Service Pack 1 ou Windows 2000 SP2 ou version antérieure, seul un des objets déclenchera un événement. Sur les ordinateurs exécutant Windows XP SP1 et versions ultérieures, Windows 2000 SP3 ou version ultérieure ou Windows Server 2003, tous les <xref:System.IO.FileSystemWatcher> objets déclenche les événements appropriés.  
  
 Notez qu’un <xref:System.IO.FileSystemWatcher> peut manquer un événement lorsque la taille de mémoire tampon est dépassée. Pour éviter de manquer des événements, suivez ces instructions :  
  
-   Augmenter la taille du tampon en définissant le <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriété.  
  
-   Évitez de regarder les fichiers portant des noms de fichiers longs, car un nom de fichier long contribue au remplissage de la mémoire tampon. Pensez à renommer ces fichiers à l’aide des noms plus courts.  
  
-   Gardez votre événement aussi court que possible du code de gestion.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileSystemWatcher> à surveiller le répertoire spécifié au moment de l’exécution. Le composant est défini pour surveiller les modifications de `LastWrite` et `LastAccess` du temps, la création, suppression, ou le changement de nom des fichiers texte dans le répertoire. Si un fichier est modifié, créé ou supprimé, le chemin d’accès au fichier s’imprime sur la console. Lorsqu’un fichier est renommé, les chemins d’accès nouvelles et anciennes impriment sur la console.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">pour dériver la <see cref="T:System.Diagnostics.ProcessStartInfo" /> classe. Valeur de la demande : <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Jeux d’autorisations nommés : <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">À l’aide d’un composant FileSystemWatcher dans un formulaire Windows</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas surveiller un ordinateur distant qui n’a pas de Windows NT ou Windows 2000. Vous ne pouvez pas surveiller un ordinateur distant de Windows NT 4.0 à partir d’un ordinateur Windows NT 4.0.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.IO.FileSystemWatcher>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|combinaison d’opérations OR `LastWrite`, `FileName`, et `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*« (Analyse de tous les fichiers.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|une chaîne vide ( » »)|  
  
> [!NOTE]
>  Le composant ne surveillera pas le répertoire spécifié jusqu'à ce que le <xref:System.IO.FileSystemWatcher.Path%2A> est défini, et <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> est `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileSystemWatcher> objet à surveiller le répertoire spécifié au moment de l’exécution. Le <xref:System.IO.FileSystemWatcher> objet surveille les modifications apportées dans `LastWrite` et `LastAccess` heures et pour la création, suppression ou modification du nom du texte de fichiers dans le répertoire. Si un fichier est modifié, créé ou supprimé, le chemin d’accès au fichier s’affiche dans la console. Lorsqu’un fichier est renommé, les chemins d’accès nouvelles et anciennes affichent dans la console.  
  
 Cet exemple utilise le <xref:System.Diagnostics> et <xref:System.IO> espaces de noms.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Répertoire à surveiller en notation standard ou UNC (Universal Naming Convention).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileSystemWatcher" /> en fonction du répertoire spécifié à surveiller.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Le composant ne surveillera pas le répertoire spécifié jusqu'à ce que le <xref:System.IO.FileSystemWatcher.Path%2A> est défini, et <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> est `true`.  
  
 Le composant peut surveiller les fichiers sur votre ordinateur personnel, un lecteur réseau ou un ordinateur distant.  
  
 Vous ne pouvez pas surveiller un ordinateur distant qui n’a pas de Windows NT ou Windows 2000. Vous ne pouvez pas surveiller un ordinateur distant de Windows NT 4.0 à partir d’un ordinateur Windows NT 4.0. Le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété est définie par défaut à surveiller tous les fichiers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est une chaîne vide ("").  
  
ou 
Le chemin d'accès spécifié via le paramètre <paramref name="path" /> n'existe pas.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> est trop longue.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Répertoire à surveiller en notation standard ou UNC (Universal Naming Convention).</param>
        <param name="filter">Type de fichier dont le suivi doit être assuré. Par exemple, "*.txt" assure le suivi des modifications apportées à tous les fichiers texte.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileSystemWatcher" /> en fonction du répertoire spécifié et du type de fichiers à surveiller.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Le composant ne surveillera pas le répertoire spécifié jusqu'à ce que le <xref:System.IO.FileSystemWatcher.Path%2A> est défini, et <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> est `true`.  
  
 Le composant peut surveiller les fichiers sur votre ordinateur personnel, un lecteur réseau ou un ordinateur distant.  
  
 Vous ne pouvez pas surveiller un ordinateur distant qui n’a pas de Windows NT ou Windows 2000. Vous ne pouvez pas surveiller un ordinateur distant de Windows NT 4.0 à partir d’un ordinateur Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.  
  
ou 
Le paramètre <paramref name="filter" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est une chaîne vide ("").  
  
ou 
Le chemin d'accès spécifié via le paramètre <paramref name="path" /> n'existe pas.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> est trop longue.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lance l'initialisation d'un élément <see cref="T:System.IO.FileSystemWatcher" /> utilisé sur un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] conception environnement utilise cette méthode pour démarrer l’initialisation d’un composant utilisé dans un formulaire ou par un autre composant. Le <xref:System.IO.FileSystemWatcher.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.IO.FileSystemWatcher.BeginInit%2A> et <xref:System.IO.FileSystemWatcher.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un fichier ou un répertoire du <see cref="P:System.IO.FileSystemWatcher.Path" /> spécifié est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileSystemWatcher.Changed> événement est déclenché lorsque des modifications sont apportées à la taille, les attributs système, la dernière écriture heure, heure du dernier accès, autorisations de sécurité d’un fichier ou un répertoire dans le répertoire surveillé.  
  
> [!NOTE]
>  Opérations de système de fichiers courantes peuvent déclencher plusieurs événements. Par exemple, lorsqu’un fichier est déplacé d’un répertoire à un autre, plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> et certains <xref:System.IO.FileSystemWatcher.OnCreated%2A> et <xref:System.IO.FileSystemWatcher.OnDeleted%2A> événements peuvent être déclenchés. Déplacement de qu'un fichier est une opération complexe qui se compose de plusieurs opérations simples, déclenchant donc plusieurs événements. De même, certaines applications (par exemple, les logiciels antivirus) peuvent entraîner des événements de système de fichiers supplémentaires qui sont détectés par <xref:System.IO.FileSystemWatcher>.  
  
 Utilisez <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> pour restreindre le nombre de notifications générées lors du traitement de cet événement.  
  
> [!NOTE]
>  Le <xref:System.IO.FileSystemWatcher.Changed> événement est déclenché de manière inattendue lorsqu’un fichier est renommé, mais n’est pas déclenché lorsqu’un répertoire est renommé. Pour surveiller le changement de nom, utilisez le <xref:System.IO.FileSystemWatcher.Renamed> événement.  
  
> [!NOTE]
>  L’ordre dans lequel le <xref:System.IO.FileSystemWatcher.Changed> événement est déclenché par rapport à l’autre <xref:System.IO.FileSystemWatcher> événements peuvent changer lors du <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriété n’est pas `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.FileSystemWatcher.Changed> événement pour afficher le chemin d’accès à la console chaque fois que le fichier surveillé est modifié.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un fichier ou un répertoire du <see cref="P:System.IO.FileSystemWatcher.Path" /> spécifié est créé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certaines occurrences courantes, telles que la copie ou déplace un fichier ou répertoire, ne correspondent pas directement à un événement, mais ces occurrences provoquent le déclenchement d’événements. Lorsque vous copiez un fichier ou répertoire, le système déclenche un <xref:System.IO.FileSystemWatcher.Created> événement dans le répertoire dans lequel le fichier a été copié, si le suivi de ce répertoire. Si le répertoire à partir duquel vous avez copié suivi est assuré par une autre instance de <xref:System.IO.FileSystemWatcher>, aucun événement ne serait déclenché. Par exemple, vous créez deux instances de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 est défini pour surveiller les « C:\My Documents » et FileSystemWatcher2 est défini pour surveiller les « Documents C:\Your ». Si vous copiez un fichier à partir de « Mes Documents » dans « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> événement sera déclenché par FileSystemWatcher2, mais aucun événement n’est déclenché par FileSystemWatcher1. Contrairement à copier, déplacer un fichier ou répertoire déclenche deux événements. À partir de l’exemple précédent, si vous déplacez un fichier à partir de « Mes Documents » vers « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> aurait été déclenché par FileSystemWatcher2 et un <xref:System.IO.FileSystemWatcher.Deleted> aurait été déclenché par FileSystemWatcher1.  
  
> [!NOTE]
>  Opérations de système de fichiers courantes peuvent déclencher plusieurs événements. Par exemple, lorsqu’un fichier est déplacé d’un répertoire à un autre, plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> et certains <xref:System.IO.FileSystemWatcher.OnCreated%2A> et <xref:System.IO.FileSystemWatcher.OnDeleted%2A> événements peuvent être déclenchés. Déplacement de qu'un fichier est une opération complexe qui se compose de plusieurs opérations simples, déclenchant donc plusieurs événements. De même, certaines applications (par exemple, les logiciels antivirus) peuvent entraîner des événements de système de fichiers supplémentaires qui sont détectés par <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  L’ordre dans lequel le <xref:System.IO.FileSystemWatcher.Created> événement est déclenché par rapport à l’autre <xref:System.IO.FileSystemWatcher> événements peuvent changer lors du <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriété n’est pas `null`.  
  
 Le <xref:System.IO.FileSystemWatcher.OnCreated%2A> événement est déclenché dès qu’un fichier est créé. Si un fichier est copié ou transféré vers un répertoire surveillé, le <xref:System.IO.FileSystemWatcher.OnCreated%2A> événement est déclenché immédiatement, suivi par un ou plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> événements.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.FileSystemWatcher.Created> événement pour afficher le chemin d’accès à la console chaque fois que le fichier à suivre est créé.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un fichier ou un répertoire du <see cref="P:System.IO.FileSystemWatcher.Path" /> spécifié est supprimé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certaines occurrences courantes, telles que la copie ou déplace un fichier ou répertoire, ne correspondent pas directement à un événement, mais ces occurrences provoquent le déclenchement d’événements. Lorsque vous copiez un fichier ou répertoire, le système déclenche un <xref:System.IO.FileSystemWatcher.Created> événement dans le répertoire dans lequel le fichier a été copié, si le suivi de ce répertoire. Si le répertoire à partir duquel vous avez copié suivi est assuré par une autre instance de <xref:System.IO.FileSystemWatcher>, aucun événement ne serait déclenché. Par exemple, vous créez deux instances de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 est défini pour surveiller les « C:\My Documents » et FileSystemWatcher2 est défini pour surveiller les « Documents C:\Your ». Si vous copiez un fichier à partir de « Mes Documents » dans « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> événement sera déclenché par FileSystemWatcher2, mais aucun événement n’est déclenché par FileSystemWatcher1. Contrairement à copier, déplacer un fichier ou répertoire déclenche deux événements. À partir de l’exemple précédent, si vous déplacez un fichier à partir de « Mes Documents » vers « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> aurait été déclenché par FileSystemWatcher2 et un <xref:System.IO.FileSystemWatcher.Deleted> aurait été déclenché par FileSystemWatcher1.  
  
> [!NOTE]
>  Opérations de système de fichiers courantes peuvent déclencher plusieurs événements. Par exemple, lorsqu’un fichier est déplacé d’un répertoire à un autre, plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> et certains <xref:System.IO.FileSystemWatcher.OnCreated%2A> et <xref:System.IO.FileSystemWatcher.OnDeleted%2A> événements peuvent être déclenchés. Déplacement de qu'un fichier est une opération complexe qui se compose de plusieurs opérations simples, déclenchant donc plusieurs événements. De même, certaines applications (par exemple, les logiciels antivirus) peuvent entraîner des événements de système de fichiers supplémentaires qui sont détectés par <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  L’ordre dans lequel le <xref:System.IO.FileSystemWatcher.Deleted> événement est déclenché par rapport à l’autre <xref:System.IO.FileSystemWatcher> événements peuvent changer lors du <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriété n’est pas `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.FileSystemWatcher.Deleted> événement pour afficher le chemin d’accès à la console chaque fois que le fichier à suivre est supprimé.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.FileSystemWatcher" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). <xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.FileSystemWatcher.Dispose%2A> méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle <xref:System.IO.FileSystemWatcher.Dispose%2A> avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.Compression.DeflateStream>. Cette méthode appelle la méthode <xref:System.ComponentModel.Component.Dispose%2A> de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le composant est activé.</summary>
        <value><see langword="true" /> si le composant est activé ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />. Si vous utilisez le composant sur un concepteur dans [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], la valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le composant déclenche des événements, sauf si vous définissez <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> à `true`.  
  
> [!NOTE]
>  Le composant ne surveillera pas le répertoire spécifié jusqu'à ce que le <xref:System.IO.FileSystemWatcher.Path%2A> propriété a été définie et <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> est `true`.  
  
 Le <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> méthode permet de gestionnaires d’événements à appeler pour répondre aux modifications de fichier même si cette propriété est définie sur `false`.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileSystemWatcher> à surveiller le répertoire spécifié au moment de l’exécution. Le composant est défini pour surveiller les modifications de `LastWrite` et `LastAccess` du temps, la création, suppression, ou le changement de nom des fichiers texte dans le répertoire. Si un fichier est modifié, créé ou supprimé, le chemin d’accès au fichier s’imprime sur la console. Lorsqu’un fichier est renommé, les chemins d’accès nouvelles et anciennes impriment sur la console.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet <see cref="T:System.IO.FileSystemWatcher" /> a été supprimé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Microsoft Windows NT ou une version ultérieure.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le répertoire spécifié dans <see cref="P:System.IO.FileSystemWatcher.Path" /> est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> n'a pas été défini ou n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine l'initialisation d'un <see cref="T:System.IO.FileSystemWatcher" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] conception environnement utilise cette méthode pour terminer l’initialisation d’un composant utilisé dans un formulaire ou par un autre composant. Le <xref:System.IO.FileSystemWatcher.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.IO.FileSystemWatcher.BeginInit%2A> et <xref:System.IO.FileSystemWatcher.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'instance de <see cref="T:System.IO.FileSystemWatcher" /> ne peut pas continuer à surveiller des modifications ou lorsque la mémoire tampon interne excède.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché chaque fois que quelque chose empêche le <xref:System.IO.FileSystemWatcher> objet à partir de la surveillance des modifications. Par exemple, si l’objet contrôle les modifications dans un répertoire distant et la connexion à ce répertoire est perdue, le <xref:System.IO.FileSystemWatcher.Error> événement est déclenché.  
  
 Le système vous informe des modifications de fichier, et stocke ces modifications dans une mémoire tampon que le composant crée et passe aux API. Si plusieurs modifications sont apportées dans une courte période, la mémoire tampon peut provoquer un débordement. Cela entraîne le composant de perdre la trace des modifications dans le répertoire, et il ne sera qu’une notification standard. Augmentation de la taille de la mémoire tampon est coûteuse, car elle provient de non à la mémoire paginée ne peut pas être transférée sur le disque, c’est le cas conserver la mémoire tampon aussi réduite que possible. Pour éviter un dépassement de capacité de mémoire tampon, utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> notifications de modifications de propriétés à filtrer les indésirables.  
  
> [!NOTE]
>  Opérations de système de fichiers courantes peuvent déclencher plusieurs événements. Par exemple, lorsqu’un fichier est déplacé d’un répertoire à un autre, plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> et certains <xref:System.IO.FileSystemWatcher.OnCreated%2A> et <xref:System.IO.FileSystemWatcher.OnDeleted%2A> événements peuvent être déclenchés. Déplacement de qu'un fichier est une opération complexe qui se compose de plusieurs opérations simples, déclenchant donc plusieurs événements. De même, certaines applications (par exemple, les logiciels antivirus) peuvent entraîner des événements de système de fichiers supplémentaires qui sont détectés par <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la chaîne de filtrage utilisée pour déterminer les fichiers à surveiller dans un répertoire.</summary>
        <value>Chaîne de filtrage. La valeur par défaut est « *. \*« (Surveille tous les fichiers.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour surveiller les modifications dans tous les fichiers, la valeur la <xref:System.IO.FileSystemWatcher.Filter%2A> propriété sur une chaîne vide ( » »). Pour visionner un fichier spécifique, définissez la <xref:System.IO.FileSystemWatcher.Filter%2A> propriété le nom de fichier. Par exemple, pour surveiller les modifications apportées au fichier mondoc.txt, définissez le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété « Doit être mondoc.txt ». Vous pouvez également surveiller les modifications apportées à un certain type de fichier. Par exemple, pour surveiller les modifications dans les fichiers texte, définissez le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété sur « *.txt ». Utilisation de plusieurs filtres tels que «\*.txt&#124;\*.doc » n’est pas pris en charge.  
  
 Le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété peut être modifiée après le <xref:System.IO.FileSystemWatcher> objet a commencé à recevoir des événements.  
  
 Pour plus d’informations sur le filtrage de notifications inutiles, consultez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, et <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriétés.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> accepte les caractères génériques pour les fichiers correspondants, comme indiqué dans les exemples suivants.  
  
|Chaîne de filtrage|Surveille les fichiers suivants|  
|-------------------|---------------------------------|  
|*.\*|Tous les fichiers (par défaut). Une chaîne vide (" ») surveille également tous les fichiers.|  
|*.txt|Tous les fichiers avec une extension « txt ».|  
|*recipe.doc|Tous les fichiers se terminant par « recette » avec une extension « doc ».|  
|win*.xml|Tous les fichiers commençant par « win » avec une extension « xml ».|  
|Sales * 200 ?. xls|Correspond à ce qui suit :<br /><br /> Ventes juillet 2001.xlsSales août 2002.xlsSales mars 2004.xls<br /><br /> mais ne correspond pas à :<br /><br /> Ventes Nov 1999.xls|  
|MyReport.Doc|Surveille uniquement le suivi de MyReport.doc|  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileSystemWatcher> à surveiller le répertoire spécifié au moment de l’exécution. Le composant est défini pour surveiller les modifications de `LastWrite` et `LastAccess` du temps, la création, suppression, ou le changement de nom des fichiers texte dans le répertoire. Si un fichier est modifié, créé ou supprimé, le chemin d’accès au fichier s’imprime sur la console. Lorsqu’un fichier est renommé, les chemins d’accès nouvelles et anciennes impriment sur la console.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les sous-répertoires du chemin d'accès spécifié doivent être surveillés.</summary>
        <value><see langword="true" /> si vous voulez surveiller les sous-répertoires ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> à `true` lorsque vous souhaitez surveiller les notifications de modification des fichiers et répertoires contenus dans le répertoire spécifié par le biais du <xref:System.IO.FileSystemWatcher.Path%2A> propriété et ses sous-répertoires. Définition de la <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propriété `false` vous aide à réduire le nombre de notifications envoyées à la mémoire tampon interne. Pour plus d’informations sur le filtrage de notifications inutiles, consultez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> et <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriétés.  
  
 Lorsque `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> est récurrente à travers l’ensemble du sous-arbre, pas seulement les répertoires enfants immédiats. Le chemin d’accès relatif à un fichier ou répertoire dans le sous-arbre retourne dans le <xref:System.IO.FileSystemEventArgs.Name%2A> propriété de <xref:System.IO.FileSystemEventArgs> et <xref:System.IO.RenamedEventArgs.OldName%2A> propriété de <xref:System.IO.RenamedEventArgs>, selon les modifications suivies. Vous pouvez obtenir le chemin d’accès qualifié complet à partir de la <xref:System.IO.FileSystemEventArgs.FullPath%2A> propriété de <xref:System.IO.FileSystemEventArgs> et <xref:System.IO.RenamedEventArgs.OldFullPath%2A> propriété de <xref:System.IO.RenamedEventArgs>, selon les modifications suivies.  
  
 Si un répertoire est créé dans le sous-arbre du répertoire que vous surveillez et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> est `true`, ce répertoire sera automatiquement surveillé.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille (en octets) de la mémoire tampon interne.</summary>
        <value>Taille de la mémoire tampon interne en octets. La valeur par défaut est 8192 (8 Ko).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez définir la mémoire tampon de 4 Ko ou plus, mais il ne doit pas dépasser 64 Ko. Si vous essayez de définir la <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriété inférieure à 4 096 octets, votre valeur est ignorée et la <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriété est définie sur 4 096 octets. Pour de meilleures performances, utilisez un multiple de 4 Ko sur les ordinateurs Intel.  
  
 Le système notifie le composant des modifications de fichier, et stocke ces modifications dans une mémoire tampon le composant crée et passe aux API. Chaque événement peut utiliser jusqu'à 16 octets de mémoire, sans le nom de fichier. Si plusieurs modifications sont apportées dans une courte période, la mémoire tampon peut provoquer un débordement. Cela entraîne le composant de perdre la trace des modifications dans le répertoire, et il ne sera qu’une notification standard. Augmentation de la taille de la mémoire tampon peut empêcher manquantes du système de fichiers des événements de modification. Toutefois, augmenter la taille de mémoire tampon est coûteuse, car elle provient d’une mémoire non paginée ne peut pas être transférée sur le disque, par conséquent, conserver la mémoire tampon autant que possible. Pour éviter un dépassement de capacité de mémoire tampon, utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> et <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> notifications de modifications de propriétés à filtrer les indésirables.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de modifications à surveiller.</summary>
        <value>Une des valeurs de <see cref="T:System.IO.NotifyFilters" />. La valeur par défaut est la combinaison d'opérations de bits OR de <see langword="LastWrite" />, <see langword="FileName" /> et de <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez combiner les membres de la <xref:System.IO.NotifyFilters> énumération pour surveiller plusieurs types de modification à la fois. Par exemple, vous pouvez regarder les modifications de taille d’un fichier et les modifications dans le `LastWrite` temps. Cela déclenche un événement chaque fois qu’il existe un changement de taille de fichier ou dossier, ou une modification de la `LastWrite` l’heure de fichier ou du dossier.  
  
 Il s’agit d’une façon de filtrer les notifications inutiles. Pour plus d’informations sur le filtrage de notifications inutiles, consultez le <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, et <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propriétés.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileSystemWatcher> à surveiller le répertoire spécifié au moment de l’exécution. Le composant est défini pour surveiller les modifications de `LastWrite` et `LastAccess` du temps, la création, suppression, ou le changement de nom des fichiers texte dans le répertoire. Si un fichier est modifié, créé ou supprimé, le chemin d’accès au fichier s’imprime sur la console. Lorsqu’un fichier est renommé, les chemins d’accès nouvelles et anciennes impriment sur la console.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur n'est pas une combinaison d'opérations de bits OR valide des valeurs <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur qui est définie n'est pas valide.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.FileSystemEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> est appelée lorsque des modifications sont apportées à la taille, les attributs système, heure de dernière écriture, heure du dernier accès, autorisations de sécurité d’un fichier ou un répertoire dans le répertoire surveillé.  
  
 Utilisez le <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propriété pour restreindre le nombre d’événements déclenché lorsque le <xref:System.IO.FileSystemWatcher.Changed> événement est géré.  
  
 Le <xref:System.IO.FileSystemWatcher.OnCreated%2A> événement est déclenché dès qu’un fichier est créé. Si un fichier est copié ou transféré vers un répertoire surveillé, le <xref:System.IO.FileSystemWatcher.OnCreated%2A> événement est déclenché immédiatement, suivi par un ou plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> événements.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> (méthode).</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.FileSystemEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> est appelé lorsqu’un fichier ou répertoire est créé dans le répertoire surveillé.  
  
 Certaines occurrences courantes, telles que la copie ou déplace un fichier ou répertoire, ne correspondent pas directement à un événement, mais ces occurrences provoquent le déclenchement d’événements. Lorsque vous copiez un fichier ou répertoire, le système déclenche un <xref:System.IO.FileSystemWatcher.Created> événement dans le répertoire dans lequel le fichier a été copié, si le suivi de ce répertoire. Si le répertoire à partir duquel vous avez copié suivi est assuré par une autre instance de <xref:System.IO.FileSystemWatcher>, aucun événement ne serait déclenché. Par exemple, vous créez deux instances de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 est défini pour surveiller les « C:\My Documents » et FileSystemWatcher2 est défini pour surveiller les « Documents C:\Your ». Si vous copiez un fichier à partir de « Mes Documents » et collez-le dans « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> événement sera déclenché par FileSystemWatcher2, mais aucun événement n’est déclenché par FileSystemWatcher1. Contrairement à la copie, le déplacement d’un fichier ou répertoire déclenche deux événements. À partir de l’exemple précédent, si vous déplacez un fichier à partir de « Mes Documents » vers « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> aurait été déclenché FileSystemWatcher2 et un <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1 aurait été déclenché.  
  
 Le <xref:System.IO.FileSystemWatcher.OnCreated%2A> événement est déclenché dès qu’un fichier est créé. Si un fichier est copié ou transféré vers un répertoire surveillé, le <xref:System.IO.FileSystemWatcher.OnCreated%2A> événement est déclenché immédiatement, suivi par un ou plusieurs <xref:System.IO.FileSystemWatcher.OnChanged%2A> événements.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> (méthode).</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.FileSystemEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> est appelée lorsqu’un fichier ou répertoire, dans le répertoire surveillé, est supprimé.  
  
 Certaines occurrences courantes, telles que la copie ou déplace un fichier ou répertoire, ne correspondent pas directement à un événement, mais ces occurrences provoquent le déclenchement d’événements. Lorsque vous copiez un fichier ou répertoire, le système déclenche un <xref:System.IO.FileSystemWatcher.Created> événement dans le répertoire dans lequel le fichier a été copié, si le suivi de ce répertoire. Si le répertoire à partir duquel vous avez copié suivi est assuré par une autre instance de <xref:System.IO.FileSystemWatcher>, aucun événement ne serait déclenché. Par exemple, vous créez deux instances de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 est défini pour surveiller les « C:\My Documents » et FileSystemWatcher2 est défini pour surveiller les « Documents C:\Your ». Si vous copiez un fichier à partir de « Mes Documents » dans « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> événement sera déclenché par FileSystemWatcher2, mais aucun événement n’est déclenché par FileSystemWatcher1. Contrairement à la copie, le déplacement d’un fichier ou répertoire déclenche deux événements. À partir de l’exemple précédent, si vous déplacez un fichier à partir de « Mes Documents » vers « Vos Documents », un <xref:System.IO.FileSystemWatcher.Created> aurait été déclenché par FileSystemWatcher2 et un <xref:System.IO.FileSystemWatcher.Deleted> aurait été déclenché par FileSystemWatcher1.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> (méthode).</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.ErrorEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> est appelée lorsqu’une erreur se produit.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> (méthode).</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.RenamedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> est appelée lorsqu’un fichier ou répertoire dans le répertoire surveillé est renommé. Son <xref:System.IO.RenamedEventArgs> argument contient des informations sur l’opération de changement de nom, tels que le type de modification, le chemin d’accès nouvel et ancienne et les anciens et nouveaux noms. Notez que son <xref:System.IO.FileSystemEventArgs.Name> propriété peut être null pour les événements renommés du si le <xref:System.IO.FileSystemWatcher> ne correspondent pas les événements anciens et nouveaux noms à partir du système d’exploitation. 
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> (méthode).</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le chemin d'accès du répertoire à surveiller.</summary>
        <value>Chemin d'accès à surveiller. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’un chemin d’accès qualifié complet à un répertoire. Si le <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propriété est `true`, ce répertoire est la racine à laquelle le système surveille les modifications ; sinon, il est le seul répertoire observé. Pour visionner un fichier spécifique, définissez la <xref:System.IO.FileSystemWatcher.Path%2A> propriété dans le répertoire complet, correct et le <xref:System.IO.FileSystemWatcher.Filter%2A> propriété le nom de fichier.  
  
 Le <xref:System.IO.FileSystemWatcher.Path%2A> propriété prend en charge les chemins d’accès UNC Universal Naming Convention ().  
  
> [!NOTE]
>  Cette propriété doit être définie avant que le composant peut surveiller les modifications.  
  
 Lorsqu’un répertoire est renommé, le <xref:System.IO.FileSystemWatcher> rattache automatiquement à l’élément qui vient d’être renommé. Par exemple, si vous définissez le <xref:System.IO.FileSystemWatcher.Path%2A> propriété à « C:\My Documents » et puis renommez manuellement le répertoire « C:\Your Documents », le composant continue à écouter les notifications de modification sur le répertoire. Toutefois, lorsque vous demandez le <xref:System.IO.FileSystemWatcher.Path%2A> propriété, elle contient l’ancien chemin d’accès. Cela se produit car le composant détermine le répertoire à surveiller basé sur le handle, plutôt que le nom du répertoire. Changement de nom n’affecte pas le handle. Par conséquent, si vous détruisez le composant, puis la recréer sans mettre à jour le <xref:System.IO.FileSystemWatcher.Path%2A> propriété, votre application échoue, car le répertoire n’existe plus.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileSystemWatcher> à surveiller le répertoire spécifié au moment de l’exécution. Le composant est défini pour surveiller les modifications de `LastWrite` et `LastAccess` du temps, la création, suppression, ou le changement de nom des fichiers texte dans le répertoire. Si un fichier est modifié, créé ou supprimé, le chemin d’accès au fichier s’imprime sur la console. Lorsqu’un fichier est renommé, les chemins d’accès nouvelles et anciennes impriment sur la console.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès spécifié n'existe pas ou est introuvable.  
  
ou 
Le chemin d'accès spécifié contient des caractères génériques.  
  
ou 
Le chemin d'accès spécifié contient des caractères de chemin non valides.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un fichier ou un répertoire du <see cref="P:System.IO.FileSystemWatcher.Path" /> spécifié est renommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Renamed` événement est un <xref:System.IO.RenamedEventHandler> délégué ayant la signature suivante :

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Le <xref:System.IO.RenamedEventArgs> objet fournit des informations sur l’opération de changement de nom, tels que le type de la modification du nom (le <xref:System.IO.FileSystemEventArgs.ChangeType> propriété), les anciens et nouveaux noms et le chemin d’accès ancienne et nouvel. Notez que le <xref:System.IO.FileSystemEventArgs.Name> propriété peut être null pour les événements renommés du si le <xref:System.IO.FileSystemWatcher> ne correspondent pas les événements anciens et nouveaux noms à partir du système d’exploitation.

 Renommer le répertoire surveillé ne déclenche pas une notification. Notifications sont déclenchées uniquement pour les entrées dans le répertoire que vous surveillez.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.FileSystemWatcher.Renamed> événement pour afficher le chemin d’accès à la console chaque fois que le fichier à suivre est renommé.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un élément <see cref="T:System.ComponentModel.ISite" /> pour l'élément <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> pour <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites lient un <xref:System.ComponentModel.Component> à un <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur gérer ses composants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet utilisé pour marshaler des appels du gestionnaire d'événements consécutifs à un changement de répertoire.</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> qui représente l'objet utilisé pour marshaler des appels du gestionnaire d'événements consécutifs à un changement de répertoire. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> est `null`, méthodes gérant le <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, et <xref:System.IO.FileSystemWatcher.Renamed> événements sont appelés sur un thread du pool de threads système. Pour plus d’informations sur les pools de threads système, consultez <xref:System.Threading.ThreadPool>.  
  
 Lorsque le <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, et <xref:System.IO.FileSystemWatcher.Renamed> événements sont gérés par un composant Windows Forms visuel, comme un <xref:System.Windows.Forms.Button>, l’accès au composant via le pool de threads système peut ne pas fonctionner ou peut entraîner une exception. Éviter ce problème en définissant <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> à un composant Windows Forms, ce qui provoque les méthodes qui gèrent le <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, et <xref:System.IO.FileSystemWatcher.Renamed> événements à appeler sur le même thread que celui sur lequel le composant a été créé.  
  
 Si le <xref:System.IO.FileSystemWatcher> est utilisé à l’intérieur de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] dans un concepteur Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> définit automatiquement le contrôle qui contient le <xref:System.IO.FileSystemWatcher>. Par exemple, si vous placez un <xref:System.IO.FileSystemWatcher> sur un concepteur pour Form1 (qui hérite <xref:System.Windows.Forms.Form>) le <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propriété du <xref:System.IO.FileSystemWatcher> est définie sur l’instance de Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Méthode synchrone qui retourne une structure contenant des informations spécifiques sur les modifications apportées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType"><see cref="T:System.IO.WatcherChangeTypes" /> dont le suivi doit être effectué.</param>
        <summary>Méthode synchrone qui retourne une structure contenant des informations spécifiques sur les modifications apportées, en fonction des types de modifications à surveiller.</summary>
        <returns><see cref="T:System.IO.WaitForChangedResult" /> qui contient des informations spécifiques sur les modifications apportées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode attend indéfiniment jusqu'à ce que la première modification se produit, puis retourne. Il est identique à l’aide de <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> avec la `timeout` paramètre la valeur -1.  
  
> [!NOTE]
>  Cette méthode permet à un gestionnaire d’événements à appeler pour répondre au fichier modifications même si le <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> propriété est définie sur `false`.  
  
 Dans certains systèmes, <xref:System.IO.FileSystemWatcher> signale les modifications apportées aux fichiers à l’aide du format de nom de 8.3 fichier court. Par exemple, une modification apportée à « LongFileName.LongExtension » peut être signalée comme « LongFi ~. LON ».  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType"><see cref="T:System.IO.WatcherChangeTypes" /> dont le suivi doit être effectué.</param>
        <param name="timeout">Délai d'attente, en millisecondes.</param>
        <summary>Méthode synchrone qui retourne une structure contenant des informations spécifiques sur les modifications apportées, en fonction des types de modifications à surveiller et du délai d'attente (en millisecondes).</summary>
        <returns><see cref="T:System.IO.WaitForChangedResult" /> qui contient des informations spécifiques sur les modifications apportées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode attend jusqu'à ce qu’une modification se produit, ou il a expiré. La valeur -1 pour le `timeout` paramètre signifie que l’attente indéfiniment.  
  
> [!NOTE]
>  Cette méthode permet à un gestionnaire d’événements à appeler pour répondre au fichier modifications même si le <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> propriété est définie sur `false`.  
  
 Dans certains systèmes, <xref:System.IO.FileSystemWatcher> signale les modifications apportées aux fichiers à l’aide du format de nom de 8.3 fichier court. Par exemple, une modification apportée à « LongFileName.LongExtension » peut être signalée comme « LongFi ~. LON ».  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>