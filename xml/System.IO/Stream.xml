<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0fb40af96c0c29647a13d4d090745e6f87d9fbdb" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56392492" /></Metadata><TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une vue générique d'une séquence d'octets. Il s’agit d’une classe abstraite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> est la classe de base abstraite de tous les flux. Un flux est une abstraction d'une séquence d'octets, comme un fichier, un appareil d'entrée/sortie, un canal de communication inter-processus ou un socket TCP/IP. Le <xref:System.IO.Stream> classe et ses classes dérivées donnent une vue générique de ces différents types d’entrée et de sortie et isolant ainsi le programmeur des détails spécifiques du système d’exploitation et aux périphériques sous-jacents.  
  
 Les flux impliquent trois opérations fondamentales :  
  
-   Vous pouvez lire à partir de flux. Lecture est le transfert de données à partir d’un flux de données dans une structure de données, tel qu’un tableau d’octets.  
  
-   Vous pouvez écrire dans le flux de données. L’écriture est le transfert de données à partir d’une structure de données dans un flux.  
  
-   Flux de données peut prendre en charge la recherche. Recherche fait référence à l’interrogation et modification de la position actuelle dans un flux de données. Seek fonctionnalité varie selon le type de magasin de stockage a un flux de données. Par exemple, les flux de réseau n’ont aucun concept unifié d’une position actuelle et par conséquent généralement ne gèrent pas recherche.  
  
 Certains des plus couramment utilisés les flux qui héritent de <xref:System.IO.Stream> sont <xref:System.IO.FileStream>, et <xref:System.IO.MemoryStream>.  
  
 Selon la source de données sous-jacente ou le référentiel, flux de données peut prendre en charge uniquement certaines de ces fonctionnalités. Vous pouvez interroger un flux de données pour ses fonctionnalités en utilisant le <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, et <xref:System.IO.Stream.CanSeek%2A> propriétés de la <xref:System.IO.Stream> classe.  
  
 Le <xref:System.IO.Stream.Read%2A> et <xref:System.IO.Stream.Write%2A> méthodes lire et écrire des données dans une variété de formats. Pour les flux qui prennent en charge la recherche, utilisez le <xref:System.IO.Stream.Seek%2A> et <xref:System.IO.Stream.SetLength%2A> méthodes et les <xref:System.IO.Stream.Position%2A> et <xref:System.IO.Stream.Length%2A> propriétés pour interroger et modifier la position actuelle et la longueur d’un flux.  
  
 Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Suppression un <xref:System.IO.Stream> objet vide toutes les données mises en mémoire tampon et appelle essentiellement le <xref:System.IO.Stream.Flush%2A> méthode pour vous. <xref:System.IO.Stream.Dispose%2A> libère également les ressources de système d’exploitation telles que les descripteurs de fichiers, les connexions réseau ou la mémoire utilisée pour toute mise en mémoire tampon interne. Le <xref:System.IO.BufferedStream> classe offre la possibilité d’encapsuler un flux mis en mémoire tampon autour d’un autre flux afin d’améliorer en lecture et d’écriture des performances.  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], la <xref:System.IO.Stream> classe inclut des méthodes async pour simplifier les opérations asynchrones. Contient une méthode async `Async` dans son nom, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>. Ces méthodes permettent d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Lorsqu’il est utilisé dans un [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> inclut deux méthodes d’extension : <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> et <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>. Ces méthodes convertissent un <xref:System.IO.Stream> objet dans un flux dans le [!INCLUDE[wrt](~/includes/wrt-md.md)]. Vous pouvez également convertir un flux de données dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] à un <xref:System.IO.Stream> objet à l’aide de la <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> et <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> méthodes. Pour plus d'informations, voir [Procédure : effectuer une conversion entre les flux du .NET Framework et les flux Windows Runtime](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)  
  
 Certaines implémentations de flux effectuent la mise en mémoire tampon locale des données sous-jacentes pour améliorer les performances. Pour ces flux, vous pouvez utiliser la <xref:System.IO.Stream.Flush%2A> ou <xref:System.IO.Stream.FlushAsync%2A> méthode pour effacer les mémoires tampons internes et de s’assurer que toutes les données a été écrites dans la source de données sous-jacente ou le référentiel.  
  
 Si vous avez besoin d’un flux sans magasin de stockage (également appelé un « bit bucket »), utilisez le <xref:System.IO.Stream.Null> champ à extraire une instance de flux de données qui est conçu à cet effet.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser deux <xref:System.IO.FileStream> objets à copier de façon asynchrone les fichiers d’un répertoire vers un autre répertoire. La classe <xref:System.IO.FileStream> dérive de la classe <xref:System.IO.Stream> . Notez que le gestionnaire d'événements <xref:System.Web.UI.WebControls.Button.Click> pour le contrôle <xref:System.Windows.Controls.Button> est marqué avec le modificateur `async` car il appelle une méthode asynchrone.  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Lorsque vous implémentez une classe dérivée de <see cref="T:System.IO.Stream" />, vous devez fournir des implémentations pour les <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> méthodes. Les méthodes asynchrones <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, et <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> utilisent les méthodes synchrones <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> dans leurs implémentations. Par conséquent, vos implémentations de <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> ne fonctionnera correctement avec les méthodes asynchrones. Les implémentations par défaut de <see cref="M:System.IO.Stream.ReadByte" /> et <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> créer un tableau d’octets à élément unique, puis appelez vos implémentations de <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Lorsque vous dérivez de <see cref="T:System.IO.Stream" />, nous vous recommandons de substituer ces méthodes pour accéder à votre mémoire tampon interne, si vous en avez pas, pour améliorer les performances. Vous devez également fournir des implémentations de <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, et <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.  
  
Ne remplacent pas le <see cref="M:System.IO.Stream.Close" /> (méthode), place tous les <see cref="T:System.IO.Stream" /> logique de nettoyage dans le <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (méthode). Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para></block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md">Comment : effectuer une conversion entre les flux .NET Framework et les flux Windows Runtime</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> est la classe de base abstraite de tous les flux.  
  
 Certains des plus couramment utilisés les flux qui héritent de <xref:System.IO.Stream> sont <xref:System.IO.FileStream>, et <xref:System.IO.MemoryStream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle lire les données.buffer</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet auquel commencer l'écriture des données lues dans le flux.</param>
        <param name="count">Nombre maximal d'octets à lire.</param>
        <param name="callback">Rappel asynchrone facultatif, à appeler quand la lecture est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête de lecture asynchrone des autres requêtes.</param>
        <summary>Débute une opération de lecture asynchrone. (Utilisez <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</summary>
        <returns>Élément <see cref="T:System.IAsyncResult" /> représentant la lecture asynchrone, qui peut être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginRead%2A> et <xref:System.IO.Stream.EndRead%2A> pour implémenter les opérations d'E/S asynchrones. Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.  
  
 L’implémentation par défaut de `BeginRead` sur un flux appelle le <xref:System.IO.Stream.Read%2A> méthode synchrone, ce qui signifie que `Read` peut se bloquer sur certains flux. Toutefois, les instances de classes telles que `FileStream` et `NetworkStream` prennent entièrement en charge les opérations asynchrones si les instances ont été ouvert de façon asynchrone. Par conséquent, les appels à `BeginRead` ne bloquera pas sur ces flux. Vous pouvez remplacer `BeginRead` (en utilisant des délégués async, par exemple) pour fournir un comportement asynchrone.  
  
 Passer le `IAsyncResult` retourner la valeur à la <xref:System.IO.Stream.EndRead%2A> méthode du flux pour déterminer le nombre d’octets lus et libérer les ressources de système d’exploitation utilisés pour la lecture. <xref:System.IO.Stream.EndRead%2A> doit être appelée une fois pour chaque appel à <xref:System.IO.Stream.BeginRead%2A>. Cela en utilisant le même code qui a appelé `BeginRead` ou dans un rappel passé à `BeginRead`.  
  
 La position actuelle dans le flux de données est mis à jour lors de la lecture asynchrone ou une écriture est émise, pas lorsque l’opération d’e/s se termine.  
  
 Plusieurs demandes asynchrones simultanées rendent l’ordre d’exécution demande incertain.  
  
 Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.  
  
 Si un flux est fermé ou que vous passez un argument non valide, les exceptions sont immédiatement levées à partir de `BeginRead`. Erreurs qui se produisent pendant une demande de lecture asynchrone, tel qu’une panne de disque pendant la requête d’e/s, se produisent sur le thread de pool de threads et lever des exceptions lors de l’appel `EndRead`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tentative de lecture asynchrone au-delà de la fin du flux, ou une erreur disque s’est produite.</exception>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <exception cref="T:System.NotSupportedException">L’implémentation du <see langword="Stream" /> en cours ne prend pas en charge l’opération de lecture.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S sur fichier asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dont sont issues les données à écrire.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet à partir duquel l'écriture doit commencer.</param>
        <param name="count">Nombre maximal d'octets à écrire.</param>
        <param name="callback">Rappel asynchrone facultatif, à appeler quand l'écriture est terminée.</param>
        <param name="state">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone des autres requêtes.</param>
        <summary>Débute une opération d'écriture asynchrone. (Utilisez <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</summary>
        <returns>Élément <see langword="IAsyncResult" /> représentant l'écriture asynchrone, qui peut être encore en attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginWrite%2A> et <xref:System.IO.Stream.EndWrite%2A> pour implémenter les opérations d'E/S asynchrones. Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.  
  
 L’implémentation par défaut de `BeginWrite` sur un flux appelle le <xref:System.IO.Stream.Write%2A> méthode synchrone, ce qui signifie que `Write` peut se bloquer sur certains flux. Toutefois, les instances de classes telles que `FileStream` et `NetworkStream` prennent entièrement en charge les opérations asynchrones si les instances ont été ouvert de façon asynchrone. Par conséquent, les appels à `BeginWrite` ne bloquera pas sur ces flux. Vous pouvez remplacer `BeginWrite` (en utilisant des délégués async, par exemple) pour fournir un comportement asynchrone.  
  
 Passer le `IAsyncResult` retourné par la méthode actuelle à <xref:System.IO.Stream.EndWrite%2A> à la fin de l’écriture et libérer des ressources de manière appropriée. <xref:System.IO.Stream.EndWrite%2A> doit être appelée une fois pour chaque appel à <xref:System.IO.Stream.BeginWrite%2A>. Cela en utilisant le même code qui a appelé `BeginWrite` ou dans un rappel passé à `BeginWrite`. Si une erreur se produit pendant une écriture asynchrone, une exception ne sera pas levée tant que `EndWrite` est appelée avec le `IAsyncResult` retourné par cette méthode.  
  
 Si un flux de données est accessible en écriture, accès en écriture à la fin du flux de données développe le flux de données.  
  
 La position actuelle dans le flux de données est mis à jour lorsque vous émettez la lecture asynchrone ou écriture, pas lorsque l’opération d’e/s se termine. Plusieurs demandes asynchrones simultanées rendent l’ordre d’exécution demande incertain.  
  
 Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.  
  
 Si un flux est fermé ou que vous passez un argument non valide, les exceptions sont immédiatement levées à partir de `BeginWrite`. Erreurs qui se produisent pendant une demande d’écriture asynchrone, tel qu’une panne de disque pendant la requête d’e/s, se produisent sur le thread de pool de threads et lever des exceptions lors de l’appel `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tentative d’écriture asynchrone au-delà de la fin du flux, ou une erreur disque s’est produite.</exception>
        <exception cref="T:System.ArgumentException">Un ou plusieurs arguments ne sont pas valides.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <exception cref="T:System.NotSupportedException">L’implémentation du <see langword="Stream" /> en cours ne prend pas en charge l’opération d’écriture.</exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S sur fichier asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, obtient une valeur indiquant si le flux actuel prend en charge la lecture.</summary>
        <value><see langword="true" /> si le flux prend en charge la lecture ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la lecture, les appels à la <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, et <xref:System.IO.Stream.BeginRead%2A> méthodes lèvent une <xref:System.NotSupportedException>.  
  
 Si le flux est fermé, cette propriété retourne `false`.  
  
   
  
## Examples  
 Voici un exemple d’utilisation le `CanRead` propriété.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, obtient une valeur indiquant si le flux actuel prend en charge la recherche.</summary>
        <value><see langword="true" /> si le flux prend en charge la recherche ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la recherche, les appels à <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, et <xref:System.IO.Stream.Seek%2A> lever un <xref:System.NotSupportedException>.  
  
 Si le flux est fermé, cette propriété retourne `false`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui détermine si le flux actuel peut dépasser le délai d'attente.</summary>
        <value>Valeur qui détermine si le flux actuel peut dépasser le délai d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.IO.Stream.CanTimeout%2A> retourne toujours `false`. Certaines implémentations de flux nécessitent un comportement différent, tel que <xref:System.Net.Sockets.NetworkStream>, qui expire si la connectivité réseau est interrompue ou perdue. Si vous implémentez un flux qui doit être en mesure de délai d’attente, cette propriété doit être substituée pour retourner `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, obtient une valeur indiquant si le flux actuel prend en charge l'écriture.</summary>
        <value><see langword="true" /> si le flux prend en charge l'écriture ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge l’écriture, un appel à <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, ou <xref:System.IO.Stream.WriteByte%2A> lève un <xref:System.NotSupportedException>. Dans ce cas, <xref:System.IO.Stream.Flush%2A> est généralement implémentée comme une méthode vide pour garantir une compatibilité complète avec d’autres <xref:System.IO.Stream> types dans la mesure où il est valide pour vider un flux en lecture seule.
  
 Si le flux est fermé, cette propriété retourne `false`.  
  
   
  
## Examples  
 Voici un exemple d’utilisation le `CanWrite` propriété.  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le flux actuel et libère toutes les ressources (comme les sockets et les handles de fichiers) associées à celui-ci. Au lieu d'appeler cette méthode, assurez-vous que le flux est correctement supprimé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.IO.Stream.Dispose%2A>, en spécifiant `true` pour libérer toutes les ressources. Vous n’avez pas à appeler spécifiquement le <xref:System.IO.Stream.Close%2A> (méthode). Au lieu de cela, vérifiez que chaque <xref:System.IO.Stream> objet est supprimé correctement. Vous pouvez déclarer <xref:System.IO.Stream> d’objets dans un `using` bloc (ou `Using` bloquer en Visual Basic) pour vous assurer que le flux de données et toutes ses ressources sont supprimés, ou vous pouvez appeler explicitement la <xref:System.IO.Stream.Dispose%2A> (méthode).  
  
 Vider le flux ne videra pas son encodeur sous-jacent, sauf si vous appelez explicitement une implémentation de <xref:System.IO.Stream.Flush%2A> ou `Close`. Paramètre <xref:System.IO.StreamWriter.AutoFlush%2A> à `true` signifie que les données sont vidées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Ainsi, l’encodeur afin de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7, où certains caractères peuvent être codés uniquement après que l’encodeur a reçu les caractères adjacents.  
  
 Tente de manipuler le flux une fois que le flux a été fermé peut lever une <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dans les classes dérivées, ne substituez pas la <see cref="M:System.IO.Stream.Close" /> (méthode), place tous les <see langword="Stream" /> logique de nettoyage dans le <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (méthode). Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit les octets du flux actuel et les écrit dans un autre flux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">Flux vers lequel le contenu du flux actuel sera copié.</param>
        <summary>Lit les octets du flux actuel et les écrit dans un autre flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Copie commence à la position actuelle dans le flux actuel et ne réinitialise pas la position de flux de destination une fois l’opération de copie est terminée.  
  
   
  
## Examples  
 L’exemple suivant copie le contenu d’un <xref:System.IO.FileStream> à un <xref:System.IO.MemoryStream>.  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le flux actuel ne prend pas en charge la lecture.  
  
ou 
 <paramref name="destination" /> ne prend pas en charge l’écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux actuel ou de <paramref name="destination" /> a été fermé avant l’appel de la méthode <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Flux vers lequel le contenu du flux actuel sera copié.</param>
        <param name="bufferSize">Taille de la mémoire tampon. Cette valeur doit être supérieure à zéro. La taille par défaut est 81920.</param>
        <summary>Lit tous les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Copie commence à la position actuelle dans le flux actuel et ne réinitialise pas la position de flux de destination une fois l’opération de copie est terminée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> est négatif ou égal à zéro.</exception>
        <exception cref="T:System.NotSupportedException">Le flux actuel ne prend pas en charge la lecture.  
  
ou 
 <paramref name="destination" /> ne prend pas en charge l’écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux actuel ou de <paramref name="destination" /> a été fermé avant l’appel de la méthode <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">Flux vers lequel le contenu du flux actuel sera copié.</param>
        <summary>Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux.</summary>
        <returns>Tâche qui représente l’opération de copie asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.CopyToAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 La copie commence à la position actuelle dans le flux actuel.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser deux <xref:System.IO.FileStream> objets à copier de façon asynchrone les fichiers d’un répertoire vers un autre. La classe <xref:System.IO.FileStream> dérive de la classe <xref:System.IO.Stream> .  Notez que le <xref:System.Web.UI.WebControls.Button.Click> Gestionnaire d’événements pour le <xref:System.Windows.Controls.Button> contrôle est marqué avec le `async` modificateur parce qu’il appelle une méthode asynchrone  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux de données actuel ou le flux de données de destination est supprimé.</exception>
        <exception cref="T:System.NotSupportedException">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Flux vers lequel le contenu du flux actuel sera copié.</param>
        <param name="bufferSize">Taille en octets de la mémoire tampon. Cette valeur doit être supérieure à zéro. La taille par défaut est 81920.</param>
        <summary>Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon spécifiée.</summary>
        <returns>Tâche qui représente l’opération de copie asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.CopyToAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 La copie commence à la position actuelle dans le flux actuel.  
  
 Pour obtenir un exemple de copie entre deux flux de données, consultez le <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffersize" /> est négatif ou égal à zéro.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux de données actuel ou le flux de données de destination est supprimé.</exception>
        <exception cref="T:System.NotSupportedException">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">Flux vers lequel le contenu du flux actuel sera copié.</param>
        <param name="bufferSize">Taille en octets de la mémoire tampon. Cette valeur doit être supérieure à zéro. La taille par défaut est 81920.</param>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation. La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Lit de façon asynchrone les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon et d'un jeton d'annulation spécifiés.</summary>
        <returns>Tâche qui représente l’opération de copie asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.CopyToAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.  
  
 La copie commence à la position actuelle dans le flux actuel.  
  
 Pour obtenir un exemple de copie entre deux flux de données, consultez le <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffersize" /> est négatif ou égal à zéro.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux de données actuel ou le flux de données de destination est supprimé.</exception>
        <exception cref="T:System.NotSupportedException">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alloue un objet <see cref="T:System.Threading.WaitHandle" />.</summary>
        <returns>Référence à l'objet <see langword="WaitHandle" /> alloué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’elle est appelée pour la première fois, la méthode actuelle crée un `WaitHandle` de l’objet et le retourne. Lors des appels ultérieurs, `CreateWaitHandle` retourne une référence à un handle d’attente.  
  
 Utilisez cette méthode si vous implémentez les méthodes asynchrones et que vous avez besoin d’un moyen de blocage <xref:System.IO.Stream.EndRead%2A> ou <xref:System.IO.Stream.EndWrite%2A> jusqu'à ce que l’opération asynchrone est terminée.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'objet <see cref="T:System.IO.Stream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime le flux, en écrivant des modifications au magasin de stockage et de fermer le flux pour libérer des ressources.  
  
 Appel `Dispose` autorise les ressources utilisées par le <xref:System.IO.Stream> d’être réaffectées à d’autres fins. Pour plus d’informations sur `Dispose`, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Placez toute logique de nettoyage pour votre objet de flux dans <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Ne remplacez pas <see cref="M:System.IO.Stream.Close" />.  
  
Notez que pour des raisons de compatibilité descendante, implémentation de cette méthode diffère des conseils recommandés pour le modèle de suppression.  Cette méthode appelle <see cref="M:System.IO.Stream.Close" />, qui appelle ensuite <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.Stream" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez libérer toutes les ressources en spécifiant `true` pour `disposing`. Lorsque `disposing` est `true`, le flux peut également garantir que données sont vidées à la mémoire tampon sous-jacente et accéder aux autres objets finalisables.  Cela ne peut pas possible lorsqu’elle est appelée à partir d’un finaliseur en raison d’un manque d’ordre parmi les finaliseurs.  
  
 Si votre flux utilise un handle de système d’exploitation pour communiquer avec sa source, envisagez d’utiliser une sous-classe de <xref:System.Runtime.InteropServices.SafeHandle> à cet effet.  
  
 Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). <xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.Stream.Dispose%2A> méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle <xref:System.IO.Stream.Dispose%2A> avec `disposing` défini sur `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dans les classes dérivées, ne substituez pas la <see cref="M:System.IO.Stream.Close" /> méthode, placez à la place, toute la logique de nettoyage de Stream dans le <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (méthode).  
  
 <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="stream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Référence à la requête asynchrone en attente à terminer.</param>
        <summary>Attend que la requête asynchrone en attente se termine. (Utilisez <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</summary>
        <returns>Nombre d'octets lus dans le flux, entre zéro (0) et le nombre demandé. Les flux retournent uniquement zéro (0) à la fin du flux ; sinon, ils devraient se bloquer jusqu'à ce qu'au moins un octet soit disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginRead%2A> et <xref:System.IO.Stream.EndRead%2A> pour implémenter les opérations d'E/S asynchrones. Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.  
  
 Appelez `EndRead` pour déterminer le nombre d’octets lus à partir du flux.  
  
 `EndRead` peut être appelée qu’une seule fois sur chaque <xref:System.IAsyncResult> de <xref:System.IO.Stream.BeginRead%2A>.  
  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Handle sur l’opération de lecture en attente n’est pas disponible.  
  
ou 
L’opération en attente ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult" /> ne provenait pas d’une méthode <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur le flux en cours.</exception>
        <exception cref="T:System.IO.IOException">Le flux est fermé ou une erreur interne s’est produite.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S sur fichier asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Référence à la requête d'E/S asynchrone en attente.</param>
        <summary>Termine une opération d'écriture asynchrone. (Utilisez <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginWrite%2A> et <xref:System.IO.Stream.EndWrite%2A> pour implémenter les opérations d'E/S asynchrones. Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.  
  
 `EndWrite` doit être appelée une seule fois sur chaque <xref:System.IAsyncResult> de <xref:System.IO.Stream.BeginWrite%2A>.  
  
 Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S. Erreurs qui se produisent pendant une demande d’écriture asynchrone, tel qu’une panne de disque pendant la requête d’e/s, se produisent sur le thread de pool de threads et deviennent visibles lors d’un appel à `EndWrite`. Les exceptions levées par le thread du pool ne sera pas visibles lors de l’appel `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un handle sur l’opération d’écriture en attente n’est pas disponible.  
  
ou 
L’opération en attente ne prend pas en charge l’écriture.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult" /> ne provenait pas d’une méthode <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur le flux en cours.</exception>
        <exception cref="T:System.IO.IOException">Le flux est fermé ou une erreur interne s’est produite.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S sur fichier asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, efface toutes les mémoires tampons pour ce flux et provoque l'écriture de toutes les données se trouvant dans des mémoires tampons sur l'appareil sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituer `Flush` sur des flux qui implémentent une mémoire tampon. Utilisez cette méthode pour déplacer toutes les informations à partir d’un mémoire tampon sous-jacente vers sa destination, désactivez la mémoire tampon, ou les deux. En fonction de l’état de l’objet, vous devrez peut-être modifier la position actuelle dans le flux de données (par exemple, si le flux sous-jacent prend en charge la recherche). Pour plus d’informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  

 Dans une classe dérivée de <xref:System.IO.Stream> qui ne prend pas en charge l’écriture, <xref:System.IO.Stream.Flush%2A> est généralement implémentée comme une méthode vide pour garantir une compatibilité complète avec d’autres <xref:System.IO.Stream> types dans la mesure où il est valide pour vider un flux en lecture seule.

 Lorsque vous utilisez le <xref:System.IO.StreamWriter> ou <xref:System.IO.BinaryWriter> class, ne videz pas la base de <xref:System.IO.Stream> objet. Au lieu de cela, utilisez la classe <xref:System.IO.Stream.Flush%2A> ou <xref:System.IO.Stream.Close%2A> (méthode), ce qui permet de s’assurer que les données sont vidées dans le flux sous-jacent et ensuite écrites dans le fichier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Efface de façon asynchrone toutes les mémoires tampons pour ce flux et provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface de façon asynchrone toutes les mémoires tampons pour ce flux et provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent.</summary>
        <returns>Tâche qui représente l’opération de vidage asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée, tel que <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream>, ne pas vider la mémoire tampon dans son implémentation de la <xref:System.IO.Stream.Flush%2A> (méthode), le <xref:System.IO.Stream.FlushAsync%2A> méthode ne sera pas vider la mémoire tampon.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation. La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Efface de façon asynchrone toutes les mémoires tampons pour ce flux, provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent et surveille les requêtes d'annulation.</summary>
        <returns>Tâche qui représente l’opération de vidage asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.  
  
 Si une classe dérivée, tel que <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream>, ne pas vider la mémoire tampon dans son implémentation de la <xref:System.IO.Stream.Flush%2A> (méthode), le <xref:System.IO.Stream.FlushAsync%2A> méthode ne sera pas vider la mémoire tampon.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, obtient la longueur du flux en octets.</summary>
        <value>Valeur de type long représentant la longueur du flux en octets.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Une classe dérivée de <see langword="Stream" /> ne prend pas en charge la recherche.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Élément <see langword="Stream" /> sans magasin de stockage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `Null` pour rediriger la sortie vers un flux qui ne consomme pas toutes les ressources système d’exploitation. Lorsque les méthodes de `Stream` qui fournissent l’écriture sont appelées sur `Null`, l’appel est simplement retourné et aucune donnée n’est écrite. `Null` implémente également un `Read` méthode qui retourne zéro sans lire des données.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Assure la prise en charge d'un <see cref="T:System.Diagnostics.Contracts.Contract" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de remplacement dans une classe dérivée, obtient ou définit la position dans le flux actuel.</summary>
        <value>Position actuelle dans le flux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le flux doit prendre en charge la recherche pour obtenir ou définir la position. Utilisez le <xref:System.IO.Stream.CanSeek%2A> propriété afin de déterminer si le flux prend en charge la recherche.  
  
 La recherche au-delà de la longueur du flux est pris en charge.  
  
 Le `Position` propriété n’assure pas le suivi du nombre d’octets à partir de flux de données qui ont été consommés, omis, ou les deux.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la recherche.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets. Quand cette méthode se termine, la mémoire tampon contient le tableau d’octets spécifié dont les valeurs comprises entre <paramref name="offset" /> et (<paramref name="offset" /> + <paramref name="count" /> - 1) sont remplacées par les octets lus dans la source actuelle.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer le stockage des données lues dans le flux actuel.</param>
        <param name="count">Nombre maximal d'octets à lire dans le flux actuel.</param>
        <summary>En cas de remplacement dans une classe dérivée, lit une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</summary>
        <returns>Nombre total d'octets lus dans la mémoire tampon. Le nombre d'octets peut être inférieur au nombre d'octets demandés si ce nombre n'est pas actuellement disponible ou égal à zéro (0) si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture. Utilisez le <xref:System.IO.Stream.ReadAsync%2A> méthode lire de façon asynchrone à partir du flux actuel.  
  
 Les implémentations de cette méthode lisent un maximum de `count` octets à partir du flux et les stocker dans `buffer` commençant à `offset`. La position actuelle dans le flux est avancée par le nombre d’octets lus ; Toutefois, si une exception se produit, la position actuelle dans le flux de données reste inchangée. Implémentations de retournent le nombre d’octets lus. L’implémentation sera bloqué jusqu'à ce qu’au moins un octet de données peut être lu, si aucune donnée n’est disponible. <xref:System.IO.Stream.Read%2A> retourne 0 uniquement lorsqu’il n’existe plus aucune donnée dans le flux de données et n’est attendue (par exemple, un socket fermé ou la fin du fichier). Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux n’a pas été atteinte.  
  
 Utilisez <xref:System.IO.BinaryReader> pour la lecture des types de données primitifs.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.IO.Stream.Read%2A> pour lire un bloc de données.  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon où écrire les données.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet auquel commencer l'écriture des données à partir du flux.</param>
        <param name="count">Nombre maximal d'octets à lire.</param>
        <summary>Lit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon. La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.ReadAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.  
  
   
  
## Examples  
 L’exemple suivant montre comment lire à partir d’un fichier de façon asynchrone. L’exemple utilise le <xref:System.IO.FileStream> classe qui dérive de la <xref:System.IO.Stream> classe.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par une opération de lecture antérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon où écrire les données.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet auquel commencer l'écriture des données à partir du flux.</param>
        <param name="count">Nombre maximal d'octets à lire.</param>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation. La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Lit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position dans le flux du nombre d'octets lus et surveille les demandes d'annulation.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon. La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.ReadAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.  
  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.  
  
 Pour obtenir un exemple, consultez le <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par une opération de lecture antérieure.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un octet du flux et avance d'un octet la position au sein du flux, ou retourne -1 si la fin du flux a été atteinte.</summary>
        <returns>Conversion de type (transtypage) de l'octet non signé en <see langword="Int32" />, ou -1 si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.  
  
 Tente de manipuler le flux une fois que le flux a été fermé pourrait lever un <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <block subset="none" type="overrides"><para>L’implémentation par défaut sur <see langword="Stream" /> crée un tableau d’un octet, puis appelle <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Bien que ce soit correct, il est inefficace. N’importe quel flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui lit la mémoire tampon directement, vous évitant l’allocation de tableau supplémentaire à chaque appel.</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'effectuer la lecture avant d’expiration du délai d’attente.</summary>
        <value>Valeur exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'effectuer la lecture avant de dépasser le délai d'attente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="P:System.IO.Stream.ReadTimeout" /> lève toujours <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides"><para>Le <see cref="P:System.IO.Stream.ReadTimeout" /> propriété doit être substituée pour fournir le comportement approprié pour le flux. Si le flux ne prend pas en charge le délai d’expiration, cette propriété doit déclencher un <see cref="T:System.InvalidOperationException" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Offset d'octet par rapport au paramètre <paramref name="origin" />.</param>
        <param name="origin">Valeur de type <see cref="T:System.IO.SeekOrigin" /> indiquant le point de référence utilisé pour obtenir la nouvelle position.</param>
        <summary>En cas de remplacement dans une classe dérivée, définit la position dans le flux actuel.</summary>
        <returns>Nouvelle position dans le flux actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Stream.CanSeek%2A> propriété afin de déterminer si l’instance actuelle prend en charge la recherche.  
  
 Si `offset` est négatif, la nouvelle position doit précéder la position spécifiée par `origin` par le nombre d’octets spécifié par `offset`. Si `offset` est zéro (0), la nouvelle position est nécessaire à la position spécifiée par `origin`. Si `offset` est un nombre positif, la nouvelle position est nécessaire pour suivre la position spécifiée par `origin` par le nombre d’octets spécifié par `offset`.  
  
 Les classes dérivées de `Stream` que la recherche de la prise en charge doit remplacer cette méthode pour fournir les fonctionnalités décrites ci-dessus.  
  
 La recherche au-delà de la longueur du flux est pris en charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la recherche, comme s’il était construit à partir d’un canal ou d’une sortie console.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Longueur souhaitée du flux actuel en octets.</param>
        <summary>En cas de substitution dans une classe dérivée, définit la longueur de flux actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur spécifiée est inférieure à la longueur actuelle du flux de données, le flux est tronqué. Si la valeur spécifiée est supérieure à la longueur actuelle du flux de données, le flux est développé. Si le flux est développé, le contenu du flux de données entre l’ancienne et la nouvelle longueur n’est pas défini.  
  
 Un flux doit prendre en charge écriture et la recherche pour `SetLength` fonctionne.  
  
 Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture et le <xref:System.IO.Stream.CanSeek%2A> propriété afin de déterminer si le recherche est pris en charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend en charge ni l’écriture, ni la recherche, comme s’il était construit à partir d’un canal ou d’une sortie console.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objet <see cref="T:System.IO.Stream" /> à synchroniser.</param>
        <summary>Crée un wrapper thread-safe (synchronisé) autour de l’objet <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.Stream" /> thread-safe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne une classe qui encapsule spécifié <xref:System.IO.Stream> de l’objet et restreint l’accès à celui-ci à partir de plusieurs threads. Tous les accès à la <xref:System.IO.Stream> objet sera thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.IO.Stream> est castée en interface <xref:System.IDisposable>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets. Cette méthode copie <paramref name="count" /> octets à partir de <paramref name="buffer" /> dans le flux actuel.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer la copie des octets dans le flux actuel.</param>
        <param name="count">Nombre d'octets à écrire dans le flux actuel.</param>
        <summary>En cas de remplacement dans une classe dérivée, écrit une séquence d'octets dans le flux actuel et avance la position actuelle dans ce flux du nombre d'octets écrits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture. Utilisez le <xref:System.IO.Stream.WriteAsync%2A> méthode à écrire de façon asynchrone dans le flux actuel.  
  
 Si l’opération d’écriture réussite, la position dans le flux avance du nombre d’octets écrits. Si une exception se produit, la position dans le flux reste inchangée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite ; par exemple, le fichier spécifié est introuvable.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l'écriture.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> a été appelée après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position actuelle dans le flux du nombre d'octets écrits.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dont sont issues les données à écrire.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet de base zéro à partir duquel commencer la copie des octets dans le flux.</param>
        <param name="count">Nombre maximal d'octets à écrire.</param>
        <summary>Écrit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position actuelle dans le flux du nombre d'octets écrits.</summary>
        <returns>Tâche qui représente l’opération d’écriture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.WriteAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.  
  
   
  
## Examples  
 L’exemple suivant montre comment écrire de façon asynchrone dans un fichier. L’exemple utilise le <xref:System.IO.FileStream> classe qui dérive de la <xref:System.IO.Stream> classe.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l'écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par une opération d’écriture précédente.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dont sont issues les données à écrire.</param>
        <param name="offset">Dans <paramref name="buffer" />, décalage d'octet de base zéro à partir duquel commencer la copie des octets dans le flux.</param>
        <param name="count">Nombre maximal d'octets à écrire.</param>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation. La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Écrit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position actuelle dans ce flux du nombre d'octets écrits et surveille les demandes d'annulation.</summary>
        <returns>Tâche qui représente l’opération d’écriture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Stream.WriteAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.  
  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.  
  
 Pour obtenir un exemple, consultez le <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l'écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par une opération d’écriture précédente.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Octet à écrire dans le flux.</param>
        <summary>Écrit un octet à la position actuelle dans le flux et avance d'un octet la position dans le flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l’écriture ou bien il est déjà fermé.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <block subset="none" type="overrides"><para>L’implémentation par défaut sur <see langword="Stream" /> crée un tableau d’un octet, puis appelle <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Bien que ce soit correct, il est inefficace. N’importe quel flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui écrit dans la mémoire tampon directement, en évitant l’allocation de tableau supplémentaire à chaque appel.</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'écrire des données avant l’expiration du délai d'attente.</summary>
        <value>Valeur exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'écrire des données avant de dépasser le délai d'attente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="P:System.IO.Stream.WriteTimeout" /> lève toujours <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides"><para>Le <see cref="P:System.IO.Stream.WriteTimeout" /> propriété doit être substituée pour fournir le comportement approprié pour le flux. Si le flux ne prend pas en charge le délai d’expiration, cette propriété doit déclencher un <see cref="T:System.InvalidOperationException" />.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>