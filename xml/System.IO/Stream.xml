<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6e126d4a1c2b7491f506aeaf53d62a461fee5276" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="40449554" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="74db6-101">Fournit une vue générique d'une séquence d'octets.</span>
      <span class="sxs-lookup">
        <span data-stu-id="74db6-101">Provides a generic view of a sequence of bytes.</span>
      </span>
      <span data-ttu-id="74db6-102">Il s'agit d'une classe abstraite.</span>
      <span class="sxs-lookup">
        <span data-stu-id="74db6-102">This is an abstract class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-103"><xref:System.IO.Stream> est la classe de base abstraite de tous les flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-103"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span> <span data-ttu-id="74db6-104">Un flux est une abstraction d'une séquence d'octets, comme un fichier, un appareil d'entrée/sortie, un canal de communication inter-processus ou un socket TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="74db6-104">A stream is an abstraction of a sequence of bytes, such as a file, an input/output device, an inter-process communication pipe, or a TCP/IP socket.</span></span> <span data-ttu-id="74db6-105">Le <xref:System.IO.Stream> classe et ses classes dérivées donnent une vue générique de ces différents types d’entrée et de sortie et isolant ainsi le programmeur des détails spécifiques du système d’exploitation et aux périphériques sous-jacents.</span><span class="sxs-lookup"><span data-stu-id="74db6-105">The <xref:System.IO.Stream> class and its derived classes provide a generic view of these different types of input and output, and isolate the programmer from the specific details of the operating system and the underlying devices.</span></span>  
  
 <span data-ttu-id="74db6-106">Les flux impliquent trois opérations fondamentales :</span><span class="sxs-lookup"><span data-stu-id="74db6-106">Streams involve three fundamental operations:</span></span>  
  
-   <span data-ttu-id="74db6-107">Vous pouvez lire à partir de flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-107">You can read from streams.</span></span> <span data-ttu-id="74db6-108">Lecture est le transfert de données à partir d’un flux de données dans une structure de données, tel qu’un tableau d’octets.</span><span class="sxs-lookup"><span data-stu-id="74db6-108">Reading is the transfer of data from a stream into a data structure, such as an array of bytes.</span></span>  
  
-   <span data-ttu-id="74db6-109">Vous pouvez écrire dans le flux de données.</span><span class="sxs-lookup"><span data-stu-id="74db6-109">You can write to streams.</span></span> <span data-ttu-id="74db6-110">L’écriture est le transfert de données à partir d’une structure de données dans un flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-110">Writing is the transfer of data from a data structure into a stream.</span></span>  
  
-   <span data-ttu-id="74db6-111">Flux de données peut prendre en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="74db6-111">Streams can support seeking.</span></span> <span data-ttu-id="74db6-112">Recherche fait référence à l’interrogation et modification de la position actuelle dans un flux de données.</span><span class="sxs-lookup"><span data-stu-id="74db6-112">Seeking refers to querying and modifying the current position within a stream.</span></span> <span data-ttu-id="74db6-113">Seek fonctionnalité varie selon le type de magasin de stockage a un flux de données.</span><span class="sxs-lookup"><span data-stu-id="74db6-113">Seek capability depends on the kind of backing store a stream has.</span></span> <span data-ttu-id="74db6-114">Par exemple, les flux de réseau n’ont aucun concept unifié d’une position actuelle et par conséquent généralement ne gèrent pas recherche.</span><span class="sxs-lookup"><span data-stu-id="74db6-114">For example, network streams have no unified concept of a current position, and therefore typically do not support seeking.</span></span>  
  
 <span data-ttu-id="74db6-115">Certains des plus couramment utilisés les flux qui héritent de <xref:System.IO.Stream> sont <xref:System.IO.FileStream>, et <xref:System.IO.MemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="74db6-115">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 <span data-ttu-id="74db6-116">Selon la source de données sous-jacente ou le référentiel, flux de données peut prendre en charge uniquement certaines de ces fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="74db6-116">Depending on the underlying data source or repository, streams might support only some of these capabilities.</span></span> <span data-ttu-id="74db6-117">Vous pouvez interroger un flux de données pour ses fonctionnalités en utilisant le <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, et <xref:System.IO.Stream.CanSeek%2A> propriétés de la <xref:System.IO.Stream> classe.</span><span class="sxs-lookup"><span data-stu-id="74db6-117">You can query a stream for its capabilities by using the <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, and <xref:System.IO.Stream.CanSeek%2A> properties of the <xref:System.IO.Stream> class.</span></span>  
  
 <span data-ttu-id="74db6-118">Le <xref:System.IO.Stream.Read%2A> et <xref:System.IO.Stream.Write%2A> méthodes lire et écrire des données dans une variété de formats.</span><span class="sxs-lookup"><span data-stu-id="74db6-118">The <xref:System.IO.Stream.Read%2A> and <xref:System.IO.Stream.Write%2A> methods read and write data in a variety of formats.</span></span> <span data-ttu-id="74db6-119">Pour les flux qui prennent en charge la recherche, utilisez le <xref:System.IO.Stream.Seek%2A> et <xref:System.IO.Stream.SetLength%2A> méthodes et les <xref:System.IO.Stream.Position%2A> et <xref:System.IO.Stream.Length%2A> propriétés pour interroger et modifier la position actuelle et la longueur d’un flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-119">For streams that support seeking, use the <xref:System.IO.Stream.Seek%2A> and <xref:System.IO.Stream.SetLength%2A> methods and the <xref:System.IO.Stream.Position%2A> and <xref:System.IO.Stream.Length%2A> properties to query and modify the current position and length of a stream.</span></span>  
  
 <span data-ttu-id="74db6-120">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="74db6-120">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="74db6-121">Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="74db6-121">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="74db6-122">Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="74db6-122">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="74db6-123">Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="74db6-123">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="74db6-124">Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="74db6-124">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="74db6-125">Suppression un <xref:System.IO.Stream> objet vide toutes les données mises en mémoire tampon et appelle essentiellement le <xref:System.IO.Stream.Flush%2A> méthode pour vous.</span><span class="sxs-lookup"><span data-stu-id="74db6-125">Disposing a <xref:System.IO.Stream> object flushes any buffered data, and essentially calls the <xref:System.IO.Stream.Flush%2A> method for you.</span></span> <span data-ttu-id="74db6-126"><xref:System.IO.Stream.Dispose%2A> libère également les ressources de système d’exploitation telles que les descripteurs de fichiers, les connexions réseau ou la mémoire utilisée pour toute mise en mémoire tampon interne.</span><span class="sxs-lookup"><span data-stu-id="74db6-126"><xref:System.IO.Stream.Dispose%2A> also releases operating system resources such as file handles, network connections, or memory used for any internal buffering.</span></span> <span data-ttu-id="74db6-127">Le <xref:System.IO.BufferedStream> classe offre la possibilité d’encapsuler un flux mis en mémoire tampon autour d’un autre flux afin d’améliorer en lecture et d’écriture des performances.</span><span class="sxs-lookup"><span data-stu-id="74db6-127">The <xref:System.IO.BufferedStream> class provides the capability of wrapping a buffered stream around another stream in order to improve read and write performance.</span></span>  
  
 <span data-ttu-id="74db6-128">En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], la <xref:System.IO.Stream> classe inclut des méthodes async pour simplifier les opérations asynchrones.</span><span class="sxs-lookup"><span data-stu-id="74db6-128">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.IO.Stream> class includes async methods to simplify asynchronous operations.</span></span> <span data-ttu-id="74db6-129">Contient une méthode async `Async` dans son nom, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-129">An async method contains `Async` in its name, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>.</span></span> <span data-ttu-id="74db6-130">Ces méthodes permettent d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-130">These methods enable you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-131">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-131">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-132">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-132">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-133">Lorsqu’il est utilisé dans un [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> inclut deux méthodes d’extension : <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> et <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-133">When used in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> includes two extension methods: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>.</span></span> <span data-ttu-id="74db6-134">Ces méthodes convertissent un <xref:System.IO.Stream> objet dans un flux dans le [!INCLUDE[wrt](~/includes/wrt-md.md)].</span><span class="sxs-lookup"><span data-stu-id="74db6-134">These methods convert a <xref:System.IO.Stream> object to a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)].</span></span> <span data-ttu-id="74db6-135">Vous pouvez également convertir un flux de données dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] à un <xref:System.IO.Stream> objet à l’aide de la <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> et <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="74db6-135">You can also convert a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)] to a <xref:System.IO.Stream> object by using the <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> methods.</span></span> <span data-ttu-id="74db6-136">Pour plus d’informations, consultez [Comment : effectuer une conversion entre les flux .NET Framework et les flux de Runtime de Windows](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)</span><span class="sxs-lookup"><span data-stu-id="74db6-136">For more information, see [How to: Convert Between .NET Framework Streams and Windows Runtime Streams](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)</span></span>  
  
 <span data-ttu-id="74db6-137">Certaines implémentations de flux effectuent la mise en mémoire tampon locale des données sous-jacentes pour améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="74db6-137">Some stream implementations perform local buffering of the underlying data to improve performance.</span></span> <span data-ttu-id="74db6-138">Pour ces flux, vous pouvez utiliser la <xref:System.IO.Stream.Flush%2A> ou <xref:System.IO.Stream.FlushAsync%2A> méthode pour effacer les mémoires tampons internes et de s’assurer que toutes les données a été écrites dans la source de données sous-jacente ou le référentiel.</span><span class="sxs-lookup"><span data-stu-id="74db6-138">For such streams, you can use the <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.FlushAsync%2A> method to clear any internal buffers and ensure that all data has been written to the underlying data source or repository.</span></span>  
  
 <span data-ttu-id="74db6-139">Si vous avez besoin d’un flux sans magasin de stockage (également appelé un « bit bucket »), utilisez le <xref:System.IO.Stream.Null> champ à extraire une instance de flux de données qui est conçu à cet effet.</span><span class="sxs-lookup"><span data-stu-id="74db6-139">If you need a stream with no backing store (also known as a bit bucket), use the <xref:System.IO.Stream.Null> field to retrieve an instance of a stream that is designed for this purpose.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-140">L’exemple suivant montre comment utiliser deux <xref:System.IO.FileStream> objets à copier de façon asynchrone les fichiers d’un répertoire vers un autre répertoire.</span><span class="sxs-lookup"><span data-stu-id="74db6-140">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another directory.</span></span> <span data-ttu-id="74db6-141">La classe <xref:System.IO.FileStream> dérive de la classe <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="74db6-141">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span> <span data-ttu-id="74db6-142">Notez que le gestionnaire d'événements <xref:System.Web.UI.WebControls.Button.Click> pour le contrôle <xref:System.Windows.Controls.Button> est marqué avec le modificateur `async` car il appelle une méthode asynchrone.</span><span class="sxs-lookup"><span data-stu-id="74db6-142">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="74db6-143">
        <para>Lorsque vous implémentez une classe dérivée de <see cref="T:System.IO.Stream" />, vous devez fournir des implémentations pour les <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> méthodes. Les méthodes asynchrones <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, et <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> utilisent les méthodes synchrones <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> dans leurs implémentations. Par conséquent, vos implémentations de <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> ne fonctionnera correctement avec les méthodes asynchrones. Les implémentations par défaut de <see cref="M:System.IO.Stream.ReadByte" /> et <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> créer un tableau d’octets à élément unique, puis appelez vos implémentations de <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> et <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Lorsque vous dérivez de <see cref="T:System.IO.Stream" />, nous vous recommandons de substituer ces méthodes pour accéder à votre mémoire tampon interne, si vous en avez pas, pour améliorer les performances. Vous devez également fournir des implémentations de <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, et <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.  Ne remplacent pas le <see cref="M:System.IO.Stream.Close" /> (méthode), place tous les <see cref="T:System.IO.Stream" /> logique de nettoyage dans le <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (méthode). Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="74db6-143">
          <para>When you implement a derived class of <see cref="T:System.IO.Stream" />, you must provide implementations for the <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> methods. The asynchronous methods <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, and <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> use the synchronous methods <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> in their implementations. Therefore, your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> will work correctly with the asynchronous methods. The default implementations of <see cref="M:System.IO.Stream.ReadByte" /> and <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> create a new single-element byte array, and then call your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. When you derive from <see cref="T:System.IO.Stream" />, we recommend that you override these methods to access your internal buffer, if you have one, for substantially better performance. You must also provide implementations of <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, and <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.  Do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all the <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method. For more information, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
        </span>
      </span>
    </block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-144">Initialise une nouvelle instance de la classe <see cref="T:System.IO.Stream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-144">Initializes a new instance of the <see cref="T:System.IO.Stream" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-145"><xref:System.IO.Stream> est la classe de base abstraite de tous les flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-145"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span>  
  
 <span data-ttu-id="74db6-146">Certains des plus couramment utilisés les flux qui héritent de <xref:System.IO.Stream> sont <xref:System.IO.FileStream>, et <xref:System.IO.MemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="74db6-146">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-147">Mémoire tampon dans laquelle lire les données.buffer</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-147">The buffer to read the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-148">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données lues à partir du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-148">The byte offset in <c>buffer</c> at which to begin writing data read from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-149">Nombre maximal d'octets à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-149">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="74db6-150">Rappel asynchrone facultatif, à appeler quand la lecture est terminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-150">An optional asynchronous callback, to be called when the read is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="74db6-151">Objet fourni par l'utilisateur qui distingue cette requête de lecture asynchrone des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-151">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-152">Débute une opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-152">Begins an asynchronous read operation.</span>
          </span>
          <span data-ttu-id="74db6-153">(Utilisez <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-153">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-154">Élément <see cref="T:System.IAsyncResult" /> représentant la lecture asynchrone, qui peut être encore en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-154">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous read, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-155">Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginRead%2A> et <xref:System.IO.Stream.EndRead%2A> pour implémenter les opérations d'E/S asynchrones.</span><span class="sxs-lookup"><span data-stu-id="74db6-155">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="74db6-156">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="74db6-156">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="74db6-157">L’implémentation par défaut de `BeginRead` sur un flux appelle le <xref:System.IO.Stream.Read%2A> méthode synchrone, ce qui signifie que `Read` peut se bloquer sur certains flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-157">The default implementation of `BeginRead` on a stream calls the <xref:System.IO.Stream.Read%2A> method synchronously, which means that `Read` might block on some streams.</span></span> <span data-ttu-id="74db6-158">Toutefois, les instances de classes telles que `FileStream` et `NetworkStream` prennent entièrement en charge les opérations asynchrones si les instances ont été ouvert de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="74db6-158">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="74db6-159">Par conséquent, les appels à `BeginRead` ne bloquera pas sur ces flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-159">Therefore, calls to `BeginRead` will not block on those streams.</span></span> <span data-ttu-id="74db6-160">Vous pouvez remplacer `BeginRead` (en utilisant des délégués async, par exemple) pour fournir un comportement asynchrone.</span><span class="sxs-lookup"><span data-stu-id="74db6-160">You can override `BeginRead` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="74db6-161">Passer le `IAsyncResult` retourner la valeur à la <xref:System.IO.Stream.EndRead%2A> méthode du flux pour déterminer le nombre d’octets lus et libérer les ressources de système d’exploitation utilisés pour la lecture.</span><span class="sxs-lookup"><span data-stu-id="74db6-161">Pass the `IAsyncResult` return value to the <xref:System.IO.Stream.EndRead%2A> method of the stream to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="74db6-162"><xref:System.IO.Stream.EndRead%2A> doit être appelée une fois pour chaque appel à <xref:System.IO.Stream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-162"><xref:System.IO.Stream.EndRead%2A> must be called once for every call to <xref:System.IO.Stream.BeginRead%2A>.</span></span> <span data-ttu-id="74db6-163">Cela en utilisant le même code qui a appelé `BeginRead` ou dans un rappel passé à `BeginRead`.</span><span class="sxs-lookup"><span data-stu-id="74db6-163">You can do this either by using the same code that called `BeginRead` or in a callback passed to `BeginRead`.</span></span>  
  
 <span data-ttu-id="74db6-164">La position actuelle dans le flux de données est mis à jour lors de la lecture asynchrone ou une écriture est émise, pas lorsque l’opération d’e/s se termine.</span><span class="sxs-lookup"><span data-stu-id="74db6-164">The current position in the stream is updated when the asynchronous read or write is issued, not when the I/O operation completes.</span></span>  
  
 <span data-ttu-id="74db6-165">Plusieurs demandes asynchrones simultanées rendent l’ordre d’exécution demande incertain.</span><span class="sxs-lookup"><span data-stu-id="74db6-165">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="74db6-166">Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="74db6-166">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="74db6-167">Si un flux est fermé ou que vous passez un argument non valide, les exceptions sont immédiatement levées à partir de `BeginRead`.</span><span class="sxs-lookup"><span data-stu-id="74db6-167">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginRead`.</span></span> <span data-ttu-id="74db6-168">Erreurs qui se produisent pendant une demande de lecture asynchrone, tel qu’une panne de disque pendant la requête d’e/s, se produisent sur le thread de pool de threads et lever des exceptions lors de l’appel `EndRead`.</span><span class="sxs-lookup"><span data-stu-id="74db6-168">Errors that occur during an asynchronous read request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndRead`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-169">Tentative de lecture asynchrone au-delà de la fin du flux, ou une erreur disque s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-169">Attempted an asynchronous read past the end of the stream, or a disk error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-170">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-170">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-171">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-171">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-172">L’implémentation du <see langword="Stream" /> en cours ne prend pas en charge l’opération de lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-172">The current <see langword="Stream" /> implementation does not support the read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-173">Mémoire tampon dont sont issues les données à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-173">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-174">Dans <c>buffer</c>, décalage d’octet à partir duquel l’écriture doit commencer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-174">The byte offset in <c>buffer</c> from which to begin writing.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-175">Nombre maximal d'octets à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-175">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="74db6-176">Rappel asynchrone facultatif, à appeler quand l'écriture est terminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-176">An optional asynchronous callback, to be called when the write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="74db6-177">Objet fourni par l'utilisateur qui distingue cette requête d'écriture asynchrone des autres requêtes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-177">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-178">Débute une opération d'écriture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-178">Begins an asynchronous write operation.</span>
          </span>
          <span data-ttu-id="74db6-179">(Utilisez <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-179">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-180">Élément <see langword="IAsyncResult" /> représentant l'écriture asynchrone, qui peut être encore en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-180">An <see langword="IAsyncResult" /> that represents the asynchronous write, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-181">Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginWrite%2A> et <xref:System.IO.Stream.EndWrite%2A> pour implémenter les opérations d'E/S asynchrones.</span><span class="sxs-lookup"><span data-stu-id="74db6-181">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="74db6-182">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="74db6-182">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="74db6-183">L’implémentation par défaut de `BeginWrite` sur un flux appelle le <xref:System.IO.Stream.Write%2A> méthode synchrone, ce qui signifie que `Write` peut se bloquer sur certains flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-183">The default implementation of `BeginWrite` on a stream calls the <xref:System.IO.Stream.Write%2A> method synchronously, which means that `Write` might block on some streams.</span></span> <span data-ttu-id="74db6-184">Toutefois, les instances de classes telles que `FileStream` et `NetworkStream` prennent entièrement en charge les opérations asynchrones si les instances ont été ouvert de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="74db6-184">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="74db6-185">Par conséquent, les appels à `BeginWrite` ne bloquera pas sur ces flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-185">Therefore, calls to `BeginWrite` will not block on those streams.</span></span> <span data-ttu-id="74db6-186">Vous pouvez remplacer `BeginWrite` (en utilisant des délégués async, par exemple) pour fournir un comportement asynchrone.</span><span class="sxs-lookup"><span data-stu-id="74db6-186">You can override `BeginWrite` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="74db6-187">Passer le `IAsyncResult` retourné par la méthode actuelle à <xref:System.IO.Stream.EndWrite%2A> à la fin de l’écriture et libérer des ressources de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="74db6-187">Pass the `IAsyncResult` returned by the current method to <xref:System.IO.Stream.EndWrite%2A> to ensure that the write completes and frees resources appropriately.</span></span> <span data-ttu-id="74db6-188"><xref:System.IO.Stream.EndWrite%2A> doit être appelée une fois pour chaque appel à <xref:System.IO.Stream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-188"><xref:System.IO.Stream.EndWrite%2A> must be called once for every call to <xref:System.IO.Stream.BeginWrite%2A>.</span></span> <span data-ttu-id="74db6-189">Cela en utilisant le même code qui a appelé `BeginWrite` ou dans un rappel passé à `BeginWrite`.</span><span class="sxs-lookup"><span data-stu-id="74db6-189">You can do this either by using the same code that called `BeginWrite` or in a callback passed to `BeginWrite`.</span></span> <span data-ttu-id="74db6-190">Si une erreur se produit pendant une écriture asynchrone, une exception ne sera pas levée tant que `EndWrite` est appelée avec le `IAsyncResult` retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="74db6-190">If an error occurs during an asynchronous write, an exception will not be thrown until `EndWrite` is called with the `IAsyncResult` returned by this method.</span></span>  
  
 <span data-ttu-id="74db6-191">Si un flux de données est accessible en écriture, accès en écriture à la fin du flux de données développe le flux de données.</span><span class="sxs-lookup"><span data-stu-id="74db6-191">If a stream is writable, writing at the end of the stream expands the stream.</span></span>  
  
 <span data-ttu-id="74db6-192">La position actuelle dans le flux de données est mis à jour lorsque vous émettez la lecture asynchrone ou écriture, pas lorsque l’opération d’e/s se termine.</span><span class="sxs-lookup"><span data-stu-id="74db6-192">The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes.</span></span> <span data-ttu-id="74db6-193">Plusieurs demandes asynchrones simultanées rendent l’ordre d’exécution demande incertain.</span><span class="sxs-lookup"><span data-stu-id="74db6-193">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="74db6-194">Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="74db6-194">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="74db6-195">Si un flux est fermé ou que vous passez un argument non valide, les exceptions sont immédiatement levées à partir de `BeginWrite`.</span><span class="sxs-lookup"><span data-stu-id="74db6-195">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginWrite`.</span></span> <span data-ttu-id="74db6-196">Erreurs qui se produisent pendant une demande d’écriture asynchrone, tel qu’une panne de disque pendant la requête d’e/s, se produisent sur le thread de pool de threads et lever des exceptions lors de l’appel `EndWrite`.</span><span class="sxs-lookup"><span data-stu-id="74db6-196">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-197">Tentative d’écriture asynchrone au-delà de la fin du flux, ou une erreur disque s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-197">Attempted an asynchronous write past the end of the stream, or a disk error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-198">Un ou plusieurs arguments ne sont pas valides.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-198">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-199">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-199">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-200">L’implémentation du <see langword="Stream" /> en cours ne prend pas en charge l’opération d’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-200">The current <see langword="Stream" /> implementation does not support the write operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-201">En cas de remplacement dans une classe dérivée, obtient une valeur indiquant si le flux actuel prend en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-201">When overridden in a derived class, gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-202">
            <see langword="true" /> si le flux prend en charge la lecture ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-202">
              <see langword="true" /> if the stream supports reading; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-203">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la lecture, les appels à la <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, et <xref:System.IO.Stream.BeginRead%2A> méthodes lèvent une <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="74db6-203">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, and <xref:System.IO.Stream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="74db6-204">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="74db6-204">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-205">Voici un exemple d’utilisation le `CanRead` propriété.</span><span class="sxs-lookup"><span data-stu-id="74db6-205">The following is an example of using the `CanRead` property.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-206">En cas de remplacement dans une classe dérivée, obtient une valeur indiquant si le flux actuel prend en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-206">When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-207">
            <see langword="true" /> si le flux prend en charge la recherche ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-207">
              <see langword="true" /> if the stream supports seeking; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-208">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la recherche, les appels à <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, et <xref:System.IO.Stream.Seek%2A> lever un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="74db6-208">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, and <xref:System.IO.Stream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="74db6-209">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="74db6-209">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-210">Obtient une valeur qui détermine si le flux actuel peut dépasser le délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-210">Gets a value that determines whether the current stream can time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-211">Valeur qui détermine si le flux actuel peut dépasser le délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-211">A value that determines whether the current stream can time out.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-212">La propriété <xref:System.IO.Stream.CanTimeout%2A> retourne toujours `false`.</span><span class="sxs-lookup"><span data-stu-id="74db6-212">The <xref:System.IO.Stream.CanTimeout%2A> property always returns `false`.</span></span> <span data-ttu-id="74db6-213">Certaines implémentations de flux nécessitent un comportement différent, tel que <xref:System.Net.Sockets.NetworkStream>, qui expire si la connectivité réseau est interrompue ou perdue.</span><span class="sxs-lookup"><span data-stu-id="74db6-213">Some stream implementations require different behavior, such as <xref:System.Net.Sockets.NetworkStream>, which times out if network connectivity is interrupted or lost.</span></span> <span data-ttu-id="74db6-214">Si vous implémentez un flux qui doit être en mesure de délai d’attente, cette propriété doit être substituée pour retourner `true`.</span><span class="sxs-lookup"><span data-stu-id="74db6-214">If you are implementing a stream that must be able to time out, this property should be overridden to return `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-215">En cas de remplacement dans une classe dérivée, obtient une valeur indiquant si le flux actuel prend en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-215">When overridden in a derived class, gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-216">
            <see langword="true" /> si le flux prend en charge l'écriture ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-216">
              <see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-217">Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge l’écriture, un appel à <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, ou <xref:System.IO.Stream.WriteByte%2A> lève un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="74db6-217">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="74db6-218">Dans ce cas, <xref:System.IO.Stream.Flush%2A> est généralement implémentée comme une méthode vide pour garantir une compatibilité complète avec d’autres <xref:System.IO.Stream> types dans la mesure où il est valide pour vider un flux en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="74db6-218">In such cases, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>
  
 <span data-ttu-id="74db6-219">Si le flux est fermé, cette propriété retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="74db6-219">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-220">Voici un exemple d’utilisation le `CanWrite` propriété.</span><span class="sxs-lookup"><span data-stu-id="74db6-220">The following is an example of using the `CanWrite` property.</span></span>  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-221">Ferme le flux actuel et libère toutes les ressources (comme les sockets et les handles de fichiers) associées à celui-ci.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-221">Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</span>
          </span>
          <span data-ttu-id="74db6-222">Au lieu d'appeler cette méthode, assurez-vous que le flux est correctement supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-222">Instead of calling this method, ensure that the stream is properly disposed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-223">Cette méthode appelle <xref:System.IO.Stream.Dispose%2A>, en spécifiant `true` pour libérer toutes les ressources.</span><span class="sxs-lookup"><span data-stu-id="74db6-223">This method calls <xref:System.IO.Stream.Dispose%2A>, specifying `true` to release all resources.</span></span> <span data-ttu-id="74db6-224">Vous n’avez pas à appeler spécifiquement le <xref:System.IO.Stream.Close%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="74db6-224">You do not have to specifically call the <xref:System.IO.Stream.Close%2A> method.</span></span> <span data-ttu-id="74db6-225">Au lieu de cela, vérifiez que chaque <xref:System.IO.Stream> objet est supprimé correctement.</span><span class="sxs-lookup"><span data-stu-id="74db6-225">Instead, ensure that every <xref:System.IO.Stream> object is properly disposed.</span></span> <span data-ttu-id="74db6-226">Vous pouvez déclarer <xref:System.IO.Stream> d’objets dans un `using` bloc (ou `Using` bloquer en Visual Basic) pour vous assurer que le flux de données et toutes ses ressources sont supprimés, ou vous pouvez appeler explicitement la <xref:System.IO.Stream.Dispose%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="74db6-226">You can declare <xref:System.IO.Stream> objects within a `using` block (or `Using` block in Visual Basic) to ensure that the stream and all of its resources are disposed, or you can explicitly call the <xref:System.IO.Stream.Dispose%2A> method.</span></span>  
  
 <span data-ttu-id="74db6-227">Vider le flux ne videra pas son encodeur sous-jacent, sauf si vous appelez explicitement une implémentation de <xref:System.IO.Stream.Flush%2A> ou `Close`.</span><span class="sxs-lookup"><span data-stu-id="74db6-227">Flushing the stream will not flush its underlying encoder unless you explicitly call an implementation of <xref:System.IO.Stream.Flush%2A> or `Close`.</span></span> <span data-ttu-id="74db6-228">Paramètre <xref:System.IO.StreamWriter.AutoFlush%2A> à `true` signifie que les données sont vidées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé.</span><span class="sxs-lookup"><span data-stu-id="74db6-228">Setting <xref:System.IO.StreamWriter.AutoFlush%2A> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="74db6-229">Ainsi, l’encodeur afin de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères.</span><span class="sxs-lookup"><span data-stu-id="74db6-229">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="74db6-230">Ce scénario affecte UTF8 et UTF7, où certains caractères peuvent être codés uniquement après que l’encodeur a reçu les caractères adjacents.</span><span class="sxs-lookup"><span data-stu-id="74db6-230">This scenario affects UTF8 and UTF7 where certain characters can be encoded only after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="74db6-231">Tente de manipuler le flux une fois que le flux a été fermé peut lever une <xref:System.ObjectDisposedException>.</span><span class="sxs-lookup"><span data-stu-id="74db6-231">Attempts to manipulate the stream after the stream has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-232">
            <para>Dans les classes dérivées, ne substituez pas la <see cref="M:System.IO.Stream.Close" /> (méthode), place tous les <see langword="Stream" /> logique de nettoyage dans le <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (méthode). Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-232">
              <para>In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the <see langword="Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method. For more information, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-233">Lit les octets du flux actuel et les écrit dans un autre flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-233">Reads the bytes from the current stream and writes them to another stream.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="74db6-234">Flux vers lequel le contenu du flux actuel sera copié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-234">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-235">Lit les octets du flux actuel et les écrit dans un autre flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-235">Reads the bytes from the current stream and writes them to another stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-236">Copie commence à la position actuelle dans le flux actuel et ne réinitialise pas la position de flux de destination une fois l’opération de copie est terminée.</span><span class="sxs-lookup"><span data-stu-id="74db6-236">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-237">L’exemple suivant copie le contenu d’un <xref:System.IO.FileStream> à un <xref:System.IO.MemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="74db6-237">The following example copies the contents of a <xref:System.IO.FileStream> to a <xref:System.IO.MemoryStream>.</span></span>  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-238">
            <paramref name="destination" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-238">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-239">Le flux actuel ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-239">The current stream does not support reading.</span>
          </span>
          <span data-ttu-id="74db6-240">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-240">-or-</span>
          </span>
          <span data-ttu-id="74db6-241">
            <paramref name="destination" /> ne prend pas en charge l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-241">
              <paramref name="destination" /> does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-242">Le flux actuel ou de <paramref name="destination" /> a été fermé avant l’appel de la méthode <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-242">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-243">Une erreur d'E/S s'est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-243">An I/O error occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="74db6-244">Flux vers lequel le contenu du flux actuel sera copié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-244">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="74db6-245">Taille de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-245">The size of the buffer.</span>
          </span>
          <span data-ttu-id="74db6-246">Cette valeur doit être supérieure à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-246">This value must be greater than zero.</span>
          </span>
          <span data-ttu-id="74db6-247">La taille par défaut est 81920.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-247">The default size is 81920.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-248">Lit tous les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-248">Reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-249">Copie commence à la position actuelle dans le flux actuel et ne réinitialise pas la position de flux de destination une fois l’opération de copie est terminée.</span><span class="sxs-lookup"><span data-stu-id="74db6-249">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-250">
            <paramref name="destination" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-250">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-251">
            <paramref name="bufferSize" /> est négatif ou égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-251">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-252">Le flux actuel ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-252">The current stream does not support reading.</span>
          </span>
          <span data-ttu-id="74db6-253">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-253">-or-</span>
          </span>
          <span data-ttu-id="74db6-254">
            <paramref name="destination" /> ne prend pas en charge l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-254">
              <paramref name="destination" /> does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-255">Le flux actuel ou de <paramref name="destination" /> a été fermé avant l’appel de la méthode <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-255">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-256">Une erreur d'E/S s'est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-256">An I/O error occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-257">Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-257">Asynchronously reads the bytes from the current stream and writes them to another stream.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="74db6-258">Flux vers lequel le contenu du flux actuel sera copié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-258">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-259">Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-259">Asynchronously reads the bytes from the current stream and writes them to another stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-260">Tâche qui représente l’opération de copie asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-260">A task that represents the asynchronous copy operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-261">Le <xref:System.IO.Stream.CopyToAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-261">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-262">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-262">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-263">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-263">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-264">La copie commence à la position actuelle dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="74db6-264">Copying begins at the current position in the current stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-265">L’exemple suivant montre comment utiliser deux <xref:System.IO.FileStream> objets à copier de façon asynchrone les fichiers d’un répertoire vers un autre.</span><span class="sxs-lookup"><span data-stu-id="74db6-265">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another.</span></span> <span data-ttu-id="74db6-266">La classe <xref:System.IO.FileStream> dérive de la classe <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="74db6-266">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span>  <span data-ttu-id="74db6-267">Notez que le <xref:System.Web.UI.WebControls.Button.Click> Gestionnaire d’événements pour le <xref:System.Windows.Controls.Button> contrôle est marqué avec le `async` modificateur parce qu’il appelle une méthode asynchrone</span><span class="sxs-lookup"><span data-stu-id="74db6-267">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-268">
            <paramref name="destination" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-268">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-269">Le flux de données actuel ou le flux de données de destination est supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-269">Either the current stream or the destination stream is disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-270">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-270">The current stream does not support reading, or the destination stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="74db6-271">Flux vers lequel le contenu du flux actuel sera copié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-271">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="74db6-272">Taille en octets de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-272">The size, in bytes, of the buffer.</span>
          </span>
          <span data-ttu-id="74db6-273">Cette valeur doit être supérieure à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-273">This value must be greater than zero.</span>
          </span>
          <span data-ttu-id="74db6-274">La taille par défaut est 81920.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-274">The default size is 81920.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-275">Lit de façon asynchrone tous les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-275">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-276">Tâche qui représente l’opération de copie asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-276">A task that represents the asynchronous copy operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-277">Le <xref:System.IO.Stream.CopyToAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-277">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-278">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-278">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-279">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-279">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-280">La copie commence à la position actuelle dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="74db6-280">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="74db6-281">Pour obtenir un exemple de copie entre deux flux de données, consultez le <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="74db6-281">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-282">
            <paramref name="destination" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-282">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-283">
            <paramref name="buffersize" /> est négatif ou égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-283">
              <paramref name="buffersize" /> is negative or zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-284">Le flux de données actuel ou le flux de données de destination est supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-284">Either the current stream or the destination stream is disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-285">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-285">The current stream does not support reading, or the destination stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="74db6-286">Flux vers lequel le contenu du flux actuel sera copié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-286">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="74db6-287">Taille en octets de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-287">The size, in bytes, of the buffer.</span>
          </span>
          <span data-ttu-id="74db6-288">Cette valeur doit être supérieure à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-288">This value must be greater than zero.</span>
          </span>
          <span data-ttu-id="74db6-289">La taille par défaut est 81920.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-289">The default size is 81920.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="74db6-290">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-290">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="74db6-291">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-291">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-292">Lit de façon asynchrone les octets du flux actuel et les écrit dans un autre flux, en utilisant une taille de mémoire tampon et d'un jeton d'annulation spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-292">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-293">Tâche qui représente l’opération de copie asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-293">A task that represents the asynchronous copy operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-294">Le <xref:System.IO.Stream.CopyToAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-294">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-295">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-295">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-296">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-296">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-297">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="74db6-297">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="74db6-298">La copie commence à la position actuelle dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="74db6-298">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="74db6-299">Pour obtenir un exemple de copie entre deux flux de données, consultez le <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="74db6-299">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-300">
            <paramref name="destination" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-300">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-301">
            <paramref name="buffersize" /> est négatif ou égal à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-301">
              <paramref name="buffersize" /> is negative or zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-302">Le flux de données actuel ou le flux de données de destination est supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-302">Either the current stream or the destination stream is disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-303">Le flux de données actuel ne prend pas en charge la lecture, ou le flux de données de destination ne prend pas en charge l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-303">The current stream does not support reading, or the destination stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-304">Alloue un objet <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-304">Allocates a <see cref="T:System.Threading.WaitHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-305">Référence à l'objet <see langword="WaitHandle" /> alloué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-305">A reference to the allocated <see langword="WaitHandle" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-306">Lorsqu’elle est appelée pour la première fois, la méthode actuelle crée un `WaitHandle` de l’objet et le retourne.</span><span class="sxs-lookup"><span data-stu-id="74db6-306">When called for the first time, the current method creates a `WaitHandle` object and returns it.</span></span> <span data-ttu-id="74db6-307">Lors des appels ultérieurs, `CreateWaitHandle` retourne une référence à un handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="74db6-307">On subsequent calls, `CreateWaitHandle` returns a reference to a new wait handle.</span></span>  
  
 <span data-ttu-id="74db6-308">Utilisez cette méthode si vous implémentez les méthodes asynchrones et que vous avez besoin d’un moyen de blocage <xref:System.IO.Stream.EndRead%2A> ou <xref:System.IO.Stream.EndWrite%2A> jusqu'à ce que l’opération asynchrone est terminée.</span><span class="sxs-lookup"><span data-stu-id="74db6-308">Use this method if you implement the asynchronous methods and require a way of blocking in <xref:System.IO.Stream.EndRead%2A> or <xref:System.IO.Stream.EndWrite%2A> until the asynchronous operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-309">Libère toutes les ressources utilisées par l'objet <see cref="T:System.IO.Stream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-309">Releases all resources used by the <see cref="T:System.IO.Stream" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-310">Libère toutes les ressources utilisées par <see cref="T:System.IO.Stream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-310">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-311">Cette méthode supprime le flux, en écrivant des modifications au magasin de stockage et de fermer le flux pour libérer des ressources.</span><span class="sxs-lookup"><span data-stu-id="74db6-311">This method disposes the stream, by writing any changes to the backing store and closing the stream to release resources.</span></span>  
  
 <span data-ttu-id="74db6-312">Appel `Dispose` autorise les ressources utilisées par le <xref:System.IO.Stream> d’être réaffectées à d’autres fins.</span><span class="sxs-lookup"><span data-stu-id="74db6-312">Calling `Dispose` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="74db6-313">Pour plus d’informations sur `Dispose`, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="74db6-313">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-314">
            <para>Placez toute logique de nettoyage pour votre objet de flux dans <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Ne remplacez pas <see cref="M:System.IO.Stream.Close" />.  Notez que pour des raisons de compatibilité descendante, implémentation de cette méthode diffère des conseils recommandés pour le modèle de suppression.  Cette méthode appelle <see cref="M:System.IO.Stream.Close" />, qui appelle ensuite <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-314">
              <para>Place all cleanup logic for your stream object in <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Do not override <see cref="M:System.IO.Stream.Close" />.  Note that because of backward compatibility requirements, this method's implementation differs from the recommended guidance for the Dispose pattern.  This method calls <see cref="M:System.IO.Stream.Close" />, which then calls <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="74db6-315">
            <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-315">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-316">Libère les ressources non managées utilisées par <see cref="T:System.IO.Stream" /> et libère éventuellement les ressources managées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-316">Releases the unmanaged resources used by the <see cref="T:System.IO.Stream" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-317">Vous devez libérer toutes les ressources en spécifiant `true` pour `disposing`.</span><span class="sxs-lookup"><span data-stu-id="74db6-317">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="74db6-318">Lorsque `disposing` est `true`, le flux peut également garantir que données sont vidées à la mémoire tampon sous-jacente et accéder aux autres objets finalisables.</span><span class="sxs-lookup"><span data-stu-id="74db6-318">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span>  <span data-ttu-id="74db6-319">Cela ne peut pas possible lorsqu’elle est appelée à partir d’un finaliseur en raison d’un manque d’ordre parmi les finaliseurs.</span><span class="sxs-lookup"><span data-stu-id="74db6-319">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>  
  
 <span data-ttu-id="74db6-320">Si votre flux utilise un handle de système d’exploitation pour communiquer avec sa source, envisagez d’utiliser une sous-classe de <xref:System.Runtime.InteropServices.SafeHandle> à cet effet.</span><span class="sxs-lookup"><span data-stu-id="74db6-320">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>  
  
 <span data-ttu-id="74db6-321">Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="74db6-321">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="74db6-322"><xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.Stream.Dispose%2A> méthode avec le `disposing` paramètre défini sur `true`.</span><span class="sxs-lookup"><span data-stu-id="74db6-322"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Stream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="74db6-323"><xref:System.Object.Finalize%2A> appelle <xref:System.IO.Stream.Dispose%2A> avec `disposing` défini sur `false`.</span><span class="sxs-lookup"><span data-stu-id="74db6-323"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Stream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-324">
            <para>Dans les classes dérivées, ne substituez pas la <see cref="M:System.IO.Stream.Close" /> méthode, placez à la place, toute la logique de nettoyage de Stream dans le <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> (méthode).  <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution de <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-324">
              <para>In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the Stream cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.  <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />. For more information about how to implement <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="74db6-325">Référence à la requête asynchrone en attente à terminer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-325">The reference to the pending asynchronous request to finish.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-326">Attend que la requête asynchrone en attente se termine.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-326">Waits for the pending asynchronous read to complete.</span>
          </span>
          <span data-ttu-id="74db6-327">(Utilisez <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-327">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-328">Nombre d'octets lus dans le flux, entre zéro (0) et le nombre demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-328">The number of bytes read from the stream, between zero (0) and the number of bytes you requested.</span>
          </span>
          <span data-ttu-id="74db6-329">Les flux retournent uniquement zéro (0) à la fin du flux ; sinon, ils devraient se bloquer jusqu'à ce qu'au moins un octet soit disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-329">Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-330">Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginRead%2A> et <xref:System.IO.Stream.EndRead%2A> pour implémenter les opérations d'E/S asynchrones.</span><span class="sxs-lookup"><span data-stu-id="74db6-330">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="74db6-331">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="74db6-331">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="74db6-332">Appelez `EndRead` pour déterminer le nombre d’octets lus à partir du flux.</span><span class="sxs-lookup"><span data-stu-id="74db6-332">Call `EndRead` to determine how many bytes were read from the stream.</span></span>  
  
 <span data-ttu-id="74db6-333">`EndRead` peut être appelée qu’une seule fois sur chaque <xref:System.IAsyncResult> de <xref:System.IO.Stream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-333">`EndRead` can be called once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="74db6-334">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="74db6-334">This method blocks until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-335">
            <paramref name="asyncResult" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-335">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-336">Handle sur l’opération de lecture en attente n’est pas disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-336">A handle to the pending read operation is not available.</span>
          </span>
          <span data-ttu-id="74db6-337">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-337">-or-</span>
          </span>
          <span data-ttu-id="74db6-338">L’opération en attente ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-338">The pending operation does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-339">
            <paramref name="asyncResult" /> ne provenait pas d’une méthode <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur le flux en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-339">
              <paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-340">Le flux est fermé ou une erreur interne s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-340">The stream is closed or an internal error has occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="74db6-341">Référence à la requête d'E/S asynchrone en attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-341">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-342">Termine une opération d'écriture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-342">Ends an asynchronous write operation.</span>
          </span>
          <span data-ttu-id="74db6-343">(Utilisez <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> à la place.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-343">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-344">Dans .NET Framework 4 et les versions antérieures, on doit utiliser des méthodes telles que <xref:System.IO.Stream.BeginWrite%2A> et <xref:System.IO.Stream.EndWrite%2A> pour implémenter les opérations d'E/S asynchrones.</span><span class="sxs-lookup"><span data-stu-id="74db6-344">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="74db6-345">Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.Stream.FlushAsync%2A>, aide vous implémentez des opérations d’e/s asynchrones plus facilement.</span><span class="sxs-lookup"><span data-stu-id="74db6-345">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="74db6-346">`EndWrite` doit être appelée une seule fois sur chaque <xref:System.IAsyncResult> de <xref:System.IO.Stream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-346">`EndWrite` must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="74db6-347">Cette méthode est bloquée jusqu'à la fin de l'opération d'E/S.</span><span class="sxs-lookup"><span data-stu-id="74db6-347">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="74db6-348">Erreurs qui se produisent pendant une demande d’écriture asynchrone, tel qu’une panne de disque pendant la requête d’e/s, se produisent sur le thread de pool de threads et deviennent visibles lors d’un appel à `EndWrite`.</span><span class="sxs-lookup"><span data-stu-id="74db6-348">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and become visible upon a call to `EndWrite`.</span></span> <span data-ttu-id="74db6-349">Les exceptions levées par le thread du pool ne sera pas visibles lors de l’appel `EndWrite`.</span><span class="sxs-lookup"><span data-stu-id="74db6-349">Exceptions thrown by the thread pool thread will not be visible when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-350">
            <paramref name="asyncResult" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-350">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-351">Un handle sur l’opération d’écriture en attente n’est pas disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-351">A handle to the pending write operation is not available.</span>
          </span>
          <span data-ttu-id="74db6-352">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-352">-or-</span>
          </span>
          <span data-ttu-id="74db6-353">L’opération en attente ne prend pas en charge l’écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-353">The pending operation does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-354">
            <paramref name="asyncResult" /> ne provenait pas d’une méthode <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur le flux en cours.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-354">
              <paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-355">Le flux est fermé ou une erreur interne s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-355">The stream is closed or an internal error has occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-356">En cas de remplacement dans une classe dérivée, efface toutes les mémoires tampons pour ce flux et provoque l'écriture de toutes les données se trouvant dans des mémoires tampons sur l'appareil sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-356">When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-357">Substituer `Flush` sur des flux qui implémentent une mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="74db6-357">Override `Flush` on streams that implement a buffer.</span></span> <span data-ttu-id="74db6-358">Utilisez cette méthode pour déplacer toutes les informations à partir d’un mémoire tampon sous-jacente vers sa destination, désactivez la mémoire tampon, ou les deux.</span><span class="sxs-lookup"><span data-stu-id="74db6-358">Use this method to move any information from an underlying buffer to its destination, clear the buffer, or both.</span></span> <span data-ttu-id="74db6-359">En fonction de l’état de l’objet, vous devrez peut-être modifier la position actuelle dans le flux de données (par exemple, si le flux sous-jacent prend en charge la recherche).</span><span class="sxs-lookup"><span data-stu-id="74db6-359">Depending upon the state of the object, you might have to modify the current position within the stream (for example, if the underlying stream supports seeking).</span></span> <span data-ttu-id="74db6-360">Pour plus d’informations, consultez <xref:System.IO.Stream.CanSeek%2A>.</span><span class="sxs-lookup"><span data-stu-id="74db6-360">For additional information see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  

 <span data-ttu-id="74db6-361">Dans une classe dérivée de <xref:System.IO.Stream> qui ne prend pas en charge l’écriture, <xref:System.IO.Stream.Flush%2A> est généralement implémentée comme une méthode vide pour garantir une compatibilité complète avec d’autres <xref:System.IO.Stream> types dans la mesure où il est valide pour vider un flux en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="74db6-361">In a class derived from <xref:System.IO.Stream> that doesn't support writing, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>

 <span data-ttu-id="74db6-362">Lorsque vous utilisez le <xref:System.IO.StreamWriter> ou <xref:System.IO.BinaryWriter> class, ne videz pas la base de <xref:System.IO.Stream> objet.</span><span class="sxs-lookup"><span data-stu-id="74db6-362">When using the <xref:System.IO.StreamWriter> or <xref:System.IO.BinaryWriter> class, do not flush the base <xref:System.IO.Stream> object.</span></span> <span data-ttu-id="74db6-363">Au lieu de cela, utilisez la classe <xref:System.IO.Stream.Flush%2A> ou <xref:System.IO.Stream.Close%2A> (méthode), ce qui permet de s’assurer que les données sont vidées dans le flux sous-jacent et ensuite écrites dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="74db6-363">Instead, use the class's <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.Close%2A> method, which makes sure that the data is flushed to the underlying stream first and then written to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-364">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-364">An I/O error occurs.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-365">Efface de façon asynchrone toutes les mémoires tampons pour ce flux et provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-365">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-366">Efface de façon asynchrone toutes les mémoires tampons pour ce flux et provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-366">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-367">Tâche qui représente l’opération de vidage asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-367">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-368">Si une classe dérivée, tel que <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream>, ne pas vider la mémoire tampon dans son implémentation de la <xref:System.IO.Stream.Flush%2A> (méthode), le <xref:System.IO.Stream.FlushAsync%2A> méthode ne sera pas vider la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="74db6-368">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-369">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-369">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="74db6-370">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-370">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="74db6-371">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-371">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-372">Efface de façon asynchrone toutes les mémoires tampons pour ce flux, provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent et surveille les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-372">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-373">Tâche qui représente l’opération de vidage asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-373">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-374">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="74db6-374">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="74db6-375">Si une classe dérivée, tel que <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream>, ne pas vider la mémoire tampon dans son implémentation de la <xref:System.IO.Stream.Flush%2A> (méthode), le <xref:System.IO.Stream.FlushAsync%2A> méthode ne sera pas vider la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="74db6-375">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-376">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-376">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-377">En cas de remplacement dans une classe dérivée, obtient la longueur du flux en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-377">When overridden in a derived class, gets the length in bytes of the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-378">Valeur de type long représentant la longueur du flux en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-378">A long value representing the length of the stream in bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-379">Une classe dérivée de <see langword="Stream" /> ne prend pas en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-379">A class derived from <see langword="Stream" /> does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-380">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-380">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-381">Élément <see langword="Stream" /> sans magasin de stockage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-381">A <see langword="Stream" /> with no backing store.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-382">Utilisez `Null` pour rediriger la sortie vers un flux qui ne consomme pas toutes les ressources système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="74db6-382">Use `Null` to redirect output to a stream that will not consume any operating system resources.</span></span> <span data-ttu-id="74db6-383">Lorsque les méthodes de `Stream` qui fournissent l’écriture sont appelées sur `Null`, l’appel est simplement retourné et aucune donnée n’est écrite.</span><span class="sxs-lookup"><span data-stu-id="74db6-383">When the methods of `Stream` that provide writing are invoked on `Null`, the call simply returns, and no data is written.</span></span> <span data-ttu-id="74db6-384">`Null` implémente également un `Read` méthode qui retourne zéro sans lire des données.</span><span class="sxs-lookup"><span data-stu-id="74db6-384">`Null` also implements a `Read` method that returns zero without reading data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-385">Assure la prise en charge d'un <see cref="T:System.Diagnostics.Contracts.Contract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-385">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-386">En cas de remplacement dans une classe dérivée, obtient ou définit la position dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-386">When overridden in a derived class, gets or sets the position within the current stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-387">Position actuelle dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-387">The current position within the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-388">Le flux doit prendre en charge la recherche pour obtenir ou définir la position.</span><span class="sxs-lookup"><span data-stu-id="74db6-388">The stream must support seeking to get or set the position.</span></span> <span data-ttu-id="74db6-389">Utilisez le <xref:System.IO.Stream.CanSeek%2A> propriété afin de déterminer si le flux prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="74db6-389">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the stream supports seeking.</span></span>  
  
 <span data-ttu-id="74db6-390">La recherche au-delà de la longueur du flux est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="74db6-390">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="74db6-391">Le `Position` propriété n’assure pas le suivi du nombre d’octets à partir de flux de données qui ont été consommés, omis, ou les deux.</span><span class="sxs-lookup"><span data-stu-id="74db6-391">The `Position` property does not keep track of the number of bytes from the stream that have been consumed, skipped, or both.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-392">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-392">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-393">Le flux ne prend pas en charge la recherche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-393">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-394">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-394">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-395">Tableau d'octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-395">An array of bytes.</span>
          </span>
          <span data-ttu-id="74db6-396">Quand cette méthode retourne un résultat, la mémoire tampon contient le tableau d’octets spécifié dont les valeurs comprises entre <c>offset</c> et (<c>offset</c> + <c>count</c> - 1) sont remplacées par les octets lus dans la source actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-396">When this method returns, the buffer contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the bytes read from the current source.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-397">Offset d’octet de base zéro dans <c>buffer</c> auquel commencer le stockage des données lues dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-397">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-398">Nombre maximal d'octets à lire dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-398">The maximum number of bytes to be read from the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-399">En cas de remplacement dans une classe dérivée, lit une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-399">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-400">Nombre total d'octets lus dans la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-400">The total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="74db6-401">Le nombre d'octets peut être inférieur au nombre d'octets demandés si ce nombre n'est pas actuellement disponible ou égal à zéro (0) si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-401">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-402">Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="74db6-402">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="74db6-403">Utilisez le <xref:System.IO.Stream.ReadAsync%2A> méthode lire de façon asynchrone à partir du flux actuel.</span><span class="sxs-lookup"><span data-stu-id="74db6-403">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="74db6-404">Les implémentations de cette méthode lisent un maximum de `count` octets à partir du flux et les stocker dans `buffer` commençant à `offset`.</span><span class="sxs-lookup"><span data-stu-id="74db6-404">Implementations of this method read a maximum of `count` bytes from the current stream and store them in `buffer` beginning at `offset`.</span></span> <span data-ttu-id="74db6-405">La position actuelle dans le flux est avancée par le nombre d’octets lus ; Toutefois, si une exception se produit, la position actuelle dans le flux de données reste inchangée.</span><span class="sxs-lookup"><span data-stu-id="74db6-405">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="74db6-406">Implémentations de retournent le nombre d’octets lus.</span><span class="sxs-lookup"><span data-stu-id="74db6-406">Implementations return the number of bytes read.</span></span> <span data-ttu-id="74db6-407">L’implémentation sera bloqué jusqu'à ce qu’au moins un octet de données peut être lu, si aucune donnée n’est disponible.</span><span class="sxs-lookup"><span data-stu-id="74db6-407">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="74db6-408"><xref:System.IO.Stream.Read%2A> retourne 0 uniquement lorsqu’il n’existe plus aucune donnée dans le flux de données et n’est attendue (par exemple, un socket fermé ou la fin du fichier).</span><span class="sxs-lookup"><span data-stu-id="74db6-408"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="74db6-409">Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux n’a pas été atteinte.</span><span class="sxs-lookup"><span data-stu-id="74db6-409">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="74db6-410">Utilisez <xref:System.IO.BinaryReader> pour la lecture des types de données primitifs.</span><span class="sxs-lookup"><span data-stu-id="74db6-410">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-411">L’exemple suivant montre comment utiliser <xref:System.IO.Stream.Read%2A> pour lire un bloc de données.</span><span class="sxs-lookup"><span data-stu-id="74db6-411">The following example shows how to use <xref:System.IO.Stream.Read%2A> to read a block of data.</span></span>  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-412">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-412">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-413">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-413">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-414">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-414">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-415">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-415">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-416">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-416">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-417">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-417">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-418">Lit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-418">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-419">Mémoire tampon dans laquelle les données sont écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-419">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-420">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données à partir du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-420">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-421">Nombre maximal d'octets à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-421">The maximum number of bytes to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-422">Lit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position dans le flux du nombre d'octets lus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-422">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-423">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-423">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="74db6-424">La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-424">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="74db6-425">La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-425">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-426">Le <xref:System.IO.Stream.ReadAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-426">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-427">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-427">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-428">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-428">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-429">Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="74db6-429">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-430">L’exemple suivant montre comment lire à partir d’un fichier de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="74db6-430">The following example shows how to read from a file asynchronously.</span></span> <span data-ttu-id="74db6-431">L’exemple utilise le <xref:System.IO.FileStream> classe qui dérive de la <xref:System.IO.Stream> classe.</span><span class="sxs-lookup"><span data-stu-id="74db6-431">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-432">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-432">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-433">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-433">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-434">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-434">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-435">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-435">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-436">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-436">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-437">Le flux est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-437">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-438">Mémoire tampon dans laquelle les données sont écrites.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-438">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-439">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données à partir du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-439">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-440">Nombre maximal d'octets à lire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-440">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="74db6-441">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-441">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="74db6-442">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-442">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-443">Lit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position dans le flux du nombre d'octets lus et surveille les demandes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-443">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-444">Tâche qui représente l'opération de lecture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-444">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="74db6-445">La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-445">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="74db6-446">La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-446">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-447">Le <xref:System.IO.Stream.ReadAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-447">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-448">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-448">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-449">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-449">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-450">Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="74db6-450">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="74db6-451">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="74db6-451">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="74db6-452">Pour obtenir un exemple, consultez le <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="74db6-452">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-453">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-453">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-454">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-454">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-455">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-455">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-456">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-456">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-457">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-457">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-458">Le flux est actuellement utilisé par une opération de lecture antérieure.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-458">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="74db6-459">Lit un octet du flux et avance d'un octet la position au sein du flux, ou retourne -1 si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-459">Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-460">Conversion de type (transtypage) de l'octet non signé en <see langword="Int32" />, ou -1 si la fin du flux a été atteinte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-460">The unsigned byte cast to an <see langword="Int32" />, or -1 if at the end of the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-461">Utilisez le <xref:System.IO.Stream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.</span><span class="sxs-lookup"><span data-stu-id="74db6-461">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="74db6-462">Tente de manipuler le flux une fois que le flux a été fermé pourrait lever un <xref:System.ObjectDisposedException>.</span><span class="sxs-lookup"><span data-stu-id="74db6-462">Attempts to manipulate the stream after the stream has been closed could throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-463">Le flux ne prend pas en charge la lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-463">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-464">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-464">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-465">
            <para>L’implémentation par défaut sur <see langword="Stream" /> crée un tableau d’un octet, puis appelle <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Bien que ce soit correct, il est inefficace. N’importe quel flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui lit la mémoire tampon directement, vous évitant l’allocation de tableau supplémentaire à chaque appel.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-465">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-466">Obtient ou définit une valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'effectuer la lecture avant d’expiration du délai d’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-466">Gets or sets a value, in miliseconds, that determines how long the stream will attempt to read before timing out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-467">Valeur exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'effectuer la lecture avant de dépasser le délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-467">A value, in miliseconds, that determines how long the stream will attempt to read before timing out.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-468">La méthode <see cref="P:System.IO.Stream.ReadTimeout" /> lève toujours <see cref="T:System.InvalidOperationException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-468">The <see cref="P:System.IO.Stream.ReadTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-469">
            <para>Le <see cref="P:System.IO.Stream.ReadTimeout" /> propriété doit être substituée pour fournir le comportement approprié pour le flux. Si le flux ne prend pas en charge le délai d’expiration, cette propriété doit déclencher un <see cref="T:System.InvalidOperationException" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-469">
              <para>The <see cref="P:System.IO.Stream.ReadTimeout" /> property should be overridden to provide the appropriate behavior for the stream. If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="74db6-470">Décalage d’octet relatif au paramètre <c>origin</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-470">A byte offset relative to the <c>origin</c> parameter.</span>
          </span>
        </param>
        <param name="origin">
          <span data-ttu-id="74db6-471">Valeur de type <see cref="T:System.IO.SeekOrigin" /> indiquant le point de référence utilisé pour obtenir la nouvelle position.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-471">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-472">En cas de remplacement dans une classe dérivée, définit la position dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-472">When overridden in a derived class, sets the position within the current stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-473">Nouvelle position dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-473">The new position within the current stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-474">Utilisez le <xref:System.IO.Stream.CanSeek%2A> propriété afin de déterminer si l’instance actuelle prend en charge la recherche.</span><span class="sxs-lookup"><span data-stu-id="74db6-474">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the current instance supports seeking.</span></span>  
  
 <span data-ttu-id="74db6-475">Si `offset` est négatif, la nouvelle position doit précéder la position spécifiée par `origin` par le nombre d’octets spécifié par `offset`.</span><span class="sxs-lookup"><span data-stu-id="74db6-475">If `offset` is negative, the new position is required to precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="74db6-476">Si `offset` est zéro (0), la nouvelle position est nécessaire à la position spécifiée par `origin`.</span><span class="sxs-lookup"><span data-stu-id="74db6-476">If `offset` is zero (0), the new position is required to be the position specified by `origin`.</span></span> <span data-ttu-id="74db6-477">Si `offset` est un nombre positif, la nouvelle position est nécessaire pour suivre la position spécifiée par `origin` par le nombre d’octets spécifié par `offset`.</span><span class="sxs-lookup"><span data-stu-id="74db6-477">If `offset` is positive, the new position is required to follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="74db6-478">Les classes dérivées de `Stream` que la recherche de la prise en charge doit remplacer cette méthode pour fournir les fonctionnalités décrites ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="74db6-478">Classes derived from `Stream` that support seeking must override this method to provide the functionality described above.</span></span>  
  
 <span data-ttu-id="74db6-479">La recherche au-delà de la longueur du flux est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="74db6-479">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-480">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-480">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-481">Le flux ne prend pas en charge la recherche, comme s’il était construit à partir d’un canal ou d’une sortie console.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-481">The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-482">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-482">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="74db6-483">Longueur souhaitée du flux actuel en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-483">The desired length of the current stream in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-484">En cas de substitution dans une classe dérivée, définit la longueur de flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-484">When overridden in a derived class, sets the length of the current stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-485">Si la valeur spécifiée est inférieure à la longueur actuelle du flux de données, le flux est tronqué.</span><span class="sxs-lookup"><span data-stu-id="74db6-485">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="74db6-486">Si la valeur spécifiée est supérieure à la longueur actuelle du flux de données, le flux est développé.</span><span class="sxs-lookup"><span data-stu-id="74db6-486">If the specified value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="74db6-487">Si le flux est développé, le contenu du flux de données entre l’ancienne et la nouvelle longueur n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="74db6-487">If the stream is expanded, the contents of the stream between the old and the new length are not defined.</span></span>  
  
 <span data-ttu-id="74db6-488">Un flux doit prendre en charge écriture et la recherche pour `SetLength` fonctionne.</span><span class="sxs-lookup"><span data-stu-id="74db6-488">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 <span data-ttu-id="74db6-489">Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture et le <xref:System.IO.Stream.CanSeek%2A> propriété afin de déterminer si le recherche est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="74db6-489">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.Stream.CanSeek%2A> property to determine whether seeking is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-490">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-490">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-491">Le flux ne prend en charge ni l’écriture, ni la recherche, comme s’il était construit à partir d’un canal ou d’une sortie console.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-491">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-492">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-492">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="74db6-493">Objet <see cref="T:System.IO.Stream" /> à synchroniser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-493">The <see cref="T:System.IO.Stream" /> object to synchronize.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-494">Crée un wrapper thread-safe (synchronisé) autour de l'objet <see cref="T:System.IO.Stream" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-494">Creates a thread-safe (synchronized) wrapper around the specified <see cref="T:System.IO.Stream" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-495">Objet <see cref="T:System.IO.Stream" /> thread-safe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-495">A thread-safe <see cref="T:System.IO.Stream" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-496">Cette méthode retourne une classe qui encapsule spécifié <xref:System.IO.Stream> de l’objet et restreint l’accès à celui-ci à partir de plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="74db6-496">This method returns a class that wraps the specified <xref:System.IO.Stream> object and restricts access to it from multiple threads.</span></span> <span data-ttu-id="74db6-497">Tous les accès à la <xref:System.IO.Stream> objet sera thread-safe.</span><span class="sxs-lookup"><span data-stu-id="74db6-497">All access to the <xref:System.IO.Stream> object will be thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-498">
            <paramref name="stream" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-498">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-499">Tableau d'octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-499">An array of bytes.</span>
          </span>
          <span data-ttu-id="74db6-500">Cette méthode copie <c>count</c> octets à partir de <c>buffer</c> dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-500">This method copies <c>count</c> bytes from <c>buffer</c> to the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-501">Dans <c>buffer</c>, décalage d’octet de base zéro auquel commencer la copie des octets dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-501">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-502">Nombre d'octets à écrire dans le flux actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-502">The number of bytes to be written to the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-503">En cas de remplacement dans une classe dérivée, écrit une séquence d'octets dans le flux actuel et avance la position actuelle dans ce flux du nombre d'octets écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-503">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-504">Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="74db6-504">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="74db6-505">Utilisez le <xref:System.IO.Stream.WriteAsync%2A> méthode à écrire de façon asynchrone dans le flux actuel.</span><span class="sxs-lookup"><span data-stu-id="74db6-505">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="74db6-506">Si l’opération d’écriture réussite, la position dans le flux avance du nombre d’octets écrits.</span><span class="sxs-lookup"><span data-stu-id="74db6-506">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="74db6-507">Si une exception se produit, la position dans le flux reste inchangée.</span><span class="sxs-lookup"><span data-stu-id="74db6-507">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-508">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-508">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-509">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-509">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-510">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-510">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-511">Une erreur d’E/S s’est produite ; par exemple, le fichier spécifié est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-511">An I/O error occured, such as the specified file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-512">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-512">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-513">
            <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> a été appelée après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-513">
              <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> was called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-514">Écrit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position actuelle dans le flux du nombre d'octets écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-514">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-515">Mémoire tampon dont sont issues les données à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-515">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-516">Le décalage en octets, commençant à zéro, dans <c>buffer</c>, où commencer la copie des octets dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-516">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-517">Nombre maximal d'octets à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-517">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-518">Écrit de façon asynchrone une séquence d'octets dans le flux actuel et avance la position actuelle dans le flux du nombre d'octets écrits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-518">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-519">Tâche qui représente l’opération d’écriture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-519">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-520">Le <xref:System.IO.Stream.WriteAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-520">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-521">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-521">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-522">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-522">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-523">Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="74db6-523">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="74db6-524">L’exemple suivant montre comment écrire de façon asynchrone dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="74db6-524">The following example shows how to write asynchronously to a file.</span></span> <span data-ttu-id="74db6-525">L’exemple utilise le <xref:System.IO.FileStream> classe qui dérive de la <xref:System.IO.Stream> classe.</span><span class="sxs-lookup"><span data-stu-id="74db6-525">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-526">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-526">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-527">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-527">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-528">La somme de <paramref name="offset" /> et de <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-528">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-529">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-529">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-530">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-530">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-531">Le flux est actuellement utilisé par une opération d’écriture précédente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-531">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="74db6-532">Mémoire tampon dont sont issues les données à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-532">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="74db6-533">Le décalage en octets, commençant à zéro, dans <c>buffer</c>, où commencer la copie des octets dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-533">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="74db6-534">Nombre maximal d'octets à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-534">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="74db6-535">Jeton pour surveiller les requêtes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-535">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="74db6-536">La valeur par défaut est <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-536">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-537">Écrit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position actuelle dans ce flux du nombre d'octets écrits et surveille les demandes d'annulation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-537">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="74db6-538">Tâche qui représente l’opération d’écriture asynchrone.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-538">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-539">Le <xref:System.IO.Stream.WriteAsync%2A> méthode vous permet d’effectuer des opérations d’e/s gourmandes en ressources sans bloquer le thread principal.</span><span class="sxs-lookup"><span data-stu-id="74db6-539">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="74db6-540">Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas.</span><span class="sxs-lookup"><span data-stu-id="74db6-540">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="74db6-541">Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.</span><span class="sxs-lookup"><span data-stu-id="74db6-541">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="74db6-542">Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="74db6-542">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="74db6-543">Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="74db6-543">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="74db6-544">Pour obtenir un exemple, consultez le <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="74db6-544">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="74db6-545">
            <paramref name="buffer" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-545">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="74db6-546">
            <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-546">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="74db6-547">La somme de <paramref name="offset" /> et de <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-547">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-548">Le flux ne prend pas en charge l'écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-548">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-549">Le flux a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-549">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-550">Le flux est actuellement utilisé par une opération d’écriture précédente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-550">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="74db6-551">Octet à écrire dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-551">The byte to write to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="74db6-552">Écrit un octet à la position actuelle dans le flux et avance d'un octet la position dans le flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-552">Writes a byte to the current position in the stream and advances the position within the stream by one byte.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="74db6-553">Utilisez le <xref:System.IO.Stream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.</span><span class="sxs-lookup"><span data-stu-id="74db6-553">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="74db6-554">Une erreur d’E/S se produit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-554">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="74db6-555">Le flux ne prend pas en charge l’écriture ou bien il est déjà fermé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-555">The stream does not support writing, or the stream is already closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="74db6-556">Des méthodes ont été appelées après la fermeture du flux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-556">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-557">
            <para>L’implémentation par défaut sur <see langword="Stream" /> crée un tableau d’un octet, puis appelle <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Bien que ce soit correct, il est inefficace. N’importe quel flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui écrit dans la mémoire tampon directement, en évitant l’allocation de tableau supplémentaire à chaque appel.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-557">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that writes to the buffer directly, avoiding the extra array allocation on every call.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="74db6-558">Obtient ou définit une valeur, exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'écrire des données avant l’expiration du délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-558">Gets or sets a value, in miliseconds, that determines how long the stream will attempt to write before timing out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="74db6-559">Valeur exprimée en millisecondes, qui définit la durée pendant laquelle le flux tentera d'écrire des données avant de dépasser le délai d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-559">A value, in miliseconds, that determines how long the stream will attempt to write before timing out.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="74db6-560">La méthode <see cref="P:System.IO.Stream.WriteTimeout" /> lève toujours <see cref="T:System.InvalidOperationException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-560">The <see cref="P:System.IO.Stream.WriteTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="74db6-561">
            <para>Le <see cref="P:System.IO.Stream.WriteTimeout" /> propriété doit être substituée pour fournir le comportement approprié pour le flux. Si le flux ne prend pas en charge le délai d’expiration, cette propriété doit déclencher un <see cref="T:System.InvalidOperationException" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="74db6-561">
              <para>The <see cref="P:System.IO.Stream.WriteTimeout" /> property should be overridden to provide the appropriate behavior for the stream. If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>