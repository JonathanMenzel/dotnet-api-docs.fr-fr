<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="284b342cd8ec18017e3ac4ac33597d46dbc3c75f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30721103" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit l'identificateur du système de type XAML pour les membres de types XAML. L'identificateur est utilisé par les lecteurs et les writers XAML lors du traitement des nœuds membres (lorsque le lecteur XAML est positionné sur un <see cref="F:System.Xaml.XamlNodeType.StartMember" />) de même que pour la logique du système de type XAML général.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> peut utiliser trois méthodes pour retourner des informations sur un membre XAML : standard commun réflexion language runtime (CLR) ; une technique de réflexion de référence uniquement appel interne API ce bit utilisation optimisée indicateurs ; ou appel virtuel substitue de la `Lookup*` API fournie par possible <xref:System.Xaml.XamlMember> sous-classes. Pour la plupart des utilisations de l’API des Services XAML .NET Framework et le <xref:System.Xaml.XamlMember> API, vous utilisez le contexte de schéma XAML par défaut. Le contexte de schéma XAML par défaut pour les Services XAML .NET Framework utilise le stockage pour le système de type CLR. Ainsi, les lecteurs XAML et les writers XAML fonctionner avec n’importe quel type ou membre qui est défini ou disponible pour le CLR et ses techniques de réflexion.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Les Classes dérivées XamlMember et API de recherche  
 <xref:System.Xaml.XamlMember> définit plusieurs membres virtuels que les classes dérivées peuvent remplacer. Ces membres ont des noms qui commencent toujours par la chaîne `Lookup`. Le reste de l’API de nommer les références à la propriété qui l’influence de la méthode virtuelle. Par exemple, un <xref:System.Xaml.XamlMember> une classe dérivée peut substituer <xref:System.Xaml.XamlMember.LookupTargetType%2A> pour influencer ce que la propriété définie par la base de <xref:System.Xaml.XamlMember.TargetType%2A> retourne dans une classe dérivée. Vous pouvez prévoir des valeurs de retour de ces propriétés dans <xref:System.Xaml.XamlMember> ou les classes dérivées existantes en lisant la documentation relative à la `Lookup*` méthodes.  
  
 L’objectif de la `Lookup*` méthodes consiste à fournir une technique extension système type XAML qui incorpore la <xref:System.Xaml.XamlMember> classe de base. En dérivant de <xref:System.Xaml.XamlMember> et en remplaçant le `Lookup` membres virtuels, vous pouvez définir le concept d’un membre XAML pour un schéma XAML dans un système de type XAML sans être lié aux caractéristiques d’un système de type de stockage ou une technologie. Vous pouvez également utiliser un contexte de schéma XAML fourni sous ce schéma et toujours retourner les résultats souhaités.  
  
 Par exemple, considérez la <xref:System.Xaml.XamlMember> propriété <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Cette propriété informe les appelants que les opérations comme l’utilisation d’un <xref:System.Xaml.XamlWriter> pour la sérialisation peut écrire une valeur pour ce membre sur un objet cible. Dans l’implémentation par défaut, la détermination de si le membre est accessible en écriture est effectuée à l’aide de techniques de réflexion par rapport à CLR de sauvegarde <xref:System.Type> et ses membres (la <xref:System.Reflection.MemberInfo>). Par conséquent, par défaut, le système de type XAML dépend du système de type CLR. Toutefois, vous pouvez supprimer cette dépendance pour votre système de type XAML signalant de <xref:System.Xaml.XamlMember.IsWritePublic%2A> en remplaçant l’API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. Au sein de votre remplacement, vous pouvez utiliser d’autres analyses, tels que les métadonnées spécifiques à votre technologie, une table de correspondance maître optimisée pour un vocabulaire XAML fixe, ou d’autres stratégies pour déterminer si un membre XAML est accessible en écriture dans votre Vocabulaire XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Construction de XamlMember sans contexte de schéma XAML  
 La plupart des constructeurs de <xref:System.Xaml.XamlMember> nécessitent un <xref:System.Xaml.XamlSchemaContext> dans le cadre de leur initialisation. Le <xref:System.Xaml.XamlSchemaContext> est également nécessaire pour de nombreuses interne <xref:System.Xaml.XamlSchemaContext> opérations, telles que l’obtention d’informations sont transférées à partir du type de stockage. Lorsque vous travaillez avec le <xref:System.Xaml.XamlMember> API, vous devez en général un <xref:System.Xaml.XamlSchemaContext> qui est disponible à partir d’une construction environnante comme un <xref:System.Xaml.XamlWriter>. Dans ce cas, vous pouvez passer le <xref:System.Xaml.XamlSchemaContext> font référence à tous les appels de système de type XAML qui requièrent un contexte de schéma XAML.  
  
 Un constructeur spécifique, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, ne nécessite pas un <xref:System.Xaml.XamlSchemaContext>. Toutefois, un <xref:System.Xaml.XamlMember> qui est construit avec les <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> signature retourne `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Pour un chemin de chargement qui implique <xref:System.Xaml.XamlObjectWriter>, ce membre ne peut pas être écrit dans un graphique d’objet. À l’aide de l’implémentation des services XAML .NET Framework, le <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque les <xref:System.Xaml.XamlMember> rapports `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Vous ne devez pas construire un <xref:System.Xaml.XamlMember> qui a la valeur `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A> , sauf si votre implémentation peut gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres moyens pour ajuster le <xref:System.Xaml.XamlObjectWriter> comportement. Par exemple, un ou plusieurs des éléments suivants peuvent être vrai pour votre implémentation :  
  
-   Le contexte de schéma XAML est disponible plus tard.  
  
-   Vous utilisez un modèle de demandeur de membre.  
  
-   Vous substituez délibérément <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> dans un writer XAML personnalisé.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Système de type CLR <see cref="T:System.Reflection.EventInfo" /> qui représente le membre d'événement.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec le système de type CLR <see cref="T:System.Reflection.EventInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un événement (propriété point de connexion de gestionnaire d’événements).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Système de type CLR <see cref="T:System.Reflection.PropertyInfo" /> qui représente le membre de propriété.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec le système de type CLR <see cref="T:System.Reflection.PropertyInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente une propriété (et en particulier n’est pas une connexion de gestionnaire d’événements).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Système de type CLR <see cref="T:System.Reflection.EventInfo" /> qui représente le membre d'événement.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec le système de type CLR <see cref="T:System.Reflection.EventInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />, notamment les informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un événement (ou une point de connexion de propriété de gestionnaire d’événements).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Système de type CLR <see cref="T:System.Reflection.PropertyInfo" /> qui représente le membre de propriété.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec la réflexion <see cref="T:System.Reflection.PropertyInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />, notamment les informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur uniquement si le membre représente une propriété et si elle n’est pas une connexion de gestionnaire d’événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nom sous forme de chaîne de l'événement pouvant être attaché.</param>
        <param name="adder">
          <see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour la méthode <see langword="Add" /> du gestionnaire de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente un événement pouvant être attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un membre d’événement pouvant être attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom sous forme de chaîne du membre.</param>
        <param name="declaringType">Informations <see cref="T:System.Xaml.XamlType" /> pour le type déclarant.</param>
        <param name="isAttachable">
          <see langword="true" /> pour indiquer que le membre peut être attaché ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" />, en utilisant un nom de chaîne et des informations sur le <see cref="T:System.Xaml.XamlType" /> déclarant. Un <see cref="T:System.Xaml.XamlMember" /> construit avec cette signature présente des limitations importantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> qui est construit avec les <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> signature retourne `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Pour un chemin de chargement qui implique <xref:System.Xaml.XamlObjectWriter>, ce membre ne peut pas être écrit dans un graphique d’objet. À l’aide de l’implémentation de Services XAML .NET Framework, le <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque les <xref:System.Xaml.XamlMember> rapports `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Vous ne devez pas construire un <xref:System.Xaml.XamlMember> avec <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` , sauf si votre implémentation peut gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres moyens pour ajuster le <xref:System.Xaml.XamlObjectWriter> comportement. Par exemple, un ou plusieurs des éléments suivants peuvent être vrai pour votre implémentation :  
  
-   Le contexte de schéma XAML est disponible plus tard.  
  
-   Vous utilisez un modèle de demandeur de membre.  
  
-   Vous substituez délibérément <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> dans un writer XAML personnalisé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="declaringType" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nom sous forme de chaîne de la propriété pouvant être attachée.</param>
        <param name="getter">
          <see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="get" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="setter">
          <see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="set" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente une propriété pouvant être jointe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente une propriété pouvant être attachée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nom sous forme de chaîne de l'événement pouvant être attaché.</param>
        <param name="adder">
          <see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour la méthode <see langword="Add" /> du gestionnaire de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente un événement pouvant être attaché, notamment des informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un membre d’événement pouvant être attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nom sous forme de chaîne de la propriété pouvant être attachée.</param>
        <param name="getter">
          <see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="get" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="setter">
          <see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="set" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente une propriété pouvant être jointe, notamment les informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un membre de propriété pouvant être attachée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type qui déclare le membre associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> du type qui déclare le membre associé à ce <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est généralement définie lors de l’initialisation et n’est généralement pas `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> informations peuvent être passées par les constructeurs pour l’initialisation. En appelant directement les constructeurs de base, l’initialisation de <xref:System.Xaml.XamlMember> classes dérivées peuvent omettre certaines les vérifications de valeur qui sont effectuées dans la classe de base. Par conséquent, l’initialisation dérivée peut modifier les informations de relation de membre de type signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations de système de type de sa déclaration CLR sous-jacente. Pour toutes les vérifications critiques de sécurité de la déclaration des informations de type, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> utilisé pour le chargement différé des objets XAML déclarés.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Xaml.XamlDeferringLoader" /> sur le générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.DeferringLoader%2A> appelle <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit dans les cas où la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'objets <see cref="T:System.Xaml.XamlMember" />. Cette liste répertorie les membres pour lesquels il existe des relations de dépendance pour l'ordre d'initialisation concernant ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Liste d'objets <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.DependsOn%2A> appelle <xref:System.Xaml.XamlMember.LookupDependsOn%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit dans les cas où la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Le `DependsOn` modèle peut être appliqué aux cas de modèle objet délibérément contredisent une règle XAML générale. La règle XAML générale est que les membres d’un type qui ne sont pas transmis en tant que texte d’initialisation (ou par une méthode de fabrique dans XAML 2009) doivent pouvoir être assigné dans n’importe quel ordre. En appliquant un `DependsOn` de modèle à un membre, vous pouvez indiquer les writers XAML à traiter toujours le membre référencé avant ce membre. Vous pouvez appliquer ce modèle dans les situations où la valeur du membre actuel requiert le contexte ou autres informations qui ne sont plus disponibles après que l’autre membre est défini.  
  
 Le `DependsOn` modèle doit être appliqué judicieusement et réservé pour les scénarios de propriété où il sert un but architectural. Grand nombre de dépendances est susceptibles de ralentir le traitement XAML. En outre, il est possible de produire des dépendances circulaires, auquel cas le comportement de traitement XAML n’est pas défini.  
  
 Exemple `DependsOn` scénarios de WPF incluent certaines propriétés sur <xref:System.Windows.Controls.ControlTemplate> et <xref:System.Windows.DataTemplate>, dans <xref:System.Windows.Trigger>et <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si l'objet actif est égal à un autre objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à cet objet.</param>
        <summary>Indique si l'objet actif est égal à un autre objet.</summary>
        <returns>
          <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="obj" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à cet objet.</param>
        <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
        <returns>
          <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cet objet.</summary>
        <returns>Code de hachage entier.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste d'espaces de noms XAML dans lesquels ce membre XAML peut exister.</summary>
        <returns>Liste d'identificateurs d'espace de noms XAML sous forme de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne la <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> résultat d’appel du <xref:System.Xaml.XamlMember.DeclaringType%2A> qui est associé à ce <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> associée à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> associée à ce <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Invoker` modèle est une technique d’extension de système de type XAML avancée. Le `Invoker` modèle permet d’injecter du comportement de mappage de type de schéma différent, tout en utilisant les définitions de système de type XAML à partir des Services XAML .NET Framework.  
  
 Si un <xref:System.Xaml.XamlMember.LookupInvoker%2A> supplante `null`, ou si l’implémentation par défaut retourne `null` , car il lui manque le <xref:System.Xaml.XamlMember.UnderlyingMember%2A> pour ce <xref:System.Xaml.XamlMember>, le <xref:System.Xaml.XamlMember.Invoker%2A> propriété renvoie <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> est la valeur par défaut. Cela est vrai pour la plupart des opérations qui utilisent les Services XAML .NET Framework et le contexte de schéma XAML par défaut, et qui ne remplacer `Invoker` modèles sont passés pour la construction des entités de système de type XAML.  
  
 Appel de <xref:System.Xaml.XamlMember.Invoker%2A> appelle <xref:System.Xaml.XamlMember.LookupInvoker%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est signalé comme étant une propriété ambiante.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est signalé comme étant une propriété ambiante ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.IsAmbient%2A> appelle <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit dans les implémentations où la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Vérifier les propriétés ambiantes est sont généralement partie d’une logique de traitement XAML pour vous assurer que les objets et valeurs qui reposent sur l’utilisation de la qualification de type peuvent fonctionner correctement. L’API des Services XAML .NET Framework et le contexte de schéma XAML par défaut remplissent cette valeur selon attribution avec <xref:System.Windows.Markup.AmbientAttribute>. L’implémentation par défaut de <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> utilise cette existant <xref:System.Windows.Markup.AmbientAttribute> technique et il retourne `true` si <xref:System.Windows.Markup.AmbientAttribute> existe sur une déclaration de membre.  
  
 <xref:System.Windows.Markup.AmbientAttribute> se trouve sur les membres de plusieurs types WPF, qui incluent <xref:System.Windows.Application>, <xref:System.Windows.Setter>, et <xref:System.Windows.Style>. Il se trouve également sur le <xref:System.Windows.ResourceDictionary> type, ce qui signifie que tout membre qui utilise <xref:System.Windows.ResourceDictionary> comme son type doit être considéré comme ambiant même si le membre n’est pas attribué spécifiquement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est un membre pouvant être attaché.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est un membre pouvant être attaché ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsAttachable%2A> la valeur est initialisée selon le constructeur utilisé pour construire un <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est une directive XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est une directive XAML ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsDirective%2A> la valeur est initialisée selon le constructeur utilisé pour construire un <xref:System.Xaml.XamlMember>. La base de <xref:System.Xaml.XamlMember> constructeurs initialisent afin que <xref:System.Xaml.XamlMember.IsDirective%2A> est `false`. Toutefois, le <xref:System.Xaml.XamlDirective> classe (un <xref:System.Xaml.XamlMember> classe dérivée) initialise afin que <xref:System.Xaml.XamlMember.IsDirective%2A> est `true`.  
  
 Si vous souhaitez signaler <xref:System.Xaml.XamlMember.IsDirective%2A> en tant que `true` aux appelants d’une classe de schéma XAML personnalisée pour les membres XAML, assurez-vous que vous dérivez de <xref:System.Xaml.XamlDirective> car il s’agit de la seule façon d’activer ce comportement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre d'événement.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un événement ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.IsEvent%2A> appelle <xref:System.Xaml.XamlMember.LookupIsEvent%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est initialisé avec une chaîne <see langword="xamlName" /> valide en tant que <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est initialisé avec une chaîne <see langword="xamlName" /> valide ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en lecture seule.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.IsReadOnly%2A> appelle <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre avec un accesseur <see langword="get" /> public pouvant être appelé.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un accesseur <see langword="get" /> public pouvant être appelé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsReadPublic%2A> valeur vérifie si le <xref:System.Xaml.XamlMember.DeclaringType%2A> est public. Si <xref:System.Xaml.XamlMember.DeclaringType%2A> est non public, le `get` accesseur ne peut être appelé de façon pratique, et <xref:System.Xaml.XamlMember.IsReadPublic%2A> retourne `false`.  
  
 Appel de <xref:System.Xaml.XamlMember.IsReadPublic%2A> appelle <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> ou une substitution spécifique de cette méthode.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> méthode est virtuelle et par conséquent, peut être remplacée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations de l’accès de système de type de sa déclaration CLR sous-jacente. Pour toutes les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le membre ne peut pas être résolu par le système de stockage utilisé pour la résolution du type et du membre.</summary>
        <value>
          <see langword="true" /> si le membre ne peut pas être résolu ; <see langword="false" /> si le membre peut être résolu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> qui est construit avec les <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> signature retourne `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Pour un chemin de chargement qui implique <xref:System.Xaml.XamlObjectWriter>, un <xref:System.Xaml.XamlMember> avec `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A> ne peut pas être écrit dans un graphique d’objet. Sous les implémentations par défaut dans l’API des Services XAML .NET Framework, le <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque les <xref:System.Xaml.XamlMember> rapports `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Vous ne devez pas construire un <xref:System.Xaml.XamlMember> qui a la valeur `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A> , sauf si votre implémentation peut gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres moyens pour ajuster le <xref:System.Xaml.XamlObjectWriter> comportement.  
  
 Appel de <xref:System.Xaml.XamlMember.IsUnknown%2A> appelle <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en écriture seule.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en écriture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.IsWriteOnly%2A> appelle <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre comportant un accesseur <see langword="set" /> public pouvant être appelé.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un accesseur <see langword="set" /> public pouvant être appelé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsWritePublic%2A> valeur considère que si la <xref:System.Xaml.XamlMember.DeclaringType%2A> est public dans le cadre de la détermination. Si <xref:System.Xaml.XamlMember.DeclaringType%2A> est non public, le `set` accesseur ne peut être appelé de façon pratique, et <xref:System.Xaml.XamlMember.IsWritePublic%2A> retourne `false`.  
  
 Appel de <xref:System.Xaml.XamlMember.IsWritePublic%2A> appelle <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> ou une substitution spécifique de cette méthode.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> méthode est virtuelle et par conséquent, peut être remplacée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations de l’accès de système de type de sa déclaration CLR sous-jacente. Pour toutes les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas d'implémentation dans une classe dérivée, retourne une implémentation de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Implémentation de <see cref="T:System.Reflection.ICustomAttributeProvider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode pour fournir la réflexion interne avec une autre façon d’obtenir les valeurs d’attribut CLR. En l’absence d’une substitution, le réflecteur interne utilise la logique de réflexion CLR typique tels que les appels à <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 L'implémentation par défaut retourne la valeur `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, lequel est utilisé pour le chargement différé des objets XAML déclarés.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> qui a une contrainte <see cref="T:System.Xaml.XamlDeferringLoader" /> sur le générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de la <xref:System.Xaml.XamlMember.DeferringLoader%2A> propriété. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlMember.DeferringLoader%2A> pour retourner une valeur différente de celle qui est activée par la réflexion interne de la valeur par défaut, et si vous fournissez également personnalisé <xref:System.Xaml.Schema.XamlMemberInvoker> plus d’informations.  
  
 L’implémentation par défaut retourne un objet en lisant <xref:System.Windows.Markup.XamlDeferLoadAttribute> ou en utilisant un <xref:System.Xaml.XamlDeferringLoader> à partir du type déclarant. Si aucun objet n’est disponible, cette méthode peut retourner `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste d'objets <see cref="T:System.Xaml.XamlMember" />. Cette liste répertorie les membres pour lesquels il existe des relations de dépendance pour l'ordre d'initialisation concernant ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Liste d'objets <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de la <xref:System.Xaml.XamlMember.DependsOn%2A> propriété. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlMember.DependsOn%2A> pour retourner une valeur différente de celle qui est activée par la réflexion interne de la valeur par défaut, et si vous fournissez également personnalisé <xref:System.Xaml.Schema.XamlMemberInvoker> plus d’informations.  
  
 Les implémentations de lecteur et un writer XAML WPF ce cas avec l’attribut <xref:System.Windows.Markup.DependsOnAttribute>. L’implémentation par défaut utilise cette existant <xref:System.Windows.Markup.DependsOnAttribute> technique.  
  
 Substituez cette méthode si vous n’utilisez pas <xref:System.Windows.Markup.DependsOnAttribute> pour cet objectif et prévoyez de remplacer cette technique d’indication de l’ordre de traitement des propriétés par votre propre technique. Si vous ne souhaitez pas prendre en charge un ordre de traitement de propriété, vous pouvez utiliser l’implémentation par défaut, car il ne retourne aucun résultat, ce qui convient.  
  
 La liste est en lecture seule.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Informations <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> pour ce <see cref="T:System.Xaml.XamlMember" />, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par les appels à <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 L’implémentation par défaut n’exige pas un <xref:System.Xaml.XamlMember> être construite à l’aide d’un des constructeurs qui passent un initial <xref:System.Xaml.Schema.XamlMemberInvoker>. Toutefois, un <xref:System.Xaml.XamlMember.UnderlyingMember%2A> valeur doit exister pour que la <xref:System.Xaml.XamlMember>; sinon, l’implémentation par défaut retourne `null`.  
  
 Substituez cette méthode si vous dérivez également <xref:System.Xaml.Schema.XamlMemberInvoker> et souhaitez retourner la classe dérivée. Si vous retournez `null`, <xref:System.Xaml.XamlMember.Invoker%2A> retourne <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> aux appelants.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> est signalé comme étant une propriété ambiante.</summary>
        <returns>
          <see langword="true" /> pour signaler ce <see cref="T:System.Xaml.XamlMember" /> comme une propriété ambiante ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par les appels internes qui recherchent les informations de propriété ambiantes XAML. Comportement de la propriété ambiante est comptabilisée dans le comportement de l’API publique de lecteurs et writers XAML. Les appels internes qui référencent <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> font généralement partie d’une logique de traitement XAML pour vous assurer que les objets et valeurs qui reposent sur l’utilisation de la qualification de type peuvent fonctionner correctement. L’implémentation de Services XAML .NET Framework par défaut utilise l’attribution CLR pour obtenir ces informations à partir de la réflexion sur les types de stockage. Plus précisément, l’implémentation par défaut vérifie <xref:System.Windows.Markup.AmbientAttribute> et retourne `true` pour <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> si <xref:System.Windows.Markup.AmbientAttribute> existe sur une définition de membre.  
  
 Substituez cette méthode si vous n’utilisez pas <xref:System.Windows.Markup.AmbientAttribute> pour cet objectif et prévoyez de remplacer cette technique d’indication des propriétés XAML ambiantes par votre propre technique.  
  
 Exemples d’API de WPF cet attribut avec <xref:System.Windows.Markup.AmbientAttribute> sont <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> et <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un événement.</summary>
        <returns>
          <see langword="true" /> pour signaler que ce <see cref="T:System.Xaml.XamlMember" /> représente un événement ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut vérifie si <xref:System.Xaml.XamlMember.UnderlyingMember%2A> est de type <xref:System.Reflection.EventInfo>et si tel est le cas, renvoie `true`.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsEvent%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pouvant être interprétée pour déterminer le XAML des représentations de système de type au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété en lecture seule escomptée.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété prévue en lecture seule ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne `true` si <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe, mais publique `set` accesseur n’existe pas, comme déterminé par la réflexion interne.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pouvant être interprétée pour déterminer le XAML des représentations de système de type au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété qui a un accesseur <see langword="get" /> public.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété comportant un accesseur <see langword="get" /> public ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne des résultats basés sur une réflexion interne ou la négation de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, dans cet ordre.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Indique si le membre lui-même est public ; elle retourne `true` pour un membre public sur un type déclarant de nonpublic. Utilisez <xref:System.Xaml.XamlMember.IsReadPublic%2A> à la place, si vous souhaitez également la visibilité du type déclarant.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> méthode est virtuelle et par conséquent, peut être remplacée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations de l’accès de système de type de sa déclaration CLR sous-jacente. Pour toutes les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre qui ne peut pas être résolu par le système de stockage utilisé pour la résolution du type et du membre.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre qui ne peut pas être résolu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsUnknown%2A>. L’implémentation par défaut retourne des résultats qui sont basés sur la réflexion interne ou sur la recherche pour un `null` valeur <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, dans cet ordre.  
  
 Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre comportant un accesseur <see langword="set" /> public mais pas d'accesseur <see langword="get" /> public.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en écriture seule ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne `true` si un <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe qui a un public `set` accesseur et un nonpublic `get` accesseur, comme déterminé par la réflexion interne.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre comportant un accesseur <see langword="set" /> public.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre accessible en écriture ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne des résultats basés sur la réflexion interne ou la négation de <xref:System.Xaml.XamlMember.IsReadOnly%2A>, dans cet ordre.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> méthode est virtuelle et par conséquent, peut être remplacée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations de l’accès de système de type de sa déclaration CLR sous-jacente. Pour toutes les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le crochet ouvrant et le crochet fermant d’une extension de balisage.</summary>
        <returns>Collection contenant le crochet ouvrant et le crochet fermant.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Xaml.XamlType" /> du type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</summary>
        <returns>Type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut fait la distinction entre les membres pouvant être attachés et non-pouvant être attachée. Pour les membres non attachables, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retourne toujours <xref:System.Xaml.XamlMember.DeclaringType%2A>. Pour les membres pouvant être attachés, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retourne un résultat basé sur l’examen de la <xref:System.Xaml.XamlMember.UnderlyingMember%2A> type de paramètre d’accesseur et interprète ce type basé sur le contexte de schéma XAML.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.TargetType%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.Type%2A>. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlMember.Type%2A> pour retourner une valeur différente de celle qui est activée par la réflexion interne de la valeur par défaut, et si vous fournissez également personnalisé <xref:System.Xaml.Schema.XamlMemberInvoker> plus d’informations.  
  
 L’implémentation par défaut utilise différents chemins de code et concepts pour retourné <xref:System.Xaml.XamlType> qui repose sur le fait que cela <xref:System.Xaml.XamlMember> représente une propriété, une méthode ou un événement.  
  
-   Pour une propriété, retournée <xref:System.Xaml.XamlType> est le type qui définit la propriété ou est retourné par la propriété.  
  
-   Pour un événement, retourné <xref:System.Xaml.XamlType> est le type de gestionnaire d’événements requis (délégué dans une implémentation CLR).  
  
-   Pour une méthode, <xref:System.Xaml.XamlType> est le type de retour.  
  
 Dans chaque cas, le contexte de schéma XAML est utilisé pour évaluer le type XAML à partir du type de système sous-jacent.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.Type%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une implémentation de convertisseur de type qui est associée à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Instance de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.ComponentModel.TypeConverter" />, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut utilise la logique suivante et l’ordre de traitement :  
  
-   Si l’attribution existe au niveau du membre (<xref:System.ComponentModel.TypeConverterAttribute>), les informations d’attribut sont utilisées pour un appel à <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> par rapport au contexte de schéma XAML.  
  
-   Si <xref:System.Xaml.XamlMember.Type%2A> est valide, un convertisseur de type qui est associé au type est retourné.  
  
-   Si le membre est un événement, un convertisseur de type spécifique à l’événement est retourné.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.TypeConverter%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un accesseur <see langword="get" /> associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> pour l'accesseur <see langword="get" /> associé , sinon <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut interprète la <xref:System.Xaml.XamlMember.UnderlyingMember%2A> propriété en tant que <xref:System.Reflection.PropertyInfo> et retourne la valeur de <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (avec le paramètre défini sur `true`), ce qui signifie que la méthode retournée peut être non publique. Ce comportement peut provoquer des `null` dans certains cas. y compris les cas où aucun accesseur associé n’existe ou le membre n’est pas une propriété.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de la <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> propriété associé à un <xref:System.Xaml.Schema.XamlMemberInvoker>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas. Veillez à implémenter <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, et <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> afin que tous les retournent des résultats mis en corrélation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Reflection.MemberInfo" /> de système de type CLR associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Objet <see cref="T:System.Reflection.MemberInfo" /> de système de type CLR associé à ce <see cref="T:System.Xaml.XamlMember" /> ; sinon <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne les informations de membre sous-jacent, qui sont basées sur la construction. Si le <xref:System.Reflection.MemberInfo> objet est construit avec une signature qui ne fournit pas suffisamment d’informations pour définir le membre sous-jacent, cette méthode retourne `null`.  
  
 Si un membre sous-jacent a été défini pendant la construction, vous ne devez pas appeler cette méthode.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas. Veillez à implémenter <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, et <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> afin que tous les retournent des résultats mis en corrélation.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un accesseur <see langword="set" /> associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> pour l'accesseur <see langword="set" /> associé , sinon <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut interprète <xref:System.Xaml.XamlMember.UnderlyingMember%2A> en tant que <xref:System.Reflection.PropertyInfo> et retourne la valeur de <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (avec le paramètre défini sur `true`), ce qui signifie que la méthode retournée peut être non publique. Cela peut entraîner de `null` pour certains cas, notamment s’il n’existe pas d’accesseur, ou le membre n’est pas une propriété.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> sur associé à un <xref:System.Xaml.Schema.XamlMemberInvoker>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas. Veillez à implémenter <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, et <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> afin que tous les retournent des résultats mis en corrélation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une implémentation du sérialiseur de valeur associée à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Instance de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.Windows.Markup.ValueSerializer" />, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut utilise la logique suivante et l’ordre de traitement :  
  
-   Si l’attribution existe au niveau du membre (<xref:System.Windows.Markup.ValueSerializerAttribute>), les informations d’attribut sont utilisées pour un appel à <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> par rapport au contexte de schéma XAML.  
  
-   Si <xref:System.Xaml.XamlMember.Type%2A> est valide, un convertisseur de valeur qui est associé au type est retourné.  
  
-   Si les conditions précédentes ne s’appliquent pas, `null` est retourné.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit le crochet ouvrant et le crochet fermant d’une extension de balisage.</summary>
        <value>Collection contenant le crochet ouvrant et le crochet fermant.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la chaîne de nom <see langword="xamlName" /> qui déclare ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Chaîne de nom <see langword="xamlName" /> qui déclare ce <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est toujours définie pendant la construction. Les constructeurs sont implémentées par <xref:System.Xaml.XamlMember> généralement lève une exception si un nom initial n’est pas spécifié ; par conséquent, attendez-vous à cette propriété doit être `null` ou une chaîne vide, si vous utilisez des Services XAML .NET Framework par défaut implémentations.  
  
 [XamlName, grammaire](~/docs/framework/xaml-services/xamlname-grammar.md) et des règles d’affectation de noms pour le type CLR et les membres ne sont pas des intersections exactes. Il est possible de déclarer un nom de membre qui est valide sous le CLR mais pas valide sous désignation XAML. Vous devez éviter cette situation si possible.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.Xaml.XamlMember" /> spécifiés ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="xamlMember1" /> est égale à la valeur de <paramref name="xamlMember2" /> ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.Xaml.XamlMember" /> spécifiés ont des valeurs différentes.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="xamlMember1" /> est différente de la valeur de <paramref name="xamlMember2" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URI d'espace de noms XAML qui identifie l'espace de noms XAML principal de ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Identificateur pour l'espace de noms XAML principal de ce <see cref="T:System.Xaml.XamlMember" />, sous forme de chaîne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> propriété fournit la même valeur que l’appel <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> et l’obtention de la première chaîne de valeur de la liste retournée. L’espace de noms XAML par défaut doit être utilisé lors de l’écriture du membre dans le texte ou autres représentations qui conservent les informations d’espace de noms XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> qui indique comment un concepteur visuel doit traiter le membre.</summary>
        <value>Valeur de l'énumération <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />. La valeur par défaut est <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</summary>
        <value>Type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée est différente pour les membres pouvant être attachés et non-pouvant être attachée. Pour les membres non attachables, <xref:System.Xaml.XamlMember.TargetType%2A> retourne <xref:System.Xaml.XamlMember.DeclaringType%2A>. Pour les membres pouvant être attachés, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retourne un résultat qui est basé sur cette logique :  
  
-   Si la réflexion ne peut pas résoudre un stockage (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), cette méthode retourne une constante interne qui représente un type d’objet générique.  
  
-   Si la condition précédente ne s’applique pas, <xref:System.Xaml.XamlMember.LookupTargetType%2A> est appelée. L’implémentation par défaut retourne un <xref:System.Xaml.XamlType> basé sur l’examen des méthodes qui implémentent le `get` et `set` accesseurs. Une classe peut substituer <xref:System.Xaml.XamlMember.LookupTargetType%2A> à utiliser un comportement différent tel que d’autres formes de métadonnées qui peut-être signaler des types de cibles pour les membres pouvant être attachés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une représentation sous forme de chaîne de <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Représentation sous forme de chaîne de <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation retourne <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.Type%2A> appelle <xref:System.Xaml.XamlMember.LookupType%2A> ou une substitution spécifique de cette méthode. Cela se produit lorsque la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Dans le comportement par défaut (aucun <xref:System.Xaml.XamlMember.LookupType%2A> remplacer), retourné <xref:System.Xaml.XamlType> peut avoir des significations conceptuelles différentes. Signification dépend de si cela <xref:System.Xaml.XamlMember> représente une propriété, une méthode ou un événement, comme le montre la liste suivante :  
  
-   Pour une propriété, retournée <xref:System.Xaml.XamlType> est le type qui définit la propriété ou est retourné par la propriété.  
  
-   Pour un événement, retourné <xref:System.Xaml.XamlType> est le type de gestionnaire d’événements requis (délégué dans une implémentation CLR).  
  
-   Pour une méthode, <xref:System.Xaml.XamlType> est le type de retour de cette méthode, qui peut être `null`.  
  
 Dans chaque cas, le contexte de schéma XAML est utilisé pour évaluer le type XAML à partir du type de stockage.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, qui peut être utilisé pour la construction de conversion de type des objets XAML déclarés.</summary>
        <value>Valeur <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.ComponentModel.TypeConverter" /> sur le générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.TypeConverter%2A> appelle <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit lorsque la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 La valeur pour les implémentations qui retournent une propriété non null <xref:System.Xaml.XamlMember.TypeConverter%2A> ne sont pas nécessairement un <xref:System.ComponentModel.TypeConverter>. Voici une liste de valeurs de retour non null possibles pour <xref:System.Xaml.XamlMember.TypeConverter%2A> et ce que ces valeurs représentent :  
  
-   La valeur de retour signale un convertisseur de type qui est attribué spécifiquement à ce membre, ou plus généralement au type cible du convertisseur. Ce comportement est généralement quelles la plupart des systèmes de type XAML et les processeurs XAML recherchent pour instancier un convertisseur de type et appeler ses méthodes.  
  
-   La valeur de retour signale un convertisseur de valeurs intégrés. Ces convertisseurs existent pour certaines opérations internes qui sont effectuées par un writer XAML. En particulier, ces convertisseurs de valeurs intégrés convertissent les valeurs de chaîne brute d’attribut pour les primitives de langage XAML. Pour l’implémentation de Services XAML .NET Framework, ces conversions de type intégré renvoient souvent à un convertisseur de type qui est défini dans l’assembly système. Par exemple, une conversion pour un <xref:System.Int32> valeur intègre transféré de conversion et par conséquent, le <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> valeur références <xref:System.ComponentModel.Int32Converter>.  
  
-   La valeur de retour signale le cas spécial d’un modèle d’objet sans contrainte ; Autrement dit, le <xref:System.Xaml.XamlMember> a un <xref:System.Xaml.XamlMember.Type%2A> valeur <xref:System.Object>. Dans ce cas, le <xref:System.Xaml.Schema.XamlValueConverter%601> indique que le <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> est {`Object}`. Toutefois, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> est `null` , car aucun type ou une instance n’est disponible pour effectuer cette conversion. Au lieu de cela, le comportement du modèle objet ne peut pas être déterminé jusqu'à l’exécution, lorsque l’exécution de la technologie spécifique détermine la gestion de son graphique d’objet.  
  
 Si vous pouvez accéder à une travail <xref:System.ComponentModel.TypeConverter> de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, vous pouvez appeler ses méthodes de conversion. Toutefois, de nombreuses méthodes de conversion s’appuient sur le contexte de service. Si vous n’avez pas le même contexte de service disponible que le convertisseur de type attend pour son rôle typique d’écriture d’objets pour les graphiques d’objets, les méthodes du convertisseur peuvent lever des exceptions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Reflection.MemberInfo" /> du système de type CLR qui est disponible pour un membre construit par <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> ou <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Informations <see cref="T:System.Reflection.MemberInfo" /> du système de type CLR utilisées pour le transtypage à partir des paramètres du constructeur initial. Un<see cref="T:System.Xaml.XamlMember" /> construit avec la signature <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> retourne <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.UnderlyingMember%2A> appelle <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> utilisé pour la sérialisation de valeur des objets XAML déclarés.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Windows.Markup.ValueSerializer" /> sur le générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de <xref:System.Xaml.XamlMember.ValueSerializer%2A> appelle <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit lorsque la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Valeur de pas tous les cas qui retournent une propriété non null pour <xref:System.Xaml.XamlMember.ValueSerializer%2A> sont nécessairement un <xref:System.Windows.Markup.ValueSerializer>. Consultez <xref:System.Xaml.XamlMember.TypeConverter%2A>; les mêmes considérations s’appliquent à <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>