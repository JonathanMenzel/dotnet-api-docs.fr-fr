<Type Name="XamlSchemaContext" FullName="System.Xaml.XamlSchemaContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="30dfd7e6872cbf5555a5fecd6d6b0694782c7865" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52251647" /></Metadata><TypeSignature Language="C#" Value="public class XamlSchemaContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlSchemaContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlSchemaContext" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlSchemaContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlSchemaContext" />
  <TypeSignature Language="F#" Value="type XamlSchemaContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Définit un contexte réutilisable pour l'interprétation ou le mappage des types XAML, ainsi que des types sous-jacents dans les assemblys.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contexte de schéma XAML fournit une couche d’abstraction entre un schéma ou de vocabulaire pour XAML et d’une implémentation d’analyseur spécifique. En insérant le concept d’un contexte de schéma, le schéma peut être utilisé avec différents analyseurs XAML et le contexte de schéma complète les informations qui sont nécessaires pour interagir avec un analyseur XAML spécifique. Par exemple, le contexte de schéma XAML fournit des API qui se rapportent à des concepts XAML ou à la liaison de CLR pour le système de type XAML de requête. Le contexte de schéma XAML est également chargé de gérer la liste des assemblys chargés, qui définit l’emplacement où un analyseur XAML recherche des types de stockage.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Dans un <see cref="T:System.AppDomain" />, un <see cref="T:System.Xaml.XamlSchemaContext" /> peuvent être partagées entre plusieurs appelants totale et les appelants de confiance partielle. Cette situation existe dans les infrastructures telles que WPF, qui fournissent des accès en confiance partielle à XAML du chargement pour les parties du modèle d’application WPF. La valeur par défaut <see cref="T:System.Xaml.XamlSchemaContext" /> implémentation fournit des dispositifs de protection dans ce scénario en conservant toutes ses propriétés et paramètres immuable. Les implémentations dérivées doivent envisager de suivre également ce modèle d’immuabilité pour les propriétés et les paramètres d’un contexte de schéma XAML.  
  
Le <see cref="T:System.Xaml.XamlSchemaContext" /> classe de base est conçue afin que les recherches n’aient pas d’effets observables de manière externe. Les types qui sont référencés par <see cref="T:System.Xaml.XamlSchemaContext" /> API dans la base de classe, telle que <see cref="T:System.Xaml.XamlType" /> ou <see cref="T:System.Xaml.XamlMember" />, également ne produire aucun effet secondaire à partir de recherches. Toutes les données qui sont nécessaire pour effectuer une détermination du schéma doivent être disponibles à partir de la construction et les paramètres de la <see cref="T:System.AppDomain" />. Notez qu’aucune API de recherche s’appuient sur les services explicitement passés ; leur entrée s’appuie sur la chaîne d’entrée uniquement.  
  
Le <see cref="T:System.Xaml.XamlSchemaContext" /> classe de base et <see cref="T:System.Xaml.XamlType" /> et <see cref="T:System.Xaml.XamlMember" /> sont tous thread-safe dans leurs implémentations de base. Si vous dérivez de <see cref="T:System.Xaml.XamlSchemaContext" /> ou dériver des classes de système de type XAML tel que <see cref="T:System.Xaml.XamlType" /> et <see cref="T:System.Xaml.XamlMember" /> , vous pouvez choisir si vos classes doivent se comporter comme thread-safe.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext referenceAssemblies" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Jeu énumérable d'éléments d'informations sur l'assembly. Chaque élément d'informations de l'assembly est spécifié par une valeur <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlSchemaContext" /> en fonction d'un jeu d'assemblys de référence.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Objet de paramètres à utiliser pour construire le <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlSchemaContext" /> en fonction d'un objet de paramètres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet de paramètres stocke des informations sur le convertisseur de texte et les caractéristiques d’extension de balisage pour le contexte de schéma. Pour plus d'informations, consultez <xref:System.Xaml.XamlSchemaContextSettings>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies, System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies, class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly), settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies, System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; * System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext (referenceAssemblies, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Jeu énumérable d'informations sur l'assembly. Chaque élément d'informations de l'assembly est spécifié par une valeur <see cref="T:System.Reflection.Assembly" />.</param>
        <param name="settings">Objet de paramètres à utiliser pour construire le <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlSchemaContext" /> en fonction d'un jeu d'assemblys de référence et d'un objet de paramètres.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!XamlSchemaContext ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="xamlSchemaContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit une implémentation <see langword="Finalize" /> non standard qui n'appelle pas <see langword="Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contextes de schéma XAML ne doivent pas être supprimés par le garbage collection automatique ou par des opérations manuelles. Bien que les contextes de schéma XAML n’aient aucune ressource non managée, <xref:System.Windows.Markup.XamlDeferLoadAttribute> propriétés peuvent être toujours actives, et suppression d’un contexte de schéma XAML peut interférer avec l’opération de chargement différé associée.  
  
 <xref:System.AppDomain.AssemblyLoad> des gestionnaires d’événements sont accrochés en interne comme références faibles, sont nettoyés par cette implémentation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifyAssemblyNamesInClrNamespaces">
      <MemberSignature Language="C#" Value="public bool FullyQualifyAssemblyNamesInClrNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullyQualifyAssemblyNamesInClrNamespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FullyQualifyAssemblyNamesInClrNamespaces { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifyAssemblyNamesInClrNamespaces : bool" Usage="System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si un schéma XAML et son contexte utilisent des noms d'assembly qualifiés complets dans les valeurs qui sont retournées par l'API de recherche.</summary>
        <value><see langword="true" /> si un schéma XAML et son contexte utilisent des noms d'assembly qualifiés complets dans les valeurs qui sont retournées par les API de recherche ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne le <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> valeur qui est établie dans les paramètres pour le <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> signature de constructeur. Si d’autres signatures ont été utilisés pour la construction ou si <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> n’a pas la valeur `true`, la valeur de cette propriété est `false`.  
  
 La valeur de cette propriété influence les chaînes qui sont retournées par <xref:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces%2A>. Si <xref:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces%2A> est `true`, la partie de l’assembly de la chaîne signale l’équivalent de <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetAllXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetAllXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlNamespaces () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetAllXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;&#xA;override this.GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;" Usage="xamlSchemaContext.GetAllXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recherche les assemblys qui sont détenus par ce <see cref="T:System.Xaml.XamlSchemaContext" /> et retourne un jeu d'espaces de noms.</summary>
        <returns>Jeu énumérable d'identificateurs d'espace de noms. Ces identificateurs sont fournis sous forme de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche uniquement les assemblys de référence s’ils sont passés dans via le paramètre de construction ou de propriété. Si aucun assembly n’est établi en tant qu’assemblys de référence, la logique de cette méthode examine tous les assemblys chargés où cela <xref:System.Xaml.XamlSchemaContext> est actif.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt; GetAllXamlTypes (string xamlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlType&gt; GetAllXamlTypes(string xamlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlTypes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlTypes (xamlNamespace As String) As ICollection(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::ICollection&lt;System::Xaml::XamlType ^&gt; ^ GetAllXamlTypes(System::String ^ xamlNamespace);" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;&#xA;override this.GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;" Usage="xamlSchemaContext.GetAllXamlTypes xamlNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Espace de noms XAML pour lequel retourner les types.</param>
        <summary>Recherche les assemblys qui sont détenus par ce <see cref="T:System.Xaml.XamlSchemaContext" /> et retourne un jeu de types à partir de l'espace de noms XAML spécifié.</summary>
        <returns>Jeu énumérable de types XAML. Chaque type XAML du jeu est représenté par un objet <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetPreferredPrefix (string xmlns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPreferredPrefix(string xmlns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetPreferredPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredPrefix (xmlns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPreferredPrefix(System::String ^ xmlns);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredPrefix : string -&gt; string&#xA;override this.GetPreferredPrefix : string -&gt; string" Usage="xamlSchemaContext.GetPreferredPrefix xmlns" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlns">Espace de noms XAML pour lequel obtenir le préfixe préféré.</param>
        <summary>Obtient une chaîne signalée comme préfixe préféré à utiliser par les consommateurs lorsqu'ils mappent l'espace de noms XAML spécifié.</summary>
        <returns>Chaîne que les consommateurs doivent utiliser lorsqu'ils mappent l'espace de noms XAML spécifié pour l'utilisation de balises.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le consommateur le plus immédiat des informations est généralement un writer XAML. D’autres consommateurs indirects incluent des outils de conception.  
  
 Dans le cadre de la liaison XAML pour le common language runtime (CLR), vous pouvez spécifier ces informations en appliquant <xref:System.Windows.Markup.XmlnsPrefixAttribute> au niveau de l’assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlns" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter&lt;TConverterBase&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt; GetValueConverter&lt;TConverterBase&gt; (Type converterType, System.Xaml.XamlType targetType) where TConverterBase : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Xaml.Schema.XamlValueConverter`1&lt;!!TConverterBase&gt; GetValueConverter&lt;class TConverterBase&gt;(class System.Type converterType, class System.Xaml.XamlType targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetValueConverter``1(System.Type,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueConverter(Of TConverterBase As Class) (converterType As Type, targetType As XamlType) As XamlValueConverter(Of TConverterBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TConverterBase&gt;&#xA; where TConverterBase : class System::Xaml::Schema::XamlValueConverter&lt;TConverterBase&gt; ^ GetValueConverter(Type ^ converterType, System::Xaml::XamlType ^ targetType);" />
      <MemberSignature Language="F#" Value="member this.GetValueConverter : Type * System.Xaml.XamlType -&gt; System.Xaml.Schema.XamlValueConverter&lt;'ConverterBase (requires 'ConverterBase : null)&gt; (requires 'ConverterBase : null)" Usage="xamlSchemaContext.GetValueConverter (converterType, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TConverterBase">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <typeparam name="TConverterBase">Classe de base du convertisseur spécifique.</typeparam>
        <param name="converterType">Implémentation du convertisseur.</param>
        <param name="targetType">Type de destination souhaité pour le convertisseur.</param>
        <summary>Retourne un convertisseur de valeurs qui peut effectuer une conversion dans le <paramref name="targetType" /> demandé.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> comportant une contrainte qui correspond à la contrainte mise sur l'appel de méthode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlDirective">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlDirective GetXamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlDirective GetXamlDirective(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlDirective(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlDirective (xamlNamespace As String, name As String) As XamlDirective" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlDirective ^ GetXamlDirective(System::String ^ xamlNamespace, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective&#xA;override this.GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective" Usage="xamlSchemaContext.GetXamlDirective (xamlNamespace, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlDirective</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Espace de noms XAML qui contient la directive nommée.</param>
        <param name="name">Nom de la directive à obtenir.</param>
        <summary>Retourne une valeur <see cref="T:System.Xaml.XamlDirective" /> qui représente une directive, pour le langage XAML ou pour une implémentation particulière.</summary>
        <returns>Objet <see cref="T:System.Xaml.XamlDirective" /> qui représente la directive demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode si vous créez une classe dérivée de <xref:System.Xaml.XamlDirective> dans le cadre d’un scénario d’extension de système de type XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlNamespace" /> ou <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXamlType">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un <see cref="T:System.Xaml.XamlType" /> qui est basé sur un identificateur de type CLR ou XAML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlType GetXamlType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : Type -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : Type -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type pour lequel obtenir un <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Retourne un <see cref="T:System.Xaml.XamlType" /> qui est basé sur un identificateur de type CLR.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> qui correspond au <paramref name="type" /> d'entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge suppose que vous utilisez le CLR pour le système de type de stockage. Si vous n’utilisez pas le système de type CLR, utilisez <xref:System.Xaml.XamlSchemaContext.GetXamlType%28System.Xaml.Schema.XamlTypeName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType GetXamlType (System.Xaml.Schema.XamlTypeName xamlTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlType GetXamlType(class System.Xaml.Schema.XamlTypeName xamlTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Xaml.Schema.XamlTypeName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlType ^ GetXamlType(System::Xaml::Schema::XamlTypeName ^ xamlTypeName);" />
      <MemberSignature Language="F#" Value="member this.GetXamlType : System.Xaml.Schema.XamlTypeName -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType xamlTypeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlTypeName" Type="System.Xaml.Schema.XamlTypeName" />
      </Parameters>
      <Docs>
        <param name="xamlTypeName">Nom de type XAML pour lequel obtenir un <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Retourne un <see cref="T:System.Xaml.XamlType" /> qui est basé sur un nom de type de système XAML.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> qui correspond au <paramref name="xamlTypeName" /> d'entrée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Un composant de <paramref name="xamlTypeName" /> (<see cref="P:System.Xaml.Schema.XamlTypeName.Name" /> ou <see cref="P:System.Xaml.Schema.XamlTypeName.Namespace" />) est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlTypeName" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Xaml.Schema.XamlTypeName" />
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xaml.XamlType GetXamlType (string xamlNamespace, string name, params System.Xaml.XamlType[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(string xamlNamespace, string name, class System.Xaml.XamlType[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.String,System.String,System.Xaml.XamlType[])" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetXamlType (xamlNamespace As String, name As String, ParamArray typeArguments As XamlType()) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(System::String ^ xamlNamespace, System::String ^ name, ... cli::array &lt;System::Xaml::XamlType ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType (xamlNamespace, name, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Xaml.XamlType[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Espace de noms XAML qui contient le type souhaité.</param>
        <param name="name">Nom de chaîne du type souhaité.</param>
        <param name="typeArguments">Arguments de type d'initialisation pour un type générique.</param>
        <summary>Retourne un <see cref="T:System.Xaml.XamlType" /> basé sur un espace de noms XAML et une chaîne de nom de type. Cette signature peut spécifier les arguments de type dans les cas où le type souhaité est un type générique.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> qui correspond aux critères d'entrée.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAssemblyResolve">
      <MemberSignature Language="C#" Value="protected internal virtual System.Reflection.Assembly OnAssemblyResolve (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Reflection.Assembly OnAssemblyResolve(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.OnAssemblyResolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function OnAssemblyResolve (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Reflection::Assembly ^ OnAssemblyResolve(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member OnAssemblyResolve : string -&gt; System.Reflection.Assembly&#xA;override this.OnAssemblyResolve : string -&gt; System.Reflection.Assembly" Usage="xamlSchemaContext.OnAssemblyResolve assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de l'assembly à charger.</param>
        <summary>Appelé lorsque les opérations utilisent ce contexte de schéma pour résoudre un assembly requis pour résoudre les espaces de noms XAML qu'il contient.</summary>
        <returns>Assembly résolu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La technique de résolution d’assembly sous-jacente, qui est une API interne, comporte des tolérances intégrées pour différents formats de chaîne d’un nom d’assembly en fonction de la <xref:System.Reflection.AssemblyName> comportement de construction.  
  
 L’objectif de cette API consiste à activer la résolution de première occurrence par rapport à des ensembles connus d’assemblys, tels que des assemblys de référence et non par rapport à un global assembly cache. Si la liste des assemblys de référence est remplie, l’implémentation par défaut peut accéder aux assemblys de référence connus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt; ReferenceAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Reflection.Assembly&gt; ReferenceAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReferenceAssemblies As IList(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ ReferenceAssemblies { System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceAssemblies : System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;" Usage="System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un jeu énumérable d'assemblys de référence pour le contexte de schéma XAML.</summary>
        <value>Jeu énumérable d'assemblys de référence pour le contexte de schéma. Chaque élément d'informations de l'assembly est spécifié par une valeur <see cref="T:System.Reflection.Assembly" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportMarkupExtensionsWithDuplicateArity">
      <MemberSignature Language="C#" Value="public bool SupportMarkupExtensionsWithDuplicateArity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportMarkupExtensionsWithDuplicateArity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportMarkupExtensionsWithDuplicateArity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportMarkupExtensionsWithDuplicateArity : bool" Usage="System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si un schéma XAML et son contexte prennent en charge les extensions de balisage qui comportent deux constructeurs avec la même arité (nombre de paramètres d'entrée).</summary>
        <value><see langword="true" /> si le contexte de schéma autorise les extensions de balisage avec arité en double ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne le <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> valeur qui est établie dans les paramètres pour le <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> signature de constructeur. Si d’autres signatures sont utilisés pour la construction ou si <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> n’a pas la valeur `true`, la valeur de cette propriété est `false`.  
  
 Arité double des extensions de balisage n’est pas spécialement adressée par la spécification XAML [MS-XAML], section 6.6.7.2. Il s’agit, car la formation de l’élément d’informations pour une extension de balisage XAML est identique quel que soit l’arité en double qui peut-être exister dans l’implémentation d’extension de balisage. Seul l’appel réel de l’extension de balisage et sa `ProvideValue` expose tous les problèmes associés à une arité en double. Comportement de gestion des arité en double est donc indéfini et est conservé jusqu'à chaque implémentation le contexte de schéma XAML et son intégration de writer XAML. Le contexte de schéma XAML par défaut telle qu’implémentée pour les opérations de Services XAML du .NET Framework ne prend pas en charge l’arité en double ; différentes API des Services XAML .NET Framework lève des exceptions lors du traitement d’extension de balisage avec arité en double sous-jacente.  
  
 Pour plus d’informations sur la définition d’extensions de balisage, consultez [Markup Extensions for XAML Overview](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetCompatibleXamlNamespace">
      <MemberSignature Language="C#" Value="public virtual bool TryGetCompatibleXamlNamespace (string xamlNamespace, out string compatibleNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetCompatibleXamlNamespace(string xamlNamespace, [out] string&amp; compatibleNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.TryGetCompatibleXamlNamespace(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetCompatibleXamlNamespace (xamlNamespace As String, ByRef compatibleNamespace As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetCompatibleXamlNamespace(System::String ^ xamlNamespace, [Runtime::InteropServices::Out] System::String ^ % compatibleNamespace);" />
      <MemberSignature Language="F#" Value="abstract member TryGetCompatibleXamlNamespace : string *  -&gt; bool&#xA;override this.TryGetCompatibleXamlNamespace : string *  -&gt; bool" Usage="xamlSchemaContext.TryGetCompatibleXamlNamespace (xamlNamespace, compatibleNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="compatibleNamespace" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Chaîne <see langword="xmlns" /> de l'espace de noms XAML pour lequel rechercher un résultat compatible.</param>
        <param name="compatibleNamespace">Cette méthode retourne la chaîne <see langword="xmlns" /> pour une demande d'espace de noms XAML compatible. Peut être identique à <paramref name="xamlNamespace" /> si la méthode retourne la valeur <see langword="false" />.</param>
        <summary>Retourne des informations indiquant la réussite ou l'échec d'une demande d'espace de noms XAML compatible. Une demande réussie signale cet espace de noms XAML en tant que paramètre de sortie.</summary>
        <returns><see langword="true" /> si <paramref name="compatibleNamespace" /> contient un résultat utilisable ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En interne, cette méthode utilise l’ordre de recherche suivant :  
  
1.  Un dictionnaire de compatibilité implémenté en interne, ce qui peut avoir été rempli par une recherche antérieure.  
  
2.  Le <xref:System.Windows.Markup.XmlnsCompatibleWithAttribute> évaluation du paramètre.  
  
 Si aucun autre espace de noms compatible n’est découvert et cette méthode retourne `false`, le `compatibleNamespace` sortie de paramètre peut avoir la même valeur que le `xamlNamespace` d’entrée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlNamespace" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>