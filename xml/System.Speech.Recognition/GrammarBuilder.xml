<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b9acf95eaa6f22da284f0c7784b2bb67c022774" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51893035" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit un mécanisme pour la génération par programmation des contraintes d'une syntaxe de reconnaissance vocale.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Syntaxe de reconnaissance vocale est généralement créés dans le format XML défini par le [Speech Recognition Grammar Specification (SRGS) Version 1.0](https://go.microsoft.com/fwlink/?LinkId=201761). Si vous êtes familiarisé avec SRGS mais qui souhaitent générer des grammaires par programme, vous pouvez utiliser le <xref:System.Speech.Recognition.SrgsGrammar> espace de noms, dont les membres correspondent étroitement aux éléments et attributs définis par SRGS. Si vous n’êtes pas familiarisé avec SRGS ou si vous souhaitez une approche légère et par programmation à la création de grammaires avec laquelle vous pouvez effectuer efficacement les nombreux scénarios courants ; Vous pouvez utiliser la <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> classes.  
  
 Utilisez <xref:System.Speech.Recognition.GrammarBuilder> composé d’objets pour générer une arborescence hiérarchique de <xref:System.Speech.Recognition.Choices> objets qui contiennent des expressions autre entrecoupé de préambule et d’expressions de post-amble sur chaque nœud et amorcée avec des valeurs sémantiques qui communiquent la signification du application.  
  
 Pour utiliser un <xref:System.Speech.Recognition.GrammarBuilder> pour créer un <xref:System.Speech.Recognition.Grammar> d’objet, procédez comme suit.  
  
1.  Créez un objet <xref:System.Speech.Recognition.GrammarBuilder>.  
  
2.  Ajouter des contraintes à la <xref:System.Speech.Recognition.GrammarBuilder>, tel que <xref:System.String> objets, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>et d’autres <xref:System.Speech.Recognition.GrammarBuilder> objets qui définissent les contraintes de la grammaire.  
  
3.  Utilisez une de la <xref:System.Speech.Recognition.Grammar.%23ctor%2A> constructeurs pour créer un <xref:System.Speech.Recognition.Grammar> objet à partir de la fin <xref:System.Speech.Recognition.GrammarBuilder> grammaire.  
  
 Création avec <xref:System.Speech.Recognition.GrammarBuilder> est optimale pour les grammaires qui ont une seule règle contenant des listes, ou peut-être les listes de listes. Pour générer par programmation les grammaires qui ont plusieurs règles, ou qui ont besoin de créer des références de règle interne, utilisez les classes de le <xref:System.Speech.Recognition.SrgsGrammar> espace de noms.  
  
 Instances de <xref:System.Speech.Recognition.GrammarBuilder> peut également être obtenu par les conversions implicites à partir de certaines autres classes ou en combinant un <xref:System.Speech.Recognition.GrammarBuilder> avec un second objet qui contient des contraintes pour une grammaire... Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs et le <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> méthodes.  
  
 Pour ajouter des règles à un existant <xref:System.Speech.Recognition.GrammarBuilder>, utilisez le <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, et <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> méthodes.  
  
> [!IMPORTANT]
>  Le module de reconnaissance vocale peut lever une exception lors de l’utilisation d’une syntaxe de reconnaissance vocale qui contient les éléments sémantiques en double portant le même nom de clé ou plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises de la valeur du même élément sémantique. 
  
 Pour faciliter le débogage, le <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> propriété retourne l’état actuel de la <xref:System.Speech.Recognition.GrammarBuilder> sous forme de chaîne.  
  
 Pour plus d’informations sur la création et à l’aide de la syntaxe de reconnaissance vocale, consultez [la reconnaissance vocale](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) et [création de grammaires de GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets pour construire une grammaire qui puisse reconnaître une des deux expressions, « faire arrière-plan *colorChoice*» ou « en arrière-plan la valeur *colorChoice*".  
  
 L’exemple utilise un <xref:System.Speech.Recognition.Choices> objet pour créer une liste de valeurs acceptables pour *colorChoice* à partir d’un tableau de <xref:System.String> objets. Un <xref:System.Speech.Recognition.Choices> objet est analogue à la `one-of` élément dans la spécification SRGS et contient un ensemble d’autres expressions, qui peut être reconnu lors de la lecture. L’exemple utilise également un <xref:System.Speech.Recognition.Choices> objet pour regrouper un tableau de deux <xref:System.Speech.Recognition.GrammarBuilder> des objets dans une paire d’expressions autres que la grammaire résultante peut reconnaître. Autres mots ou expressions sont un composant de la plupart des grammaires et le <xref:System.Speech.Recognition.Choices> objet fournit cette fonctionnalité pour les grammaires construit avec <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 L’exemple enfin crée un <xref:System.Speech.Recognition.Grammar> de l’objet à partir d’un <xref:System.Speech.Recognition.GrammarBuilder> construit à partir d’un <xref:System.Speech.Recognition.Choices> objet.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instances de cette classe peuvent également être obtenus par les conversions implicites à partir d’autres classes ou en combinant un <xref:System.Speech.Recognition.GrammarBuilder> objet avec un deuxième objet à partir d’un nouveau <xref:System.Speech.Recognition.GrammarBuilder>. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> méthodes.  
  
 Pour ajouter des contraintes à un existant <xref:System.Speech.Recognition.GrammarBuilder>, utilisez le <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, et <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> méthodes et le <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateur.  
  
> [!IMPORTANT]
>  Le module de reconnaissance vocale peut lever une exception lors de l’utilisation d’une syntaxe de reconnaissance vocale qui contient les éléments sémantiques en double portant le même nom de clé ou plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises de la valeur du même élément sémantique.
  
 Pour plus d’informations sur la création et à l’aide de la syntaxe de reconnaissance vocale, consultez [la reconnaissance vocale](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) et [création de grammaires de GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance vide de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour ajouter des règles à un existant <xref:System.Speech.Recognition.GrammarBuilder> de l’objet, utilisez le <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, et <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> méthodes et le <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateur.  
  
> [!IMPORTANT]
>  Le module de reconnaissance vocale peut lever une exception lors de l’utilisation d’une syntaxe de reconnaissance vocale qui contient les éléments sémantiques en double portant le même nom de clé ou plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises de la valeur du même élément sémantique.
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets pour construire une grammaire qui puisse reconnaître une des deux expressions, « faire arrière-plan *colorChoice*» ou « en arrière-plan la valeur *colorChoice*".  
  
 L’exemple utilise un <xref:System.Speech.Recognition.Choices> objet pour créer une liste de valeurs acceptables pour *colorChoice* à partir d’un tableau de <xref:System.String> objets. Un <xref:System.Speech.Recognition.Choices> objet est analogue à la `one-of` élément dans la spécification SRGS et contient un ensemble d’autres expressions, chacun d'entre eux peut être reconnu lors de la lecture. L’exemple utilise également un <xref:System.Speech.Recognition.Choices> objet pour regrouper un tableau de deux <xref:System.Speech.Recognition.GrammarBuilder> des objets dans une paire d’expressions autres que la grammaire résultante peut reconnaître. Autres mots ou expressions sont un composant de la plupart des grammaires et le <xref:System.Speech.Recognition.Choices> objet fournit cette fonctionnalité pour les grammaires construit avec <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 L’exemple enfin crée un <xref:System.Speech.Recognition.Grammar> de l’objet à partir d’un <xref:System.Speech.Recognition.GrammarBuilder> construit à partir d’un <xref:System.Speech.Recognition.Choices> objet.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Jeu d'alternatives.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> à partir d'un ensemble de solutions de remplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la création d’une grammaire de reconnaissance vocale qui contient des alternatives, consultez [à l’aide de choix pour créer une syntaxe de GrammarBuilder](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets pour construire une grammaire qui puisse reconnaître une des deux expressions, « faire arrière-plan *colorChoice*» ou « en arrière-plan la valeur *colorChoice*".  
  
 L’exemple utilise un <xref:System.Speech.Recognition.Choices> objet pour créer une liste de valeurs acceptables pour *colorChoice* à partir d’un tableau de <xref:System.String> objets. Un <xref:System.Speech.Recognition.Choices> objet est analogue à la `one-of` élément dans la spécification SRGS et contient un ensemble d’autres expressions, qui peut être reconnu lors de la lecture. L’exemple utilise également un <xref:System.Speech.Recognition.Choices> objet pour regrouper un tableau de deux <xref:System.Speech.Recognition.GrammarBuilder> des objets dans une paire d’expressions autres que la grammaire résultante peut reconnaître. Autres mots ou expressions sont un composant de la plupart des grammaires et le <xref:System.Speech.Recognition.Choices> objet fournit cette fonctionnalité pour les grammaires construit avec <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 L’exemple enfin crée un <xref:System.Speech.Recognition.Grammar> de l’objet à partir d’un <xref:System.Speech.Recognition.GrammarBuilder> construit à partir d’un <xref:System.Speech.Recognition.Choices> objet.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé sémantique.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> à partir d'une clé sémantique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous créez un <xref:System.Speech.Recognition.GrammarBuilder> de l’instance à partir d’un <xref:System.Speech.Recognition.SemanticResultValue> de l’objet, vous ajoutez des informations sémantiques à la grammaire qui peut être retournée dans le résultat de la reconnaissance. Vous pouvez accéder aux informations sémantiques dans le résultat de reconnaissance à l’aide de la <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> propriété de <xref:System.Speech.Recognition.RecognizedPhrase>, qui est disponible dans le gestionnaire pour le `SpeechRecognized` événement. Si le <xref:System.Speech.Recognition.GrammarBuilder> définit un <xref:System.Speech.Recognition.SemanticResultKey>, cela peut être utilisé pour récupérer les informations de sémantique dans un résultat de reconnaissance qui est associé à la clé. Consultez l’exemple de <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>et également voir <xref:System.Speech.Recognition.SemanticResultValue> et <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Lorsque vous construisez <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. 
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *colorChoice*» et « en arrière-plan la valeur *colorChoice*», où  *colorChoice* est sélectionné à partir d’un jeu de couleurs. La grammaire permet à un utilisateur de parler de plusieurs noms de couleur et retourne des informations sémantiques sur le nom de couleur reconnu à l’application.  
  
 L’exemple utilise un seul <xref:System.Speech.Recognition.SemanticResultKey> avec lequel vous pouvez récupérer le <xref:System.Speech.Recognition.SemanticValue> qui est associé à la couleur parlée par l’utilisateur. Par exemple, si l’entrée contient la phrase, « Jeu arrière-plan rouge », le résultat de la reconnaissance contient la valeur sémantique de « #ff0000 », que vous pouvez récupérer à l’aide d’un gestionnaire pour le `SpeechRecognized` événement.  
  
 L’exemple utilise <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, et <xref:System.Speech.Recognition.GrammarBuilder> objets pour générer les contraintes qui sont toutes contenues dans la dernière <xref:System.Speech.Recognition.GrammarBuilder> objet, `bothPhrases`. Enfin, l’exemple construit un <xref:System.Speech.Recognition.Grammar> objet à partir de la fin <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Valeur ou paire nom/valeur sémantique.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> à partir d'une valeur sémantique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous créez un <xref:System.Speech.Recognition.GrammarBuilder> de l’instance à partir d’un <xref:System.Speech.Recognition.SemanticResultValue> de l’objet, vous ajoutez des informations sémantiques à la grammaire qui peut être retournée dans le résultat de la reconnaissance. Vous pouvez accéder aux informations sémantiques dans le résultat de reconnaissance à l’aide de la <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> propriété de <xref:System.Speech.Recognition.RecognizedPhrase>, qui est disponible dans le gestionnaire pour le `SpeechRecognized` événement. Si le <xref:System.Speech.Recognition.GrammarBuilder> définit un <xref:System.Speech.Recognition.SemanticResultKey>, cela peut être utilisé pour récupérer les informations de sémantique dans un résultat de reconnaissance qui est associé à la clé. Consultez l’exemple de <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>et également voir <xref:System.Speech.Recognition.SemanticResultValue> et <xref:System.Speech.Recognition.SemanticResultKey>.  
  
> [!IMPORTANT]
>  Lorsque vous construisez <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. 
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *colorChoice*» et « en arrière-plan la valeur *colorChoice*», où  *colorChoice* est sélectionné à partir d’un jeu de couleurs. La grammaire permet à un utilisateur de parler de plusieurs noms de couleur et retourne des informations sémantiques sur le nom de couleur reconnu à l’application.  
  
 L’exemple utilise un seul <xref:System.Speech.Recognition.SemanticResultKey> avec lequel vous pouvez récupérer le <xref:System.Speech.Recognition.SemanticValue> qui est associé à la couleur parlée par l’utilisateur. Par exemple, si l’entrée contient la phrase, « Jeu arrière-plan rouge », le résultat de la reconnaissance contient la valeur sémantique de « #ff0000 », que vous pouvez récupérer à l’aide d’un gestionnaire pour le `SpeechRecognized` événement.  
  
 L’exemple utilise <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, et <xref:System.Speech.Recognition.GrammarBuilder> objets pour générer les contraintes qui sont toutes contenues dans la dernière <xref:System.Speech.Recognition.GrammarBuilder> objet, `bothPhrases`. Enfin, l’exemple construit un <xref:System.Speech.Recognition.Grammar> objet à partir de la fin <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Séquence de mots.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> à partir d'une suite de mots.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’expression représente une expression parlée exacte que la grammaire de reconnaissance vocale peut reconnaître. Pour plus d’informations sur la création d’une grammaire de reconnaissance vocale qui contient des chaînes, consultez [l’utilisation de chaînes pour créer une syntaxe de GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets pour construire une grammaire qui puisse reconnaître une des deux expressions, « faire arrière-plan *colorChoice*» ou « en arrière-plan la valeur *colorChoice*".  
  
 Après avoir créé une liste de valeurs acceptables pour *colorChoice* à l’aide un <xref:System.Speech.Recognition.Choices> de l’objet, l’exemple initialise deux <xref:System.Speech.Recognition.GrammarBuilder> objets, `makePhrase` et `setPhrase`, à l’aide d’une chaîne en tant qu’argument.  
  
 L’exemple crée enfin un <xref:System.Speech.Recognition.Grammar> de l’objet à partir d’un <xref:System.Speech.Recognition.Choices> objet converti en un <xref:System.Speech.Recognition.GrammarBuilder> objet.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Séquence de mots.</param>
        <param name="subsetMatchingCriteria">Mode correspondant que la syntaxe de reconnaissance vocale utilise pour identifier l'expression.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour un sous-ensemble d'une suite de mots.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `phrase` paramètre représente l’expression de la grammaire de reconnaissance vocale peut reconnaître. Le `subsetMatchingMode` paramètre spécifie un sous-ensemble de l’expression qui peut être prononcé pour obtenir une reconnaissance réussie de la phrase entière. Vous pouvez utiliser cela pour créer une syntaxe avec une liste d’entrées qui ont des noms longs, sans que les utilisateurs de parler dans un nom complet pour correspondre à un élément.  
  
 Pour plus d’informations sur les modes de correspondance, consultez <xref:System.Speech.Recognition.SubsetMatchingMode>. Pour plus d’informations sur la création d’une grammaire de reconnaissance vocale qui contient des chaînes, consultez [l’utilisation de chaînes pour créer une syntaxe de GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour chaque <xref:System.Speech.Recognition.SubsetMatchingMode> valeur et une syntaxe pour le choix entre les grammaires de mode correspondant. Si la valeur de `phrase` est « un deux trois quatre cinq six sept », puis la grammaire sous-séquence reconnaît l’entrée « deux trois quatre », mais pas l’entrée » un trois cinq ». Toutefois, la grammaire de sous-ensemble commandée reconnaît les deux de ces entrées.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Élément répété.</param>
        <param name="minRepeat">Nombre minimal de fois où l’entrée correspondant à l’élément défini par <c>builder</c> doit se produire pour constituer une correspondance.</param>
        <param name="maxRepeat">Nombre maximal de fois où l’entrée correspondant à l’élément défini par <c>builder</c> peut se produire pour constituer une correspondance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> à partir d'un élément répété.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de `minRepeat` est 0, la nouvelle <xref:System.Speech.Recognition.GrammarBuilder> représente un élément facultatif.  
  
 La valeur de `minRepeat` doit être supérieur ou égal à 0 et inférieur ou égal à la valeur de `maxRepeat`.  
  
> [!IMPORTANT]
>  Lorsque vous spécifiez se répète pour <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. 
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour commander un. Il commence par une expression facultative, à l’ouverture, suivie d’un à quatre garniture et se ferme avec le mot « pizza ».  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Séquence de mots répétée.</param>
        <param name="minRepeat">Nombre minimum de fois où l'entrée correspondant à l'expression doit se produire pour constituer une correspondance.</param>
        <param name="maxRepeat">Nombre maximum de fois où l'entrée correspondant à l'expression peut se produire pour constituer une correspondance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Speech.Recognition.GrammarBuilder" /> à partir de la séquence de mots d'une <see cref="T:System.String" /> et spécifie le nombre de fois que la <see cref="T:System.String" /> peut être répétée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de `minRepeat` est 0, la nouvelle <xref:System.Speech.Recognition.GrammarBuilder> représente un élément facultatif.  
  
 La valeur de `minRepeat` doit être supérieur ou égal à 0 et inférieur ou égal à la valeur de `maxRepeat`. Pour plus d’informations sur la création d’une grammaire de reconnaissance vocale qui contient des chaînes, consultez [l’utilisation de chaînes pour créer une syntaxe de GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour commander un. Il commence par une expression facultative, à l’ouverture, suivie d’un à quatre garniture et se ferme avec le mot « pizza ».  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient une séquence de deux éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> méthodes fournissent un autre mécanisme par lequel vous pouvez combiner différents types pour créer la diversité et la flexibilité dans les grammaires généré avec <xref:System.Speech.Recognition.GrammarBuilder>. Ces méthodes correspondent aux statiques <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> méthodes, qui sont également définies sur le <xref:System.Speech.Recognition.GrammarBuilder> classe. L’ordre des paramètres détermine l’ordre des éléments dans le nouveau <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Un <xref:System.Speech.Recognition.GrammarBuilder> peut également être obtenu à partir de <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, et [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733) objets. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs.  
  
> [!IMPORTANT]
>  Le module de reconnaissance vocale peut lever une exception lors de l’utilisation d’une syntaxe de reconnaissance vocale qui contient les éléments sémantiques en double portant le même nom de clé ou plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises de la valeur du même élément sémantique. 
  
 Pour plus d’informations sur la création et à l’aide de la syntaxe de reconnaissance vocale, consultez [la reconnaissance vocale](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) et [création de grammaires de GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Le premier élément de grammaire, qui représente un ensemble d’alternatives.</param>
        <param name="builder">Le deuxième élément de grammaire.</param>
        <summary>Crée un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> nouveau qui contient un objet <see cref="T:System.Speech.Recognition.Choices" /> suivi d’un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence de l’élément <paramref name="choices" /> suivi par l’élément <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge les conversions implicites à partir des classes suivantes :  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre.  
  
 Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs.  
  
> [!IMPORTANT]
>  Lorsque vous combinez <xref:System.Speech.Recognition.Choices> et <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. Pour plus d’informations sur la création d’une grammaire de reconnaissance vocale qui contient des informations de sémantiques, consultez [ajouter une sémantique à une syntaxe de GrammarBuilder](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Premier élément de syntaxe.</param>
        <param name="choices">Second élément de grammaire qui représente un ensemble de solutions de remplacement.</param>
        <summary>Crée un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> nouveau qui contient un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" /> suivi d’un objet <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence de l’élément <paramref name="builder" /> suivi par l’élément <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge les conversions implicites à partir des classes suivantes :  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre.  
  
 Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs.  
  
> [!IMPORTANT]
>  Lorsque vous combinez <xref:System.Speech.Recognition.Choices> et <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances avec d’autres éléments de grammaire, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui peut modifier à plusieurs reprises la <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. 
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *couleur*» et « en arrière-plan la valeur *couleur*», où *couleur* est sélectionné à partir d’un jeu de couleurs. Différents types sont utilisés pour générer la grammaire finale, tel que [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, et <xref:System.Speech.Recognition.GrammarBuilder> objets. Les opérateurs de conversion explicite dans les appels à la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> méthodes sont facultatives.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Premier élément de syntaxe.</param>
        <param name="builder2">Le deuxième élément de grammaire.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient une séquence de deux objets <see cref="T:System.Speech.Recognition.GrammarBuilder" /> .</summary>
        <returns>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence de l’élément <paramref name="builder1" /> suivi par l’élément <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge les conversions implicites à partir des classes suivantes :  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder1` ou `builder2` paramètre.  
  
 Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs.  
  
> [!IMPORTANT]
>  Lorsque vous combinez <xref:System.Speech.Recognition.Choices> et <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances avec d’autres éléments de grammaire, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui peut modifier à plusieurs reprises la <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. 
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *couleur*» et « en arrière-plan la valeur *couleur*», où *couleur* est sélectionné à partir d’un jeu de couleurs. Différents types sont utilisés pour générer la grammaire finale, tel que [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, et <xref:System.Speech.Recognition.GrammarBuilder> objets. Les opérateurs de conversion explicite dans les appels à la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> méthodes sont facultatives.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Premier élément de syntaxe.</param>
        <param name="phrase">Second élément de grammaire qui représente une séquence de mots.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" /> suivi d'une expression.</summary>
        <returns>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence de l’élément <paramref name="builder" /> suivi par l’élément <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge les conversions implicites à partir des classes suivantes :  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre.  
  
 Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *couleur*» et « en arrière-plan la valeur *couleur*», où *couleur* est sélectionné à partir d’un jeu de couleurs. Différents types sont utilisés pour générer la grammaire finale, tel que [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, et <xref:System.Speech.Recognition.GrammarBuilder> objets. Les opérateurs de conversion explicite dans les appels à la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> méthodes sont facultatives.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Premier élément de grammaire qui représente une séquence de mots.</param>
        <param name="builder">Le deuxième élément de grammaire.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient une expression suivie d'un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" /> .</summary>
        <returns>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence de l’élément <paramref name="phrase" /> suivi par l’élément <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge les conversions implicites à partir des classes suivantes :  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre.  
  
 Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> et <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> opérateurs.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *couleur*» et « en arrière-plan la valeur *couleur*», où *couleur* est sélectionné à partir d’un jeu de couleurs. Différents types sont utilisés pour générer la grammaire finale, tel que [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, et <xref:System.Speech.Recognition.GrammarBuilder> objets. Les opérateurs de conversion explicite dans les appels à la <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> méthodes sont facultatives.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un élément de syntaxe à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ces méthodes pour ajouter des éléments de syntaxe à un existant <xref:System.Speech.Recognition.GrammarBuilder>. Lorsque vous créez des éléments de syntaxe, vous pouvez les ajouter au générateur existant pour développer progressivement les contraintes pour une grammaire de reconnaissance vocale. Chaque élément est ajouté à la fin de la séquence en cours d’éléments.  
  
 Cette méthode a des surcharges pour ajouter des données <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>, <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, et <xref:System.Speech.Recognition.SemanticResultValue> objets.  
  
> [!IMPORTANT]
>  Le module de reconnaissance vocale peut lever une exception lors de l’utilisation d’une syntaxe de reconnaissance vocale qui contient les éléments sémantiques en double portant le même nom de clé ou plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises de la valeur du même élément sémantique. 
  
 Pour plus d’informations sur la création et à l’aide de la syntaxe de reconnaissance vocale, consultez [la reconnaissance vocale](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) et [création de grammaires de GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Ensemble des alternatives à ajouter.</param>
        <summary>Ajoute un ensemble d'alternatives à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` est ajouté à la fin de la séquence en cours d’éléments.  
  
> [!IMPORTANT]
>  Lorsque vous ajoutez <xref:System.Speech.Recognition.Choices> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances pour un <xref:System.Speech.Recognition.GrammarBuilder> d’objet, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourrait à plusieurs reprises modifier le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour les expressions telles que « James appel au travail » et « Appel Anne sur son téléphone portable », où le mot « phone » est facultatif. L’exemple illustre l’utilisation de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> (méthode).  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Élément de grammaire à ajouter.</param>
        <summary>Ajoute un élément de syntaxe à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` est ajouté à la fin de la séquence en cours d’éléments de syntaxe.  
  
> [!NOTE]
>  Lorsque vous ajoutez <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances pour un <xref:System.Speech.Recognition.GrammarBuilder> d’objet, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourrait à plusieurs reprises modifier le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances. 
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour les expressions telles que « James appel au travail » et « Appel Anne sur son téléphone portable », où le mot « phone » est facultatif. <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets sont utilisés pour construire la grammaire. L’exemple illustre l’utilisation de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> (méthode).  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé sémantique à ajouter.</param>
        <summary>Ajoute une clé sémantique à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` est ajouté à la fin de la séquence en cours d’éléments.  
  
> [!IMPORTANT]
>  Lorsque vous ajoutez <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances pour un <xref:System.Speech.Recognition.GrammarBuilder> d’objet, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
   
  
## Examples  
 L’exemple suivant fait partie d’une application de console pour le choix des villes d’origine et de destination pour un vol. L’application reconnaît des expressions telles que « Je veux passage vers Miami à Chicago ». Le gestionnaire pour le <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> événement utilise la <xref:System.Speech.Recognition.SemanticResultKey> pour extraire le code d’aéroport spécifié dans le <xref:System.Speech.Recognition.SemanticResultValue> les villes d’origine et destination.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Valeur sémantique à ajouter.</param>
        <summary>Ajoute une valeur sémantique à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` est ajouté à la fin de la séquence en cours d’éléments.  
  
> [!IMPORTANT]
>  Lorsque vous ajoutez <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances pour un <xref:System.Speech.Recognition.GrammarBuilder> d’objet, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
   
  
## Examples  
 L’exemple suivant fait partie d’une application de console pour le choix des villes d’origine et de destination pour un vol. L’application reconnaît des expressions telles que « Je veux passage vers Miami à Chicago ». Le gestionnaire pour le <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> événement utilise la <xref:System.Speech.Recognition.SemanticResultKey> pour extraire le code d’aéroport spécifié dans le <xref:System.Speech.Recognition.SemanticResultValue> les villes d’origine et destination.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Séquence de mots à ajouter.</param>
        <summary>Ajoute une expression à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` est ajouté à la fin de la séquence en cours d’éléments.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Séquence de mots à ajouter.</param>
        <param name="subsetMatchingCriteria">Mode correspondant utilisé par la grammaire pour identifier l'expression.</param>
        <summary>Ajoute un élément pour un sous-ensemble d'une expression à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’élément du sous-ensemble est ajouté à la fin de la séquence en cours d’éléments. Pour plus d’informations sur la création d’une grammaire de reconnaissance vocale à l’aide de chaînes, consultez [l’utilisation de chaînes pour créer une syntaxe de GrammarBuilder](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Pour plus d’informations sur l’utilisation des modes de correspondance du sous-ensemble, consultez <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour chaque <xref:System.Speech.Recognition.SubsetMatchingMode> valeur. Par exemple, la grammaire générée `OrderedSubset` reconnaît les expressions, » trois quatre cinq » et « un trois cinq » et la grammaire `Subsequence` reconnaît l’expression « trois quatre cinq », mais pas l’expression, » un trois cinq ».  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Élément de syntaxe répété à ajouter.</param>
        <param name="minRepeat">Nombre minimal de fois où l’entrée correspondant à l’élément défini par <c>builder</c> doit se produire pour constituer une correspondance.</param>
        <param name="maxRepeat">Nombre maximal de fois où l’entrée correspondant à l’élément défini par <c>builder</c> peut se produire pour constituer une correspondance.</param>
        <summary>Ajoute un élément de syntaxe répété à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de `minRepeat` doit être supérieur ou égal à 0 et inférieur ou égal à la valeur de `maxRepeat`.  
  
> [!IMPORTANT]
>  Lorsque vous ajoutez <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances pour un <xref:System.Speech.Recognition.GrammarBuilder> d’objet, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourrait à plusieurs reprises modifier le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour les expressions telles que « James appel au travail » et « Appel Anne sur son téléphone portable », où le mot « phone » est facultatif. <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets sont utilisés pour construire la grammaire. L’exemple illustre l’utilisation de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> (méthode).  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Séquence de mots répétée à ajouter.</param>
        <param name="minRepeat">Nombre minimal de fois où l’entrée correspondant à <c>phrase</c> doit se produire pour constituer une correspondance.</param>
        <param name="maxRepeat">Nombre maximal de fois où l’entrée correspondant à <c>phrase</c> peut se produire pour constituer une correspondance.</param>
        <summary>Ajoute une expression répétée à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de `minRepeat` doit être supérieur ou égal à 0 et inférieur ou égal à la valeur de `maxRepeat`.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour les expressions telles que « James appel au travail » et « Appel Anne sur son téléphone portable », où le mot « phone » est facultatif. <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets sont utilisés pour construire la grammaire. L’exemple illustre l’utilisation de la <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> (méthode).  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute une syntaxe de dictée à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> méthodes vous permettent d’ajouter une syntaxe de dictée comme une règle à un <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Pour plus d’informations sur les grammaires de dictée, consultez <xref:System.Speech.Recognition.DictationGrammar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute la syntaxe de dictée par défaut à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les grammaires de dictée, consultez <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale qui incorpore la dictée.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Catégorie de la syntaxe de dictée à ajouter.</param>
        <summary>Ajoute la syntaxe de dictée spécifiée à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser la syntaxe de dictée orthographe, définissez `category` à `spelling`.  
  
 Pour plus d’informations sur les grammaires de dictée, consultez <xref:System.Speech.Recognition.DictationGrammar>.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale qui incorpore les règles de grammaire dictée.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un fichier de syntaxe ou une règle de grammaire à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> méthodes peuvent ajouter un fichier de grammaire ou une règle de grammaire à partir d’un fichier. Ces méthodes permettent aux applications s’utiliser des règles grammaticales de pré-déploiement ou disponible publiquement. L’application doit avoir un accès en lecture à l’emplacement des fichiers de grammaire spécifiée.  
  
 Ces méthodes peuvent lire une grammaire de reconnaissance vocale à partir des formats suivants.  
  
-   Les fichiers au format XML qui se conforment à la W3C [Speech Recognition Grammar Specification (SRGS) Version 1.0](https://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Fichiers binaires qui sont conformes au Microsoft Speech Recognition grammaire Format binaire (extension de fichier .cfg)  
  
 Compilation d’un SRGS au format XML fichier de grammaire à un fichier binaire de grammaire avec l’extension .cfg peut réduire le temps consommé par recherche une correspondance, en particulier si la grammaire requiert la reconnaissance d’un grand nombre de mots et d’expressions. Pour plus d’informations sur la compilation des grammaires SRGS au format binaire CFG, consultez <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès ou URI (Universal Resource Identifier) du fichier qui décrit une grammaire de reconnaissance vocale dans un format pris en charge.</param>
        <summary>Ajoute un fichier de définition de syntaxe à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’URI fourni par le `path` argument peut être local ou distant. L’application doit avoir un accès en lecture à l’emplacement des fichiers de grammaire spécifiée.  
  
 Une représentation sous forme de W3C Speech Recognition Grammar Specification (SRGS) pouvez définir une règle racine. Cette méthode ajoute la syntaxe, à partir de sa règle racine, à la séquence en cours d’éléments de syntaxe. Pour ajouter une règle de syntaxe spécifique, utilisez le <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> (méthode).  
  
   
  
## Examples  
 L’exemple c# suivant crée une grammaire de reconnaissance vocale qui utilise la règle nommée `Cities` dans un fichier SRGS local, cities.grxml. Le contenu du fichier cities.grxml apparaît sous l’exemple de code c#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès ou URI (Universal Resource Identifier) du fichier qui décrit une grammaire de reconnaissance vocale dans un format pris en charge.</param>
        <param name="rule">Identificateur de la règle à ajouter, ou la valeur <see langword="null" /> pour ajouter la règle racine par défaut du fichier de grammaire.</param>
        <summary>Ajoute la règle spécifiée d'un fichier de définition de syntaxe à la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’URI fourni par le `path` argument peut être local ou distant. L’application doit avoir un accès en lecture à l’emplacement des fichiers de grammaire spécifiée.  
  
 Vous pouvez utiliser la <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> méthode pour ajouter un début du fichier de grammaire à sa règle racine.  
  
   
  
## Examples  
 L’exemple c# suivant crée une grammaire de reconnaissance vocale qui utilise la règle nommée `Cities` dans un fichier SRGS local, cities.grxml. Le contenu du fichier cities.grxml apparaît sous l’exemple de code c#.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute un élément de syntaxe de reconnaissance qui correspond à une entrée dans la séquence en cours d'éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’élément de caractère générique est ajouté à la fin de la séquence en cours d’éléments.  
  
 L’élément de caractère générique correspond à n’importe quel mot prononcé. Il ne correspond pas de bruit de fond ou silence.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire qui accepte l’entrée de mot de passe comme un caractère générique. L’exemple joint un <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> Gestionnaire d’événements à la grammaire qui valide l’entrée de mot de passe.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la culture de la syntaxe de reconnaissance vocale.</summary>
        <value>Culture du <see cref="T:System.Speech.Recognition.GrammarBuilder" />. La valeur par défaut est la propriété <see cref="P:System.Threading.Thread.CurrentUICulture" /> du thread en cours d'exécution.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Speech.Recognition.Grammar.%23ctor%2A> le constructeur crée un <xref:System.Speech.Recognition.Grammar> objet qui peut être utilisé par un module de reconnaissance vocale de la culture correspondante. Uniquement les <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> propriété de la <xref:System.Speech.Recognition.GrammarBuilder> qui est fourni comme le paramètre au constructeur de grammaire est utilisé pour définir la culture de la grammaire de reconnaissance vocale qui en résulte.  
  
 Microsoft Windows et l’API System.Speech acceptent tous les codes de langue-pays valides. Pour effectuer la reconnaissance vocale à l’aide de la langue spécifiée dans le `Culture` propriété, un moteur de reconnaissance vocale qui prend en charge que le code de langue-pays doit être installé. Le module de reconnaissance vocale fournis avec Microsoft Windows 7 fonctionne avec les codes de langue-pays suivants.  
  
-   en-GB. Anglais (Royaume-Uni)  
  
-   en-US. Anglais (États-Unis)  
  
-   fr-fr. Allemand (Allemagne)  
  
-   es-ES. Espagnol (Espagne)  
  
-   fr-FR. Français (France)  
  
-   ja-JP. Japonais (Japon)  
  
-   zh-CN. Chinois (Chine)  
  
-   zh-TW. Chinois (Taïwan)  
  
 Codes de langue à deux lettres tels que « fr », « fr », ou « es » sont également autorisées.  
  
   
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour commander un avec garniture jusqu'à quatre. Il définit spécifiquement le <xref:System.Speech.Recognition.GrammarBuilder> culture de l’objet vers l’anglais (États-Unis).  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une chaîne qui indique les contenus et la structure de la grammaire contenus par <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <value>Contenu et structure en cours de <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale pour commander un avec garniture jusqu'à quatre. Il écrit l’état de la <xref:System.Speech.Recognition.GrammarBuilder> à la console avant de créer la grammaire. Cette méthode génère la sortie suivante :  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Créer les grammaires à l’aide de GrammarBuilder</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui correspond à une séquence de deux éléments de syntaxe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des opérandes détermine l’ordre des éléments dans le nouveau <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Attention est recommandée lors de la combinaison <xref:System.Speech.Recognition.Choices> ou <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances avec d’autres éléments de grammaire. Le module de reconnaissance vocale peut lever une exception lors de l’utilisation d’une syntaxe de reconnaissance vocale qui contient les éléments sémantiques en double portant le même nom de clé ou plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises de la valeur du même élément sémantique. 
  
 Pour plus d’informations sur la création et à l’aide de la syntaxe de reconnaissance vocale, consultez [la reconnaissance vocale](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) et [création de grammaires de GrammarBuilder](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Le premier élément de grammaire, qui représente un ensemble d’alternatives.</param>
        <param name="builder">Le deuxième élément de grammaire.</param>
        <summary>Crée un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> nouveau qui contient un objet <see cref="T:System.Speech.Recognition.Choices" /> suivi d’un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Retourne un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence du paramètre <paramref name="choices" /> suivi du paramètre <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge des conversions depuis les classes suivantes.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> opérateurs.  
  
> [!IMPORTANT]
>  Lorsque vous combinez <xref:System.Speech.Recognition.Choices> et <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Premier élément de syntaxe.</param>
        <param name="choices">Deuxième élément de syntaxe qui représente un ensemble d'autres éléments.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> suivi d'un <see cref="T:System.Speech.Recognition.Choices" />.</summary>
        <returns>Retourne un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence du paramètre <paramref name="builder" /> suivi du paramètre <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge des conversions depuis les classes suivantes :  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> opérateurs.  
  
> [!IMPORTANT]
>  Lorsque vous combinez <xref:System.Speech.Recognition.Choices> et <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *couleur*» et « en arrière-plan la valeur *couleur*», où *couleur* est sélectionné à partir d’un jeu de couleurs. Différents types sont utilisés pour générer la grammaire finale, tel que [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, et <xref:System.Speech.Recognition.GrammarBuilder> objets.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Premier élément de syntaxe.</param>
        <param name="builder2">Le deuxième élément de grammaire.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient une séquence de deux objets <see cref="T:System.Speech.Recognition.GrammarBuilder" /> .</summary>
        <returns>Retourne un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence du paramètre <paramref name="builder1" /> suivi du paramètre <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge des conversions depuis les classes suivantes.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder1` et `builder2` paramètres. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> opérateurs.  
  
> [!IMPORTANT]
>  Lorsque vous combinez <xref:System.Speech.Recognition.GrammarBuilder> objets qui contiennent <xref:System.Speech.Recognition.SemanticResultValue> ou <xref:System.Speech.Recognition.SemanticResultKey> instances, assurez-vous que vous évitez de créer des éléments de sémantiques en double avec le même nom de clé ou de plusieurs éléments sémantiques qui pourraient modifier à plusieurs reprises le <xref:System.Speech.Recognition.SemanticValue.Value%2A> propriété d’un <xref:System.Speech.Recognition.SemanticValue> objet. Le module de reconnaissance vocale peut lever une exception si elle rencontre ces circonstances.
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Premier élément de syntaxe.</param>
        <param name="phrase">Second élément de grammaire qui représente une séquence de mots.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> suivi d'une expression.</summary>
        <returns>Retourne un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence du paramètre <paramref name="builder" /> suivi du paramètre <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge des conversions depuis les classes suivantes.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> opérateurs.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Premier élément de grammaire qui représente une séquence de mots.</param>
        <param name="builder">Le deuxième élément de grammaire.</param>
        <summary>Crée un nouveau <see cref="T:System.Speech.Recognition.GrammarBuilder" /> qui contient une expression suivie d'un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> .</summary>
        <returns>Retourne un <see cref="T:System.Speech.Recognition.GrammarBuilder" /> pour la séquence du paramètre <paramref name="phrase" /> suivi du paramètre <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> prend en charge des conversions depuis les classes suivantes.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Cette méthode accepte les objets répertoriés ci-dessus pour le `builder` paramètre. Pour plus d’informations, consultez le <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> opérateurs.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître les deux expressions, « faire arrière-plan *couleur*» et « en arrière-plan la valeur *couleur*», où *couleur* est sélectionné à partir d’un jeu de couleurs. Différents types sont utilisés pour générer la grammaire finale, tel que [chaîne](https://go.microsoft.com/fwlink/?LinkId=159733), <xref:System.Speech.Recognition.Choices>, et <xref:System.Speech.Recognition.GrammarBuilder> objets.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit un autre type en un <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversion implicite crée une nouvelle instance de <xref:System.Speech.Recognition.GrammarBuilder>. Vous pouvez effectuer un cast de chacune des classes suivantes à un <xref:System.Speech.Recognition.GrammarBuilder>.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Chacune des conversions implicites est équivalente à l’appel du constructeur.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Ensemble des alternatives à convertir.</param>
        <summary>Convertit un objet <see cref="T:System.Speech.Recognition.Choices" /> en un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objet <see cref="T:System.Speech.Recognition.Choices" /> converti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversion implicite crée une nouvelle instance de <xref:System.Speech.Recognition.GrammarBuilder>. Cet opérateur de conversion est équivalent à l’appel <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> et en spécifiant `choices` pour le `alternateChoices`.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître une réponse à un « Oui » ou « non » question. L’opérateur de conversion implicite est utilisé dans la construction d’un <xref:System.Speech.Recognition.SemanticResultValue> à partir de l’objet une <xref:System.Speech.Recognition.Choices> objet, dans la construction d’un <xref:System.Speech.Recognition.Choices> objet à partir de deux <xref:System.Speech.Recognition.SemanticResultValue> objets et dans la construction d’un <xref:System.Speech.Recognition.Grammar> objet à partir d’un <xref:System.Speech.Recognition.SemanticResultKey> objet.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Touche sémantique à convertir.</param>
        <summary>Convertit un objet <see cref="T:System.Speech.Recognition.SemanticResultKey" /> en un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objet <see cref="T:System.Speech.Recognition.SemanticResultKey" /> converti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversion implicite crée une nouvelle instance de <xref:System.Speech.Recognition.GrammarBuilder>. Cet opérateur de conversion est équivalent à l’appel <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> et en spécifiant `semanticKey` pour le `key`.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître une réponse à un « Oui » ou « non » question. L’opérateur de conversion implicite est utilisé dans la construction d’un <xref:System.Speech.Recognition.SemanticResultValue> à partir de l’objet une <xref:System.Speech.Recognition.Choices> objet, dans la construction d’un <xref:System.Speech.Recognition.Choices> objet à partir de deux <xref:System.Speech.Recognition.SemanticResultValue> objets et dans la construction d’un <xref:System.Speech.Recognition.Grammar> objet à partir d’un <xref:System.Speech.Recognition.SemanticResultKey> objet.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">Objet <see cref="T:System.Speech.Recognition.SemanticResultValue" /> à convertir.</param>
        <summary>Convertit un objet <see cref="T:System.Speech.Recognition.SemanticResultValue" /> en un objet <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Objet <see cref="T:System.Speech.Recognition.SemanticResultValue" /> converti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversion implicite crée une nouvelle instance de <xref:System.Speech.Recognition.GrammarBuilder>. Cet opérateur de conversion est équivalent à l’appel <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> et en spécifiant `semanticValue` pour le `value`.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant crée une grammaire de reconnaissance vocale capable de reconnaître une réponse à un « Oui » ou « non » question. L’opérateur de conversion implicite est utilisé dans la construction d’un <xref:System.Speech.Recognition.SemanticResultValue> à partir de l’objet une <xref:System.Speech.Recognition.Choices>objet, dans la construction d’un <xref:System.Speech.Recognition.Choices> objet à partir de deux <xref:System.Speech.Recognition.SemanticResultValue> objets et dans la construction d’un <xref:System.Speech.Recognition.Grammar> objet à partir d’un <xref:System.Speech.Recognition.SemanticResultKey> objet.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Chaîne à convertir.</param>
        <summary>Convertit une chaîne en objet <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</summary>
        <returns>Chaîne convertie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conversion implicite crée une nouvelle instance de <xref:System.Speech.Recognition.GrammarBuilder>. Cet opérateur de conversion est équivalent à l’appel <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> et en spécifiant les mêmes `phrase`.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant utilise <xref:System.Speech.Recognition.GrammarBuilder> et <xref:System.Speech.Recognition.Choices> objets pour construire une grammaire qui puisse reconnaître une des deux expressions, « faire arrière-plan *colorChoice*» ou « en arrière-plan la valeur *colorChoice*".  
  
 Après avoir créé une liste de valeurs acceptables pour *colorChoice* à l’aide un <xref:System.Speech.Recognition.Choices> de l’objet, l’exemple initialise deux <xref:System.Speech.Recognition.GrammarBuilder> objets, `makePhrase` et `setPhrase`, à l’aide de la conversion implicite de chaîne objets.  
  
 L’exemple crée enfin un <xref:System.Speech.Recognition.Grammar> de l’objet à partir d’un <xref:System.Speech.Recognition.Choices> objet converti en un <xref:System.Speech.Recognition.GrammarBuilder> objet.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>